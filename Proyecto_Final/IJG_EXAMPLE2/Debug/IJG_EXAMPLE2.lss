
IJG_EXAMPLE2.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0001b902  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8001da00  8001da00  0001de00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00002a68  8001dc00  8001dc00  0001e000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         0000055c  00000008  80020668  00020c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000564  80020bc4  00021164  2**0
                  ALLOC
  8 .bss          000008d8  00000568  00000568  00000000  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  00021164  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00002508  00000000  00000000  00021198  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00004b45  00000000  00000000  000236a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00064efe  00000000  00000000  000281e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000cfc3  00000000  00000000  0008d0e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000250af  00000000  00000000  0009a0a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00006e30  00000000  00000000  000bf158  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000c6f7  00000000  00000000  000c5f88  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000209ce  00000000  00000000  000d267f  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 017d7669  00000000  00000000  000f304d  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 20 .heap         02000000  d0000000  d0000000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00002dc8  00000000  00000000  018ca6b8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c1 ac 	sub	pc,pc,-15956

Disassembly of section .text:

80002004 <sd_mmc_spi_get_capacity>:
80002004:	d4 01       	pushm	lr
80002006:	4c 18       	lddpc	r8,80002108 <sd_mmc_spi_get_capacity+0x104>
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
80002008:	11 db       	ld.ub	r11,r8[0x5]
  if (card_type == SD_CARD_2_SDHC) {
8000200a:	4c 18       	lddpc	r8,8000210c <sd_mmc_spi_get_capacity+0x108>
8000200c:	11 8a       	ld.ub	r10,r8[0x0]
8000200e:	30 38       	mov	r8,3
80002010:	f0 0a 18 00 	cp.b	r10,r8
80002014:	c2 71       	brne	80002062 <sd_mmc_spi_get_capacity+0x5e>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80002016:	4b d8       	lddpc	r8,80002108 <sd_mmc_spi_get_capacity+0x104>
80002018:	f1 3a 00 08 	ld.ub	r10,r8[8]
8000201c:	f1 39 00 09 	ld.ub	r9,r8[9]
80002020:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80002024:	11 fa       	ld.ub	r10,r8[0x7]
80002026:	f5 da c0 06 	bfextu	r10,r10,0x0,0x6
8000202a:	f3 ea 11 0a 	or	r10,r9,r10<<0x10
    ++c_size;
8000202e:	2f fa       	sub	r10,-1
    capacity = (uint64_t)c_size << 19;
80002030:	f4 0b 16 0d 	lsr	r11,r10,0xd
80002034:	16 99       	mov	r9,r11
80002036:	f4 08 15 13 	lsl	r8,r10,0x13
8000203a:	4b 6a       	lddpc	r10,80002110 <sd_mmc_spi_get_capacity+0x10c>
8000203c:	f4 e9 00 00 	st.d	r10[0],r8
    capacity_mult = (c_size >> 13) & 0x01FF;
80002040:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80002044:	4b 48       	lddpc	r8,80002114 <sd_mmc_spi_get_capacity+0x110>
80002046:	b0 0b       	st.h	r8[0x0],r11
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80002048:	f4 ea 00 00 	ld.d	r10,r10[0]
8000204c:	90 09       	ld.sh	r9,r8[0x0]
8000204e:	f4 08 16 09 	lsr	r8,r10,0x9
80002052:	f1 eb 11 78 	or	r8,r8,r11<<0x17
80002056:	20 18       	sub	r8,1
80002058:	b7 79       	lsl	r9,0x17
8000205a:	12 08       	add	r8,r9
8000205c:	4a f9       	lddpc	r9,80002118 <sd_mmc_spi_get_capacity+0x114>
8000205e:	93 08       	st.w	r9[0x0],r8
80002060:	c4 28       	rjmp	800020e4 <sd_mmc_spi_get_capacity+0xe0>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002062:	4a a8       	lddpc	r8,80002108 <sd_mmc_spi_get_capacity+0x104>
80002064:	f1 3c 00 0a 	ld.ub	r12,r8[10]
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002068:	f1 39 00 08 	ld.ub	r9,r8[8]
8000206c:	a7 89       	lsr	r9,0x6
8000206e:	11 fe       	ld.ub	lr,r8[0x7]
80002070:	f2 0e 00 29 	add	r9,r9,lr<<0x2
80002074:	11 ee       	ld.ub	lr,r8[0x6]
80002076:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
8000207a:	ab 6e       	lsl	lr,0xa
8000207c:	1c 09       	add	r9,lr
8000207e:	2f f9       	sub	r9,-1
80002080:	f1 38 00 09 	ld.ub	r8,r8[9]
80002084:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002088:	f8 0e 16 07 	lsr	lr,r12,0x7
8000208c:	fc 08 00 18 	add	r8,lr,r8<<0x1
80002090:	2f e8       	sub	r8,-2
80002092:	f2 08 09 49 	lsl	r9,r9,r8
80002096:	20 19       	sub	r9,1
80002098:	4a 08       	lddpc	r8,80002118 <sd_mmc_spi_get_capacity+0x114>
8000209a:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
8000209c:	70 0e       	ld.w	lr,r8[0x0]
8000209e:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
800020a2:	2f fe       	sub	lr,-1
800020a4:	fc 0b 09 48 	lsl	r8,lr,r11
800020a8:	30 09       	mov	r9,0
800020aa:	49 ae       	lddpc	lr,80002110 <sd_mmc_spi_get_capacity+0x10c>
800020ac:	fc e9 00 00 	st.d	lr[0],r8
    capacity_mult = 0;
800020b0:	49 98       	lddpc	r8,80002114 <sd_mmc_spi_get_capacity+0x110>
800020b2:	b0 09       	st.h	r8[0x0],r9
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
800020b4:	30 98       	mov	r8,9
800020b6:	f0 0b 18 00 	cp.b	r11,r8
800020ba:	e0 88 00 08 	brls	800020ca <sd_mmc_spi_get_capacity+0xc6>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
800020be:	49 78       	lddpc	r8,80002118 <sd_mmc_spi_get_capacity+0x114>
800020c0:	70 09       	ld.w	r9,r8[0x0]
800020c2:	20 9b       	sub	r11,9
800020c4:	f2 0b 09 4b 	lsl	r11,r9,r11
800020c8:	91 0b       	st.w	r8[0x0],r11
    }
  }
  if (card_type == MMC_CARD)
800020ca:	58 0a       	cp.w	r10,0
800020cc:	c0 c1       	brne	800020e4 <sd_mmc_spi_get_capacity+0xe0>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
800020ce:	f1 dc c0 45 	bfextu	r8,r12,0x2,0x5
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
800020d2:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800020d6:	48 d9       	lddpc	r9,80002108 <sd_mmc_spi_get_capacity+0x104>
800020d8:	f3 39 00 0b 	ld.ub	r9,r9[11]
800020dc:	a3 7c       	lsl	r12,0x3
800020de:	f9 e9 12 59 	or	r9,r12,r9>>0x5
800020e2:	c0 c8       	rjmp	800020fa <sd_mmc_spi_get_capacity+0xf6>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
800020e4:	48 9a       	lddpc	r10,80002108 <sd_mmc_spi_get_capacity+0x104>
800020e6:	f5 39 00 0a 	ld.ub	r9,r10[10]
800020ea:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
800020ee:	f5 38 00 0b 	ld.ub	r8,r10[11]
800020f2:	a7 98       	lsr	r8,0x7
800020f4:	f0 09 00 18 	add	r8,r8,r9<<0x1
800020f8:	30 09       	mov	r9,0
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
800020fa:	2f f9       	sub	r9,-1
800020fc:	2f f8       	sub	r8,-1
800020fe:	b1 39       	mul	r9,r8
80002100:	48 78       	lddpc	r8,8000211c <sd_mmc_spi_get_capacity+0x118>
80002102:	b0 09       	st.h	r8[0x0],r9
}
80002104:	d8 02       	popm	pc
80002106:	00 00       	add	r0,r0
80002108:	00 00       	add	r0,r0
8000210a:	09 dc       	ld.ub	r12,r4[0x5]
8000210c:	00 00       	add	r0,r0
8000210e:	09 da       	ld.ub	r10,r4[0x5]
80002110:	00 00       	add	r0,r0
80002112:	09 c8       	ld.ub	r8,r4[0x4]
80002114:	00 00       	add	r0,r0
80002116:	09 d0       	ld.ub	r0,r4[0x5]
80002118:	00 00       	add	r0,r0
8000211a:	09 d4       	ld.ub	r4,r4[0x5]
8000211c:	00 00       	add	r0,r0
8000211e:	09 d2       	ld.ub	r2,r4[0x5]

80002120 <sd_mmc_spi_write_close>:
//! page programming.
//!
void sd_mmc_spi_write_close (void)
{

}
80002120:	5e fc       	retal	r12
80002122:	d7 03       	nop

80002124 <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
80002124:	d4 01       	pushm	lr
80002126:	20 1d       	sub	sp,4
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002128:	18 9b       	mov	r11,r12
8000212a:	fe 7c 24 00 	mov	r12,-56320
8000212e:	f0 1f 00 09 	mcall	80002150 <sd_mmc_spi_send_and_read+0x2c>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002132:	fa cb ff fe 	sub	r11,sp,-2
80002136:	fe 7c 24 00 	mov	r12,-56320
8000213a:	f0 1f 00 07 	mcall	80002154 <sd_mmc_spi_send_and_read+0x30>
8000213e:	58 1c       	cp.w	r12,1
80002140:	c0 41       	brne	80002148 <sd_mmc_spi_send_and_read+0x24>
80002142:	e0 6c 00 ff 	mov	r12,255
80002146:	c0 28       	rjmp	8000214a <sd_mmc_spi_send_and_read+0x26>
     return 0xFF;
   return data_read;
80002148:	1b bc       	ld.ub	r12,sp[0x3]
}
8000214a:	2f fd       	sub	sp,-4
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	2d 8e       	sub	lr,-40
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	2d aa       	sub	r10,-38

80002158 <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
80002158:	d4 21       	pushm	r4-r7,lr
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000215a:	30 1b       	mov	r11,1
8000215c:	fe 7c 24 00 	mov	r12,-56320
80002160:	f0 1f 00 10 	mcall	800021a0 <sd_mmc_spi_wait_not_busy+0x48>
80002164:	30 07       	mov	r7,0
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002166:	e0 65 00 ff 	mov	r5,255
8000216a:	48 f4       	lddpc	r4,800021a4 <sd_mmc_spi_wait_not_busy+0x4c>
8000216c:	3f f6       	mov	r6,-1
8000216e:	c0 b8       	rjmp	80002184 <sd_mmc_spi_wait_not_busy+0x2c>
  {
    retry++;
80002170:	2f f7       	sub	r7,-1
    if (retry == 200000)
80002172:	e2 57 0d 40 	cp.w	r7,200000
80002176:	c0 71       	brne	80002184 <sd_mmc_spi_wait_not_busy+0x2c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002178:	30 1b       	mov	r11,1
8000217a:	fe 7c 24 00 	mov	r12,-56320
8000217e:	f0 1f 00 0b 	mcall	800021a8 <sd_mmc_spi_wait_not_busy+0x50>
80002182:	d8 2a       	popm	r4-r7,pc,r12=0
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002184:	0a 9c       	mov	r12,r5
80002186:	f0 1f 00 0a 	mcall	800021ac <sd_mmc_spi_wait_not_busy+0x54>
8000218a:	a8 8c       	st.b	r4[0x0],r12
8000218c:	ec 0c 18 00 	cp.b	r12,r6
80002190:	cf 01       	brne	80002170 <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002192:	30 1b       	mov	r11,1
80002194:	fe 7c 24 00 	mov	r12,-56320
80002198:	f0 1f 00 04 	mcall	800021a8 <sd_mmc_spi_wait_not_busy+0x50>
8000219c:	da 2a       	popm	r4-r7,pc,r12=1
8000219e:	00 00       	add	r0,r0
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	2c 5c       	sub	r12,-59
800021a4:	00 00       	add	r0,r0
800021a6:	09 ec       	ld.ub	r12,r4[0x6]
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	2c a8       	sub	r8,-54
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	21 24       	sub	r4,18

800021b0 <sd_mmc_spi_write_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_write_open (uint32_t pos)
{
800021b0:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9; // gl_ptr_mem = pos * 512
800021b2:	a9 7c       	lsl	r12,0x9
800021b4:	48 38       	lddpc	r8,800021c0 <sd_mmc_spi_write_open+0x10>
800021b6:	91 0c       	st.w	r8[0x0],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
800021b8:	f0 1f 00 03 	mcall	800021c4 <sd_mmc_spi_write_open+0x14>
}
800021bc:	d8 02       	popm	pc
800021be:	00 00       	add	r0,r0
800021c0:	00 00       	add	r0,r0
800021c2:	05 68       	ld.uh	r8,--r2
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	21 58       	sub	r8,21

800021c8 <sd_mmc_spi_read_close>:

//!
//! @brief This function unselects the current SD_MMC memory.
//!
bool sd_mmc_spi_read_close (void)
{
800021c8:	d4 01       	pushm	lr
  if (false == sd_mmc_spi_wait_not_busy())
800021ca:	f0 1f 00 02 	mcall	800021d0 <sd_mmc_spi_read_close+0x8>
    return false;
  return true;
}
800021ce:	d8 02       	popm	pc
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	21 58       	sub	r8,21

800021d4 <sd_mmc_spi_read_open>:
//! @param  pos   Sector address
//!
//! @return bit
//!   The open succeeded      -> true
bool sd_mmc_spi_read_open (uint32_t pos)
{
800021d4:	d4 01       	pushm	lr
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9;        // gl_ptr_mem = pos * 512
800021d6:	a9 7c       	lsl	r12,0x9
800021d8:	48 38       	lddpc	r8,800021e4 <sd_mmc_spi_read_open+0x10>
800021da:	91 0c       	st.w	r8[0x0],r12

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
800021dc:	f0 1f 00 03 	mcall	800021e8 <sd_mmc_spi_read_open+0x14>
}
800021e0:	d8 02       	popm	pc
800021e2:	00 00       	add	r0,r0
800021e4:	00 00       	add	r0,r0
800021e6:	05 68       	ld.uh	r8,--r2
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	21 58       	sub	r8,21

800021ec <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
800021ec:	eb cd 40 f8 	pushm	r3-r7,lr
800021f0:	18 96       	mov	r6,r12
800021f2:	16 97       	mov	r7,r11
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
800021f4:	e0 6b 00 ff 	mov	r11,255
800021f8:	fe 7c 24 00 	mov	r12,-56320
800021fc:	f0 1f 00 2b 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80002200:	0c 9b       	mov	r11,r6
80002202:	a7 ab       	sbr	r11,0x6
80002204:	5c 5b       	castu.b	r11
80002206:	fe 7c 24 00 	mov	r12,-56320
8000220a:	f0 1f 00 28 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
8000220e:	ee 0b 16 18 	lsr	r11,r7,0x18
80002212:	fe 7c 24 00 	mov	r12,-56320
80002216:	f0 1f 00 25 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>16);
8000221a:	ee 0b 16 10 	lsr	r11,r7,0x10
8000221e:	fe 7c 24 00 	mov	r12,-56320
80002222:	f0 1f 00 22 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg>>8 );
80002226:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
8000222a:	fe 7c 24 00 	mov	r12,-56320
8000222e:	f0 1f 00 1f 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
  spi_write(SD_MMC_SPI, arg    );
80002232:	0e 9b       	mov	r11,r7
80002234:	5c 7b       	castu.h	r11
80002236:	fe 7c 24 00 	mov	r12,-56320
8000223a:	f0 1f 00 1c 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
  switch(command)
8000223e:	30 08       	mov	r8,0
80002240:	f0 06 18 00 	cp.b	r6,r8
80002244:	c0 60       	breq	80002250 <sd_mmc_spi_command+0x64>
80002246:	30 88       	mov	r8,8
80002248:	f0 06 18 00 	cp.b	r6,r8
8000224c:	c1 01       	brne	8000226c <sd_mmc_spi_command+0x80>
8000224e:	c0 88       	rjmp	8000225e <sd_mmc_spi_command+0x72>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80002250:	e0 6b 00 95 	mov	r11,149
80002254:	fe 7c 24 00 	mov	r12,-56320
80002258:	f0 1f 00 14 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
         break;
8000225c:	c0 e8       	rjmp	80002278 <sd_mmc_spi_command+0x8c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
8000225e:	e0 6b 00 87 	mov	r11,135
80002262:	fe 7c 24 00 	mov	r12,-56320
80002266:	f0 1f 00 11 	mcall	800022a8 <sd_mmc_spi_command+0xbc>
         break;
8000226a:	c0 78       	rjmp	80002278 <sd_mmc_spi_command+0x8c>
      default:
         spi_write(SD_MMC_SPI, 0xff);
8000226c:	e0 6b 00 ff 	mov	r11,255
80002270:	fe 7c 24 00 	mov	r12,-56320
80002274:	f0 1f 00 0d 	mcall	800022a8 <sd_mmc_spi_command+0xbc>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80002278:	3f f9       	mov	r9,-1
8000227a:	48 d8       	lddpc	r8,800022ac <sd_mmc_spi_command+0xc0>
8000227c:	b0 89       	st.b	r8[0x0],r9
8000227e:	30 07       	mov	r7,0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002280:	e0 64 00 ff 	mov	r4,255
80002284:	10 93       	mov	r3,r8
80002286:	12 96       	mov	r6,r9
  {
    retry++;
    if(retry > 10) break;
80002288:	30 b5       	mov	r5,11
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000228a:	c0 68       	rjmp	80002296 <sd_mmc_spi_command+0xaa>
  {
    retry++;
8000228c:	2f f7       	sub	r7,-1
8000228e:	5c 57       	castu.b	r7
    if(retry > 10) break;
80002290:	ea 07 18 00 	cp.b	r7,r5
80002294:	c0 80       	breq	800022a4 <sd_mmc_spi_command+0xb8>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002296:	08 9c       	mov	r12,r4
80002298:	f0 1f 00 06 	mcall	800022b0 <sd_mmc_spi_command+0xc4>
8000229c:	a6 8c       	st.b	r3[0x0],r12
8000229e:	ec 0c 18 00 	cp.b	r12,r6
800022a2:	cf 50       	breq	8000228c <sd_mmc_spi_command+0xa0>
  {
    retry++;
    if(retry > 10) break;
  }
  return r1;
}
800022a4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	2d 8e       	sub	lr,-40
800022ac:	00 00       	add	r0,r0
800022ae:	09 ec       	ld.ub	r12,r4[0x6]
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	21 24       	sub	r4,18

800022b4 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
800022b4:	eb cd 40 c0 	pushm	r6-r7,lr
800022b8:	18 97       	mov	r7,r12
800022ba:	16 96       	mov	r6,r11
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800022bc:	30 1b       	mov	r11,1
800022be:	fe 7c 24 00 	mov	r12,-56320
800022c2:	f0 1f 00 09 	mcall	800022e4 <sd_mmc_spi_send_command+0x30>
  r1 = sd_mmc_spi_command(command, arg);
800022c6:	0c 9b       	mov	r11,r6
800022c8:	0e 9c       	mov	r12,r7
800022ca:	f0 1f 00 08 	mcall	800022e8 <sd_mmc_spi_send_command+0x34>
800022ce:	48 87       	lddpc	r7,800022ec <sd_mmc_spi_send_command+0x38>
800022d0:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800022d2:	30 1b       	mov	r11,1
800022d4:	fe 7c 24 00 	mov	r12,-56320
800022d8:	f0 1f 00 06 	mcall	800022f0 <sd_mmc_spi_send_command+0x3c>
  return r1;
}
800022dc:	0f 8c       	ld.ub	r12,r7[0x0]
800022de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800022e2:	00 00       	add	r0,r0
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	2c 5c       	sub	r12,-59
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	21 ec       	sub	r12,30
800022ec:	00 00       	add	r0,r0
800022ee:	09 ec       	ld.ub	r12,r4[0x6]
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	2c a8       	sub	r8,-54

800022f4 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
800022f4:	eb cd 40 fe 	pushm	r1-r7,lr
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
800022f8:	49 a8       	lddpc	r8,80002360 <sd_mmc_spi_check_presence+0x6c>
800022fa:	11 89       	ld.ub	r9,r8[0x0]
800022fc:	30 08       	mov	r8,0
800022fe:	f0 09 18 00 	cp.b	r9,r8
80002302:	c1 f1       	brne	80002340 <sd_mmc_spi_check_presence+0x4c>
80002304:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002306:	0e 94       	mov	r4,r7
80002308:	49 73       	lddpc	r3,80002364 <sd_mmc_spi_check_presence+0x70>
8000230a:	30 16       	mov	r6,1
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000230c:	e0 62 00 ff 	mov	r2,255
80002310:	fe 71 24 00 	mov	r1,-56320
      retry++;
      if (retry > 10)
80002314:	30 b5       	mov	r5,11
80002316:	c0 c8       	rjmp	8000232e <sd_mmc_spi_check_presence+0x3a>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002318:	04 9b       	mov	r11,r2
8000231a:	02 9c       	mov	r12,r1
8000231c:	f0 1f 00 13 	mcall	80002368 <sd_mmc_spi_check_presence+0x74>
      retry++;
80002320:	2f f7       	sub	r7,-1
80002322:	5c 87       	casts.h	r7
      if (retry > 10)
80002324:	ea 07 19 00 	cp.h	r7,r5
80002328:	c0 31       	brne	8000232e <sd_mmc_spi_check_presence+0x3a>
8000232a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
8000232e:	08 9b       	mov	r11,r4
80002330:	08 9c       	mov	r12,r4
80002332:	f0 1f 00 0f 	mcall	8000236c <sd_mmc_spi_check_presence+0x78>
80002336:	a6 8c       	st.b	r3[0x0],r12
80002338:	ec 0c 18 00 	cp.b	r12,r6
8000233c:	ce e1       	brne	80002318 <sd_mmc_spi_check_presence+0x24>
8000233e:	c0 e8       	rjmp	8000235a <sd_mmc_spi_check_presence+0x66>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80002340:	30 0b       	mov	r11,0
80002342:	33 bc       	mov	r12,59
80002344:	f0 1f 00 0a 	mcall	8000236c <sd_mmc_spi_check_presence+0x78>
80002348:	48 78       	lddpc	r8,80002364 <sd_mmc_spi_check_presence+0x70>
8000234a:	b0 8c       	st.b	r8[0x0],r12
8000234c:	58 0c       	cp.w	r12,0
8000234e:	c0 60       	breq	8000235a <sd_mmc_spi_check_presence+0x66>
      return true;
    sd_mmc_spi_init_done = false;
80002350:	30 09       	mov	r9,0
80002352:	48 48       	lddpc	r8,80002360 <sd_mmc_spi_check_presence+0x6c>
80002354:	b0 89       	st.b	r8[0x0],r9
80002356:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
    return false;
8000235a:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
8000235e:	00 00       	add	r0,r0
80002360:	00 00       	add	r0,r0
80002362:	05 80       	ld.ub	r0,r2[0x0]
80002364:	00 00       	add	r0,r0
80002366:	09 ec       	ld.ub	r12,r4[0x6]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	2d 8e       	sub	lr,-40
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	22 b4       	sub	r4,43

80002370 <sd_mmc_spi_write_sector_from_ram>:
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
{
80002370:	eb cd 40 e0 	pushm	r5-r7,lr
80002374:	18 97       	mov	r7,r12
  const uint8_t *_ram = ram;
  uint16_t i;

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002376:	f0 1f 00 49 	mcall	80002498 <sd_mmc_spi_write_sector_from_ram+0x128>
8000237a:	e0 80 00 8c 	breq	80002492 <sd_mmc_spi_write_sector_from_ram+0x122>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000237e:	30 1b       	mov	r11,1
80002380:	fe 7c 24 00 	mov	r12,-56320
80002384:	f0 1f 00 46 	mcall	8000249c <sd_mmc_spi_write_sector_from_ram+0x12c>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80002388:	4c 68       	lddpc	r8,800024a0 <sd_mmc_spi_write_sector_from_ram+0x130>
8000238a:	11 89       	ld.ub	r9,r8[0x0]
8000238c:	30 38       	mov	r8,3
8000238e:	f0 09 18 00 	cp.b	r9,r8
80002392:	c0 a1       	brne	800023a6 <sd_mmc_spi_write_sector_from_ram+0x36>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
80002394:	4c 48       	lddpc	r8,800024a4 <sd_mmc_spi_write_sector_from_ram+0x134>
80002396:	70 0b       	ld.w	r11,r8[0x0]
80002398:	a9 9b       	lsr	r11,0x9
8000239a:	31 8c       	mov	r12,24
8000239c:	f0 1f 00 43 	mcall	800024a8 <sd_mmc_spi_write_sector_from_ram+0x138>
800023a0:	4c 38       	lddpc	r8,800024ac <sd_mmc_spi_write_sector_from_ram+0x13c>
800023a2:	b0 8c       	st.b	r8[0x0],r12
800023a4:	c0 88       	rjmp	800023b4 <sd_mmc_spi_write_sector_from_ram+0x44>
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
800023a6:	4c 08       	lddpc	r8,800024a4 <sd_mmc_spi_write_sector_from_ram+0x134>
800023a8:	70 0b       	ld.w	r11,r8[0x0]
800023aa:	31 8c       	mov	r12,24
800023ac:	f0 1f 00 3f 	mcall	800024a8 <sd_mmc_spi_write_sector_from_ram+0x138>
800023b0:	4b f8       	lddpc	r8,800024ac <sd_mmc_spi_write_sector_from_ram+0x13c>
800023b2:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if(r1 != 0x00)
800023b4:	4b e8       	lddpc	r8,800024ac <sd_mmc_spi_write_sector_from_ram+0x13c>
800023b6:	11 89       	ld.ub	r9,r8[0x0]
800023b8:	30 08       	mov	r8,0
800023ba:	f0 09 18 00 	cp.b	r9,r8
800023be:	c0 80       	breq	800023ce <sd_mmc_spi_write_sector_from_ram+0x5e>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800023c0:	30 1b       	mov	r11,1
800023c2:	fe 7c 24 00 	mov	r12,-56320
800023c6:	f0 1f 00 3b 	mcall	800024b0 <sd_mmc_spi_write_sector_from_ram+0x140>
800023ca:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800023ce:	e0 6b 00 ff 	mov	r11,255
800023d2:	fe 7c 24 00 	mov	r12,-56320
800023d6:	f0 1f 00 38 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
800023da:	e0 6b 00 fe 	mov	r11,254
800023de:	fe 7c 24 00 	mov	r12,-56320
800023e2:	f0 1f 00 35 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
800023e6:	ee c6 fe 00 	sub	r6,r7,-512
  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
800023ea:	fe 75 24 00 	mov	r5,-56320
800023ee:	0f 3b       	ld.ub	r11,r7++
800023f0:	0a 9c       	mov	r12,r5
800023f2:	f0 1f 00 31 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800023f6:	0c 37       	cp.w	r7,r6
800023f8:	cf b1       	brne	800023ee <sd_mmc_spi_write_sector_from_ram+0x7e>
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
800023fa:	e0 6b 00 ff 	mov	r11,255
800023fe:	fe 7c 24 00 	mov	r12,-56320
80002402:	f0 1f 00 2d 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>
  spi_write(SD_MMC_SPI,0xFF);
80002406:	e0 6b 00 ff 	mov	r11,255
8000240a:	fe 7c 24 00 	mov	r12,-56320
8000240e:	f0 1f 00 2a 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002412:	e0 6c 00 ff 	mov	r12,255
80002416:	f0 1f 00 29 	mcall	800024b8 <sd_mmc_spi_write_sector_from_ram+0x148>
8000241a:	4a 58       	lddpc	r8,800024ac <sd_mmc_spi_write_sector_from_ram+0x13c>
8000241c:	b0 8c       	st.b	r8[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
8000241e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002422:	58 5c       	cp.w	r12,5
80002424:	c1 40       	breq	8000244c <sd_mmc_spi_write_sector_from_ram+0xdc>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80002426:	e0 6b 00 ff 	mov	r11,255
8000242a:	fe 7c 24 00 	mov	r12,-56320
8000242e:	f0 1f 00 22 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>
    spi_write(SD_MMC_SPI,0xFF);
80002432:	e0 6b 00 ff 	mov	r11,255
80002436:	fe 7c 24 00 	mov	r12,-56320
8000243a:	f0 1f 00 1f 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000243e:	30 1b       	mov	r11,1
80002440:	fe 7c 24 00 	mov	r12,-56320
80002444:	f0 1f 00 1b 	mcall	800024b0 <sd_mmc_spi_write_sector_from_ram+0x140>
80002448:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
8000244c:	e0 6b 00 ff 	mov	r11,255
80002450:	fe 7c 24 00 	mov	r12,-56320
80002454:	f0 1f 00 18 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>
  spi_write(SD_MMC_SPI,0xFF);
80002458:	e0 6b 00 ff 	mov	r11,255
8000245c:	fe 7c 24 00 	mov	r12,-56320
80002460:	f0 1f 00 15 	mcall	800024b4 <sd_mmc_spi_write_sector_from_ram+0x144>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002464:	30 1b       	mov	r11,1
80002466:	fe 7c 24 00 	mov	r12,-56320
8000246a:	f0 1f 00 12 	mcall	800024b0 <sd_mmc_spi_write_sector_from_ram+0x140>
  gl_ptr_mem += 512;        // Update the memory pointer.
8000246e:	48 e8       	lddpc	r8,800024a4 <sd_mmc_spi_write_sector_from_ram+0x134>
80002470:	70 09       	ld.w	r9,r8[0x0]
80002472:	f2 c9 fe 00 	sub	r9,r9,-512
80002476:	91 09       	st.w	r8[0x0],r9
80002478:	30 07       	mov	r7,0
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
8000247a:	30 a6       	mov	r6,10
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
8000247c:	c0 68       	rjmp	80002488 <sd_mmc_spi_write_sector_from_ram+0x118>
  {
    i++;
8000247e:	2f f7       	sub	r7,-1
80002480:	5c 87       	casts.h	r7
    if (i == 10)
80002482:	ec 07 19 00 	cp.h	r7,r6
80002486:	c0 60       	breq	80002492 <sd_mmc_spi_write_sector_from_ram+0x122>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
80002488:	f0 1f 00 04 	mcall	80002498 <sd_mmc_spi_write_sector_from_ram+0x128>
8000248c:	cf 90       	breq	8000247e <sd_mmc_spi_write_sector_from_ram+0x10e>
8000248e:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002492:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80002496:	00 00       	add	r0,r0
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	21 58       	sub	r8,21
8000249c:	80 00       	ld.sh	r0,r0[0x0]
8000249e:	2c 5c       	sub	r12,-59
800024a0:	00 00       	add	r0,r0
800024a2:	09 da       	ld.ub	r10,r4[0x5]
800024a4:	00 00       	add	r0,r0
800024a6:	05 68       	ld.uh	r8,--r2
800024a8:	80 00       	ld.sh	r0,r0[0x0]
800024aa:	21 ec       	sub	r12,30
800024ac:	00 00       	add	r0,r0
800024ae:	09 ec       	ld.ub	r12,r4[0x6]
800024b0:	80 00       	ld.sh	r0,r0[0x0]
800024b2:	2c a8       	sub	r8,-54
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	2d 8e       	sub	lr,-40
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	21 24       	sub	r4,18

800024bc <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
800024bc:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800024c0:	f0 1f 00 1c 	mcall	80002530 <sd_mmc_spi_check_hc+0x74>
800024c4:	c0 31       	brne	800024ca <sd_mmc_spi_check_hc+0xe>
800024c6:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800024ca:	30 1b       	mov	r11,1
800024cc:	fe 7c 24 00 	mov	r12,-56320
800024d0:	f0 1f 00 19 	mcall	80002534 <sd_mmc_spi_check_hc+0x78>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
800024d4:	30 0b       	mov	r11,0
800024d6:	33 ac       	mov	r12,58
800024d8:	f0 1f 00 18 	mcall	80002538 <sd_mmc_spi_check_hc+0x7c>
800024dc:	49 88       	lddpc	r8,8000253c <sd_mmc_spi_check_hc+0x80>
800024de:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0) {
800024e0:	58 0c       	cp.w	r12,0
800024e2:	c0 80       	breq	800024f2 <sd_mmc_spi_check_hc+0x36>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800024e4:	30 1b       	mov	r11,1
800024e6:	fe 7c 24 00 	mov	r12,-56320
800024ea:	f0 1f 00 16 	mcall	80002540 <sd_mmc_spi_check_hc+0x84>
800024ee:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
800024f2:	e0 6c 00 ff 	mov	r12,255
800024f6:	f0 1f 00 14 	mcall	80002544 <sd_mmc_spi_check_hc+0x88>
800024fa:	18 96       	mov	r6,r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
800024fc:	e0 6c 00 ff 	mov	r12,255
80002500:	f0 1f 00 11 	mcall	80002544 <sd_mmc_spi_check_hc+0x88>
80002504:	48 e7       	lddpc	r7,8000253c <sd_mmc_spi_check_hc+0x80>
80002506:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002508:	e0 6c 00 ff 	mov	r12,255
8000250c:	f0 1f 00 0e 	mcall	80002544 <sd_mmc_spi_check_hc+0x88>
80002510:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002512:	e0 6c 00 ff 	mov	r12,255
80002516:	f0 1f 00 0c 	mcall	80002544 <sd_mmc_spi_check_hc+0x88>
8000251a:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000251c:	30 1b       	mov	r11,1
8000251e:	fe 7c 24 00 	mov	r12,-56320
80002522:	f0 1f 00 08 	mcall	80002540 <sd_mmc_spi_check_hc+0x84>
80002526:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
8000252a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000252e:	00 00       	add	r0,r0
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	21 58       	sub	r8,21
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	2c 5c       	sub	r12,-59
80002538:	80 00       	ld.sh	r0,r0[0x0]
8000253a:	21 ec       	sub	r12,30
8000253c:	00 00       	add	r0,r0
8000253e:	09 ec       	ld.ub	r12,r4[0x6]
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	2c a8       	sub	r8,-54
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	21 24       	sub	r4,18

80002548 <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80002548:	eb cd 40 80 	pushm	r7,lr
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000254c:	f0 1f 00 27 	mcall	800025e8 <sd_mmc_spi_get_if+0xa0>
80002550:	c0 31       	brne	80002556 <sd_mmc_spi_get_if+0xe>
80002552:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002556:	30 1b       	mov	r11,1
80002558:	fe 7c 24 00 	mov	r12,-56320
8000255c:	f0 1f 00 24 	mcall	800025ec <sd_mmc_spi_get_if+0xa4>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
80002560:	e0 6b 01 aa 	mov	r11,426
80002564:	30 8c       	mov	r12,8
80002566:	f0 1f 00 23 	mcall	800025f0 <sd_mmc_spi_get_if+0xa8>
8000256a:	4a 38       	lddpc	r8,800025f4 <sd_mmc_spi_get_if+0xac>
8000256c:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
8000256e:	e2 1c 00 04 	andl	r12,0x4,COH
80002572:	c0 80       	breq	80002582 <sd_mmc_spi_get_if+0x3a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002574:	30 1b       	mov	r11,1
80002576:	fe 7c 24 00 	mov	r12,-56320
8000257a:	f0 1f 00 20 	mcall	800025f8 <sd_mmc_spi_get_if+0xb0>
8000257e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002582:	e0 6c 00 ff 	mov	r12,255
80002586:	f0 1f 00 1e 	mcall	800025fc <sd_mmc_spi_get_if+0xb4>
8000258a:	49 b7       	lddpc	r7,800025f4 <sd_mmc_spi_get_if+0xac>
8000258c:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000258e:	e0 6c 00 ff 	mov	r12,255
80002592:	f0 1f 00 1b 	mcall	800025fc <sd_mmc_spi_get_if+0xb4>
80002596:	ae 8c       	st.b	r7[0x0],r12
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002598:	e0 6c 00 ff 	mov	r12,255
8000259c:	f0 1f 00 18 	mcall	800025fc <sd_mmc_spi_get_if+0xb4>
800025a0:	ae 8c       	st.b	r7[0x0],r12
  if((r1 & 0x01) == 0) {
800025a2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800025a6:	c0 81       	brne	800025b6 <sd_mmc_spi_get_if+0x6e>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025a8:	30 1b       	mov	r11,1
800025aa:	fe 7c 24 00 	mov	r12,-56320
800025ae:	f0 1f 00 13 	mcall	800025f8 <sd_mmc_spi_get_if+0xb0>
800025b2:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
800025b6:	e0 6c 00 ff 	mov	r12,255
800025ba:	f0 1f 00 11 	mcall	800025fc <sd_mmc_spi_get_if+0xb4>
800025be:	48 e8       	lddpc	r8,800025f4 <sd_mmc_spi_get_if+0xac>
800025c0:	b0 8c       	st.b	r8[0x0],r12
  if(r1 != 0xaa) {
800025c2:	3a a8       	mov	r8,-86
800025c4:	f0 0c 18 00 	cp.b	r12,r8
800025c8:	c0 80       	breq	800025d8 <sd_mmc_spi_get_if+0x90>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025ca:	30 1b       	mov	r11,1
800025cc:	fe 7c 24 00 	mov	r12,-56320
800025d0:	f0 1f 00 0a 	mcall	800025f8 <sd_mmc_spi_get_if+0xb0>
800025d4:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025d8:	30 1b       	mov	r11,1
800025da:	fe 7c 24 00 	mov	r12,-56320
800025de:	f0 1f 00 07 	mcall	800025f8 <sd_mmc_spi_get_if+0xb0>
800025e2:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800025e6:	00 00       	add	r0,r0
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	21 58       	sub	r8,21
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	2c 5c       	sub	r12,-59
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	21 ec       	sub	r12,30
800025f4:	00 00       	add	r0,r0
800025f6:	09 ec       	ld.ub	r12,r4[0x6]
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	2c a8       	sub	r8,-54
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	21 24       	sub	r4,18

80002600 <sd_mmc_spi_read_sector_to_ram>:
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
80002600:	eb cd 40 f8 	pushm	r3-r7,lr
80002604:	20 1d       	sub	sp,4
80002606:	18 93       	mov	r3,r12
  uint8_t *_ram = ram;
  uint16_t  i;
  uint16_t  read_time_out;
  unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002608:	f0 1f 00 48 	mcall	80002728 <sd_mmc_spi_read_sector_to_ram+0x128>
8000260c:	e0 80 00 8a 	breq	80002720 <sd_mmc_spi_read_sector_to_ram+0x120>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002610:	30 1b       	mov	r11,1
80002612:	fe 7c 24 00 	mov	r12,-56320
80002616:	f0 1f 00 46 	mcall	8000272c <sd_mmc_spi_read_sector_to_ram+0x12c>

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
8000261a:	4c 68       	lddpc	r8,80002730 <sd_mmc_spi_read_sector_to_ram+0x130>
8000261c:	11 89       	ld.ub	r9,r8[0x0]
8000261e:	30 38       	mov	r8,3
80002620:	f0 09 18 00 	cp.b	r9,r8
80002624:	c0 a1       	brne	80002638 <sd_mmc_spi_read_sector_to_ram+0x38>
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
80002626:	4c 48       	lddpc	r8,80002734 <sd_mmc_spi_read_sector_to_ram+0x134>
80002628:	70 0b       	ld.w	r11,r8[0x0]
8000262a:	a9 9b       	lsr	r11,0x9
8000262c:	31 1c       	mov	r12,17
8000262e:	f0 1f 00 43 	mcall	80002738 <sd_mmc_spi_read_sector_to_ram+0x138>
80002632:	4c 38       	lddpc	r8,8000273c <sd_mmc_spi_read_sector_to_ram+0x13c>
80002634:	b0 8c       	st.b	r8[0x0],r12
80002636:	c0 88       	rjmp	80002646 <sd_mmc_spi_read_sector_to_ram+0x46>
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
80002638:	4b f8       	lddpc	r8,80002734 <sd_mmc_spi_read_sector_to_ram+0x134>
8000263a:	70 0b       	ld.w	r11,r8[0x0]
8000263c:	31 1c       	mov	r12,17
8000263e:	f0 1f 00 3f 	mcall	80002738 <sd_mmc_spi_read_sector_to_ram+0x138>
80002642:	4b f8       	lddpc	r8,8000273c <sd_mmc_spi_read_sector_to_ram+0x13c>
80002644:	b0 8c       	st.b	r8[0x0],r12
  }

  // check for valid response
  if (r1 != 0x00)
80002646:	4b e8       	lddpc	r8,8000273c <sd_mmc_spi_read_sector_to_ram+0x13c>
80002648:	11 89       	ld.ub	r9,r8[0x0]
8000264a:	30 08       	mov	r8,0
8000264c:	f0 09 18 00 	cp.b	r9,r8
80002650:	c1 20       	breq	80002674 <sd_mmc_spi_read_sector_to_ram+0x74>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002652:	30 1b       	mov	r11,1
80002654:	fe 7c 24 00 	mov	r12,-56320
80002658:	f0 1f 00 3a 	mcall	80002740 <sd_mmc_spi_read_sector_to_ram+0x140>
8000265c:	30 0c       	mov	r12,0
    return false;
8000265e:	c6 18       	rjmp	80002720 <sd_mmc_spi_read_sector_to_ram+0x120>

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
80002660:	20 17       	sub	r7,1
80002662:	5c 87       	casts.h	r7
     if (read_time_out == 0)   // TIME-OUT
80002664:	c0 e1       	brne	80002680 <sd_mmc_spi_read_sector_to_ram+0x80>
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
80002666:	30 1b       	mov	r11,1
80002668:	fe 7c 24 00 	mov	r12,-56320
8000266c:	f0 1f 00 35 	mcall	80002740 <sd_mmc_spi_read_sector_to_ram+0x140>
80002670:	30 0c       	mov	r12,0
       return false;
80002672:	c5 78       	rjmp	80002720 <sd_mmc_spi_read_sector_to_ram+0x120>
80002674:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002678:	e0 65 00 ff 	mov	r5,255
8000267c:	4b 04       	lddpc	r4,8000273c <sd_mmc_spi_read_sector_to_ram+0x13c>
8000267e:	3f f6       	mov	r6,-1
80002680:	0a 9c       	mov	r12,r5
80002682:	f0 1f 00 31 	mcall	80002744 <sd_mmc_spi_read_sector_to_ram+0x144>
80002686:	a8 8c       	st.b	r4[0x0],r12
80002688:	ec 0c 18 00 	cp.b	r12,r6
8000268c:	ce a0       	breq	80002660 <sd_mmc_spi_read_sector_to_ram+0x60>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
8000268e:	3f e8       	mov	r8,-2
80002690:	f0 0c 18 00 	cp.b	r12,r8
80002694:	c0 e0       	breq	800026b0 <sd_mmc_spi_read_sector_to_ram+0xb0>
  {
    spi_write(SD_MMC_SPI,0xFF);
80002696:	e0 6b 00 ff 	mov	r11,255
8000269a:	fe 7c 24 00 	mov	r12,-56320
8000269e:	f0 1f 00 2b 	mcall	80002748 <sd_mmc_spi_read_sector_to_ram+0x148>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800026a2:	30 1b       	mov	r11,1
800026a4:	fe 7c 24 00 	mov	r12,-56320
800026a8:	f0 1f 00 26 	mcall	80002740 <sd_mmc_spi_read_sector_to_ram+0x140>
800026ac:	30 0c       	mov	r12,0
    return false;
800026ae:	c3 98       	rjmp	80002720 <sd_mmc_spi_read_sector_to_ram+0x120>
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
{
  uint8_t *_ram = ram;
800026b0:	06 97       	mov	r7,r3
//!
//! @return bit
//!   The read succeeded   -> true
//!   The read failed (bad address, etc.)  -> false
//!/
bool sd_mmc_spi_read_sector_to_ram(void *ram)
800026b2:	e6 c5 fe 00 	sub	r5,r3,-512
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800026b6:	e0 64 00 ff 	mov	r4,255
800026ba:	fe 76 24 00 	mov	r6,-56320
    spi_read(SD_MMC_SPI,&data_read);
800026be:	fa c3 ff fe 	sub	r3,sp,-2
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,0xFF);
800026c2:	08 9b       	mov	r11,r4
800026c4:	0c 9c       	mov	r12,r6
800026c6:	f0 1f 00 21 	mcall	80002748 <sd_mmc_spi_read_sector_to_ram+0x148>
    spi_read(SD_MMC_SPI,&data_read);
800026ca:	06 9b       	mov	r11,r3
800026cc:	0c 9c       	mov	r12,r6
800026ce:	f0 1f 00 20 	mcall	8000274c <sd_mmc_spi_read_sector_to_ram+0x14c>
    *_ram++=data_read;
800026d2:	9a 18       	ld.sh	r8,sp[0x2]
800026d4:	0e c8       	st.b	r7++,r8
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return false;
  }

  // store datablock
  for(i=0;i<MMC_SECTOR_SIZE;i++)
800026d6:	0a 37       	cp.w	r7,r5
800026d8:	cf 51       	brne	800026c2 <sd_mmc_spi_read_sector_to_ram+0xc2>
  {
    spi_write(SD_MMC_SPI,0xFF);
    spi_read(SD_MMC_SPI,&data_read);
    *_ram++=data_read;
  }
  gl_ptr_mem += 512;     // Update the memory pointer.
800026da:	49 78       	lddpc	r8,80002734 <sd_mmc_spi_read_sector_to_ram+0x134>
800026dc:	70 09       	ld.w	r9,r8[0x0]
800026de:	f2 c9 fe 00 	sub	r9,r9,-512
800026e2:	91 09       	st.w	r8[0x0],r9

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
800026e4:	e0 6b 00 ff 	mov	r11,255
800026e8:	fe 7c 24 00 	mov	r12,-56320
800026ec:	f0 1f 00 17 	mcall	80002748 <sd_mmc_spi_read_sector_to_ram+0x148>
  spi_write(SD_MMC_SPI,0xFF);
800026f0:	e0 6b 00 ff 	mov	r11,255
800026f4:	fe 7c 24 00 	mov	r12,-56320
800026f8:	f0 1f 00 14 	mcall	80002748 <sd_mmc_spi_read_sector_to_ram+0x148>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
800026fc:	e0 6b 00 ff 	mov	r11,255
80002700:	fe 7c 24 00 	mov	r12,-56320
80002704:	f0 1f 00 11 	mcall	80002748 <sd_mmc_spi_read_sector_to_ram+0x148>
  spi_write(SD_MMC_SPI,0xFF);
80002708:	e0 6b 00 ff 	mov	r11,255
8000270c:	fe 7c 24 00 	mov	r12,-56320
80002710:	f0 1f 00 0e 	mcall	80002748 <sd_mmc_spi_read_sector_to_ram+0x148>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002714:	30 1b       	mov	r11,1
80002716:	fe 7c 24 00 	mov	r12,-56320
8000271a:	f0 1f 00 0a 	mcall	80002740 <sd_mmc_spi_read_sector_to_ram+0x140>
8000271e:	30 1c       	mov	r12,1

  return true;   // Read done.
}
80002720:	2f fd       	sub	sp,-4
80002722:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002726:	00 00       	add	r0,r0
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	21 58       	sub	r8,21
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	2c 5c       	sub	r12,-59
80002730:	00 00       	add	r0,r0
80002732:	09 da       	ld.ub	r10,r4[0x5]
80002734:	00 00       	add	r0,r0
80002736:	05 68       	ld.uh	r8,--r2
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	21 ec       	sub	r12,30
8000273c:	00 00       	add	r0,r0
8000273e:	09 ec       	ld.ub	r12,r4[0x6]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	2c a8       	sub	r8,-54
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	21 24       	sub	r4,18
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	2d 8e       	sub	lr,-40
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	2d aa       	sub	r10,-38

80002750 <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
80002750:	eb cd 40 fc 	pushm	r2-r7,lr
80002754:	20 1d       	sub	sp,4
80002756:	18 92       	mov	r2,r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
80002758:	f0 1f 00 32 	mcall	80002820 <sd_mmc_spi_get_csd+0xd0>
8000275c:	c5 f0       	breq	8000281a <sd_mmc_spi_get_csd+0xca>
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000275e:	30 1b       	mov	r11,1
80002760:	fe 7c 24 00 	mov	r12,-56320
80002764:	f0 1f 00 30 	mcall	80002824 <sd_mmc_spi_get_csd+0xd4>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
80002768:	30 0b       	mov	r11,0
8000276a:	30 9c       	mov	r12,9
8000276c:	f0 1f 00 2f 	mcall	80002828 <sd_mmc_spi_get_csd+0xd8>
80002770:	4a f8       	lddpc	r8,8000282c <sd_mmc_spi_get_csd+0xdc>
80002772:	b0 8c       	st.b	r8[0x0],r12
  // check for valid response
  if(r1 != 0x00)
80002774:	58 0c       	cp.w	r12,0
80002776:	c0 81       	brne	80002786 <sd_mmc_spi_get_csd+0x36>
80002778:	30 07       	mov	r7,0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
8000277a:	e0 64 00 ff 	mov	r4,255
8000277e:	10 93       	mov	r3,r8
80002780:	3f e6       	mov	r6,-2
  {
    if (retry > 8)
80002782:	30 95       	mov	r5,9
80002784:	c1 78       	rjmp	800027b2 <sd_mmc_spi_get_csd+0x62>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002786:	30 1b       	mov	r11,1
80002788:	fe 7c 24 00 	mov	r12,-56320
8000278c:	f0 1f 00 29 	mcall	80002830 <sd_mmc_spi_get_csd+0xe0>
    sd_mmc_spi_init_done = false;
80002790:	30 09       	mov	r9,0
80002792:	4a 98       	lddpc	r8,80002834 <sd_mmc_spi_get_csd+0xe4>
80002794:	b0 89       	st.b	r8[0x0],r9
80002796:	30 0c       	mov	r12,0
    return false;
80002798:	c4 18       	rjmp	8000281a <sd_mmc_spi_get_csd+0xca>
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
  {
    if (retry > 8)
8000279a:	ea 07 18 00 	cp.b	r7,r5
8000279e:	c0 81       	brne	800027ae <sd_mmc_spi_get_csd+0x5e>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800027a0:	30 1b       	mov	r11,1
800027a2:	fe 7c 24 00 	mov	r12,-56320
800027a6:	f0 1f 00 23 	mcall	80002830 <sd_mmc_spi_get_csd+0xe0>
800027aa:	30 0c       	mov	r12,0
      return false;
800027ac:	c3 78       	rjmp	8000281a <sd_mmc_spi_get_csd+0xca>
    }
    retry++;
800027ae:	2f f7       	sub	r7,-1
800027b0:	5c 57       	castu.b	r7
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800027b2:	08 9c       	mov	r12,r4
800027b4:	f0 1f 00 21 	mcall	80002838 <sd_mmc_spi_get_csd+0xe8>
800027b8:	a6 8c       	st.b	r3[0x0],r12
800027ba:	ec 0c 18 00 	cp.b	r12,r6
800027be:	ce e1       	brne	8000279a <sd_mmc_spi_get_csd+0x4a>
800027c0:	30 07       	mov	r7,0
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800027c2:	e0 65 00 ff 	mov	r5,255
800027c6:	fe 76 24 00 	mov	r6,-56320
   spi_read(SD_MMC_SPI,&data_read);
800027ca:	fa c4 ff fe 	sub	r4,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800027ce:	0a 9b       	mov	r11,r5
800027d0:	0c 9c       	mov	r12,r6
800027d2:	f0 1f 00 1b 	mcall	8000283c <sd_mmc_spi_get_csd+0xec>
   spi_read(SD_MMC_SPI,&data_read);
800027d6:	08 9b       	mov	r11,r4
800027d8:	0c 9c       	mov	r12,r6
800027da:	f0 1f 00 1a 	mcall	80002840 <sd_mmc_spi_get_csd+0xf0>
    buffer[retry] = data_read;
800027de:	9a 18       	ld.sh	r8,sp[0x2]
800027e0:	e4 07 0b 08 	st.b	r2[r7],r8
800027e4:	2f f7       	sub	r7,-1
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
800027e6:	59 07       	cp.w	r7,16
800027e8:	cf 31       	brne	800027ce <sd_mmc_spi_get_csd+0x7e>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
800027ea:	e0 6b 00 ff 	mov	r11,255
800027ee:	fe 7c 24 00 	mov	r12,-56320
800027f2:	f0 1f 00 13 	mcall	8000283c <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);
800027f6:	e0 6b 00 ff 	mov	r11,255
800027fa:	fe 7c 24 00 	mov	r12,-56320
800027fe:	f0 1f 00 10 	mcall	8000283c <sd_mmc_spi_get_csd+0xec>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80002802:	e0 6b 00 ff 	mov	r11,255
80002806:	fe 7c 24 00 	mov	r12,-56320
8000280a:	f0 1f 00 0d 	mcall	8000283c <sd_mmc_spi_get_csd+0xec>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000280e:	30 1b       	mov	r11,1
80002810:	fe 7c 24 00 	mov	r12,-56320
80002814:	f0 1f 00 07 	mcall	80002830 <sd_mmc_spi_get_csd+0xe0>
80002818:	30 1c       	mov	r12,1
  return true;
}
8000281a:	2f fd       	sub	sp,-4
8000281c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	21 58       	sub	r8,21
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	2c 5c       	sub	r12,-59
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	21 ec       	sub	r12,30
8000282c:	00 00       	add	r0,r0
8000282e:	09 ec       	ld.ub	r12,r4[0x6]
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	2c a8       	sub	r8,-54
80002834:	00 00       	add	r0,r0
80002836:	05 80       	ld.ub	r0,r2[0x0]
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	21 24       	sub	r4,18
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	2d 8e       	sub	lr,-40
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	2d aa       	sub	r10,-38

80002844 <sd_mmc_spi_internal_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
80002844:	d4 31       	pushm	r0-r7,lr
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
80002846:	fe fb 02 66 	ld.w	r11,pc[614]
8000284a:	e6 68 1a 80 	mov	r8,400000
8000284e:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80002850:	fe f8 02 60 	ld.w	r8,pc[608]
80002854:	70 0a       	ld.w	r10,r8[0x0]
80002856:	fe 7c 24 00 	mov	r12,-56320
8000285a:	f0 1f 00 97 	mcall	80002ab4 <sd_mmc_spi_internal_init+0x270>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000285e:	30 1b       	mov	r11,1
80002860:	fe 7c 24 00 	mov	r12,-56320
80002864:	f0 1f 00 95 	mcall	80002ab8 <sd_mmc_spi_internal_init+0x274>
80002868:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
    spi_write(SD_MMC_SPI,0xFF);
8000286a:	e0 66 00 ff 	mov	r6,255
8000286e:	fe 75 24 00 	mov	r5,-56320
80002872:	0c 9b       	mov	r11,r6
80002874:	0a 9c       	mov	r12,r5
80002876:	f0 1f 00 92 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
8000287a:	2f f7       	sub	r7,-1
8000287c:	58 a7       	cp.w	r7,10
8000287e:	cf a1       	brne	80002872 <sd_mmc_spi_internal_init+0x2e>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002880:	30 1b       	mov	r11,1
80002882:	fe 7c 24 00 	mov	r12,-56320
80002886:	f0 1f 00 8f 	mcall	80002ac0 <sd_mmc_spi_internal_init+0x27c>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
8000288a:	30 08       	mov	r8,0
8000288c:	fe f9 02 38 	ld.w	r9,pc[568]
80002890:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
80002892:	fe f9 02 36 	ld.w	r9,pc[566]
80002896:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80002898:	30 0b       	mov	r11,0
8000289a:	16 9c       	mov	r12,r11
8000289c:	f0 1f 00 8c 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
800028a0:	fe f8 02 30 	ld.w	r8,pc[560]
800028a4:	b0 8c       	st.b	r8[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800028a6:	e0 6b 00 ff 	mov	r11,255
800028aa:	fe 7c 24 00 	mov	r12,-56320
800028ae:	f0 1f 00 84 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
800028b2:	30 17       	mov	r7,1
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800028b4:	fe f6 02 1c 	ld.w	r6,pc[540]
800028b8:	30 15       	mov	r5,1
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028ba:	30 03       	mov	r3,0
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800028bc:	e0 62 00 ff 	mov	r2,255
800028c0:	fe 71 24 00 	mov	r1,-56320
    // do retry counter
    retry++;
    if(retry > 100)
800028c4:	36 54       	mov	r4,101
800028c6:	c1 08       	rjmp	800028e6 <sd_mmc_spi_internal_init+0xa2>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800028c8:	06 9b       	mov	r11,r3
800028ca:	06 9c       	mov	r12,r3
800028cc:	f0 1f 00 80 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
800028d0:	ac 8c       	st.b	r6[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800028d2:	04 9b       	mov	r11,r2
800028d4:	02 9c       	mov	r12,r1
800028d6:	f0 1f 00 7a 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
    // do retry counter
    retry++;
800028da:	2f f7       	sub	r7,-1
800028dc:	5c 87       	casts.h	r7
    if(retry > 100)
800028de:	e8 07 19 00 	cp.h	r7,r4
800028e2:	e0 80 00 e4 	breq	80002aaa <sd_mmc_spi_internal_init+0x266>
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800028e6:	0d 88       	ld.ub	r8,r6[0x0]
800028e8:	ea 08 18 00 	cp.b	r8,r5
800028ec:	ce e1       	brne	800028c8 <sd_mmc_spi_internal_init+0x84>

  if_cond = sd_mmc_spi_get_if();
800028ee:	f0 1f 00 7a 	mcall	80002ad4 <sd_mmc_spi_internal_init+0x290>
  if(if_cond == -1) {
800028f2:	5b fc       	cp.w	r12,-1
800028f4:	e0 80 00 db 	breq	80002aaa <sd_mmc_spi_internal_init+0x266>
      return false; // card is bad
  } else if (if_cond == 1) {
800028f8:	58 1c       	cp.w	r12,1
800028fa:	c0 51       	brne	80002904 <sd_mmc_spi_internal_init+0xc0>
      card_type = SD_CARD_2;
800028fc:	30 29       	mov	r9,2
800028fe:	4f 38       	lddpc	r8,80002ac8 <sd_mmc_spi_internal_init+0x284>
80002900:	b0 89       	st.b	r8[0x0],r9
80002902:	c4 c8       	rjmp	8000299a <sd_mmc_spi_internal_init+0x156>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
80002904:	30 0b       	mov	r11,0
80002906:	33 7c       	mov	r12,55
80002908:	f0 1f 00 71 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
8000290c:	4f 17       	lddpc	r7,80002ad0 <sd_mmc_spi_internal_init+0x28c>
8000290e:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80002910:	e0 6b 00 ff 	mov	r11,255
80002914:	fe 7c 24 00 	mov	r12,-56320
80002918:	f0 1f 00 69 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
8000291c:	30 0b       	mov	r11,0
8000291e:	32 9c       	mov	r12,41
80002920:	f0 1f 00 6b 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
80002924:	ae 8c       	st.b	r7[0x0],r12
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80002926:	e0 6b 00 ff 	mov	r11,255
8000292a:	fe 7c 24 00 	mov	r12,-56320
8000292e:	f0 1f 00 64 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
80002932:	0f 88       	ld.ub	r8,r7[0x0]
80002934:	e2 18 00 fe 	andl	r8,0xfe,COH
80002938:	c0 51       	brne	80002942 <sd_mmc_spi_internal_init+0xfe>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
8000293a:	30 19       	mov	r9,1
8000293c:	4e 38       	lddpc	r8,80002ac8 <sd_mmc_spi_internal_init+0x284>
8000293e:	b0 89       	st.b	r8[0x0],r9
80002940:	c2 d8       	rjmp	8000299a <sd_mmc_spi_internal_init+0x156>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80002942:	30 09       	mov	r9,0
80002944:	4e 18       	lddpc	r8,80002ac8 <sd_mmc_spi_internal_init+0x284>
80002946:	b0 89       	st.b	r8[0x0],r9
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80002948:	30 0b       	mov	r11,0
8000294a:	16 9c       	mov	r12,r11
8000294c:	f0 1f 00 60 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
80002950:	4e 08       	lddpc	r8,80002ad0 <sd_mmc_spi_internal_init+0x28c>
80002952:	b0 8c       	st.b	r8[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002954:	e0 6b 00 ff 	mov	r11,255
80002958:	fe 7c 24 00 	mov	r12,-56320
8000295c:	f0 1f 00 58 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
80002960:	30 17       	mov	r7,1
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80002962:	4d c6       	lddpc	r6,80002ad0 <sd_mmc_spi_internal_init+0x28c>
80002964:	30 15       	mov	r5,1
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80002966:	30 03       	mov	r3,0
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002968:	e0 62 00 ff 	mov	r2,255
8000296c:	fe 71 24 00 	mov	r1,-56320
        // do retry counter
        retry++;
        if(retry > 100)
80002970:	36 54       	mov	r4,101
80002972:	c1 08       	rjmp	80002992 <sd_mmc_spi_internal_init+0x14e>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80002974:	06 9b       	mov	r11,r3
80002976:	06 9c       	mov	r12,r3
80002978:	f0 1f 00 55 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
8000297c:	ac 8c       	st.b	r6[0x0],r12
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000297e:	04 9b       	mov	r11,r2
80002980:	02 9c       	mov	r12,r1
80002982:	f0 1f 00 4f 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
        // do retry counter
        retry++;
80002986:	2f f7       	sub	r7,-1
80002988:	5c 87       	casts.h	r7
        if(retry > 100)
8000298a:	e8 07 19 00 	cp.h	r7,r4
8000298e:	e0 80 00 8e 	breq	80002aaa <sd_mmc_spi_internal_init+0x266>
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80002992:	0d 88       	ld.ub	r8,r6[0x0]
80002994:	ea 08 18 00 	cp.b	r8,r5
80002998:	ce e1       	brne	80002974 <sd_mmc_spi_internal_init+0x130>
8000299a:	30 07       	mov	r7,0

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
8000299c:	4c b4       	lddpc	r4,80002ac8 <sd_mmc_spi_internal_init+0x284>
8000299e:	30 15       	mov	r5,1
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800029a0:	0e 93       	mov	r3,r7
800029a2:	33 70       	mov	r0,55
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800029a4:	4c b6       	lddpc	r6,80002ad0 <sd_mmc_spi_internal_init+0x28c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800029a6:	e0 62 00 ff 	mov	r2,255
800029aa:	fe 71 24 00 	mov	r1,-56320

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800029ae:	09 88       	ld.ub	r8,r4[0x0]
800029b0:	ea 08 18 00 	cp.b	r8,r5
800029b4:	c1 10       	breq	800029d6 <sd_mmc_spi_internal_init+0x192>
800029b6:	c0 63       	brcs	800029c2 <sd_mmc_spi_internal_init+0x17e>
800029b8:	30 29       	mov	r9,2
800029ba:	f2 08 18 00 	cp.b	r8,r9
800029be:	c2 81       	brne	80002a0e <sd_mmc_spi_internal_init+0x1ca>
800029c0:	c1 98       	rjmp	800029f2 <sd_mmc_spi_internal_init+0x1ae>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
800029c2:	06 9b       	mov	r11,r3
800029c4:	30 1c       	mov	r12,1
800029c6:	f0 1f 00 42 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
800029ca:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800029cc:	04 9b       	mov	r11,r2
800029ce:	02 9c       	mov	r12,r1
800029d0:	f0 1f 00 3b 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
      break;
800029d4:	c1 d8       	rjmp	80002a0e <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800029d6:	06 9b       	mov	r11,r3
800029d8:	00 9c       	mov	r12,r0
800029da:	f0 1f 00 3d 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800029de:	06 9b       	mov	r11,r3
800029e0:	32 9c       	mov	r12,41
800029e2:	f0 1f 00 3b 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
800029e6:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800029e8:	04 9b       	mov	r11,r2
800029ea:	02 9c       	mov	r12,r1
800029ec:	f0 1f 00 34 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
      break;
800029f0:	c0 f8       	rjmp	80002a0e <sd_mmc_spi_internal_init+0x1ca>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800029f2:	06 9b       	mov	r11,r3
800029f4:	00 9c       	mov	r12,r0
800029f6:	f0 1f 00 36 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
800029fa:	fc 1b 40 00 	movh	r11,0x4000
800029fe:	32 9c       	mov	r12,41
80002a00:	f0 1f 00 33 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
80002a04:	ac 8c       	st.b	r6[0x0],r12
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a06:	04 9b       	mov	r11,r2
80002a08:	02 9c       	mov	r12,r1
80002a0a:	f0 1f 00 2d 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
      break;
    }
     // do retry counter
     retry++;
80002a0e:	2f f7       	sub	r7,-1
80002a10:	5c 87       	casts.h	r7
     if(retry == 50000)    // measured approx. 500 on several cards
80002a12:	fe 78 c3 50 	mov	r8,-15536
80002a16:	f0 07 19 00 	cp.h	r7,r8
80002a1a:	c4 80       	breq	80002aaa <sd_mmc_spi_internal_init+0x266>
        return false;
  } while (r1);
80002a1c:	0d 89       	ld.ub	r9,r6[0x0]
80002a1e:	30 08       	mov	r8,0
80002a20:	f0 09 18 00 	cp.b	r9,r8
80002a24:	cc 51       	brne	800029ae <sd_mmc_spi_internal_init+0x16a>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
80002a26:	4a 98       	lddpc	r8,80002ac8 <sd_mmc_spi_internal_init+0x284>
80002a28:	11 89       	ld.ub	r9,r8[0x0]
80002a2a:	30 28       	mov	r8,2
80002a2c:	f0 09 18 00 	cp.b	r9,r8
80002a30:	c0 a1       	brne	80002a44 <sd_mmc_spi_internal_init+0x200>
    if_cond = sd_mmc_spi_check_hc();
80002a32:	f0 1f 00 2a 	mcall	80002ad8 <sd_mmc_spi_internal_init+0x294>
    if (if_cond == -1) {
80002a36:	5b fc       	cp.w	r12,-1
80002a38:	c3 90       	breq	80002aaa <sd_mmc_spi_internal_init+0x266>
      return false;
    } else if (if_cond == 1){
80002a3a:	58 1c       	cp.w	r12,1
80002a3c:	c0 41       	brne	80002a44 <sd_mmc_spi_internal_init+0x200>
          card_type = SD_CARD_2_SDHC;
80002a3e:	30 39       	mov	r9,3
80002a40:	4a 28       	lddpc	r8,80002ac8 <sd_mmc_spi_internal_init+0x284>
80002a42:	b0 89       	st.b	r8[0x0],r9
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
80002a44:	30 0b       	mov	r11,0
80002a46:	33 bc       	mov	r12,59
80002a48:	f0 1f 00 21 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
80002a4c:	4a 17       	lddpc	r7,80002ad0 <sd_mmc_spi_internal_init+0x28c>
80002a4e:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a50:	e0 6b 00 ff 	mov	r11,255
80002a54:	fe 7c 24 00 	mov	r12,-56320
80002a58:	f0 1f 00 19 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
80002a5c:	e0 6b 02 00 	mov	r11,512
80002a60:	31 0c       	mov	r12,16
80002a62:	f0 1f 00 1b 	mcall	80002acc <sd_mmc_spi_internal_init+0x288>
80002a66:	ae 8c       	st.b	r7[0x0],r12
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a68:	e0 6b 00 ff 	mov	r11,255
80002a6c:	fe 7c 24 00 	mov	r12,-56320
80002a70:	f0 1f 00 13 	mcall	80002abc <sd_mmc_spi_internal_init+0x278>
  if (r1 != 0x00)
80002a74:	0f 89       	ld.ub	r9,r7[0x0]
80002a76:	30 08       	mov	r8,0
80002a78:	f0 09 18 00 	cp.b	r9,r8
80002a7c:	c1 71       	brne	80002aaa <sd_mmc_spi_internal_init+0x266>
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
80002a7e:	49 8c       	lddpc	r12,80002adc <sd_mmc_spi_internal_init+0x298>
80002a80:	f0 1f 00 18 	mcall	80002ae0 <sd_mmc_spi_internal_init+0x29c>
80002a84:	c1 30       	breq	80002aaa <sd_mmc_spi_internal_init+0x266>
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
80002a86:	f0 1f 00 18 	mcall	80002ae4 <sd_mmc_spi_internal_init+0x2a0>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
80002a8a:	30 19       	mov	r9,1
80002a8c:	48 e8       	lddpc	r8,80002ac4 <sd_mmc_spi_internal_init+0x280>
80002a8e:	b0 89       	st.b	r8[0x0],r9

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80002a90:	48 7b       	lddpc	r11,80002aac <sd_mmc_spi_internal_init+0x268>
80002a92:	e0 68 1b 00 	mov	r8,6912
80002a96:	ea 18 00 b7 	orh	r8,0xb7
80002a9a:	97 18       	st.w	r11[0x4],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80002a9c:	48 58       	lddpc	r8,80002ab0 <sd_mmc_spi_internal_init+0x26c>
80002a9e:	70 0a       	ld.w	r10,r8[0x0]
80002aa0:	fe 7c 24 00 	mov	r12,-56320
80002aa4:	f0 1f 00 04 	mcall	80002ab4 <sd_mmc_spi_internal_init+0x270>
80002aa8:	da 3a       	popm	r0-r7,pc,r12=1
  return true;
80002aaa:	d8 3a       	popm	r0-r7,pc,r12=0
80002aac:	00 00       	add	r0,r0
80002aae:	05 6c       	ld.uh	r12,--r2
80002ab0:	00 00       	add	r0,r0
80002ab2:	05 7c       	ld.ub	r12,--r2
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	2c d0       	sub	r0,-51
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	2c 5c       	sub	r12,-59
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	2d 8e       	sub	lr,-40
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	2c a8       	sub	r8,-54
80002ac4:	00 00       	add	r0,r0
80002ac6:	05 80       	ld.ub	r0,r2[0x0]
80002ac8:	00 00       	add	r0,r0
80002aca:	09 da       	ld.ub	r10,r4[0x5]
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	22 b4       	sub	r4,43
80002ad0:	00 00       	add	r0,r0
80002ad2:	09 ec       	ld.ub	r12,r4[0x6]
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	25 48       	sub	r8,84
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	24 bc       	sub	r12,75
80002adc:	00 00       	add	r0,r0
80002ade:	09 dc       	ld.ub	r12,r4[0x5]
80002ae0:	80 00       	ld.sh	r0,r0[0x0]
80002ae2:	27 50       	sub	r0,117
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	20 04       	sub	r4,0

80002ae8 <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
80002ae8:	d4 01       	pushm	lr
  if (sd_mmc_spi_check_presence())
80002aea:	f0 1f 00 07 	mcall	80002b04 <sd_mmc_spi_mem_check+0x1c>
80002aee:	c0 a0       	breq	80002b02 <sd_mmc_spi_mem_check+0x1a>
  {
    if (sd_mmc_spi_init_done == false)
80002af0:	48 68       	lddpc	r8,80002b08 <sd_mmc_spi_mem_check+0x20>
80002af2:	11 89       	ld.ub	r9,r8[0x0]
80002af4:	30 08       	mov	r8,0
80002af6:	f0 09 18 00 	cp.b	r9,r8
80002afa:	c0 20       	breq	80002afe <sd_mmc_spi_mem_check+0x16>
80002afc:	da 0a       	popm	pc,r12=1
    {
      return sd_mmc_spi_internal_init();
80002afe:	f0 1f 00 04 	mcall	80002b0c <sd_mmc_spi_mem_check+0x24>
    }
    else
      return true;
  }
  return false;
}
80002b02:	d8 02       	popm	pc
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	22 f4       	sub	r4,47
80002b08:	00 00       	add	r0,r0
80002b0a:	05 80       	ld.ub	r0,r2[0x0]
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	28 44       	sub	r4,-124

80002b10 <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
80002b10:	eb cd 40 10 	pushm	r4,lr
80002b14:	fa c4 ff f8 	sub	r4,sp,-8
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
80002b18:	48 88       	lddpc	r8,80002b38 <sd_mmc_spi_init+0x28>
80002b1a:	91 0c       	st.w	r8[0x0],r12
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
80002b1c:	48 88       	lddpc	r8,80002b3c <sd_mmc_spi_init+0x2c>
80002b1e:	e8 ea 00 00 	ld.d	r10,r4[0]
80002b22:	f0 eb 00 00 	st.d	r8[0],r10
80002b26:	e8 ea 00 08 	ld.d	r10,r4[8]
80002b2a:	f0 eb 00 08 	st.d	r8[8],r10

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
80002b2e:	f0 1f 00 05 	mcall	80002b40 <sd_mmc_spi_init+0x30>
}
80002b32:	e3 cd 80 10 	ldm	sp++,r4,pc
80002b36:	00 00       	add	r0,r0
80002b38:	00 00       	add	r0,r0
80002b3a:	05 7c       	ld.ub	r12,--r2
80002b3c:	00 00       	add	r0,r0
80002b3e:	05 6c       	ld.uh	r12,--r2
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	28 44       	sub	r4,-124

80002b44 <adc_configure>:
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
80002b44:	78 18       	ld.w	r8,r12[0x4]
80002b46:	ea 18 0f 00 	orh	r8,0xf00
80002b4a:	99 18       	st.w	r12[0x4],r8

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
80002b4c:	78 18       	ld.w	r8,r12[0x4]
80002b4e:	ea 18 00 1f 	orh	r8,0x1f
80002b52:	99 18       	st.w	r12[0x4],r8
}
80002b54:	5e fc       	retal	r12

80002b56 <adc_start>:
void adc_start(volatile avr32_adc_t *adc)
{
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
80002b56:	30 28       	mov	r8,2
80002b58:	99 08       	st.w	r12[0x0],r8
}
80002b5a:	5e fc       	retal	r12

80002b5c <adc_enable>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
80002b5c:	30 18       	mov	r8,1
80002b5e:	f0 0b 09 48 	lsl	r8,r8,r11
80002b62:	99 48       	st.w	r12[0x10],r8
}
80002b64:	5e fc       	retal	r12

80002b66 <adc_get_status>:
{
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	return ((adc->chsr & (1 << channel)) ? true : false);
80002b66:	78 68       	ld.w	r8,r12[0x18]
80002b68:	30 19       	mov	r9,1
80002b6a:	f2 0b 09 49 	lsl	r9,r9,r11
80002b6e:	f3 e8 00 08 	and	r8,r9,r8
}
80002b72:	5f 1c       	srne	r12
80002b74:	5e fc       	retal	r12
80002b76:	d7 03       	nop

80002b78 <adc_disable>:
 *
 * \param *adc Base address of the ADC
 * \param  channel   channel to disable (0 to 7)
 */
void adc_disable(volatile avr32_adc_t *adc, uint16_t channel)
{
80002b78:	eb cd 40 c0 	pushm	r6-r7,lr
80002b7c:	18 96       	mov	r6,r12
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	if (adc_get_status(adc, channel) == true) {
80002b7e:	ef db c0 10 	bfextu	r7,r11,0x0,0x10
80002b82:	0e 9b       	mov	r11,r7
80002b84:	f0 1f 00 06 	mcall	80002b9c <adc_disable+0x24>
80002b88:	c0 70       	breq	80002b96 <adc_disable+0x1e>
		/* disable channel */
		adc->chdr |= (1 << channel);
80002b8a:	6c 58       	ld.w	r8,r6[0x14]
80002b8c:	30 19       	mov	r9,1
80002b8e:	f2 07 09 47 	lsl	r7,r9,r7
80002b92:	10 47       	or	r7,r8
80002b94:	8d 57       	st.w	r6[0x14],r7
80002b96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b9a:	00 00       	add	r0,r0
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	2b 66       	sub	r6,-74

80002ba0 <adc_check_eoc>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
80002ba0:	78 78       	ld.w	r8,r12[0x1c]
80002ba2:	30 19       	mov	r9,1
80002ba4:	f2 0b 09 49 	lsl	r9,r9,r11
80002ba8:	f3 e8 00 08 	and	r8,r9,r8
}
80002bac:	5f 1c       	srne	r12
80002bae:	5e fc       	retal	r12

80002bb0 <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
80002bb0:	eb cd 40 e0 	pushm	r5-r7,lr
80002bb4:	18 97       	mov	r7,r12
80002bb6:	16 95       	mov	r5,r11
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
80002bb8:	ed db c0 10 	bfextu	r6,r11,0x0,0x10
80002bbc:	0c 9b       	mov	r11,r6
80002bbe:	0e 9c       	mov	r12,r7
80002bc0:	f0 1f 00 05 	mcall	80002bd4 <adc_get_value+0x24>
80002bc4:	cf c0       	breq	80002bbc <adc_get_value+0xc>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
80002bc6:	2d 07       	sub	r7,-48
80002bc8:	5c 75       	castu.h	r5
}
80002bca:	ee 05 03 2c 	ld.w	r12,r7[r5<<0x2]
80002bce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002bd2:	00 00       	add	r0,r0
80002bd4:	80 00       	ld.sh	r0,r0[0x0]
80002bd6:	2b a0       	sub	r0,-70

80002bd8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002bd8:	f8 c8 00 01 	sub	r8,r12,1
80002bdc:	f0 0b 00 0b 	add	r11,r8,r11
80002be0:	f6 0c 0d 0a 	divu	r10,r11,r12
80002be4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002be6:	f4 c8 00 01 	sub	r8,r10,1
80002bea:	e0 48 00 fe 	cp.w	r8,254
80002bee:	e0 88 00 03 	brls	80002bf4 <getBaudDiv+0x1c>
80002bf2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80002bf4:	5c 8c       	casts.h	r12
}
80002bf6:	5e fc       	retal	r12

80002bf8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80002bf8:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002bfc:	30 18       	mov	r8,1
80002bfe:	f0 09 18 00 	cp.b	r9,r8
80002c02:	e0 88 00 04 	brls	80002c0a <spi_initMaster+0x12>
80002c06:	30 2c       	mov	r12,2
80002c08:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80002c0a:	e0 68 00 80 	mov	r8,128
80002c0e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80002c10:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80002c12:	30 19       	mov	r9,1
80002c14:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80002c18:	f7 39 00 0d 	ld.ub	r9,r11[13]
80002c1c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80002c20:	30 09       	mov	r9,0
80002c22:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80002c26:	30 fa       	mov	r10,15
80002c28:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80002c2c:	99 18       	st.w	r12[0x4],r8
80002c2e:	5e f9       	retal	r9

80002c30 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80002c30:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80002c32:	30 18       	mov	r8,1
80002c34:	f0 0b 18 00 	cp.b	r11,r8
80002c38:	5f be       	srhi	lr
80002c3a:	f0 0a 18 00 	cp.b	r10,r8
80002c3e:	5f b8       	srhi	r8
80002c40:	fd e8 10 08 	or	r8,lr,r8
80002c44:	c0 30       	breq	80002c4a <spi_selectionMode+0x1a>
80002c46:	30 2c       	mov	r12,2
80002c48:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80002c4a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80002c4c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80002c50:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80002c54:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80002c58:	99 18       	st.w	r12[0x4],r8
80002c5a:	d8 0a       	popm	pc,r12=0

80002c5c <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002c5c:	78 18       	ld.w	r8,r12[0x4]
80002c5e:	ea 18 00 0f 	orh	r8,0xf
80002c62:	99 18       	st.w	r12[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002c64:	78 18       	ld.w	r8,r12[0x4]
80002c66:	e2 18 00 04 	andl	r8,0x4,COH
80002c6a:	c0 f0       	breq	80002c88 <spi_selectChip+0x2c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002c6c:	30 e8       	mov	r8,14
80002c6e:	f0 0b 18 00 	cp.b	r11,r8
80002c72:	e0 8b 00 19 	brhi	80002ca4 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80002c76:	78 18       	ld.w	r8,r12[0x4]
80002c78:	b1 6b       	lsl	r11,0x10
80002c7a:	ea 1b ff f0 	orh	r11,0xfff0
80002c7e:	e8 1b ff ff 	orl	r11,0xffff
80002c82:	10 6b       	and	r11,r8
80002c84:	99 1b       	st.w	r12[0x4],r11
80002c86:	5e fd       	retal	0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80002c88:	30 38       	mov	r8,3
80002c8a:	f0 0b 18 00 	cp.b	r11,r8
80002c8e:	e0 8b 00 0b 	brhi	80002ca4 <spi_selectChip+0x48>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002c92:	78 18       	ld.w	r8,r12[0x4]
80002c94:	2f 0b       	sub	r11,-16
80002c96:	30 19       	mov	r9,1
80002c98:	f2 0b 09 4b 	lsl	r11,r9,r11
80002c9c:	5c db       	com	r11
80002c9e:	10 6b       	and	r11,r8
80002ca0:	99 1b       	st.w	r12[0x4],r11
80002ca2:	5e fd       	retal	0
80002ca4:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80002ca6:	5e fc       	retal	r12

80002ca8 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80002ca8:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002cac:	c0 58       	rjmp	80002cb6 <spi_unselectChip+0xe>
		if (!timeout--) {
80002cae:	58 08       	cp.w	r8,0
80002cb0:	c0 21       	brne	80002cb4 <spi_unselectChip+0xc>
80002cb2:	5e ff       	retal	1
80002cb4:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002cb6:	78 49       	ld.w	r9,r12[0x10]
80002cb8:	e2 19 02 00 	andl	r9,0x200,COH
80002cbc:	cf 90       	breq	80002cae <spi_unselectChip+0x6>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002cbe:	78 18       	ld.w	r8,r12[0x4]
80002cc0:	ea 18 00 0f 	orh	r8,0xf
80002cc4:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80002cc6:	fc 18 01 00 	movh	r8,0x100
80002cca:	99 08       	st.w	r12[0x0],r8
80002ccc:	5e fd       	retal	0
80002cce:	d7 03       	nop

80002cd0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80002cd0:	eb cd 40 f8 	pushm	r3-r7,lr
80002cd4:	18 95       	mov	r5,r12
80002cd6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002cd8:	f7 36 00 0c 	ld.ub	r6,r11[12]
80002cdc:	30 38       	mov	r8,3
80002cde:	f0 06 18 00 	cp.b	r6,r8
80002ce2:	e0 8b 00 4d 	brhi	80002d7c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
80002ce6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002cea:	30 18       	mov	r8,1
80002cec:	f0 04 18 00 	cp.b	r4,r8
80002cf0:	e0 8b 00 46 	brhi	80002d7c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80002cf4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002cf8:	30 78       	mov	r8,7
80002cfa:	f0 03 18 00 	cp.b	r3,r8
80002cfe:	e0 88 00 3f 	brls	80002d7c <spi_setupChipReg+0xac>
80002d02:	31 08       	mov	r8,16
80002d04:	f0 03 18 00 	cp.b	r3,r8
80002d08:	e0 8b 00 3a 	brhi	80002d7c <spi_setupChipReg+0xac>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002d0c:	14 9b       	mov	r11,r10
80002d0e:	6e 1c       	ld.w	r12,r7[0x4]
80002d10:	f0 1f 00 1d 	mcall	80002d84 <spi_setupChipReg+0xb4>

	if (baudDiv < 0) {
80002d14:	c3 45       	brlt	80002d7c <spi_setupChipReg+0xac>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002d16:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002d18:	ec 09 16 01 	lsr	r9,r6,0x1
80002d1c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002d20:	ec 16 00 01 	eorl	r6,0x1
80002d24:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80002d28:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002d2c:	20 83       	sub	r3,8
80002d2e:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002d32:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002d36:	ef 39 00 09 	ld.ub	r9,r7[9]
80002d3a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80002d3e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80002d42:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80002d46:	0f 89       	ld.ub	r9,r7[0x0]
80002d48:	30 1a       	mov	r10,1
80002d4a:	f4 09 18 00 	cp.b	r9,r10
80002d4e:	c0 e0       	breq	80002d6a <spi_setupChipReg+0x9a>
80002d50:	c0 a3       	brcs	80002d64 <spi_setupChipReg+0x94>
80002d52:	30 2a       	mov	r10,2
80002d54:	f4 09 18 00 	cp.b	r9,r10
80002d58:	c0 c0       	breq	80002d70 <spi_setupChipReg+0xa0>
80002d5a:	30 3a       	mov	r10,3
80002d5c:	f4 09 18 00 	cp.b	r9,r10
80002d60:	c0 e1       	brne	80002d7c <spi_setupChipReg+0xac>
80002d62:	c0 a8       	rjmp	80002d76 <spi_setupChipReg+0xa6>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80002d64:	8b c8       	st.w	r5[0x30],r8
80002d66:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002d6a:	8b d8       	st.w	r5[0x34],r8
80002d6c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80002d70:	8b e8       	st.w	r5[0x38],r8
80002d72:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002d76:	8b f8       	st.w	r5[0x3c],r8
80002d78:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		break;
80002d7c:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
80002d7e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002d82:	00 00       	add	r0,r0
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	2b d8       	sub	r8,-67

80002d88 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80002d88:	30 18       	mov	r8,1
80002d8a:	99 08       	st.w	r12[0x0],r8
}
80002d8c:	5e fc       	retal	r12

80002d8e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80002d8e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d92:	c0 58       	rjmp	80002d9c <spi_write+0xe>
		if (!timeout--) {
80002d94:	58 08       	cp.w	r8,0
80002d96:	c0 21       	brne	80002d9a <spi_write+0xc>
80002d98:	5e ff       	retal	1
80002d9a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80002d9c:	78 49       	ld.w	r9,r12[0x10]
80002d9e:	e2 19 00 02 	andl	r9,0x2,COH
80002da2:	cf 90       	breq	80002d94 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80002da4:	5c 7b       	castu.h	r11
80002da6:	99 3b       	st.w	r12[0xc],r11
80002da8:	5e fd       	retal	0

80002daa <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80002daa:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002dae:	c0 58       	rjmp	80002db8 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80002db0:	58 08       	cp.w	r8,0
80002db2:	c0 21       	brne	80002db6 <spi_read+0xc>
80002db4:	5e ff       	retal	1
80002db6:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80002db8:	78 49       	ld.w	r9,r12[0x10]
80002dba:	e2 19 02 01 	andl	r9,0x201,COH
80002dbe:	e0 49 02 01 	cp.w	r9,513
80002dc2:	cf 71       	brne	80002db0 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80002dc4:	78 28       	ld.w	r8,r12[0x8]
80002dc6:	b6 08       	st.h	r11[0x0],r8
80002dc8:	5e fd       	retal	0

80002dca <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80002dca:	76 09       	ld.w	r9,r11[0x0]
80002dcc:	58 29       	cp.w	r9,2
80002dce:	e0 88 00 03 	brls	80002dd4 <tc_init_waveform+0xa>
80002dd2:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80002dd4:	76 18       	ld.w	r8,r11[0x4]
80002dd6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80002dda:	af ba       	sbr	r10,0xf
80002ddc:	10 9b       	mov	r11,r8
80002dde:	e6 1b c0 00 	andh	r11,0xc000,COH
80002de2:	16 4a       	or	r10,r11
80002de4:	10 9b       	mov	r11,r8
80002de6:	e6 1b 30 00 	andh	r11,0x3000,COH
80002dea:	16 4a       	or	r10,r11
80002dec:	10 9b       	mov	r11,r8
80002dee:	e6 1b 0c 00 	andh	r11,0xc00,COH
80002df2:	16 4a       	or	r10,r11
80002df4:	10 9b       	mov	r11,r8
80002df6:	e6 1b 03 00 	andh	r11,0x300,COH
80002dfa:	16 4a       	or	r10,r11
80002dfc:	10 9b       	mov	r11,r8
80002dfe:	e6 1b 00 c0 	andh	r11,0xc0,COH
80002e02:	16 4a       	or	r10,r11
80002e04:	10 9b       	mov	r11,r8
80002e06:	e6 1b 00 30 	andh	r11,0x30,COH
80002e0a:	16 4a       	or	r10,r11
80002e0c:	10 9b       	mov	r11,r8
80002e0e:	e6 1b 00 0c 	andh	r11,0xc,COH
80002e12:	16 4a       	or	r10,r11
80002e14:	10 9b       	mov	r11,r8
80002e16:	e6 1b 00 03 	andh	r11,0x3,COH
80002e1a:	16 4a       	or	r10,r11
80002e1c:	10 9b       	mov	r11,r8
80002e1e:	e2 1b 60 00 	andl	r11,0x6000,COH
80002e22:	16 4a       	or	r10,r11
80002e24:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80002e28:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80002e2c:	10 9b       	mov	r11,r8
80002e2e:	e2 1b 0c 00 	andl	r11,0xc00,COH
80002e32:	16 4a       	or	r10,r11
80002e34:	10 9b       	mov	r11,r8
80002e36:	e2 1b 03 00 	andl	r11,0x300,COH
80002e3a:	16 4a       	or	r10,r11
80002e3c:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80002e40:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80002e44:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80002e48:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80002e4c:	10 9b       	mov	r11,r8
80002e4e:	e2 1b 00 30 	andl	r11,0x30,COH
80002e52:	16 4a       	or	r10,r11
80002e54:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80002e58:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80002e5c:	a5 69       	lsl	r9,0x4
80002e5e:	2f f9       	sub	r9,-1
80002e60:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80002e64:	5e fd       	retal	0

80002e66 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e66:	58 2b       	cp.w	r11,2
80002e68:	e0 88 00 03 	brls	80002e6e <tc_start+0x8>
80002e6c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80002e6e:	a7 6b       	lsl	r11,0x6
80002e70:	16 0c       	add	r12,r11
80002e72:	30 58       	mov	r8,5
80002e74:	99 08       	st.w	r12[0x0],r8
80002e76:	5e fd       	retal	0

80002e78 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80002e78:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002e7c:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002e80:	58 2b       	cp.w	r11,2
80002e82:	e0 88 00 04 	brls	80002e8a <tc_configure_interrupts+0x12>
80002e86:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80002e8a:	ee 19 00 01 	eorh	r9,0x1
80002e8e:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80002e92:	74 08       	ld.w	r8,r10[0x0]
80002e94:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80002e98:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80002e9c:	a7 6e       	lsl	lr,0x6
80002e9e:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80002ea2:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80002ea6:	0e 4e       	or	lr,r7
80002ea8:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80002eac:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80002eb0:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80002eb4:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80002eb8:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80002ebc:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80002ec0:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80002ec4:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80002ec8:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80002ecc:	fd e8 10 18 	or	r8,lr,r8<<0x1
80002ed0:	f6 0e 15 06 	lsl	lr,r11,0x6
80002ed4:	f8 0e 00 0e 	add	lr,r12,lr
80002ed8:	2d ce       	sub	lr,-36
80002eda:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002edc:	58 09       	cp.w	r9,0
80002ede:	c0 20       	breq	80002ee2 <tc_configure_interrupts+0x6a>
80002ee0:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002ee2:	74 08       	ld.w	r8,r10[0x0]
80002ee4:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80002ee8:	e0 65 00 80 	mov	r5,128
80002eec:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80002ef0:	74 08       	ld.w	r8,r10[0x0]
80002ef2:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80002ef6:	f9 b4 00 40 	moveq	r4,64
80002efa:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80002efe:	74 08       	ld.w	r8,r10[0x0]
80002f00:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80002f04:	f9 b3 00 20 	moveq	r3,32
80002f08:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80002f0c:	74 08       	ld.w	r8,r10[0x0]
80002f0e:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80002f12:	f9 b2 00 10 	moveq	r2,16
80002f16:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80002f1a:	74 08       	ld.w	r8,r10[0x0]
80002f1c:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80002f20:	f9 b6 00 08 	moveq	r6,8
80002f24:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80002f28:	74 08       	ld.w	r8,r10[0x0]
80002f2a:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80002f2e:	f9 b7 00 04 	moveq	r7,4
80002f32:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80002f36:	74 08       	ld.w	r8,r10[0x0]
80002f38:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80002f3c:	f9 be 00 02 	moveq	lr,2
80002f40:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002f44:	74 08       	ld.w	r8,r10[0x0]
80002f46:	ec 18 00 01 	eorl	r8,0x1
80002f4a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002f4e:	eb e8 10 08 	or	r8,r5,r8
80002f52:	08 48       	or	r8,r4
80002f54:	06 48       	or	r8,r3
80002f56:	04 48       	or	r8,r2
80002f58:	0c 48       	or	r8,r6
80002f5a:	0e 48       	or	r8,r7
80002f5c:	1c 48       	or	r8,lr
80002f5e:	f6 0a 15 06 	lsl	r10,r11,0x6
80002f62:	f8 0a 00 0a 	add	r10,r12,r10
80002f66:	2d 8a       	sub	r10,-40
80002f68:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002f6a:	a7 6b       	lsl	r11,0x6
80002f6c:	2e 0b       	sub	r11,-32
80002f6e:	16 0c       	add	r12,r11
80002f70:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002f72:	58 09       	cp.w	r9,0
80002f74:	c0 31       	brne	80002f7a <tc_configure_interrupts+0x102>
80002f76:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80002f7a:	d5 03       	csrf	0x10
80002f7c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80002f80 <fat_check_open>:
//! @return    true  a file is opened
//! @return    false otherwise
//!
bool  fat_check_open( void )
{
   if( Fat_file_isnot_open() )
80002f80:	48 68       	lddpc	r8,80002f98 <fat_check_open+0x18>
80002f82:	11 89       	ld.ub	r9,r8[0x0]
80002f84:	30 08       	mov	r8,0
80002f86:	f0 09 18 00 	cp.b	r9,r8
80002f8a:	c0 20       	breq	80002f8e <fat_check_open+0xe>
80002f8c:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_FILE_NO_OPEN;
80002f8e:	31 79       	mov	r9,23
80002f90:	48 38       	lddpc	r8,80002f9c <fat_check_open+0x1c>
80002f92:	b0 89       	st.b	r8[0x0],r9
80002f94:	5e fd       	retal	0
80002f96:	00 00       	add	r0,r0
80002f98:	00 00       	add	r0,r0
80002f9a:	09 f4       	ld.ub	r4,r4[0x7]
80002f9c:	00 00       	add	r0,r0
80002f9e:	0c 84       	andn	r4,r6

80002fa0 <fat_check_select>:
//! @return    true  a file is selected
//! @return    false otherwise
//!
bool  fat_check_select( void )
{
   if (FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file)
80002fa0:	48 68       	lddpc	r8,80002fb8 <fat_check_select+0x18>
80002fa2:	90 19       	ld.sh	r9,r8[0x2]
80002fa4:	3f f8       	mov	r8,-1
80002fa6:	f0 09 19 00 	cp.h	r9,r8
80002faa:	c0 20       	breq	80002fae <fat_check_select+0xe>
80002fac:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE_SEL;
80002fae:	30 f9       	mov	r9,15
80002fb0:	48 38       	lddpc	r8,80002fbc <fat_check_select+0x1c>
80002fb2:	b0 89       	st.b	r8[0x0],r9
80002fb4:	5e fd       	retal	0
80002fb6:	00 00       	add	r0,r0
80002fb8:	00 00       	add	r0,r0
80002fba:	0c 80       	andn	r0,r6
80002fbc:	00 00       	add	r0,r0
80002fbe:	0c 84       	andn	r4,r6

80002fc0 <fat_check_is_file>:
//! @return    true  It is a file and not a directory
//! @return    false otherwise
//!
bool  fat_check_is_file( void )
{
   if( Fat_is_not_a_file )
80002fc0:	48 58       	lddpc	r8,80002fd4 <fat_check_is_file+0x14>
80002fc2:	11 a8       	ld.ub	r8,r8[0x2]
80002fc4:	e2 18 00 18 	andl	r8,0x18,COH
80002fc8:	c0 21       	brne	80002fcc <fat_check_is_file+0xc>
80002fca:	5e ff       	retal	1
   {
      fs_g_status = FS_ERR_NO_FILE;   // It isn't a file, it is a directory or a volume id
80002fcc:	31 39       	mov	r9,19
80002fce:	48 38       	lddpc	r8,80002fd8 <fat_check_is_file+0x18>
80002fd0:	b0 89       	st.b	r8[0x0],r9
80002fd2:	5e fd       	retal	0
80002fd4:	00 00       	add	r0,r0
80002fd6:	09 f4       	ld.ub	r4,r4[0x7]
80002fd8:	00 00       	add	r0,r0
80002fda:	0c 84       	andn	r4,r6

80002fdc <fat_checkcluster>:
//!   fs_g_cluster.u32_val       value to check
//! @endverbatim
//!
uint8_t    fat_checkcluster( void )
{
  if ( !fs_g_cluster.u32_val )
80002fdc:	49 68       	lddpc	r8,80003034 <fat_checkcluster+0x58>
80002fde:	70 18       	ld.w	r8,r8[0x4]
80002fe0:	58 08       	cp.w	r8,0
80002fe2:	c0 21       	brne	80002fe6 <fat_checkcluster+0xa>
80002fe4:	5e ff       	retal	1
    return FS_CLUS_BAD;

  // Cluster bad if (FAT12 == 0x0FF7) (FAT16 == 0xFFF7) (FAT32 == 0x0FFFFFF7)
  // Last cluster if (FAT12 > 0x0FF7) (FAT16 > 0xFFF7) (FAT32 > 0x0FFFFFF7)
  if ( Is_fat32 )
80002fe6:	49 59       	lddpc	r9,80003038 <fat_checkcluster+0x5c>
80002fe8:	13 89       	ld.ub	r9,r9[0x0]
80002fea:	30 3a       	mov	r10,3
80002fec:	f4 09 18 00 	cp.b	r9,r10
80002ff0:	c0 a1       	brne	80003004 <fat_checkcluster+0x28>
  {
    if (fs_g_cluster.u32_val >= 0x0FFFFFF8)
80002ff2:	e0 69 ff f7 	mov	r9,65527
80002ff6:	ea 19 0f ff 	orh	r9,0xfff
80002ffa:	12 38       	cp.w	r8,r9
80002ffc:	e0 8b 00 19 	brhi	8000302e <fat_checkcluster+0x52>
80003000:	5f 0c       	sreq	r12
80003002:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0x0FFFFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat16 )
80003004:	30 2a       	mov	r10,2
80003006:	f4 09 18 00 	cp.b	r9,r10
8000300a:	c0 71       	brne	80003018 <fat_checkcluster+0x3c>
  {
    if (fs_g_cluster.u32_val >= 0xFFF8)
8000300c:	e0 48 ff f7 	cp.w	r8,65527
80003010:	e0 8b 00 0f 	brhi	8000302e <fat_checkcluster+0x52>
80003014:	5f 0c       	sreq	r12
80003016:	5e fc       	retal	r12
      return FS_CLUS_END;
    else if (fs_g_cluster.u32_val == 0xFFF7)
      return FS_CLUS_BAD;
  }
  else if ( Is_fat12 )
80003018:	30 1a       	mov	r10,1
8000301a:	f4 09 18 00 	cp.b	r9,r10
8000301e:	c0 20       	breq	80003022 <fat_checkcluster+0x46>
80003020:	5e fd       	retal	0
  {
    if (fs_g_cluster.u32_val >= 0xFF8)
80003022:	e0 48 0f f7 	cp.w	r8,4087
80003026:	e0 8b 00 04 	brhi	8000302e <fat_checkcluster+0x52>
8000302a:	5f 0c       	sreq	r12
8000302c:	5e fc       	retal	r12
8000302e:	30 2c       	mov	r12,2
    else if (fs_g_cluster.u32_val == 0xFF7)
      return FS_CLUS_BAD;
  }

  return FS_CLUS_OK;
}
80003030:	5e fc       	retal	r12
80003032:	00 00       	add	r0,r0
80003034:	00 00       	add	r0,r0
80003036:	0c d4       	st.w	--r6,r4
80003038:	00 00       	add	r0,r0
8000303a:	0c 80       	andn	r0,r6

8000303c <fat_cache_clusterlist_reset>:
//! This function resets the cluster list caches
//!
void  fat_cache_clusterlist_reset( void )
{
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
8000303c:	30 0a       	mov	r10,0
8000303e:	48 88       	lddpc	r8,8000305c <fat_cache_clusterlist_reset+0x20>
80003040:	b0 8a       	st.b	r8[0x0],r10
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
80003042:	48 88       	lddpc	r8,80003060 <fat_cache_clusterlist_reset+0x24>
80003044:	30 19       	mov	r9,1
80003046:	b0 89       	st.b	r8[0x0],r9
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
80003048:	3f f9       	mov	r9,-1
8000304a:	b0 a9       	st.b	r8[0x2],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
8000304c:	b0 99       	st.b	r8[0x1],r9
   uint8_t u8_i;
   fs_g_u8_current_cache=0;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      // The cache list is split in two cache (file cluster list and directory cluster list)
      fs_g_cache_clusterlist[u8_i].b_cache_file = (u8_i<FS_NB_CACHE_CLUSLIST)?true:false;
8000304e:	f1 6a 00 14 	st.b	r8[20],r10
      fs_g_cache_clusterlist[u8_i].u8_lun = 0xFF;
80003052:	f1 69 00 16 	st.b	r8[22],r9
      fs_g_cache_clusterlist[u8_i].u8_level_use = 0xFF;
80003056:	f1 69 00 15 	st.b	r8[21],r9
   }
}
8000305a:	5e fc       	retal	r12
8000305c:	00 00       	add	r0,r0
8000305e:	0c 86       	andn	r6,r6
80003060:	00 00       	add	r0,r0
80003062:	0a 08       	add	r8,r5

80003064 <fat_cache_clusterlist_update_start>:
//! This function initializes a cache in cluster list caches
//!
//! @param     b_for_file  If true then it is a file cluster list else a directory cluster list  <br>
//!
void  fat_cache_clusterlist_update_start( bool b_for_file )
{
80003064:	48 ea       	lddpc	r10,8000309c <fat_cache_clusterlist_update_start+0x38>
80003066:	15 88       	ld.ub	r8,r10[0x0]
80003068:	f8 08 18 00 	cp.b	r8,r12
8000306c:	5f 18       	srne	r8
         if( (FS_NB_CACHE_CLUSLIST-2) < fs_g_cache_clusterlist[u8_i].u8_level_use )
#endif
            break;
      }
   }
   fs_g_u8_current_cache = u8_i;
8000306e:	48 d9       	lddpc	r9,800030a0 <fat_cache_clusterlist_update_start+0x3c>
80003070:	b2 88       	st.b	r9[0x0],r8
   fs_g_cache_clusterlist[fs_g_u8_current_cache].b_cache_file = b_for_file;
80003072:	f0 0b 15 02 	lsl	r11,r8,0x2
80003076:	f6 08 00 09 	add	r9,r11,r8
8000307a:	f4 09 00 29 	add	r9,r10,r9<<0x2
8000307e:	b2 8c       	st.b	r9[0x0],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
80003080:	3f fc       	mov	r12,-1
80003082:	b2 ac       	st.b	r9[0x2],r12
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;
80003084:	f6 08 00 08 	add	r8,r11,r8
80003088:	2f f8       	sub	r8,-1
8000308a:	48 7b       	lddpc	r11,800030a4 <fat_cache_clusterlist_update_start+0x40>
8000308c:	76 0b       	ld.w	r11,r11[0x0]
8000308e:	f4 08 09 2b 	st.w	r10[r8<<0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start    = fs_g_seg.u32_size_or_pos;
80003092:	48 68       	lddpc	r8,800030a8 <fat_cache_clusterlist_update_start+0x44>
80003094:	70 18       	ld.w	r8,r8[0x4]
80003096:	93 28       	st.w	r9[0x8],r8
}
80003098:	5e fc       	retal	r12
8000309a:	00 00       	add	r0,r0
8000309c:	00 00       	add	r0,r0
8000309e:	0a 08       	add	r8,r5
800030a0:	00 00       	add	r0,r0
800030a2:	0c 86       	andn	r6,r6
800030a4:	00 00       	add	r0,r0
800030a6:	0c d4       	st.w	--r6,r4
800030a8:	00 00       	add	r0,r0
800030aa:	0c dc       	st.w	--r6,r12

800030ac <fat_cache_clusterlist_update_select>:
{
   uint8_t u8_i;
   uint8_t u8_level_to_update;
   bool b_file_cache;

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
800030ac:	49 88       	lddpc	r8,8000310c <fat_cache_clusterlist_update_select+0x60>
800030ae:	11 88       	ld.ub	r8,r8[0x0]
800030b0:	49 8a       	lddpc	r10,80003110 <fat_cache_clusterlist_update_select+0x64>
800030b2:	f0 08 00 2b 	add	r11,r8,r8<<0x2
800030b6:	f4 0b 00 2b 	add	r11,r10,r11<<0x2
800030ba:	17 89       	ld.ub	r9,r11[0x0]
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
800030bc:	17 9b       	ld.ub	r11,r11[0x1]
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
800030be:	15 8a       	ld.ub	r10,r10[0x0]
800030c0:	f2 0a 18 00 	cp.b	r10,r9
800030c4:	c0 a1       	brne	800030d8 <fat_cache_clusterlist_update_select+0x2c>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
800030c6:	49 3a       	lddpc	r10,80003110 <fat_cache_clusterlist_update_select+0x64>
800030c8:	15 9a       	ld.ub	r10,r10[0x1]
800030ca:	f4 0b 18 00 	cp.b	r11,r10
800030ce:	e0 88 00 05 	brls	800030d8 <fat_cache_clusterlist_update_select+0x2c>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
800030d2:	2f fa       	sub	r10,-1
800030d4:	48 fc       	lddpc	r12,80003110 <fat_cache_clusterlist_update_select+0x64>
800030d6:	b8 9a       	st.b	r12[0x1],r10

   b_file_cache         = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].b_cache_file;
   u8_level_to_update   = fs_g_cache_clusterlist[ fs_g_u8_current_cache ].u8_level_use;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( fs_g_cache_clusterlist[u8_i].b_cache_file == b_file_cache )
800030d8:	48 ea       	lddpc	r10,80003110 <fat_cache_clusterlist_update_select+0x64>
800030da:	f5 3a 00 14 	ld.ub	r10,r10[20]
800030de:	f2 0a 18 00 	cp.b	r10,r9
800030e2:	c0 c1       	brne	800030fa <fat_cache_clusterlist_update_select+0x4e>
         if( u8_level_to_update > fs_g_cache_clusterlist[u8_i].u8_level_use )
800030e4:	48 b9       	lddpc	r9,80003110 <fat_cache_clusterlist_update_select+0x64>
800030e6:	f3 39 00 15 	ld.ub	r9,r9[21]
800030ea:	f2 0b 18 00 	cp.b	r11,r9
800030ee:	e0 88 00 06 	brls	800030fa <fat_cache_clusterlist_update_select+0x4e>
           fs_g_cache_clusterlist[u8_i].u8_level_use++;
800030f2:	2f f9       	sub	r9,-1
800030f4:	48 7a       	lddpc	r10,80003110 <fat_cache_clusterlist_update_select+0x64>
800030f6:	f5 69 00 15 	st.b	r10[21],r9
   }
   fs_g_cache_clusterlist[  fs_g_u8_current_cache  ].u8_level_use = 0;
800030fa:	f0 08 00 28 	add	r8,r8,r8<<0x2
800030fe:	48 59       	lddpc	r9,80003110 <fat_cache_clusterlist_update_select+0x64>
80003100:	f2 08 00 28 	add	r8,r9,r8<<0x2
80003104:	30 09       	mov	r9,0
80003106:	b0 99       	st.b	r8[0x1],r9
}
80003108:	5e fc       	retal	r12
8000310a:	00 00       	add	r0,r0
8000310c:	00 00       	add	r0,r0
8000310e:	0c 86       	andn	r6,r6
80003110:	00 00       	add	r0,r0
80003112:	0a 08       	add	r8,r5

80003114 <fat_cache_clusterlist_update_finish>:


//! This function updates a cache of cluster list caches
//!
void  fat_cache_clusterlist_update_finish( void )
{
80003114:	eb cd 40 c0 	pushm	r6-r7,lr
   uint8_t u8_cluster_offset = fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start % fs_g_nav.u8_BPB_SecPerClus;
80003118:	49 08       	lddpc	r8,80003158 <fat_cache_clusterlist_update_finish+0x44>
8000311a:	11 88       	ld.ub	r8,r8[0x0]
8000311c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003120:	48 f9       	lddpc	r9,8000315c <fat_cache_clusterlist_update_finish+0x48>
80003122:	f2 08 00 28 	add	r8,r9,r8<<0x2
80003126:	f0 ca ff f8 	sub	r10,r8,-8
8000312a:	48 eb       	lddpc	r11,80003160 <fat_cache_clusterlist_update_finish+0x4c>
8000312c:	17 97       	ld.ub	r7,r11[0x1]
8000312e:	74 09       	ld.w	r9,r10[0x0]
80003130:	f2 07 0d 06 	divu	r6,r9,r7
80003134:	0e 99       	mov	r9,r7
80003136:	5c 59       	castu.b	r9
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = fs_g_nav.u8_lun;          // valid cache
80003138:	17 8b       	ld.ub	r11,r11[0x0]
8000313a:	b0 ab       	st.b	r8[0x2],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start   -= u8_cluster_offset;
8000313c:	74 0b       	ld.w	r11,r10[0x0]
8000313e:	12 1b       	sub	r11,r9
80003140:	95 0b       	st.w	r10[0x0],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_addr     = fs_g_seg.u32_addr - u8_cluster_offset;
80003142:	48 9a       	lddpc	r10,80003164 <fat_cache_clusterlist_update_finish+0x50>
80003144:	74 0b       	ld.w	r11,r10[0x0]
80003146:	12 1b       	sub	r11,r9
80003148:	91 3b       	st.w	r8[0xc],r11
   fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_size     = fs_g_seg.u32_size_or_pos + u8_cluster_offset;
8000314a:	74 1a       	ld.w	r10,r10[0x4]
8000314c:	14 09       	add	r9,r10
8000314e:	91 49       	st.w	r8[0x10],r9

   // Update the "level used" of cache
   fat_cache_clusterlist_update_select();
80003150:	f0 1f 00 06 	mcall	80003168 <fat_cache_clusterlist_update_finish+0x54>
}
80003154:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003158:	00 00       	add	r0,r0
8000315a:	0c 86       	andn	r6,r6
8000315c:	00 00       	add	r0,r0
8000315e:	0a 08       	add	r8,r5
80003160:	00 00       	add	r0,r0
80003162:	0c 34       	cp.w	r4,r6
80003164:	00 00       	add	r0,r0
80003166:	0c dc       	st.w	--r6,r12
80003168:	80 00       	ld.sh	r0,r0[0x0]
8000316a:	30 ac       	mov	r12,10

8000316c <fat_cache_clusterlist_update_read>:
//!
//! @return    true  cluster list found and global variable fs_g_seg updated
//! @return    false no found in cluster list caches
//!
bool  fat_cache_clusterlist_update_read( bool b_for_file )
{
8000316c:	eb cd 40 c0 	pushm	r6-r7,lr
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
80003170:	4c 18       	lddpc	r8,80003274 <fat_cache_clusterlist_update_read+0x108>
80003172:	11 89       	ld.ub	r9,r8[0x0]
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003174:	4c 18       	lddpc	r8,80003278 <fat_cache_clusterlist_update_read+0x10c>
80003176:	70 0a       	ld.w	r10,r8[0x0]
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003178:	4c 18       	lddpc	r8,8000327c <fat_cache_clusterlist_update_read+0x110>
8000317a:	70 1b       	ld.w	r11,r8[0x4]
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
8000317c:	4c 18       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
8000317e:	11 88       	ld.ub	r8,r8[0x0]
80003180:	f8 08 18 00 	cp.b	r8,r12
80003184:	c1 11       	brne	800031a6 <fat_cache_clusterlist_update_read+0x3a>
80003186:	4b f8       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
80003188:	11 a8       	ld.ub	r8,r8[0x2]
8000318a:	f2 08 18 00 	cp.b	r8,r9
8000318e:	c0 c1       	brne	800031a6 <fat_cache_clusterlist_update_read+0x3a>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
80003190:	4b c8       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
80003192:	70 18       	ld.w	r8,r8[0x4]
80003194:	14 38       	cp.w	r8,r10
80003196:	c0 81       	brne	800031a6 <fat_cache_clusterlist_update_read+0x3a>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
80003198:	4b a8       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
8000319a:	70 28       	ld.w	r8,r8[0x8]
8000319c:	10 3b       	cp.w	r11,r8
8000319e:	c0 43       	brcs	800031a6 <fat_cache_clusterlist_update_read+0x3a>
800031a0:	30 0a       	mov	r10,0
800031a2:	14 99       	mov	r9,r10
800031a4:	c1 88       	rjmp	800031d4 <fat_cache_clusterlist_update_read+0x68>
{
   uint32_t u32_tmp;
   uint8_t u8_i;
   for( u8_i=0; u8_i<(FS_NB_CACHE_CLUSLIST*2); u8_i++ )
   {
      if( (fs_g_cache_clusterlist[u8_i].b_cache_file == b_for_file)
800031a6:	4b 78       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
800031a8:	f1 38 00 14 	ld.ub	r8,r8[20]
800031ac:	f8 08 18 00 	cp.b	r8,r12
800031b0:	c5 e1       	brne	8000326c <fat_cache_clusterlist_update_read+0x100>
800031b2:	4b 48       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
800031b4:	f1 38 00 16 	ld.ub	r8,r8[22]
800031b8:	f2 08 18 00 	cp.b	r8,r9
800031bc:	c5 81       	brne	8000326c <fat_cache_clusterlist_update_read+0x100>
      &&  (fs_g_cache_clusterlist[u8_i].u8_lun == fs_g_nav.u8_lun ) )
      {
         if( fs_g_cache_clusterlist[u8_i].u32_cluster == fs_g_cluster.u32_pos )
800031be:	4b 18       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
800031c0:	70 68       	ld.w	r8,r8[0x18]
800031c2:	14 38       	cp.w	r8,r10
800031c4:	c5 41       	brne	8000326c <fat_cache_clusterlist_update_read+0x100>
         {
            if( fs_g_cache_clusterlist[u8_i].u32_start <= fs_g_seg.u32_size_or_pos )
800031c6:	4a f8       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
800031c8:	70 78       	ld.w	r8,r8[0x1c]
800031ca:	16 38       	cp.w	r8,r11
800031cc:	e0 8b 00 50 	brhi	8000326c <fat_cache_clusterlist_update_read+0x100>
800031d0:	30 1a       	mov	r10,1
800031d2:	14 99       	mov	r9,r10
            {
               // The segment research is in or after the cache
               if( fs_g_cache_clusterlist[u8_i].u32_size  > (fs_g_seg.u32_size_or_pos-fs_g_cache_clusterlist[u8_i].u32_start) )
800031d4:	f2 0e 15 02 	lsl	lr,r9,0x2
800031d8:	12 0e       	add	lr,r9
800031da:	4a ac       	lddpc	r12,80003280 <fat_cache_clusterlist_update_read+0x114>
800031dc:	f8 0e 00 2c 	add	r12,r12,lr<<0x2
800031e0:	78 4c       	ld.w	r12,r12[0x10]
800031e2:	f6 08 01 08 	sub	r8,r11,r8
800031e6:	10 3c       	cp.w	r12,r8
800031e8:	e0 88 00 16 	brls	80003214 <fat_cache_clusterlist_update_read+0xa8>
               {
                  //** The segment research is in cache, then compute the segment infos
                  fs_g_seg.u32_size_or_pos -= fs_g_cache_clusterlist[u8_i].u32_start;
                  fs_g_seg.u32_addr = fs_g_cache_clusterlist[u8_i].u32_addr + fs_g_seg.u32_size_or_pos;
800031ec:	4a 4b       	lddpc	r11,8000327c <fat_cache_clusterlist_update_read+0x110>
800031ee:	f2 0e 15 02 	lsl	lr,r9,0x2
800031f2:	fc 09 00 09 	add	r9,lr,r9
800031f6:	4a 3e       	lddpc	lr,80003280 <fat_cache_clusterlist_update_read+0x114>
800031f8:	fc 09 00 29 	add	r9,lr,r9<<0x2
800031fc:	72 39       	ld.w	r9,r9[0xc]
800031fe:	f0 09 00 09 	add	r9,r8,r9
80003202:	97 09       	st.w	r11[0x0],r9
                  fs_g_seg.u32_size_or_pos = fs_g_cache_clusterlist[u8_i].u32_size - fs_g_seg.u32_size_or_pos;
80003204:	10 1c       	sub	r12,r8
80003206:	97 1c       	st.w	r11[0x4],r12
                  fs_g_u8_current_cache = u8_i;
80003208:	49 f8       	lddpc	r8,80003284 <fat_cache_clusterlist_update_read+0x118>
8000320a:	b0 8a       	st.b	r8[0x0],r10
                  fat_cache_clusterlist_update_select();
8000320c:	f0 1f 00 1f 	mcall	80003288 <fat_cache_clusterlist_update_read+0x11c>
80003210:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
                  return true;   // the segment is in cluster list cache
               }else{
                  //** It is after the cache then get cache information and continue to read the cluster list in FAT
                  // Store the result in this cache
                  fs_g_u8_current_cache = u8_i;
80003214:	49 c8       	lddpc	r8,80003284 <fat_cache_clusterlist_update_read+0x118>
80003216:	b0 8a       	st.b	r8[0x0],r10
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;   // invalid cache
80003218:	f2 08 15 02 	lsl	r8,r9,0x2
8000321c:	f0 09 00 09 	add	r9,r8,r9
80003220:	49 88       	lddpc	r8,80003280 <fat_cache_clusterlist_update_read+0x114>
80003222:	f0 09 00 28 	add	r8,r8,r9<<0x2
80003226:	3f f9       	mov	r9,-1
80003228:	b0 a9       	st.b	r8[0x2],r9
                  // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // It is the same cluster start

                  // Get cache information to take time during the next FAT access
                  // Compute the cluster number corresponding at the last cluster of the cluster list cache
                  fs_g_cluster.u32_pos     = ((fs_g_cache_clusterlist[u8_i].u32_addr -fs_g_nav.u32_ptr_fat - fs_g_nav.u32_offset_data + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000322a:	70 4c       	ld.w	r12,r8[0x10]
8000322c:	49 2a       	lddpc	r10,80003274 <fat_cache_clusterlist_update_read+0x108>
8000322e:	15 99       	ld.ub	r9,r10[0x1]
80003230:	70 3e       	ld.w	lr,r8[0xc]
80003232:	f8 0e 00 0e 	add	lr,r12,lr
80003236:	20 1e       	sub	lr,1
80003238:	74 57       	ld.w	r7,r10[0x14]
8000323a:	fc 07 01 07 	sub	r7,lr,r7
8000323e:	74 4a       	ld.w	r10,r10[0x10]
80003240:	14 17       	sub	r7,r10
80003242:	ee 09 0d 06 	divu	r6,r7,r9
80003246:	0c 97       	mov	r7,r6
80003248:	2f e7       	sub	r7,-2
8000324a:	48 ca       	lddpc	r10,80003278 <fat_cache_clusterlist_update_read+0x10c>
8000324c:	95 07       	st.w	r10[0x0],r7
                                             / fs_g_nav.u8_BPB_SecPerClus) +2;
                  u32_tmp  = fs_g_seg.u32_size_or_pos;                                 // save position ask
                  // Compute the position of the end of cluster list cache, and decrement the position asked
                  fs_g_seg.u32_size_or_pos-= ((fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start + fs_g_cache_clusterlist[u8_i].u32_size -1)
8000324e:	2f 88       	sub	r8,-8
80003250:	70 0a       	ld.w	r10,r8[0x0]
80003252:	14 0c       	add	r12,r10
80003254:	f8 c7 00 01 	sub	r7,r12,1
80003258:	ee 09 0d 06 	divu	r6,r7,r9
8000325c:	ad 39       	mul	r9,r6
8000325e:	48 8a       	lddpc	r10,8000327c <fat_cache_clusterlist_update_read+0x110>
80003260:	f6 09 01 09 	sub	r9,r11,r9
80003264:	95 19       	st.w	r10[0x4],r9
                                             / fs_g_nav.u8_BPB_SecPerClus)
                                             * fs_g_nav.u8_BPB_SecPerClus;
                  fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start = u32_tmp;   // Update cache with the position asked
80003266:	91 0b       	st.w	r8[0x0],r11
80003268:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
            }
         }
      }
   }
   // No found in cache then read FAT and store the result in cache
   fat_cache_clusterlist_update_start(b_for_file);
8000326c:	f0 1f 00 08 	mcall	8000328c <fat_cache_clusterlist_update_read+0x120>
80003270:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003274:	00 00       	add	r0,r0
80003276:	0c 34       	cp.w	r4,r6
80003278:	00 00       	add	r0,r0
8000327a:	0c d4       	st.w	--r6,r4
8000327c:	00 00       	add	r0,r0
8000327e:	0c dc       	st.w	--r6,r12
80003280:	00 00       	add	r0,r0
80003282:	0a 08       	add	r8,r5
80003284:	00 00       	add	r0,r0
80003286:	0c 86       	andn	r6,r6
80003288:	80 00       	ld.sh	r0,r0[0x0]
8000328a:	30 ac       	mov	r12,10
8000328c:	80 00       	ld.sh	r0,r0[0x0]
8000328e:	30 64       	mov	r4,6

80003290 <fat_entry_is_dir>:
//! @return    true,    this entry is a directory
//! @return    false,   otherwise
//!
bool  fat_entry_is_dir(void)
{
   fs_g_status = FS_ERR_NO_DIR;
80003290:	30 d9       	mov	r9,13
80003292:	48 48       	lddpc	r8,800032a0 <fat_entry_is_dir+0x10>
80003294:	b0 89       	st.b	r8[0x0],r9
80003296:	48 48       	lddpc	r8,800032a4 <fat_entry_is_dir+0x14>
80003298:	11 ac       	ld.ub	r12,r8[0x2]
   return (FS_ATTR_DIRECTORY & fs_g_nav_entry.u8_attr);
}
8000329a:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000329e:	5e fc       	retal	r12
800032a0:	00 00       	add	r0,r0
800032a2:	0c 84       	andn	r4,r6
800032a4:	00 00       	add	r0,r0
800032a6:	09 f4       	ld.ub	r4,r4[0x7]

800032a8 <fat_clear_entry_info_and_ptr>:

//! This function resets the selection pointers
//!
void  fat_clear_entry_info_and_ptr( void )
{
   fs_g_nav_fast.u16_entry_pos_sel_file= FS_NO_SEL;
800032a8:	3f f9       	mov	r9,-1
800032aa:	48 c8       	lddpc	r8,800032d8 <fat_clear_entry_info_and_ptr+0x30>
800032ac:	b0 19       	st.h	r8[0x2],r9
   fs_g_nav.u16_pos_sel_file           = FS_NO_SEL;
800032ae:	48 c8       	lddpc	r8,800032dc <fat_clear_entry_info_and_ptr+0x34>
800032b0:	f1 59 00 24 	st.h	r8[36],r9
   if( !fs_g_nav.b_mode_nav_single )
800032b4:	f1 39 00 2d 	ld.ub	r9,r8[45]
800032b8:	30 08       	mov	r8,0
800032ba:	f0 09 18 00 	cp.b	r9,r8
800032be:	c0 51       	brne	800032c8 <fat_clear_entry_info_and_ptr+0x20>
   {
      fs_g_nav.b_mode_nav                 = FS_DIR;
800032c0:	10 99       	mov	r9,r8
800032c2:	48 78       	lddpc	r8,800032dc <fat_clear_entry_info_and_ptr+0x34>
800032c4:	f1 69 00 2c 	st.b	r8[44],r9
   }
   fs_g_nav_entry.u8_attr     = 0;
800032c8:	48 68       	lddpc	r8,800032e0 <fat_clear_entry_info_and_ptr+0x38>
800032ca:	30 09       	mov	r9,0
800032cc:	b0 a9       	st.b	r8[0x2],r9
   fs_g_nav_entry.u32_cluster = 0;
800032ce:	30 0a       	mov	r10,0
800032d0:	91 1a       	st.w	r8[0x4],r10
   fs_g_nav_entry.u32_size    = 0;
800032d2:	91 2a       	st.w	r8[0x8],r10
   Fat_file_close();
800032d4:	b0 89       	st.b	r8[0x0],r9
}
800032d6:	5e fc       	retal	r12
800032d8:	00 00       	add	r0,r0
800032da:	0c 80       	andn	r0,r6
800032dc:	00 00       	add	r0,r0
800032de:	0c 34       	cp.w	r4,r6
800032e0:	00 00       	add	r0,r0
800032e2:	09 f4       	ld.ub	r4,r4[0x7]

800032e4 <fat_check_eof_name>:
//! @return    true, it is a character to signal a end of name (0,'\\','/')
//! @return    false, otherwise
//!
bool  fat_check_eof_name( uint16_t character )
{
   return (('\0'==character)||('\\'==character)||('/'==character));
800032e4:	30 08       	mov	r8,0
800032e6:	f0 0c 19 00 	cp.h	r12,r8
800032ea:	5f 0a       	sreq	r10
800032ec:	35 c9       	mov	r9,92
800032ee:	f2 0c 19 00 	cp.h	r12,r9
800032f2:	5f 09       	sreq	r9
800032f4:	f5 e9 10 09 	or	r9,r10,r9
800032f8:	f0 09 18 00 	cp.b	r9,r8
800032fc:	c0 20       	breq	80003300 <fat_check_eof_name+0x1c>
800032fe:	5e ff       	retal	1
80003300:	32 f8       	mov	r8,47
80003302:	f0 0c 19 00 	cp.h	r12,r8
80003306:	5f 0c       	sreq	r12
}
80003308:	5e fc       	retal	r12
8000330a:	d7 03       	nop

8000330c <fat_get_ptr_entry>:
//! This function returns a cache pointer on the current entry
//!
//! @return a pointer on the internal cache
//!
PTR_CACHE fat_get_ptr_entry( void )
{
8000330c:	48 48       	lddpc	r8,8000331c <fat_get_ptr_entry+0x10>
8000330e:	90 98       	ld.uh	r8,r8[0x2]
80003310:	a5 78       	lsl	r8,0x5
80003312:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
   return &fs_g_sector[(fs_g_nav_fast.u16_entry_pos_sel_file * FS_SIZE_FILE_ENTRY) & FS_512B_MASK];
}
80003316:	48 3c       	lddpc	r12,80003320 <fat_get_ptr_entry+0x14>
80003318:	10 0c       	add	r12,r8
8000331a:	5e fc       	retal	r12
8000331c:	00 00       	add	r0,r0
8000331e:	0c 80       	andn	r0,r6
80003320:	00 00       	add	r0,r0
80003322:	0a 34       	cp.w	r4,r5

80003324 <fat_entry_longname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_longname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case )
{
80003324:	d4 31       	pushm	r0-r7,lr
80003326:	20 3d       	sub	sp,12
80003328:	18 97       	mov	r7,r12
8000332a:	16 94       	mov	r4,r11
8000332c:	14 96       	mov	r6,r10
8000332e:	50 09       	stdsp	sp[0x0],r9
   uint8_t u8_pos_name;
   PTR_CACHE ptr_entry;
   uint16_t u16_unicode_entry;
   uint16_t u16_unicode_szname;

   ptr_entry = fat_get_ptr_entry();
80003330:	f0 1f 00 5e 	mcall	800034a8 <fat_entry_longname+0x184>

   if( (FS_ENTRY_END == *ptr_entry )            // end of directory
80003334:	19 88       	ld.ub	r8,r12[0x0]
80003336:	30 09       	mov	r9,0
80003338:	f2 08 18 00 	cp.b	r8,r9
8000333c:	5f 0b       	sreq	r11
8000333e:	3e 5a       	mov	r10,-27
80003340:	f4 08 18 00 	cp.b	r8,r10
80003344:	5f 0a       	sreq	r10
80003346:	f7 ea 10 0a 	or	r10,r11,r10
8000334a:	f2 0a 18 00 	cp.b	r10,r9
8000334e:	c0 71       	brne	8000335c <fat_entry_longname+0x38>
   ||  (FS_ENTRY_DEL == *ptr_entry )            // entry deleted
   ||  (FS_ATTR_LFN_ENTRY != ptr_entry[11]) )   // no long name
80003350:	f9 3a 00 0b 	ld.ub	r10,r12[11]
80003354:	30 f9       	mov	r9,15
80003356:	f2 0a 18 00 	cp.b	r10,r9
8000335a:	c0 60       	breq	80003366 <fat_entry_longname+0x42>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
8000335c:	30 b9       	mov	r9,11
8000335e:	4d 48       	lddpc	r8,800034ac <fat_entry_longname+0x188>
80003360:	b0 89       	st.b	r8[0x0],r9
80003362:	30 0c       	mov	r12,0
      return false;
80003364:	c9 c8       	rjmp	8000349c <fat_entry_longname+0x178>
   }

   if( g_b_string_length )
80003366:	4d 39       	lddpc	r9,800034b0 <fat_entry_longname+0x18c>
80003368:	13 8a       	ld.ub	r10,r9[0x0]
8000336a:	30 09       	mov	r9,0
8000336c:	f2 0a 18 00 	cp.b	r10,r9
80003370:	c0 90       	breq	80003382 <fat_entry_longname+0x5e>
   {
      if ( 0 == (FS_ENTRY_LFN_LAST & *ptr_entry))
80003372:	e2 18 00 40 	andl	r8,0x40,COH
80003376:	c0 61       	brne	80003382 <fat_entry_longname+0x5e>
      {
         // no necessary -> ((FS_STR_UNICODE)sz_name)[0] = FS_SIZE_LFN_ENTRY;
         fs_g_status = FS_NO_LAST_LFN_ENTRY;
80003378:	31 09       	mov	r9,16
8000337a:	4c d8       	lddpc	r8,800034ac <fat_entry_longname+0x188>
8000337c:	b0 89       	st.b	r8[0x0],r9
8000337e:	30 0c       	mov	r12,0
         return false;                          // Other entry long name
80003380:	c8 e8       	rjmp	8000349c <fat_entry_longname+0x178>
      }
   }

   ptr_entry++;                                 // The long name start at offset 1 of the entry file
80003382:	2f fc       	sub	r12,-1
80003384:	30 08       	mov	r8,0

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80003386:	fa ca ff f6 	sub	r10,sp,-10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
8000338a:	30 0b       	mov	r11,0
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
      MSB(u16_unicode_entry) = ptr_entry[1];
      if( FS_NAME_GET == b_mode )
      {
         if( !g_b_string_length )
8000338c:	4c 95       	lddpc	r5,800034b0 <fat_entry_longname+0x18c>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
8000338e:	20 14       	sub	r4,1
80003390:	50 14       	stdsp	sp[0x4],r4
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
           return false;
         }
      }

      if( 0 == u16_unicode_entry)
80003392:	30 01       	mov	r1,0
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80003394:	30 44       	mov	r4,4
   ptr_entry++;                                 // The long name start at offset 1 of the entry file

   u8_pos_name=0;
   while( 1 )
   {
      LSB(u16_unicode_entry) = ptr_entry[0];
80003396:	19 89       	ld.ub	r9,r12[0x0]
80003398:	b4 99       	st.b	r10[0x1],r9
      MSB(u16_unicode_entry) = ptr_entry[1];
8000339a:	19 99       	ld.ub	r9,r12[0x1]
8000339c:	b4 89       	st.b	r10[0x0],r9
      if( FS_NAME_GET == b_mode )
8000339e:	58 06       	cp.w	r6,0
800033a0:	c0 f0       	breq	800033be <fat_entry_longname+0x9a>
      {
         if( !g_b_string_length )
800033a2:	0b 89       	ld.ub	r9,r5[0x0]
800033a4:	f6 09 18 00 	cp.b	r9,r11
800033a8:	c3 91       	brne	8000341a <fat_entry_longname+0xf6>
         {
            // Check the end of buffer
            if( u8_pos_name>=(u8_size_max-1) )
800033aa:	40 1e       	lddsp	lr,sp[0x4]
800033ac:	1c 38       	cp.w	r8,lr
800033ae:	c0 55       	brlt	800033b8 <fat_entry_longname+0x94>
               // Write end of string
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
800033b0:	30 08       	mov	r8,0
800033b2:	ae 88       	st.b	r7[0x0],r8
800033b4:	30 1c       	mov	r12,1
               }
               return true;                     // the buffer is full
800033b6:	c7 38       	rjmp	8000349c <fat_entry_longname+0x178>
            // Read and store the long name
            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u16_unicode_entry;
            }else{
               sz_name[0] = (uint8_t)u16_unicode_entry;
800033b8:	9a 59       	ld.sh	r9,sp[0xa]
800033ba:	ae 89       	st.b	r7[0x0],r9
800033bc:	c2 f8       	rjmp	8000341a <fat_entry_longname+0xf6>
      {
         if( Is_unicode )
         {
            u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_unicode_szname = sz_name[0];
800033be:	0f 89       	ld.ub	r9,r7[0x0]
         }
         // Check the name
         if( '*' == u16_unicode_szname )
800033c0:	32 a3       	mov	r3,42
800033c2:	e6 09 19 00 	cp.h	r9,r3
800033c6:	c6 a0       	breq	8000349a <fat_entry_longname+0x176>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
800033c8:	9a 5e       	ld.sh	lr,sp[0xa]
800033ca:	58 0e       	cp.w	lr,0
800033cc:	c0 e1       	brne	800033e8 <fat_entry_longname+0xc4>
800033ce:	35 c0       	mov	r0,92
800033d0:	e0 09 19 00 	cp.h	r9,r0
800033d4:	5f 12       	srne	r2
800033d6:	32 f3       	mov	r3,47
800033d8:	e6 09 19 00 	cp.h	r9,r3
800033dc:	5f 13       	srne	r3
800033de:	e5 e3 00 03 	and	r3,r2,r3
800033e2:	f6 03 18 00 	cp.b	r3,r11
800033e6:	c1 e0       	breq	80003422 <fat_entry_longname+0xfe>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
800033e8:	e7 d9 c0 10 	bfextu	r3,r9,0x0,0x10
800033ec:	e5 de c0 10 	bfextu	r2,lr,0x0,0x10
         if( '*' == u16_unicode_szname )
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( ((0 != u16_unicode_entry ) || (( '\\' != u16_unicode_szname) && ( '/' != u16_unicode_szname)) )
800033f0:	e4 c0 ff e0 	sub	r0,r2,-32
800033f4:	00 33       	cp.w	r3,r0
800033f6:	c0 41       	brne	800033fe <fat_entry_longname+0xda>
800033f8:	40 00       	lddsp	r0,sp[0x0]
800033fa:	58 00       	cp.w	r0,0
800033fc:	c0 f0       	breq	8000341a <fat_entry_longname+0xf6>
800033fe:	22 02       	sub	r2,32
80003400:	04 33       	cp.w	r3,r2
80003402:	c0 41       	brne	8000340a <fat_entry_longname+0xe6>
80003404:	40 03       	lddsp	r3,sp[0x0]
80003406:	58 03       	cp.w	r3,0
80003408:	c0 90       	breq	8000341a <fat_entry_longname+0xf6>
8000340a:	fc 09 19 00 	cp.h	r9,lr
8000340e:	c0 60       	breq	8000341a <fat_entry_longname+0xf6>
         &&  ((u16_unicode_szname != (u16_unicode_entry+('a'-'A'))) || b_match_case)
         &&  ((u16_unicode_szname != (u16_unicode_entry-('a'-'A'))) || b_match_case)
         &&  (u16_unicode_szname != u16_unicode_entry) )
         {
           fs_g_status = FS_ERR_NAME_INCORRECT; //  The name don't corresponding at filter name
80003410:	31 69       	mov	r9,22
80003412:	4a 78       	lddpc	r8,800034ac <fat_entry_longname+0x188>
80003414:	b0 89       	st.b	r8[0x0],r9
80003416:	30 0c       	mov	r12,0
           return false;
80003418:	c4 28       	rjmp	8000349c <fat_entry_longname+0x178>
         }
      }

      if( 0 == u16_unicode_entry)
8000341a:	9a 59       	ld.sh	r9,sp[0xa]
8000341c:	e2 09 19 00 	cp.h	r9,r1
80003420:	c0 b1       	brne	80003436 <fat_entry_longname+0x112>
      {
         if( g_b_string_length )
80003422:	4a 49       	lddpc	r9,800034b0 <fat_entry_longname+0x18c>
80003424:	13 8a       	ld.ub	r10,r9[0x0]
80003426:	30 09       	mov	r9,0
80003428:	f2 0a 18 00 	cp.b	r10,r9
8000342c:	c3 70       	breq	8000349a <fat_entry_longname+0x176>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;
8000342e:	2f f8       	sub	r8,-1
80003430:	ae 08       	st.h	r7[0x0],r8
80003432:	30 1c       	mov	r12,1
80003434:	c3 48       	rjmp	8000349c <fat_entry_longname+0x178>
         }
         return true;                           // Last long name entry
      }
      if( 4 == u8_pos_name )
80003436:	e8 08 18 00 	cp.b	r8,r4
8000343a:	c0 31       	brne	80003440 <fat_entry_longname+0x11c>
         ptr_entry += 3;                        // Go to second character
8000343c:	2f dc       	sub	r12,-3
8000343e:	c2 58       	rjmp	80003488 <fat_entry_longname+0x164>

      if( 10 == u8_pos_name )
80003440:	30 a9       	mov	r9,10
80003442:	f2 08 18 00 	cp.b	r8,r9
80003446:	c0 31       	brne	8000344c <fat_entry_longname+0x128>
         ptr_entry += 2;                        // Go to third character
80003448:	2f ec       	sub	r12,-2
8000344a:	c1 f8       	rjmp	80003488 <fat_entry_longname+0x164>

      if( 12 == u8_pos_name )
8000344c:	30 c9       	mov	r9,12
8000344e:	f2 08 18 00 	cp.b	r8,r9
80003452:	c1 b1       	brne	80003488 <fat_entry_longname+0x164>
      {  // End of entry long name
         ptr_entry -= (FS_SIZE_FILE_ENTRY-2);   // Go to the first byte of the file entry
         if ( 0 == (FS_ENTRY_LFN_LAST & ptr_entry[0]))
80003454:	f9 38 ff e2 	ld.ub	r8,r12[-30]
80003458:	e2 18 00 40 	andl	r8,0x40,COH
8000345c:	c0 61       	brne	80003468 <fat_entry_longname+0x144>
         {
            fs_g_status = FS_NO_LAST_LFN_ENTRY;
8000345e:	31 09       	mov	r9,16
80003460:	49 38       	lddpc	r8,800034ac <fat_entry_longname+0x188>
80003462:	b0 89       	st.b	r8[0x0],r9
80003464:	30 0c       	mov	r12,0
            return false;                       // Other long name entry is present
80003466:	c1 b8       	rjmp	8000349c <fat_entry_longname+0x178>
         }
         else
         {  // It is the last long name entry
            // then it is the end of name
            if( (FS_NAME_GET == b_mode) && g_b_string_length )
80003468:	58 06       	cp.w	r6,0
8000346a:	c0 b0       	breq	80003480 <fat_entry_longname+0x15c>
8000346c:	49 18       	lddpc	r8,800034b0 <fat_entry_longname+0x18c>
8000346e:	11 89       	ld.ub	r9,r8[0x0]
80003470:	30 08       	mov	r8,0
80003472:	f0 09 18 00 	cp.b	r9,r8
80003476:	c1 50       	breq	800034a0 <fat_entry_longname+0x17c>
            {
               ((FS_STR_UNICODE)sz_name)[0] = 14;
80003478:	30 e8       	mov	r8,14
8000347a:	ae 08       	st.h	r7[0x0],r8
8000347c:	30 1c       	mov	r12,1
               return true;
8000347e:	c0 f8       	rjmp	8000349c <fat_entry_longname+0x178>
               {
                  u16_unicode_szname = ((FS_STR_UNICODE)sz_name)[0];
               }else{
                  u16_unicode_szname = sz_name[0];
               }
               return fat_check_eof_name(u16_unicode_szname);
80003480:	0f 9c       	ld.ub	r12,r7[0x1]
80003482:	f0 1f 00 0d 	mcall	800034b4 <fat_entry_longname+0x190>
80003486:	c0 b8       	rjmp	8000349c <fat_entry_longname+0x178>
            }
         }
      }

      if( !g_b_string_length )
80003488:	0b 89       	ld.ub	r9,r5[0x0]
      {
         sz_name += (Is_unicode? 2 : 1 );
8000348a:	f6 09 18 00 	cp.b	r9,r11
8000348e:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
80003492:	2f f8       	sub	r8,-1
80003494:	5c 58       	castu.b	r8
      ptr_entry+=2;
80003496:	2f ec       	sub	r12,-2
   }
80003498:	c7 fb       	rjmp	80003396 <fat_entry_longname+0x72>
8000349a:	30 1c       	mov	r12,1
}
8000349c:	2f dd       	sub	sp,-12
8000349e:	d8 32       	popm	r0-r7,pc
               // Write end of string UNICODE
               if( Is_unicode )
               {
                  ((FS_STR_UNICODE)sz_name)[0] = 0;
               }else{
                  sz_name[0] = 0;
800034a0:	30 08       	mov	r8,0
800034a2:	ae 98       	st.b	r7[0x1],r8
800034a4:	30 1c       	mov	r12,1
               }
               return true;
800034a6:	cf bb       	rjmp	8000349c <fat_entry_longname+0x178>
800034a8:	80 00       	ld.sh	r0,r0[0x0]
800034aa:	33 0c       	mov	r12,48
800034ac:	00 00       	add	r0,r0
800034ae:	0c 84       	andn	r4,r6
800034b0:	00 00       	add	r0,r0
800034b2:	0c 85       	andn	r5,r6
800034b4:	80 00       	ld.sh	r0,r0[0x0]
800034b6:	32 e4       	mov	r4,46

800034b8 <fat_entry_shortname>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_shortname( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode )
{
800034b8:	d4 31       	pushm	r0-r7,lr
800034ba:	20 2d       	sub	sp,8
800034bc:	18 97       	mov	r7,r12
800034be:	50 1b       	stdsp	sp[0x4],r11
800034c0:	14 96       	mov	r6,r10
   uint8_t u8_pos_name;
   uint8_t u8_entry_char, u8_szname_char;
   PTR_CACHE ptr_entry;
   uint8_t u8_pos_entry;

   fs_g_status = FS_ERR_NAME_INCORRECT;  // by default the name don't corresponding at filter name
800034c2:	31 69       	mov	r9,22
800034c4:	4b c8       	lddpc	r8,800035b4 <fat_entry_shortname+0xfc>
800034c6:	b0 89       	st.b	r8[0x0],r9

   u8_pos_name = 0;
   u8_pos_entry = 0;
   ptr_entry = fat_get_ptr_entry();
800034c8:	f0 1f 00 3c 	mcall	800035b8 <fat_entry_shortname+0x100>
800034cc:	30 08       	mov	r8,0
800034ce:	10 9a       	mov	r10,r8
800034d0:	30 1b       	mov	r11,1
800034d2:	50 0b       	stdsp	sp[0x0],r11

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
800034d4:	30 be       	mov	lr,11
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800034d6:	10 93       	mov	r3,r8
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
800034d8:	30 85       	mov	r5,8
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
800034da:	32 04       	mov	r4,32
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
         }
         if ('*' == u8_szname_char)
800034dc:	32 a2       	mov	r2,42
   ptr_entry = fat_get_ptr_entry();

   // for each characters of short name
   while( 1 )
   {
      if( FS_SIZE_SFNAME == u8_pos_entry )
800034de:	fc 08 18 00 	cp.b	r8,lr
800034e2:	c1 90       	breq	80003514 <fat_entry_shortname+0x5c>
      {
         u8_entry_char = 0;   // end of name
      }
      else
      {
         u8_entry_char = ptr_entry[ u8_pos_entry ];
800034e4:	f8 08 07 09 	ld.ub	r9,r12[r8]
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT == u8_pos_entry) && b_extension_nostart)  // end of name and '.' character not written
800034e8:	ea 08 18 00 	cp.b	r8,r5
800034ec:	c0 41       	brne	800034f4 <fat_entry_shortname+0x3c>
800034ee:	40 01       	lddsp	r1,sp[0x0]
800034f0:	58 01       	cp.w	r1,0
800034f2:	c0 81       	brne	80003502 <fat_entry_shortname+0x4a>
800034f4:	e8 09 18 00 	cp.b	r9,r4
800034f8:	c0 f1       	brne	80003516 <fat_entry_shortname+0x5e>
         ||  ( ' ' == u8_entry_char) )
         {
            // end of name or extension
            if( (FS_SIZE_SFNAME_WITHOUT_EXT >= u8_pos_entry)         // End of name without extension
800034fa:	ea 08 18 00 	cp.b	r8,r5
800034fe:	e0 8b 00 0b 	brhi	80003514 <fat_entry_shortname+0x5c>
            &&  (' ' != ptr_entry[ FS_SIZE_SFNAME_WITHOUT_EXT ]) )   // extension exists
80003502:	f9 39 00 08 	ld.ub	r9,r12[8]
80003506:	e8 09 18 00 	cp.b	r9,r4
8000350a:	c0 50       	breq	80003514 <fat_entry_shortname+0x5c>
8000350c:	30 78       	mov	r8,7
8000350e:	32 e9       	mov	r9,46
80003510:	50 03       	stdsp	sp[0x0],r3
80003512:	c0 28       	rjmp	80003516 <fat_entry_shortname+0x5e>
80003514:	06 99       	mov	r9,r3
               u8_entry_char = 0;                                    // end of name
            }
         }
      }

      if( FS_NAME_GET == b_mode )
80003516:	58 06       	cp.w	r6,0
80003518:	c1 80       	breq	80003548 <fat_entry_shortname+0x90>
      {
         if( !g_b_string_length )
8000351a:	4a 9b       	lddpc	r11,800035bc <fat_entry_shortname+0x104>
8000351c:	17 81       	ld.ub	r1,r11[0x0]
8000351e:	30 0b       	mov	r11,0
80003520:	f6 01 18 00 	cp.b	r1,r11
80003524:	c2 c1       	brne	8000357c <fat_entry_shortname+0xc4>
         {
            if(u8_pos_name >= (u8_size_max-1))
80003526:	40 1b       	lddsp	r11,sp[0x4]
80003528:	20 1b       	sub	r11,1
8000352a:	16 3a       	cp.w	r10,r11
8000352c:	c0 35       	brlt	80003532 <fat_entry_shortname+0x7a>
8000352e:	06 99       	mov	r9,r3
80003530:	c0 a8       	rjmp	80003544 <fat_entry_shortname+0x8c>
               u8_entry_char = 0;                                    // buffer full then force end of string

            if( ('A'<=u8_entry_char) && (u8_entry_char<='Z'))
80003532:	f2 c1 00 41 	sub	r1,r9,65
80003536:	31 9b       	mov	r11,25
80003538:	f6 01 18 00 	cp.b	r1,r11
8000353c:	e0 8b 00 04 	brhi	80003544 <fat_entry_shortname+0x8c>
               u8_entry_char += ('a'-'A');                           // display short name in down case
80003540:	2e 09       	sub	r9,-32
80003542:	5c 59       	castu.b	r9

            if( Is_unicode )
            {
               ((FS_STR_UNICODE)sz_name)[0] = u8_entry_char;
            }else{
               sz_name[0] = u8_entry_char;
80003544:	ae 89       	st.b	r7[0x0],r9
80003546:	c1 b8       	rjmp	8000357c <fat_entry_shortname+0xc4>

         if( Is_unicode )
         {
            u8_szname_char = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u8_szname_char = sz_name[0];
80003548:	0f 8b       	ld.ub	r11,r7[0x0]
         }
         if ('*' == u8_szname_char)
8000354a:	e4 0b 18 00 	cp.b	r11,r2
8000354e:	c2 f0       	breq	800035ac <fat_entry_shortname+0xf4>
         {  // end of filter name which authorize all next character
            return true;   //*** The name is correct ***
         }

         if( (0 != u8_entry_char) || (('\\' != u8_szname_char) && ('/' != u8_szname_char)) )
80003550:	58 09       	cp.w	r9,0
80003552:	c0 c1       	brne	8000356a <fat_entry_shortname+0xb2>
80003554:	35 c1       	mov	r1,92
80003556:	e2 0b 18 00 	cp.b	r11,r1
8000355a:	5f 10       	srne	r0
8000355c:	32 f1       	mov	r1,47
8000355e:	e2 0b 18 00 	cp.b	r11,r1
80003562:	5f 11       	srne	r1
80003564:	e1 e1 00 01 	and	r1,r0,r1
80003568:	c0 c0       	breq	80003580 <fat_entry_shortname+0xc8>
         {
            if((u8_szname_char != u8_entry_char)
8000356a:	f2 0b 18 00 	cp.b	r11,r9
8000356e:	c0 70       	breq	8000357c <fat_entry_shortname+0xc4>
80003570:	f2 c1 ff e0 	sub	r1,r9,-32
80003574:	02 3b       	cp.w	r11,r1
80003576:	c0 30       	breq	8000357c <fat_entry_shortname+0xc4>
80003578:	30 0c       	mov	r12,0
8000357a:	c1 a8       	rjmp	800035ae <fat_entry_shortname+0xf6>
               return false;  // short name not equal
         }
      }

      // For each characters
      if (0 == u8_entry_char)
8000357c:	58 09       	cp.w	r9,0
8000357e:	c0 b1       	brne	80003594 <fat_entry_shortname+0xdc>
      {
         if( g_b_string_length )
80003580:	48 f8       	lddpc	r8,800035bc <fat_entry_shortname+0x104>
80003582:	11 89       	ld.ub	r9,r8[0x0]
80003584:	30 08       	mov	r8,0
80003586:	f0 09 18 00 	cp.b	r9,r8
8000358a:	c1 10       	breq	800035ac <fat_entry_shortname+0xf4>
         {
            ((FS_STR_UNICODE)sz_name)[0] = u8_pos_name+1;      // Get length name
8000358c:	2f fa       	sub	r10,-1
8000358e:	ae 0a       	st.h	r7[0x0],r10
80003590:	30 1c       	mov	r12,1
80003592:	c0 e8       	rjmp	800035ae <fat_entry_shortname+0xf6>
         }
         return true;   // End of test correct or end of get name
      }
      if( !g_b_string_length )
80003594:	48 a9       	lddpc	r9,800035bc <fat_entry_shortname+0x104>
80003596:	13 8b       	ld.ub	r11,r9[0x0]
80003598:	30 09       	mov	r9,0
      {
         sz_name += (Is_unicode? 2 : 1 );
8000359a:	f2 0b 18 00 	cp.b	r11,r9
8000359e:	f7 b7 00 ff 	subeq	r7,-1
      }
      u8_pos_name++;
800035a2:	2f fa       	sub	r10,-1
800035a4:	5c 5a       	castu.b	r10
      u8_pos_entry++;
800035a6:	2f f8       	sub	r8,-1
800035a8:	5c 58       	castu.b	r8
   }
800035aa:	c9 ab       	rjmp	800034de <fat_entry_shortname+0x26>
800035ac:	30 1c       	mov	r12,1
}
800035ae:	2f ed       	sub	sp,-8
800035b0:	d8 32       	popm	r0-r7,pc
800035b2:	00 00       	add	r0,r0
800035b4:	00 00       	add	r0,r0
800035b6:	0c 84       	andn	r4,r6
800035b8:	80 00       	ld.sh	r0,r0[0x0]
800035ba:	33 0c       	mov	r12,48
800035bc:	00 00       	add	r0,r0
800035be:	0c 85       	andn	r5,r6

800035c0 <fat_get_entry_info>:
//! OUT:
//!   fs_g_nav_entry. u32_cluster, u8_attr, u32_size
//! @endverbatim
//!
void  fat_get_entry_info( void )
{
800035c0:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   ptr_entry = fat_get_ptr_entry();
800035c2:	f0 1f 00 10 	mcall	80003600 <fat_get_entry_info+0x40>

   // Get Attribute
   ptr_entry+= 11;
   fs_g_nav_entry.u8_attr = ptr_entry[0];
800035c6:	49 08       	lddpc	r8,80003604 <fat_get_entry_info+0x44>
800035c8:	f9 39 00 0b 	ld.ub	r9,r12[11]
800035cc:	b0 a9       	st.b	r8[0x2],r9

   // Get the first cluster of the file cluster list
   ptr_entry += (20-11);
800035ce:	f8 ca ff ec 	sub	r10,r12,-20
   LSB2(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
800035d2:	f0 c9 ff fc 	sub	r9,r8,-4
800035d6:	15 8b       	ld.ub	r11,r10[0x0]
800035d8:	b2 9b       	st.b	r9[0x1],r11
   LSB3(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
800035da:	15 9a       	ld.ub	r10,r10[0x1]
800035dc:	b2 8a       	st.b	r9[0x0],r10
   ptr_entry += (26-20);
800035de:	f8 ca ff e6 	sub	r10,r12,-26
   LSB0(fs_g_nav_entry.u32_cluster) = ptr_entry[0];
800035e2:	15 8b       	ld.ub	r11,r10[0x0]
800035e4:	b2 bb       	st.b	r9[0x3],r11
   LSB1(fs_g_nav_entry.u32_cluster) = ptr_entry[1];
800035e6:	15 9a       	ld.ub	r10,r10[0x1]
800035e8:	b2 aa       	st.b	r9[0x2],r10

   // Get the size of file
   ptr_entry += (28-26);
800035ea:	2e 4c       	sub	r12,-28
   LSB0(fs_g_nav_entry.u32_size) = ptr_entry[0];
800035ec:	2f 88       	sub	r8,-8
800035ee:	19 89       	ld.ub	r9,r12[0x0]
800035f0:	b0 b9       	st.b	r8[0x3],r9
   LSB1(fs_g_nav_entry.u32_size) = ptr_entry[1];
800035f2:	19 99       	ld.ub	r9,r12[0x1]
800035f4:	b0 a9       	st.b	r8[0x2],r9
   LSB2(fs_g_nav_entry.u32_size) = ptr_entry[2];
800035f6:	19 a9       	ld.ub	r9,r12[0x2]
800035f8:	b0 99       	st.b	r8[0x1],r9
   LSB3(fs_g_nav_entry.u32_size) = ptr_entry[3];
800035fa:	19 b9       	ld.ub	r9,r12[0x3]
800035fc:	b0 89       	st.b	r8[0x0],r9
}
800035fe:	d8 02       	popm	pc
80003600:	80 00       	ld.sh	r0,r0[0x0]
80003602:	33 0c       	mov	r12,48
80003604:	00 00       	add	r0,r0
80003606:	09 f4       	ld.ub	r4,r4[0x7]

80003608 <fat_entry_check>:
//!   fs_g_sector       The directory sector corresponding at the current position
//!   fs_g_nav_fast.u16_entry_pos_sel_file    Position in directory of the entry file (unit entry)
//! @endverbatim
//!
bool  fat_entry_check( bool b_type )
{
80003608:	eb cd 40 80 	pushm	r7,lr
8000360c:	18 97       	mov	r7,r12
   PTR_CACHE u8_ptr_entry;
   uint8_t u8_first_byte, u8_seconde_byte;
   uint8_t u8_attribut;

   u8_ptr_entry = fat_get_ptr_entry();
8000360e:	f0 1f 00 14 	mcall	8000365c <fat_entry_check+0x54>

   u8_first_byte = u8_ptr_entry[0];
80003612:	19 88       	ld.ub	r8,r12[0x0]
   if ( FS_ENTRY_END == u8_first_byte )
80003614:	58 08       	cp.w	r8,0
80003616:	c0 61       	brne	80003622 <fat_entry_check+0x1a>
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;   // end of directory
80003618:	30 a9       	mov	r9,10
8000361a:	49 28       	lddpc	r8,80003660 <fat_entry_check+0x58>
8000361c:	b0 89       	st.b	r8[0x0],r9
8000361e:	30 07       	mov	r7,0
      return false;
80003620:	c1 a8       	rjmp	80003654 <fat_entry_check+0x4c>
   }
   fs_g_status = FS_ERR_ENTRY_BAD;        // by default BAD ENTRY
80003622:	30 ba       	mov	r10,11
80003624:	48 f9       	lddpc	r9,80003660 <fat_entry_check+0x58>
80003626:	b2 8a       	st.b	r9[0x0],r10
   if ( FS_ENTRY_DEL == u8_first_byte )      { return false;   } // entry deleted
80003628:	3e 59       	mov	r9,-27
8000362a:	f2 08 18 00 	cp.b	r8,r9
8000362e:	c1 20       	breq	80003652 <fat_entry_check+0x4a>
   if (   '.'  == u8_first_byte )            { return false;   } // current dir "."
80003630:	32 e9       	mov	r9,46
80003632:	f2 08 18 00 	cp.b	r8,r9
80003636:	c0 e0       	breq	80003652 <fat_entry_check+0x4a>
   if ( ('.'  == u8_first_byte)
   &&   ('.'  == u8_seconde_byte) )          { return false;   } // current dir ".."

   // Check Attribute
   u8_attribut = u8_ptr_entry[11];
   if ( FS_ATTR_VOLUME_ID & u8_attribut )    { return false;   } // volume id
80003638:	f9 38 00 0b 	ld.ub	r8,r12[11]
8000363c:	10 99       	mov	r9,r8
8000363e:	e2 19 00 08 	andl	r9,0x8,COH
80003642:	c0 81       	brne	80003652 <fat_entry_check+0x4a>
   // Optimization, this line isn't necessary because the next test control this case
   // if ( FS_ATTR_LFN_ENTRY == *u8_ptr_entry) { return false;   } // long file name

   // Check entry type
   if( FS_ATTR_DIRECTORY & u8_attribut )
80003644:	e2 18 00 10 	andl	r8,0x10,COH
80003648:	c0 60       	breq	80003654 <fat_entry_check+0x4c>
   {
      return (FS_DIR == b_type);
8000364a:	ec 17 00 01 	eorl	r7,0x1
8000364e:	5c 57       	castu.b	r7
80003650:	c0 28       	rjmp	80003654 <fat_entry_check+0x4c>
80003652:	30 07       	mov	r7,0
   }else{
      return (FS_FILE == b_type);
   }
}
80003654:	0e 9c       	mov	r12,r7
80003656:	e3 cd 80 80 	ldm	sp++,r7,pc
8000365a:	00 00       	add	r0,r0
8000365c:	80 00       	ld.sh	r0,r0[0x0]
8000365e:	33 0c       	mov	r12,48
80003660:	00 00       	add	r0,r0
80003662:	0c 84       	andn	r4,r6

80003664 <fat_cache_reset>:

//! This function resets the sector cache
//!
void  fat_cache_reset( void )
{
   fs_g_sectorcache.u8_lun                = FS_BUF_SECTOR_EMPTY;
80003664:	48 58       	lddpc	r8,80003678 <fat_cache_reset+0x14>
80003666:	3f f9       	mov	r9,-1
80003668:	b0 89       	st.b	r8[0x0],r9
   fs_g_sectorcache.u8_dirty              = false;
8000366a:	30 09       	mov	r9,0
8000366c:	f1 69 00 08 	st.b	r8[8],r9
   fs_g_sectorcache.u32_clusterlist_start = 0xFFFFFFFF;
80003670:	3f f9       	mov	r9,-1
80003672:	91 39       	st.w	r8[0xc],r9
}
80003674:	5e fc       	retal	r12
80003676:	00 00       	add	r0,r0
80003678:	00 00       	add	r0,r0
8000367a:	0c bc       	st.h	r6++,r12

8000367c <fat_cache_mark_sector_as_dirty>:

//! This function sets a flag to signal that sector cache is modified
//!
void  fat_cache_mark_sector_as_dirty( void )
{
   fs_g_sectorcache.u8_dirty = true;
8000367c:	30 19       	mov	r9,1
8000367e:	48 38       	lddpc	r8,80003688 <fat_cache_mark_sector_as_dirty+0xc>
80003680:	f1 69 00 08 	st.b	r8[8],r9
}
80003684:	5e fc       	retal	r12
80003686:	00 00       	add	r0,r0
80003688:	00 00       	add	r0,r0
8000368a:	0c bc       	st.h	r6++,r12

8000368c <fat_write_entry_file>:
//! OUT:
//!   fs_g_sector    Updated
//! @endverbatim
//!
void  fat_write_entry_file( void )
{
8000368c:	d4 01       	pushm	lr
   PTR_CACHE ptr_entry;

   fat_cache_mark_sector_as_dirty();
8000368e:	f0 1f 00 11 	mcall	800036d0 <fat_write_entry_file+0x44>
   ptr_entry = fat_get_ptr_entry();
80003692:	f0 1f 00 11 	mcall	800036d4 <fat_write_entry_file+0x48>
         fs_g_nav_entry.u32_cluster = 0;
   }

   //! Write the Attribute
   ptr_entry+= 11;
   ptr_entry[0] = fs_g_nav_entry.u8_attr;
80003696:	49 18       	lddpc	r8,800036d8 <fat_write_entry_file+0x4c>
80003698:	11 a9       	ld.ub	r9,r8[0x2]
8000369a:	f9 69 00 0b 	st.b	r12[11],r9

   // Write the first cluster of file cluster list
   ptr_entry += (20-11);
8000369e:	f8 ca ff ec 	sub	r10,r12,-20
   ptr_entry[0] = LSB2(fs_g_nav_entry.u32_cluster);
800036a2:	f0 c9 ff fc 	sub	r9,r8,-4
800036a6:	13 9b       	ld.ub	r11,r9[0x1]
800036a8:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB3(fs_g_nav_entry.u32_cluster);
800036aa:	13 8b       	ld.ub	r11,r9[0x0]
800036ac:	b4 9b       	st.b	r10[0x1],r11
   ptr_entry += (26-20);
800036ae:	f8 ca ff e6 	sub	r10,r12,-26
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_cluster);
800036b2:	13 bb       	ld.ub	r11,r9[0x3]
800036b4:	b4 8b       	st.b	r10[0x0],r11
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_cluster);
800036b6:	13 a9       	ld.ub	r9,r9[0x2]
800036b8:	b4 99       	st.b	r10[0x1],r9

   //! Write the size of file
   ptr_entry += (28-26);
800036ba:	2e 4c       	sub	r12,-28
   ptr_entry[0] = LSB0(fs_g_nav_entry.u32_size);
800036bc:	2f 88       	sub	r8,-8
800036be:	11 b9       	ld.ub	r9,r8[0x3]
800036c0:	b8 89       	st.b	r12[0x0],r9
   ptr_entry[1] = LSB1(fs_g_nav_entry.u32_size);
800036c2:	11 a9       	ld.ub	r9,r8[0x2]
800036c4:	b8 99       	st.b	r12[0x1],r9
   ptr_entry[2] = LSB2(fs_g_nav_entry.u32_size);
800036c6:	11 99       	ld.ub	r9,r8[0x1]
800036c8:	b8 a9       	st.b	r12[0x2],r9
   ptr_entry[3] = LSB3(fs_g_nav_entry.u32_size);
800036ca:	11 88       	ld.ub	r8,r8[0x0]
800036cc:	b8 b8       	st.b	r12[0x3],r8
}
800036ce:	d8 02       	popm	pc
800036d0:	80 00       	ld.sh	r0,r0[0x0]
800036d2:	36 7c       	mov	r12,103
800036d4:	80 00       	ld.sh	r0,r0[0x0]
800036d6:	33 0c       	mov	r12,48
800036d8:	00 00       	add	r0,r0
800036da:	09 f4       	ld.ub	r4,r4[0x7]

800036dc <fat_check_nav_access_file>:

   // For each navigators
   for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
   {
      // Disk mounted ?
      if( FS_TYPE_FAT_UNM != fs_g_navext_fast[i].u8_type_fat )
800036dc:	49 88       	lddpc	r8,8000373c <fat_check_nav_access_file+0x60>
800036de:	11 89       	ld.ub	r9,r8[0x0]
800036e0:	30 08       	mov	r8,0
800036e2:	f0 09 18 00 	cp.b	r9,r8
800036e6:	c2 a0       	breq	8000373a <fat_check_nav_access_file+0x5e>
      // Is it the same disk ?
      if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
800036e8:	49 68       	lddpc	r8,80003740 <fat_check_nav_access_file+0x64>
800036ea:	11 89       	ld.ub	r9,r8[0x0]
800036ec:	49 68       	lddpc	r8,80003744 <fat_check_nav_access_file+0x68>
800036ee:	11 88       	ld.ub	r8,r8[0x0]
800036f0:	f0 09 18 00 	cp.b	r9,r8
800036f4:	c2 31       	brne	8000373a <fat_check_nav_access_file+0x5e>
#if (FS_MULTI_PARTITION == true)
      // Is it the same partition ?
      if( fs_g_nav.u8_partition == fs_g_navext[i].u8_partition )
#endif
      // Is it the same directory ?
      if( fs_g_nav.u32_cluster_sel_dir == fs_g_navext[i].u32_cluster_sel_dir )
800036f6:	49 38       	lddpc	r8,80003740 <fat_check_nav_access_file+0x64>
800036f8:	70 89       	ld.w	r9,r8[0x20]
800036fa:	49 38       	lddpc	r8,80003744 <fat_check_nav_access_file+0x68>
800036fc:	70 88       	ld.w	r8,r8[0x20]
800036fe:	10 39       	cp.w	r9,r8
80003700:	c1 d1       	brne	8000373a <fat_check_nav_access_file+0x5e>
      // Is it the same file ?
      if( fs_g_nav_fast.u16_entry_pos_sel_file == fs_g_navext_fast[i].u16_entry_pos_sel_file )
80003702:	49 28       	lddpc	r8,80003748 <fat_check_nav_access_file+0x6c>
80003704:	90 19       	ld.sh	r9,r8[0x2]
80003706:	48 e8       	lddpc	r8,8000373c <fat_check_nav_access_file+0x60>
80003708:	90 18       	ld.sh	r8,r8[0x2]
8000370a:	f0 09 19 00 	cp.h	r9,r8
8000370e:	c1 61       	brne	8000373a <fat_check_nav_access_file+0x5e>
      {
         if( mode )
80003710:	58 0c       	cp.w	r12,0
80003712:	c0 b0       	breq	80003728 <fat_check_nav_access_file+0x4c>
         {
            // Is it open ?
            if( fs_g_navext_entry[i].u8_open_mode!=0 )
80003714:	48 e8       	lddpc	r8,8000374c <fat_check_nav_access_file+0x70>
80003716:	11 89       	ld.ub	r9,r8[0x0]
80003718:	30 08       	mov	r8,0
8000371a:	f0 09 18 00 	cp.b	r9,r8
8000371e:	c0 e0       	breq	8000373a <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN;
80003720:	32 89       	mov	r9,40
80003722:	48 c8       	lddpc	r8,80003750 <fat_check_nav_access_file+0x74>
80003724:	b0 89       	st.b	r8[0x0],r9
80003726:	5e fd       	retal	0
            }
         }
         else
         {
            // Is it open in write mode ?
            if( fs_g_navext_entry[i].u8_open_mode & FOPEN_WRITE_ACCESS )
80003728:	48 98       	lddpc	r8,8000374c <fat_check_nav_access_file+0x70>
8000372a:	11 88       	ld.ub	r8,r8[0x0]
8000372c:	e2 18 00 02 	andl	r8,0x2,COH
80003730:	c0 50       	breq	8000373a <fat_check_nav_access_file+0x5e>
            {
               fs_g_status = FS_ERR_FILE_OPEN_WR;
80003732:	32 99       	mov	r9,41
80003734:	48 78       	lddpc	r8,80003750 <fat_check_nav_access_file+0x74>
80003736:	b0 89       	st.b	r8[0x0],r9
80003738:	5e fd       	retal	0
               return false;  // File opened in write mode then read access not possible
8000373a:	5e ff       	retal	1
8000373c:	00 00       	add	r0,r0
8000373e:	0c 7c       	tst	r12,r6
80003740:	00 00       	add	r0,r0
80003742:	0c 34       	cp.w	r4,r6
80003744:	00 00       	add	r0,r0
80003746:	0c 88       	andn	r8,r6
80003748:	00 00       	add	r0,r0
8000374a:	0c 80       	andn	r0,r6
8000374c:	00 00       	add	r0,r0
8000374e:	0c 6c       	and	r12,r6
80003750:	00 00       	add	r0,r0
80003752:	0c 84       	andn	r4,r6

80003754 <fat_invert_nav>:
//! This function inverts the current navigation with another
//!
//! @param     u8_idnav    Id navigator to invert
//!
void  fat_invert_nav( uint8_t u8_idnav )
{
80003754:	d4 21       	pushm	r4-r7,lr
80003756:	20 dd       	sub	sp,52
   _MEM_TYPE_SLOW_ uint8_t Temp[Max(Max(sizeof(Fs_management),sizeof(Fs_management_entry)),sizeof(Fs_management_fast))];

   if( u8_idnav == 0 )
80003758:	58 0c       	cp.w	r12,0
8000375a:	c5 a0       	breq	8000380e <fat_invert_nav+0xba>
      return;
   u8_idnav--;

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav,                     sizeof(Fs_management));
8000375c:	1a 97       	mov	r7,sp
8000375e:	4a e8       	lddpc	r8,80003814 <fat_invert_nav+0xc0>
80003760:	f0 ea 00 00 	ld.d	r10,r8[0]
80003764:	fa eb 00 00 	st.d	sp[0],r10
80003768:	f0 ea 00 08 	ld.d	r10,r8[8]
8000376c:	fa eb 00 08 	st.d	sp[8],r10
80003770:	f0 ea 00 10 	ld.d	r10,r8[16]
80003774:	fa eb 00 10 	st.d	sp[16],r10
80003778:	f0 ea 00 18 	ld.d	r10,r8[24]
8000377c:	fa eb 00 18 	st.d	sp[24],r10
80003780:	f0 ea 00 20 	ld.d	r10,r8[32]
80003784:	fa eb 00 20 	st.d	sp[32],r10
80003788:	f0 ea 00 28 	ld.d	r10,r8[40]
8000378c:	fa eb 00 28 	st.d	sp[40],r10
80003790:	70 c9       	ld.w	r9,r8[0x30]
80003792:	50 c9       	stdsp	sp[0x30],r9
   memcpy_ram2ram((uint8_t*)&fs_g_nav,                    (uint8_t*)&fs_g_navext[u8_idnav],        sizeof(Fs_management));
80003794:	f8 c6 00 01 	sub	r6,r12,1
80003798:	5c 56       	castu.b	r6
8000379a:	ec 04 10 34 	mul	r4,r6,52
8000379e:	49 f9       	lddpc	r9,80003818 <fat_invert_nav+0xc4>
800037a0:	12 04       	add	r4,r9
800037a2:	33 45       	mov	r5,52
800037a4:	0a 9a       	mov	r10,r5
800037a6:	08 9b       	mov	r11,r4
800037a8:	10 9c       	mov	r12,r8
800037aa:	f0 1f 00 1d 	mcall	8000381c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext[u8_idnav],       Temp,                               sizeof(Fs_management));
800037ae:	0a 9a       	mov	r10,r5
800037b0:	1a 9b       	mov	r11,sp
800037b2:	08 9c       	mov	r12,r4
800037b4:	f0 1f 00 1a 	mcall	8000381c <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_entry,               sizeof(Fs_management_entry));
800037b8:	49 ac       	lddpc	r12,80003820 <fat_invert_nav+0xcc>
800037ba:	f8 e8 00 00 	ld.d	r8,r12[0]
800037be:	fa e9 00 00 	st.d	sp[0],r8
800037c2:	f8 e8 00 08 	ld.d	r8,r12[8]
800037c6:	fa e9 00 08 	st.d	sp[8],r8
   memcpy_ram2ram((uint8_t*)&fs_g_nav_entry,              (uint8_t*)&fs_g_navext_entry[u8_idnav],  sizeof(Fs_management_entry));
800037ca:	ec 04 15 04 	lsl	r4,r6,0x4
800037ce:	49 68       	lddpc	r8,80003824 <fat_invert_nav+0xd0>
800037d0:	10 04       	add	r4,r8
800037d2:	31 05       	mov	r5,16
800037d4:	0a 9a       	mov	r10,r5
800037d6:	08 9b       	mov	r11,r4
800037d8:	f0 1f 00 11 	mcall	8000381c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_entry[u8_idnav], Temp,                               sizeof(Fs_management_entry));
800037dc:	0a 9a       	mov	r10,r5
800037de:	1a 9b       	mov	r11,sp
800037e0:	08 9c       	mov	r12,r4
800037e2:	f0 1f 00 0f 	mcall	8000381c <fat_invert_nav+0xc8>

   memcpy_ram2ram(Temp,                              (uint8_t*)&fs_g_nav_fast,                sizeof(Fs_management_fast));
800037e6:	49 14       	lddpc	r4,80003828 <fat_invert_nav+0xd4>
800037e8:	30 45       	mov	r5,4
800037ea:	0a 9a       	mov	r10,r5
800037ec:	08 9b       	mov	r11,r4
800037ee:	1a 9c       	mov	r12,sp
800037f0:	f0 1f 00 0b 	mcall	8000381c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_nav_fast,               (uint8_t*)&fs_g_navext_fast[u8_idnav],   sizeof(Fs_management_fast));
800037f4:	48 e8       	lddpc	r8,8000382c <fat_invert_nav+0xd8>
800037f6:	f0 06 00 26 	add	r6,r8,r6<<0x2
800037fa:	0a 9a       	mov	r10,r5
800037fc:	0c 9b       	mov	r11,r6
800037fe:	08 9c       	mov	r12,r4
80003800:	f0 1f 00 07 	mcall	8000381c <fat_invert_nav+0xc8>
   memcpy_ram2ram((uint8_t*)&fs_g_navext_fast[u8_idnav],  Temp,                               sizeof(Fs_management_fast));
80003804:	0a 9a       	mov	r10,r5
80003806:	1a 9b       	mov	r11,sp
80003808:	0c 9c       	mov	r12,r6
8000380a:	f0 1f 00 05 	mcall	8000381c <fat_invert_nav+0xc8>
}
8000380e:	2f 3d       	sub	sp,-52
80003810:	d8 22       	popm	r4-r7,pc
80003812:	00 00       	add	r0,r0
80003814:	00 00       	add	r0,r0
80003816:	0c 34       	cp.w	r4,r6
80003818:	00 00       	add	r0,r0
8000381a:	0c 88       	andn	r8,r6
8000381c:	80 01       	ld.sh	r1,r0[0x0]
8000381e:	54 ba       	stdsp	sp[0x12c],r10
80003820:	00 00       	add	r0,r0
80003822:	09 f4       	ld.ub	r4,r4[0x7]
80003824:	00 00       	add	r0,r0
80003826:	0c 6c       	and	r12,r6
80003828:	00 00       	add	r0,r0
8000382a:	0c 80       	andn	r0,r6
8000382c:	00 00       	add	r0,r0
8000382e:	0c 7c       	tst	r12,r6

80003830 <fat_cache_flush>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_cache_flush( void )
{
80003830:	d4 01       	pushm	lr
   // If the cache is modified, then write the sector cache on the device
   if ( true == fs_g_sectorcache.u8_dirty )
80003832:	49 08       	lddpc	r8,80003870 <fat_cache_flush+0x40>
80003834:	f1 39 00 08 	ld.ub	r9,r8[8]
80003838:	30 18       	mov	r8,1
8000383a:	f0 09 18 00 	cp.b	r9,r8
8000383e:	c1 81       	brne	8000386e <fat_cache_flush+0x3e>
   {
      fs_g_sectorcache.u8_dirty = false; // Always clear, although an error occur
80003840:	48 c8       	lddpc	r8,80003870 <fat_cache_flush+0x40>
80003842:	30 09       	mov	r9,0
80003844:	f1 69 00 08 	st.b	r8[8],r9
      if( mem_wr_protect( fs_g_sectorcache.u8_lun  ))
80003848:	11 8c       	ld.ub	r12,r8[0x0]
8000384a:	f0 1f 00 0b 	mcall	80003874 <fat_cache_flush+0x44>
8000384e:	c0 50       	breq	80003858 <fat_cache_flush+0x28>
      {
         fs_g_status = FS_LUN_WP;
80003850:	31 49       	mov	r9,20
80003852:	48 a8       	lddpc	r8,80003878 <fat_cache_flush+0x48>
80003854:	b0 89       	st.b	r8[0x0],r9
80003856:	d8 0a       	popm	pc,r12=0
         return false;
      }
      if (CTRL_GOOD != ram_2_memory( fs_g_sectorcache.u8_lun , fs_g_sectorcache.u32_addr , fs_g_sector ))
80003858:	48 68       	lddpc	r8,80003870 <fat_cache_flush+0x40>
8000385a:	48 9a       	lddpc	r10,8000387c <fat_cache_flush+0x4c>
8000385c:	70 1b       	ld.w	r11,r8[0x4]
8000385e:	11 8c       	ld.ub	r12,r8[0x0]
80003860:	f0 1f 00 08 	mcall	80003880 <fat_cache_flush+0x50>
80003864:	c0 50       	breq	8000386e <fat_cache_flush+0x3e>
      {
         fs_g_status = FS_ERR_HW;
80003866:	30 19       	mov	r9,1
80003868:	48 48       	lddpc	r8,80003878 <fat_cache_flush+0x48>
8000386a:	b0 89       	st.b	r8[0x0],r9
8000386c:	d8 0a       	popm	pc,r12=0
         return false;
8000386e:	da 0a       	popm	pc,r12=1
80003870:	00 00       	add	r0,r0
80003872:	0c bc       	st.h	r6++,r12
80003874:	80 00       	ld.sh	r0,r0[0x0]
80003876:	42 f8       	lddsp	r8,sp[0xbc]
80003878:	00 00       	add	r0,r0
8000387a:	0c 84       	andn	r4,r6
8000387c:	00 00       	add	r0,r0
8000387e:	0a 34       	cp.w	r4,r5
80003880:	80 00       	ld.sh	r0,r0[0x0]
80003882:	43 0c       	lddsp	r12,sp[0xc0]

80003884 <fat_cache_clear>:

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the sector cache
//!
void  fat_cache_clear( void )
{
80003884:	d4 01       	pushm	lr
   memset( fs_g_sector , 0 , FS_CACHE_SIZE );
80003886:	e0 6a 02 00 	mov	r10,512
8000388a:	30 0b       	mov	r11,0
8000388c:	48 2c       	lddpc	r12,80003894 <fat_cache_clear+0x10>
8000388e:	f0 1f 00 03 	mcall	80003898 <fat_cache_clear+0x14>
}
80003892:	d8 02       	popm	pc
80003894:	00 00       	add	r0,r0
80003896:	0a 34       	cp.w	r4,r5
80003898:	80 01       	ld.sh	r1,r0[0x0]
8000389a:	56 02       	stdsp	sp[0x180],r2

8000389c <fat_cache_read_sector>:
//!   fs_g_nav.u8_lun      drive number to read
//!   fs_gu32_addrsector   address to read (unit sector)
//! @endverbatim
//!
bool  fat_cache_read_sector( bool b_load )
{
8000389c:	eb cd 40 80 	pushm	r7,lr
800038a0:	18 97       	mov	r7,r12
   // Check if the sector asked is the same in cache
   if( (fs_g_sectorcache.u8_lun     == fs_g_nav.u8_lun )
800038a2:	49 78       	lddpc	r8,800038fc <fat_cache_read_sector+0x60>
800038a4:	11 89       	ld.ub	r9,r8[0x0]
800038a6:	49 78       	lddpc	r8,80003900 <fat_cache_read_sector+0x64>
800038a8:	11 88       	ld.ub	r8,r8[0x0]
800038aa:	f0 09 18 00 	cp.b	r9,r8
800038ae:	c0 91       	brne	800038c0 <fat_cache_read_sector+0x24>
800038b0:	49 38       	lddpc	r8,800038fc <fat_cache_read_sector+0x60>
800038b2:	70 19       	ld.w	r9,r8[0x4]
800038b4:	49 48       	lddpc	r8,80003904 <fat_cache_read_sector+0x68>
800038b6:	70 08       	ld.w	r8,r8[0x0]
800038b8:	10 39       	cp.w	r9,r8
800038ba:	c0 31       	brne	800038c0 <fat_cache_read_sector+0x24>
800038bc:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      return true;
   }

   // Write previous cache before fill cache with a new sector
   if( !fat_cache_flush())
800038c0:	f0 1f 00 12 	mcall	80003908 <fat_cache_read_sector+0x6c>
800038c4:	c1 90       	breq	800038f6 <fat_cache_read_sector+0x5a>
      return false;

   // Delete informations about the caches
   fat_cache_reset();
800038c6:	f0 1f 00 12 	mcall	8000390c <fat_cache_read_sector+0x70>

   // Init sector cache
   fs_g_sectorcache.u32_addr = fs_gu32_addrsector;
800038ca:	48 f8       	lddpc	r8,80003904 <fat_cache_read_sector+0x68>
800038cc:	70 0b       	ld.w	r11,r8[0x0]
800038ce:	48 c8       	lddpc	r8,800038fc <fat_cache_read_sector+0x60>
800038d0:	91 1b       	st.w	r8[0x4],r11
   if( b_load )
800038d2:	58 07       	cp.w	r7,0
800038d4:	c0 c0       	breq	800038ec <fat_cache_read_sector+0x50>
   {
      // Load the sector from memory
      if( CTRL_GOOD != memory_2_ram( fs_g_nav.u8_lun  , fs_g_sectorcache.u32_addr, fs_g_sector))
800038d6:	48 fa       	lddpc	r10,80003910 <fat_cache_read_sector+0x74>
800038d8:	48 a8       	lddpc	r8,80003900 <fat_cache_read_sector+0x64>
800038da:	11 8c       	ld.ub	r12,r8[0x0]
800038dc:	f0 1f 00 0e 	mcall	80003914 <fat_cache_read_sector+0x78>
800038e0:	c0 60       	breq	800038ec <fat_cache_read_sector+0x50>
      {
         fs_g_status = FS_ERR_HW;
800038e2:	30 19       	mov	r9,1
800038e4:	48 d8       	lddpc	r8,80003918 <fat_cache_read_sector+0x7c>
800038e6:	b0 89       	st.b	r8[0x0],r9
800038e8:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
         return false;
      }
   }
   // Valid sector cache
   fs_g_sectorcache.u8_lun = fs_g_nav.u8_lun;
800038ec:	48 58       	lddpc	r8,80003900 <fat_cache_read_sector+0x64>
800038ee:	11 89       	ld.ub	r9,r8[0x0]
800038f0:	48 38       	lddpc	r8,800038fc <fat_cache_read_sector+0x60>
800038f2:	b0 89       	st.b	r8[0x0],r9
800038f4:	30 1c       	mov	r12,1
   return true;
}
800038f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800038fa:	00 00       	add	r0,r0
800038fc:	00 00       	add	r0,r0
800038fe:	0c bc       	st.h	r6++,r12
80003900:	00 00       	add	r0,r0
80003902:	0c 34       	cp.w	r4,r6
80003904:	00 00       	add	r0,r0
80003906:	09 f0       	ld.ub	r0,r4[0x7]
80003908:	80 00       	ld.sh	r0,r0[0x0]
8000390a:	38 30       	mov	r0,-125
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	36 64       	mov	r4,102
80003910:	00 00       	add	r0,r0
80003912:	0a 34       	cp.w	r4,r5
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	43 48       	lddsp	r8,sp[0xd0]
80003918:	00 00       	add	r0,r0
8000391a:	0c 84       	andn	r4,r6

8000391c <fat_cluster_readnext>:
//!   fs_g_u16_pos_fat        read cluster position in FAT
//!   fs_g_cluster.u32_val    value of cluster read
//! @endverbatim
//!
bool  fat_cluster_readnext( void )
{
8000391c:	d4 01       	pushm	lr
   // Compute the next cluster position in FAT
   if ( Is_fat32 )
8000391e:	49 f8       	lddpc	r8,80003998 <fat_cluster_readnext+0x7c>
80003920:	11 89       	ld.ub	r9,r8[0x0]
80003922:	30 38       	mov	r8,3
80003924:	f0 09 18 00 	cp.b	r9,r8
80003928:	c0 61       	brne	80003934 <fat_cluster_readnext+0x18>
   {
      fs_g_u16_pos_fat += 4;
8000392a:	49 d8       	lddpc	r8,8000399c <fat_cluster_readnext+0x80>
8000392c:	90 09       	ld.sh	r9,r8[0x0]
8000392e:	2f c9       	sub	r9,-4
80003930:	b0 09       	st.h	r8[0x0],r9
80003932:	c0 58       	rjmp	8000393c <fat_cluster_readnext+0x20>
   }else{
      // Is_fat16
      fs_g_u16_pos_fat += 2;
80003934:	49 a8       	lddpc	r8,8000399c <fat_cluster_readnext+0x80>
80003936:	90 09       	ld.sh	r9,r8[0x0]
80003938:	2f e9       	sub	r9,-2
8000393a:	b0 09       	st.h	r8[0x0],r9
   }

   // Check if next cluster is in internal cache
   if( FS_CACHE_SIZE == fs_g_u16_pos_fat )
8000393c:	49 88       	lddpc	r8,8000399c <fat_cluster_readnext+0x80>
8000393e:	90 09       	ld.sh	r9,r8[0x0]
80003940:	e0 68 02 00 	mov	r8,512
80003944:	f0 09 19 00 	cp.h	r9,r8
80003948:	c0 c1       	brne	80003960 <fat_cluster_readnext+0x44>
   {
      // Update cache
      fs_g_u16_pos_fat = 0;
8000394a:	30 09       	mov	r9,0
8000394c:	49 48       	lddpc	r8,8000399c <fat_cluster_readnext+0x80>
8000394e:	b0 09       	st.h	r8[0x0],r9
      fs_gu32_addrsector++;
80003950:	49 48       	lddpc	r8,800039a0 <fat_cluster_readnext+0x84>
80003952:	70 09       	ld.w	r9,r8[0x0]
80003954:	2f f9       	sub	r9,-1
80003956:	91 09       	st.w	r8[0x0],r9
      if( !fat_cache_read_sector( true ))
80003958:	30 1c       	mov	r12,1
8000395a:	f0 1f 00 13 	mcall	800039a4 <fat_cluster_readnext+0x88>
8000395e:	c1 b0       	breq	80003994 <fat_cluster_readnext+0x78>
         return false;
   }

   //**** Read the cluster value
   LSB0( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+0];  // FAT 16,32
80003960:	49 28       	lddpc	r8,800039a8 <fat_cluster_readnext+0x8c>
80003962:	2f c8       	sub	r8,-4
80003964:	48 e9       	lddpc	r9,8000399c <fat_cluster_readnext+0x80>
80003966:	92 89       	ld.uh	r9,r9[0x0]
80003968:	49 1a       	lddpc	r10,800039ac <fat_cluster_readnext+0x90>
8000396a:	f4 09 07 0b 	ld.ub	r11,r10[r9]
8000396e:	b0 bb       	st.b	r8[0x3],r11
   LSB1( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+1];  // FAT 16,32
80003970:	12 0a       	add	r10,r9
80003972:	15 9a       	ld.ub	r10,r10[0x1]
80003974:	b0 aa       	st.b	r8[0x2],r10

   if ( Is_fat32 )
80003976:	48 9a       	lddpc	r10,80003998 <fat_cluster_readnext+0x7c>
80003978:	15 8b       	ld.ub	r11,r10[0x0]
8000397a:	30 3a       	mov	r10,3
8000397c:	f4 0b 18 00 	cp.b	r11,r10
80003980:	c0 20       	breq	80003984 <fat_cluster_readnext+0x68>
80003982:	da 0a       	popm	pc,r12=1
   {  // FAT 32
      LSB2( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+2];
80003984:	48 aa       	lddpc	r10,800039ac <fat_cluster_readnext+0x90>
80003986:	f4 09 00 09 	add	r9,r10,r9
8000398a:	13 aa       	ld.ub	r10,r9[0x2]
8000398c:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_cluster.u32_val ) = fs_g_sector[fs_g_u16_pos_fat+3];
8000398e:	13 b9       	ld.ub	r9,r9[0x3]
80003990:	b0 89       	st.b	r8[0x0],r9
80003992:	30 1c       	mov	r12,1
   }
   return true;
}
80003994:	d8 02       	popm	pc
80003996:	00 00       	add	r0,r0
80003998:	00 00       	add	r0,r0
8000399a:	0c 80       	andn	r0,r6
8000399c:	00 00       	add	r0,r0
8000399e:	0a 04       	add	r4,r5
800039a0:	00 00       	add	r0,r0
800039a2:	09 f0       	ld.ub	r0,r4[0x7]
800039a4:	80 00       	ld.sh	r0,r0[0x0]
800039a6:	38 9c       	mov	r12,-119
800039a8:	00 00       	add	r0,r0
800039aa:	0c d4       	st.w	--r6,r4
800039ac:	00 00       	add	r0,r0
800039ae:	0a 34       	cp.w	r4,r5

800039b0 <fat_cluster_val>:
//!   fs_g_u16_pos_fat        position in FAT of the cluster to read or write
//!                           value init in case of the fat_cluster_readnext() routine is used after
//! @endverbatim
//!
bool  fat_cluster_val( bool b_mode )
{
800039b0:	d4 31       	pushm	r0-r7,lr
800039b2:	18 95       	mov	r5,r12
   _MEM_TYPE_FAST_ uint32_t   u32_offset_fat =0;
   _MEM_TYPE_FAST_ uint8_t    u8_data1, u8_data2,u8_data3,u8_data4;
   _MEM_TYPE_FAST_ PTR_CACHE u8_ptr_cluster;

   //**** Compute the cluster position in FAT (sector address & position in sector)
   if ( Is_fat32 )
800039b4:	fe f8 02 18 	ld.w	r8,pc[536]
800039b8:	11 88       	ld.ub	r8,r8[0x0]
800039ba:	30 39       	mov	r9,3
800039bc:	f2 08 18 00 	cp.b	r8,r9
800039c0:	c0 d1       	brne	800039da <fat_cluster_val+0x2a>
   {
      // FAT 32
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos * 4 / FS_CACHE_SIZE;
      // Optimization of -> u32_offset_fat = fs_g_cluster.pos / 128
      u32_offset_fat = fs_g_cluster.u32_pos >> (8-1);
800039c2:	fe fa 02 0e 	ld.w	r10,pc[526]
800039c6:	74 09       	ld.w	r9,r10[0x0]
800039c8:	a7 99       	lsr	r9,0x7

      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 4) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 128) * 4
      fs_g_u16_pos_fat = ((uint16_t)(LSB0(fs_g_cluster.u32_pos) & 0x7F))<< 2;
800039ca:	15 bb       	ld.ub	r11,r10[0x3]
800039cc:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800039d0:	a3 6b       	lsl	r11,0x2
800039d2:	fe fa 02 02 	ld.w	r10,pc[514]
800039d6:	b4 0b       	st.h	r10[0x0],r11
800039d8:	c2 08       	rjmp	80003a18 <fat_cluster_val+0x68>
   }
   else if ( Is_fat16 )
800039da:	30 29       	mov	r9,2
800039dc:	f2 08 18 00 	cp.b	r8,r9
800039e0:	c0 81       	brne	800039f0 <fat_cluster_val+0x40>
   {
      // FAT 16
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos * 2 / FS_CACHE_SIZE = fs_g_cluster.u32_pos / 256;
      u32_offset_fat = LSB1(fs_g_cluster.u32_pos);
800039e2:	4f ca       	lddpc	r10,80003bd0 <fat_cluster_val+0x220>
800039e4:	15 a9       	ld.ub	r9,r10[0x2]
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos * 2) % FS_CACHE_SIZE;
      // Optimization of -> fs_g_u16_pos_fat = (fs_g_cluster.u32_pos % 256) * 2
      fs_g_u16_pos_fat = ((uint16_t)LSB0(fs_g_cluster.u32_pos)) <<1;
800039e6:	15 bb       	ld.ub	r11,r10[0x3]
800039e8:	a1 7b       	lsl	r11,0x1
800039ea:	4f ba       	lddpc	r10,80003bd4 <fat_cluster_val+0x224>
800039ec:	b4 0b       	st.h	r10[0x0],r11
800039ee:	c1 58       	rjmp	80003a18 <fat_cluster_val+0x68>
   }
   else if ( Is_fat12 )
800039f0:	30 19       	mov	r9,1
800039f2:	f2 08 18 00 	cp.b	r8,r9
800039f6:	c0 30       	breq	800039fc <fat_cluster_val+0x4c>
800039f8:	30 09       	mov	r9,0
800039fa:	c0 f8       	rjmp	80003a18 <fat_cluster_val+0x68>
   {
      // FAT 12
      // Optimization of -> fs_g_u16_pos_fat = fs_g_cluster.u32_pos + (fs_g_cluster.u32_pos/ 2)
      fs_g_u16_pos_fat = (uint16_t)fs_g_cluster.u32_pos + ((uint16_t)fs_g_cluster.u32_pos >>1);
800039fc:	4f 59       	lddpc	r9,80003bd0 <fat_cluster_val+0x220>
800039fe:	72 09       	ld.w	r9,r9[0x0]
80003a00:	4f 5a       	lddpc	r10,80003bd4 <fat_cluster_val+0x224>
80003a02:	f7 d9 c0 2f 	bfextu	r11,r9,0x1,0xf
80003a06:	12 0b       	add	r11,r9
80003a08:	b4 0b       	st.h	r10[0x0],r11
      // Optimization of -> u32_offset_fat = fs_g_cluster.u32_pos / FS_CACHE_SIZE
      u32_offset_fat = MSB(fs_g_u16_pos_fat) >> 1;
80003a0a:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
80003a0e:	f6 09 16 01 	lsr	r9,r11,0x1
      // Optimization of -> fs_g_u16_pos_fat = fs_g_u16_pos_fat % FS_CACHE_SIZE
      MSB( fs_g_u16_pos_fat ) &= 0x01;
80003a12:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
80003a16:	b4 8b       	st.b	r10[0x0],r11
   }

#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
   if (b_mode)
80003a18:	58 05       	cp.w	r5,0
80003a1a:	c2 20       	breq	80003a5e <fat_cluster_val+0xae>
   {
      // Update information about FAT modification
      if( fs_g_u32_first_mod_fat > u32_offset_fat )
80003a1c:	4e fa       	lddpc	r10,80003bd8 <fat_cluster_val+0x228>
80003a1e:	74 0a       	ld.w	r10,r10[0x0]
80003a20:	14 39       	cp.w	r9,r10
80003a22:	c0 32       	brcc	80003a28 <fat_cluster_val+0x78>
      {
         fs_g_u32_first_mod_fat = u32_offset_fat;
80003a24:	4e da       	lddpc	r10,80003bd8 <fat_cluster_val+0x228>
80003a26:	95 09       	st.w	r10[0x0],r9
      }
      if( fs_g_u32_last_mod_fat < u32_offset_fat )
80003a28:	4e da       	lddpc	r10,80003bdc <fat_cluster_val+0x22c>
80003a2a:	74 0a       	ld.w	r10,r10[0x0]
80003a2c:	14 39       	cp.w	r9,r10
80003a2e:	e0 88 00 04 	brls	80003a36 <fat_cluster_val+0x86>
      {
         fs_g_u32_last_mod_fat = u32_offset_fat;
80003a32:	4e ba       	lddpc	r10,80003bdc <fat_cluster_val+0x22c>
80003a34:	95 09       	st.w	r10[0x0],r9
      }
      if ( Is_fat12 )
80003a36:	30 1a       	mov	r10,1
80003a38:	f4 08 18 00 	cp.b	r8,r10
80003a3c:	c1 11       	brne	80003a5e <fat_cluster_val+0xae>
      {  // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80003a3e:	4e 68       	lddpc	r8,80003bd4 <fat_cluster_val+0x224>
80003a40:	90 0a       	ld.sh	r10,r8[0x0]
80003a42:	e0 68 01 ff 	mov	r8,511
80003a46:	f0 0a 19 00 	cp.h	r10,r8
80003a4a:	c0 a1       	brne	80003a5e <fat_cluster_val+0xae>
         {  // Count the next FAT sector
            if( fs_g_u32_last_mod_fat < (u32_offset_fat+1) )
80003a4c:	f2 c8 ff ff 	sub	r8,r9,-1
80003a50:	4e 3a       	lddpc	r10,80003bdc <fat_cluster_val+0x22c>
80003a52:	74 0a       	ld.w	r10,r10[0x0]
80003a54:	14 38       	cp.w	r8,r10
80003a56:	e0 88 00 04 	brls	80003a5e <fat_cluster_val+0xae>
            {
               fs_g_u32_last_mod_fat = (u32_offset_fat+1);
80003a5a:	4e 1a       	lddpc	r10,80003bdc <fat_cluster_val+0x22c>
80003a5c:	95 08       	st.w	r10[0x0],r8
      }
   }
#endif  // FS_LEVEL_FEATURES

   //**** Read cluster sector in FAT
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + u32_offset_fat;   // Computed logical sector address
80003a5e:	4e 18       	lddpc	r8,80003be0 <fat_cluster_val+0x230>
80003a60:	70 48       	ld.w	r8,r8[0x10]
80003a62:	10 09       	add	r9,r8
80003a64:	4e 08       	lddpc	r8,80003be4 <fat_cluster_val+0x234>
80003a66:	91 09       	st.w	r8[0x0],r9
   if( !fat_cache_read_sector( true ))
80003a68:	30 1c       	mov	r12,1
80003a6a:	f0 1f 00 60 	mcall	80003be8 <fat_cluster_val+0x238>
80003a6e:	e0 80 00 ad 	breq	80003bc8 <fat_cluster_val+0x218>
      return false;

   // Read cluster information
   u8_ptr_cluster = &fs_g_sector[fs_g_u16_pos_fat];
80003a72:	4d 98       	lddpc	r8,80003bd4 <fat_cluster_val+0x224>
80003a74:	90 08       	ld.sh	r8,r8[0x0]
80003a76:	ed d8 c0 10 	bfextu	r6,r8,0x0,0x10
80003a7a:	4d d9       	lddpc	r9,80003bec <fat_cluster_val+0x23c>
80003a7c:	12 06       	add	r6,r9
   u8_data1 = u8_ptr_cluster[0];
80003a7e:	0c 97       	mov	r7,r6
80003a80:	0f 32       	ld.ub	r2,r7++
   // Remark: if (fs_g_u16_pos_fat+1)=512 then it isn't a mistake, because this value will be erase in next lines
   u8_data2 = u8_ptr_cluster[1];
80003a82:	0f 8b       	ld.ub	r11,r7[0x0]
   u8_data3 = u8_ptr_cluster[2];
80003a84:	ec c4 ff fe 	sub	r4,r6,-2
80003a88:	09 81       	ld.ub	r1,r4[0x0]
   u8_data4 = u8_ptr_cluster[3];
80003a8a:	ec c3 ff fd 	sub	r3,r6,-3
80003a8e:	07 80       	ld.ub	r0,r3[0x0]

   if ( Is_fat12 )
80003a90:	4c f9       	lddpc	r9,80003bcc <fat_cluster_val+0x21c>
80003a92:	13 8a       	ld.ub	r10,r9[0x0]
80003a94:	30 19       	mov	r9,1
80003a96:	f2 0a 18 00 	cp.b	r10,r9
80003a9a:	c1 11       	brne	80003abc <fat_cluster_val+0x10c>
   {   // A cluster may be stored on two sectors
      if(  fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80003a9c:	e0 69 01 ff 	mov	r9,511
80003aa0:	f2 08 19 00 	cp.h	r8,r9
80003aa4:	c0 c1       	brne	80003abc <fat_cluster_val+0x10c>
      {  // Go to next sector
         fs_gu32_addrsector++;
80003aa6:	4d 08       	lddpc	r8,80003be4 <fat_cluster_val+0x234>
80003aa8:	70 09       	ld.w	r9,r8[0x0]
80003aaa:	2f f9       	sub	r9,-1
80003aac:	91 09       	st.w	r8[0x0],r9
         if( !fat_cache_read_sector( true ))
80003aae:	30 1c       	mov	r12,1
80003ab0:	f0 1f 00 4e 	mcall	80003be8 <fat_cluster_val+0x238>
80003ab4:	e0 80 00 8a 	breq	80003bc8 <fat_cluster_val+0x218>
           return false;
         u8_data2 = fs_g_sector[0];
80003ab8:	4c d8       	lddpc	r8,80003bec <fat_cluster_val+0x23c>
80003aba:	11 8b       	ld.ub	r11,r8[0x0]
      }
   }

   if (false == b_mode)
80003abc:	58 05       	cp.w	r5,0
80003abe:	c3 11       	brne	80003b20 <fat_cluster_val+0x170>
   {
      //**** Read the cluster value
      LSB0( fs_g_cluster.u32_val ) = u8_data1;  // FAT 12,16,32
80003ac0:	4c 48       	lddpc	r8,80003bd0 <fat_cluster_val+0x220>
80003ac2:	f0 c9 ff fc 	sub	r9,r8,-4
80003ac6:	f0 cc ff f9 	sub	r12,r8,-7
80003aca:	b8 82       	st.b	r12[0x0],r2
      LSB1( fs_g_cluster.u32_val ) = u8_data2;  // FAT 12,16,32
80003acc:	2f a8       	sub	r8,-6
80003ace:	b0 8b       	st.b	r8[0x0],r11

      if ( Is_fat32 )
80003ad0:	4b fa       	lddpc	r10,80003bcc <fat_cluster_val+0x21c>
80003ad2:	15 8a       	ld.ub	r10,r10[0x0]
80003ad4:	30 3b       	mov	r11,3
80003ad6:	f6 0a 18 00 	cp.b	r10,r11
80003ada:	c0 61       	brne	80003ae6 <fat_cluster_val+0x136>
      {  // FAT 32
         LSB2( fs_g_cluster.u32_val ) = u8_data3;
80003adc:	b2 91       	st.b	r9[0x1],r1
         LSB3( fs_g_cluster.u32_val ) = u8_data4 & 0x0F; // The high 4 bits are reserved
80003ade:	e1 d0 c0 04 	bfextu	r0,r0,0x0,0x4
80003ae2:	b2 80       	st.b	r9[0x0],r0
80003ae4:	da 3a       	popm	r0-r7,pc,r12=1
      }
      else
      {  // FAT 12 & 16 don't use the high bytes
         LSB2( fs_g_cluster.u32_val ) = 0;
80003ae6:	30 0b       	mov	r11,0
80003ae8:	b2 9b       	st.b	r9[0x1],r11
         LSB3( fs_g_cluster.u32_val ) = 0;
80003aea:	b2 8b       	st.b	r9[0x0],r11

         // FAT 12 translate 16bits value to 12bits
         if ( Is_fat12 )
80003aec:	30 19       	mov	r9,1
80003aee:	f2 0a 18 00 	cp.b	r10,r9
80003af2:	c0 20       	breq	80003af6 <fat_cluster_val+0x146>
80003af4:	da 3a       	popm	r0-r7,pc,r12=1
         {
            if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80003af6:	4b 79       	lddpc	r9,80003bd0 <fat_cluster_val+0x220>
80003af8:	13 b9       	ld.ub	r9,r9[0x3]
80003afa:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80003afe:	c0 c0       	breq	80003b16 <fat_cluster_val+0x166>
            {  // Read cluster is ODD
               LSB0( fs_g_cluster.u32_val ) = (LSB1( fs_g_cluster.u32_val ) <<4 ) + (LSB0( fs_g_cluster.u32_val ) >>4 );
80003b00:	19 8b       	ld.ub	r11,r12[0x0]
80003b02:	a5 8b       	lsr	r11,0x4
80003b04:	11 89       	ld.ub	r9,r8[0x0]
80003b06:	f2 0a 15 04 	lsl	r10,r9,0x4
80003b0a:	f6 0a 00 0a 	add	r10,r11,r10
80003b0e:	b8 8a       	st.b	r12[0x0],r10
               LSB1( fs_g_cluster.u32_val ) =  LSB1( fs_g_cluster.u32_val ) >>4 ;
80003b10:	a5 89       	lsr	r9,0x4
80003b12:	b0 89       	st.b	r8[0x0],r9
80003b14:	da 3a       	popm	r0-r7,pc,r12=1
            }
            else
            {  // Read cluster is EVEN
               LSB1( fs_g_cluster.u32_val ) &= 0x0F;
80003b16:	11 89       	ld.ub	r9,r8[0x0]
80003b18:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80003b1c:	b0 89       	st.b	r8[0x0],r9
80003b1e:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
   } else {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      //**** Write the cluster value
      if ( Is_fat12 )
80003b20:	4a b8       	lddpc	r8,80003bcc <fat_cluster_val+0x21c>
80003b22:	11 88       	ld.ub	r8,r8[0x0]
80003b24:	30 19       	mov	r9,1
80003b26:	f2 08 18 00 	cp.b	r8,r9
80003b2a:	c3 a1       	brne	80003b9e <fat_cluster_val+0x1ee>
      {
         // FAT 12, translate cluster value
         if ( 0x01 & LSB0(fs_g_cluster.u32_pos) )
80003b2c:	4a 98       	lddpc	r8,80003bd0 <fat_cluster_val+0x220>
80003b2e:	11 b8       	ld.ub	r8,r8[0x3]
80003b30:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003b34:	c1 10       	breq	80003b56 <fat_cluster_val+0x1a6>
         {  // Cluster writing is ODD
            u8_data1 = (u8_data1 & 0x0F) + (LSB0( fs_g_cluster.u32_val )<<4);
80003b36:	eb d2 c0 04 	bfextu	r5,r2,0x0,0x4
80003b3a:	4a 68       	lddpc	r8,80003bd0 <fat_cluster_val+0x220>
80003b3c:	2f c8       	sub	r8,-4
80003b3e:	11 b9       	ld.ub	r9,r8[0x3]
80003b40:	f2 0a 15 04 	lsl	r10,r9,0x4
80003b44:	14 05       	add	r5,r10
80003b46:	5c 55       	castu.b	r5
            u8_data2 = (LSB1( fs_g_cluster.u32_val )<<4) + (LSB0( fs_g_cluster.u32_val )>>4) ;
80003b48:	a5 89       	lsr	r9,0x4
80003b4a:	11 a8       	ld.ub	r8,r8[0x2]
80003b4c:	a5 68       	lsl	r8,0x4
80003b4e:	f2 08 00 0a 	add	r10,r9,r8
80003b52:	5c 5a       	castu.b	r10
80003b54:	c0 c8       	rjmp	80003b6c <fat_cluster_val+0x1bc>
         } else {
            // Cluster writing is EVEN
            u8_data1 = LSB0( fs_g_cluster.u32_val );
80003b56:	49 f8       	lddpc	r8,80003bd0 <fat_cluster_val+0x220>
80003b58:	2f c8       	sub	r8,-4
80003b5a:	11 b5       	ld.ub	r5,r8[0x3]
            u8_data2 = (u8_data2 & 0xF0) + (LSB1( fs_g_cluster.u32_val ) & 0x0F) ;
80003b5c:	16 9a       	mov	r10,r11
80003b5e:	e2 1a 00 f0 	andl	r10,0xf0,COH
80003b62:	11 a8       	ld.ub	r8,r8[0x2]
80003b64:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003b68:	10 0a       	add	r10,r8
80003b6a:	5c 5a       	castu.b	r10
         }

         // A cluster may be stored on two sectors
         if( fs_g_u16_pos_fat == (FS_CACHE_SIZE-1) )
80003b6c:	49 a8       	lddpc	r8,80003bd4 <fat_cluster_val+0x224>
80003b6e:	90 09       	ld.sh	r9,r8[0x0]
80003b70:	e0 68 01 ff 	mov	r8,511
80003b74:	f0 09 19 00 	cp.h	r9,r8
80003b78:	c2 31       	brne	80003bbe <fat_cluster_val+0x20e>
         {
            fs_g_sector[0] = u8_data2;
80003b7a:	49 d8       	lddpc	r8,80003bec <fat_cluster_val+0x23c>
80003b7c:	b0 8a       	st.b	r8[0x0],r10
            fat_cache_mark_sector_as_dirty();
80003b7e:	f0 1f 00 1d 	mcall	80003bf0 <fat_cluster_val+0x240>
            // Go to previous sector
            fs_gu32_addrsector--;
80003b82:	49 98       	lddpc	r8,80003be4 <fat_cluster_val+0x234>
80003b84:	70 09       	ld.w	r9,r8[0x0]
80003b86:	20 19       	sub	r9,1
80003b88:	91 09       	st.w	r8[0x0],r9
            if( !fat_cache_read_sector( true ))
80003b8a:	30 1c       	mov	r12,1
80003b8c:	f0 1f 00 17 	mcall	80003be8 <fat_cluster_val+0x238>
80003b90:	c1 c0       	breq	80003bc8 <fat_cluster_val+0x218>
              return false;
            // Modify the previous sector
            fs_g_sector[ FS_CACHE_SIZE-1 ] = u8_data1;
80003b92:	49 78       	lddpc	r8,80003bec <fat_cluster_val+0x23c>
80003b94:	f1 65 01 ff 	st.b	r8[511],r5
            fat_cache_mark_sector_as_dirty();
80003b98:	f0 1f 00 16 	mcall	80003bf0 <fat_cluster_val+0x240>
80003b9c:	da 3a       	popm	r0-r7,pc,r12=1
         }
      }
      else
      {
         // FAT 16 & 32
         u8_data1 = LSB0( fs_g_cluster.u32_val );
80003b9e:	48 d9       	lddpc	r9,80003bd0 <fat_cluster_val+0x220>
80003ba0:	2f c9       	sub	r9,-4
80003ba2:	13 b5       	ld.ub	r5,r9[0x3]
         u8_data2 = LSB1( fs_g_cluster.u32_val );
80003ba4:	13 aa       	ld.ub	r10,r9[0x2]
         if ( Is_fat32 )
80003ba6:	30 3b       	mov	r11,3
80003ba8:	f6 08 18 00 	cp.b	r8,r11
80003bac:	c0 91       	brne	80003bbe <fat_cluster_val+0x20e>
         {  // FAT 32
            u8_ptr_cluster[2] = LSB2( fs_g_cluster.u32_val );
80003bae:	13 98       	ld.ub	r8,r9[0x1]
80003bb0:	a8 88       	st.b	r4[0x0],r8
            u8_ptr_cluster[3] = LSB3( fs_g_cluster.u32_val ) + (u8_data4 & 0xF0); // The high 4 bits are reserved
80003bb2:	e0 10 ff f0 	andl	r0,0xfff0
80003bb6:	13 88       	ld.ub	r8,r9[0x0]
80003bb8:	f0 00 00 00 	add	r0,r8,r0
80003bbc:	a6 80       	st.b	r3[0x0],r0
         }
      }
      // Here for FAT 32, 16 & 12 (only if the cluster values are in the same sector)
      u8_ptr_cluster[0] = u8_data1;
80003bbe:	ac 85       	st.b	r6[0x0],r5
      u8_ptr_cluster[1] = u8_data2;
80003bc0:	ae 8a       	st.b	r7[0x0],r10
      fat_cache_mark_sector_as_dirty();
80003bc2:	f0 1f 00 0c 	mcall	80003bf0 <fat_cluster_val+0x240>
80003bc6:	da 3a       	popm	r0-r7,pc,r12=1
80003bc8:	d8 3a       	popm	r0-r7,pc,r12=0
80003bca:	00 00       	add	r0,r0
80003bcc:	00 00       	add	r0,r0
80003bce:	0c 80       	andn	r0,r6
80003bd0:	00 00       	add	r0,r0
80003bd2:	0c d4       	st.w	--r6,r4
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a 04       	add	r4,r5
80003bd8:	00 00       	add	r0,r0
80003bda:	0c 68       	and	r8,r6
80003bdc:	00 00       	add	r0,r0
80003bde:	0a 30       	cp.w	r0,r5
80003be0:	00 00       	add	r0,r0
80003be2:	0c 34       	cp.w	r4,r6
80003be4:	00 00       	add	r0,r0
80003be6:	09 f0       	ld.ub	r0,r4[0x7]
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	38 9c       	mov	r12,-119
80003bec:	00 00       	add	r0,r0
80003bee:	0a 34       	cp.w	r4,r5
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	36 7c       	mov	r12,103

80003bf4 <fat_cluster_list>:
//!   fs_g_seg.u32_addr          The memory segment address corresponding at the beginning of cluster list (only for action FS_CLUST_ACT_SEG & FS_CLUST_ACT_ONE)
//!   fs_g_seg.u32_size_or_pos   The memory segment size corresponding at cluster list read or cleared (unit 512B)
//! @endverbatim
//!
bool  fat_cluster_list( uint8_t opt_action, bool b_for_file )
{
80003bf4:	d4 31       	pushm	r0-r7,lr
80003bf6:	20 2d       	sub	sp,8
80003bf8:	18 93       	mov	r3,r12
80003bfa:	16 97       	mov	r7,r11
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error
80003bfc:	30 89       	mov	r9,8
80003bfe:	fe f8 02 8e 	ld.w	r8,pc[654]
80003c02:	b0 89       	st.b	r8[0x0],r9

   if(  Is_fat32
   &&  (FS_CLUST_ACT_CLR == opt_action) )
80003c04:	30 38       	mov	r8,3
80003c06:	f0 0c 18 00 	cp.b	r12,r8
80003c0a:	5f 0a       	sreq	r10
80003c0c:	50 0a       	stdsp	sp[0x0],r10
   _MEM_TYPE_FAST_ uint32_t u32_tmp;
   _MEM_TYPE_FAST_ uint8_t u8_cluster_status;

   fs_g_status = FS_ERR_FS;      // By default system error

   if(  Is_fat32
80003c0e:	fe f9 02 82 	ld.w	r9,pc[642]
80003c12:	13 89       	ld.ub	r9,r9[0x0]
80003c14:	f0 09 18 00 	cp.b	r9,r8
80003c18:	5f 08       	sreq	r8
80003c1a:	f5 e8 00 08 	and	r8,r10,r8
80003c1e:	c0 60       	breq	80003c2a <fat_cluster_list+0x36>
   &&  (FS_CLUST_ACT_CLR == opt_action) )
   {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET) )
      // Clear free space information storage in FAT32
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
80003c20:	3f fc       	mov	r12,-1
80003c22:	f0 1f 00 9d 	mcall	80003e94 <fat_cluster_list+0x2a0>
80003c26:	e0 80 01 2f 	breq	80003e84 <fat_cluster_list+0x290>
#else
      return false;
#endif
   }

   if ( 0 == fs_g_seg.u32_addr )
80003c2a:	fe f8 02 6e 	ld.w	r8,pc[622]
80003c2e:	70 08       	ld.w	r8,r8[0x0]
80003c30:	58 08       	cp.w	r8,0
80003c32:	c3 b1       	brne	80003ca8 <fat_cluster_list+0xb4>
   {
      // Cluster list of root directory
      if( FS_CLUST_ACT_CLR == opt_action )
80003c34:	40 09       	lddsp	r9,sp[0x0]
80003c36:	58 09       	cp.w	r9,0
80003c38:	e0 81 01 26 	brne	80003e84 <fat_cluster_list+0x290>
         return false;           // Impossible to erase ROOT DIR

      if ( Is_fat12 || Is_fat16 )
80003c3c:	fe f8 02 54 	ld.w	r8,pc[596]
80003c40:	11 88       	ld.ub	r8,r8[0x0]
80003c42:	f0 ca 00 01 	sub	r10,r8,1
80003c46:	30 19       	mov	r9,1
80003c48:	f2 0a 18 00 	cp.b	r10,r9
80003c4c:	e0 8b 00 23 	brhi	80003c92 <fat_cluster_list+0x9e>
      {
         // For a FAT 12 & 16, the root dir isn't a cluster list
         // Check the position
         if ( fs_g_seg.u32_size_or_pos < fs_g_nav.rootdir.seg.u16_size )
80003c50:	fe f8 02 48 	ld.w	r8,pc[584]
80003c54:	70 18       	ld.w	r8,r8[0x4]
80003c56:	fe f9 02 46 	ld.w	r9,pc[582]
80003c5a:	f3 19 00 1a 	ld.uh	r9,r9[26]
80003c5e:	12 38       	cp.w	r8,r9
80003c60:	c1 32       	brcc	80003c86 <fat_cluster_list+0x92>
         {
            // Compute the start address and the size
            fs_g_seg.u32_addr = fs_g_nav.u32_ptr_fat + fs_g_nav.rootdir.seg.u16_pos + fs_g_seg.u32_size_or_pos;
80003c62:	fe f9 02 36 	ld.w	r9,pc[566]
80003c66:	fe fa 02 36 	ld.w	r10,pc[566]
80003c6a:	74 4b       	ld.w	r11,r10[0x10]
80003c6c:	16 08       	add	r8,r11
80003c6e:	f5 1b 00 18 	ld.uh	r11,r10[24]
80003c72:	16 08       	add	r8,r11
80003c74:	93 08       	st.w	r9[0x0],r8
            fs_g_seg.u32_size_or_pos = fs_g_nav.rootdir.seg.u16_size - fs_g_seg.u32_size_or_pos;
80003c76:	f5 1a 00 1a 	ld.uh	r10,r10[26]
80003c7a:	72 18       	ld.w	r8,r9[0x4]
80003c7c:	f4 08 01 08 	sub	r8,r10,r8
80003c80:	93 18       	st.w	r9[0x4],r8
80003c82:	30 1c       	mov	r12,1
            return true;
80003c84:	c0 19       	rjmp	80003e86 <fat_cluster_list+0x292>
         } else {
            fs_g_status = FS_ERR_OUT_LIST;
80003c86:	31 a9       	mov	r9,26
80003c88:	fe f8 02 04 	ld.w	r8,pc[516]
80003c8c:	b0 89       	st.b	r8[0x0],r9
80003c8e:	30 0c       	mov	r12,0
            return false;        // Position outside the root area
80003c90:	cf b8       	rjmp	80003e86 <fat_cluster_list+0x292>
         }
      }
      if ( Is_fat32 )
80003c92:	30 39       	mov	r9,3
80003c94:	f2 08 18 00 	cp.b	r8,r9
80003c98:	c0 a1       	brne	80003cac <fat_cluster_list+0xb8>
      {
         // For FAT 32, the root is a cluster list and the first cluster is reading during the mount
         fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
80003c9a:	fe f8 02 02 	ld.w	r8,pc[514]
80003c9e:	70 69       	ld.w	r9,r8[0x18]
80003ca0:	fe f8 02 00 	ld.w	r8,pc[512]
80003ca4:	91 09       	st.w	r8[0x0],r9
80003ca6:	c0 38       	rjmp	80003cac <fat_cluster_list+0xb8>
      }
   } else {
      // It is the first cluster of a cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
80003ca8:	4f e9       	lddpc	r9,80003ea0 <fat_cluster_list+0x2ac>
80003caa:	93 08       	st.w	r9[0x0],r8
   }

   // Management of cluster list caches
   if( FS_CLUST_ACT_CLR != opt_action )
80003cac:	30 38       	mov	r8,3
80003cae:	f0 03 18 00 	cp.b	r3,r8
80003cb2:	c0 70       	breq	80003cc0 <fat_cluster_list+0xcc>
   {
      if( fat_cache_clusterlist_update_read( b_for_file ) )
80003cb4:	0e 9c       	mov	r12,r7
80003cb6:	f0 1f 00 7c 	mcall	80003ea4 <fat_cluster_list+0x2b0>
80003cba:	c0 70       	breq	80003cc8 <fat_cluster_list+0xd4>
80003cbc:	30 1c       	mov	r12,1
80003cbe:	ce 48       	rjmp	80003e86 <fat_cluster_list+0x292>
         return true;            // Segment found in cache
      // Segment not found & cache ready to update
   }else{
      fat_cache_clusterlist_reset();   // It is a clear action then clear cluster list caches
80003cc0:	f0 1f 00 7a 	mcall	80003ea8 <fat_cluster_list+0x2b4>
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
      fat_clear_info_fat_mod();        // Init cache on fat modification range
80003cc4:	f0 1f 00 7a 	mcall	80003eac <fat_cluster_list+0x2b8>
#endif  // FS_LEVEL_FEATURES
   }

   // Init loop with a start segment no found
   MSB0( fs_g_seg.u32_addr ) = 0xFF;
80003cc8:	4f 40       	lddpc	r0,80003e98 <fat_cluster_list+0x2a4>
80003cca:	3f f8       	mov	r8,-1
80003ccc:	a0 88       	st.b	r0[0x0],r8

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
80003cce:	00 96       	mov	r6,r0
80003cd0:	4f 35       	lddpc	r5,80003e9c <fat_cluster_list+0x2a8>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80003cd2:	4f 47       	lddpc	r7,80003ea0 <fat_cluster_list+0x2ac>
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
80003cd4:	30 21       	mov	r1,2
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
            return true;
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
80003cd6:	e0 c8 ff f9 	sub	r8,r0,-7
80003cda:	50 18       	stdsp	sp[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80003cdc:	30 12       	mov	r2,1
   MSB0( fs_g_seg.u32_addr ) = 0xFF;

   //**** Loop to read the cluster list
   while ( 1 )
   {
      if ( fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus )
80003cde:	6c 19       	ld.w	r9,r6[0x4]
80003ce0:	0b 98       	ld.ub	r8,r5[0x1]
80003ce2:	10 39       	cp.w	r9,r8
80003ce4:	c4 32       	brcc	80003d6a <fat_cluster_list+0x176>
      {
         // The segment starts in this cluster
         // Compute the sector address of this cluster
         fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80003ce6:	6a 4a       	ld.w	r10,r5[0x10]
80003ce8:	14 09       	add	r9,r10
80003cea:	6a 5a       	ld.w	r10,r5[0x14]
80003cec:	14 09       	add	r9,r10
80003cee:	6e 0a       	ld.w	r10,r7[0x0]
80003cf0:	20 2a       	sub	r10,2
80003cf2:	f4 08 02 48 	mul	r8,r10,r8
80003cf6:	f2 08 00 08 	add	r8,r9,r8
80003cfa:	8d 08       	st.w	r6[0x0],r8
                           + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data + fs_g_seg.u32_size_or_pos;

         if ( FS_CLUST_ACT_ONE == opt_action )
80003cfc:	e2 03 18 00 	cp.b	r3,r1
80003d00:	c0 d1       	brne	80003d1a <fat_cluster_list+0x126>
         {
            // Compute the maximum size
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus-fs_g_seg.u32_size_or_pos;
80003d02:	4e 67       	lddpc	r7,80003e98 <fat_cluster_list+0x2a4>
80003d04:	4e 68       	lddpc	r8,80003e9c <fat_cluster_list+0x2a8>
80003d06:	11 99       	ld.ub	r9,r8[0x1]
80003d08:	6e 18       	ld.w	r8,r7[0x4]
80003d0a:	f2 08 01 08 	sub	r8,r9,r8
80003d0e:	8f 18       	st.w	r7[0x4],r8
            fat_cache_clusterlist_update_finish();
80003d10:	f0 1f 00 68 	mcall	80003eb0 <fat_cluster_list+0x2bc>
            // Send a size of one sector
            fs_g_seg.u32_size_or_pos = 1;
80003d14:	30 1c       	mov	r12,1
80003d16:	8f 1c       	st.w	r7[0x4],r12
            return true;
80003d18:	cb 78       	rjmp	80003e86 <fat_cluster_list+0x292>
         }
         // Update the segment size
         fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus - LSB0( fs_g_seg.u32_size_or_pos );
80003d1a:	0b 99       	ld.ub	r9,r5[0x1]
80003d1c:	40 1a       	lddsp	r10,sp[0x4]
80003d1e:	15 88       	ld.ub	r8,r10[0x0]
80003d20:	f2 08 01 08 	sub	r8,r9,r8
80003d24:	8d 18       	st.w	r6[0x4],r8

         // Take time, during read cluster list on FAT 16 & 32
         if( (FS_CLUST_ACT_SEG == opt_action)
80003d26:	e4 03 18 00 	cp.b	r3,r2
80003d2a:	c2 01       	brne	80003d6a <fat_cluster_list+0x176>
80003d2c:	4d 99       	lddpc	r9,80003e90 <fat_cluster_list+0x29c>
80003d2e:	13 88       	ld.ub	r8,r9[0x0]
80003d30:	e4 08 18 00 	cp.b	r8,r2
80003d34:	c1 b0       	breq	80003d6a <fat_cluster_list+0x176>
         &&  (!Is_fat12) )
         {
            // Init loop with the current cluster
            u32_tmp = fs_g_cluster.u32_pos;
80003d36:	6e 04       	ld.w	r4,r7[0x0]
            if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80003d38:	30 0c       	mov	r12,0
80003d3a:	f0 1f 00 5f 	mcall	80003eb4 <fat_cluster_list+0x2c0>
80003d3e:	e0 80 00 a3 	breq	80003e84 <fat_cluster_list+0x290>
               return false;
            // Read cluster list, while this one is continue
            while(1)
            {
               if ( (++fs_g_cluster.u32_pos) != fs_g_cluster.u32_val )
80003d42:	6e 09       	ld.w	r9,r7[0x0]
80003d44:	f2 c8 ff ff 	sub	r8,r9,-1
80003d48:	8f 08       	st.w	r7[0x0],r8
80003d4a:	6e 1a       	ld.w	r10,r7[0x4]
80003d4c:	14 38       	cp.w	r8,r10
80003d4e:	c0 a0       	breq	80003d62 <fat_cluster_list+0x16e>
               {
                  fs_g_cluster.u32_pos--;                   // Recompute previous value
80003d50:	8f 09       	st.w	r7[0x0],r9
                  u32_tmp = fs_g_cluster.u32_pos - u32_tmp; // Compute the size of cluster list
                  fs_g_seg.u32_size_or_pos += u32_tmp * fs_g_nav.u8_BPB_SecPerClus;
80003d52:	08 19       	sub	r9,r4
80003d54:	0b 98       	ld.ub	r8,r5[0x1]
80003d56:	b1 39       	mul	r9,r8
80003d58:	6c 18       	ld.w	r8,r6[0x4]
80003d5a:	f2 08 00 08 	add	r8,r9,r8
80003d5e:	8d 18       	st.w	r6[0x4],r8
                  break;
80003d60:	c0 58       	rjmp	80003d6a <fat_cluster_list+0x176>
               }
               if( !fat_cluster_readnext() )
80003d62:	f0 1f 00 56 	mcall	80003eb8 <fat_cluster_list+0x2c4>
80003d66:	ce e1       	brne	80003d42 <fat_cluster_list+0x14e>
80003d68:	c8 e8       	rjmp	80003e84 <fat_cluster_list+0x290>
                  return false;
            }
         }
      }
      // Get the cluster value
      if( !fat_cluster_val( FS_CLUST_VAL_READ ))
80003d6a:	30 0c       	mov	r12,0
80003d6c:	f0 1f 00 52 	mcall	80003eb4 <fat_cluster_list+0x2c0>
80003d70:	e0 80 00 8a 	breq	80003e84 <fat_cluster_list+0x290>
         return false;

      // Read and check the status of the new cluster
      u8_cluster_status = fat_checkcluster();
80003d74:	f0 1f 00 52 	mcall	80003ebc <fat_cluster_list+0x2c8>
80003d78:	18 94       	mov	r4,r12
      if (FS_CLUS_BAD == u8_cluster_status)
80003d7a:	e4 0c 18 00 	cp.b	r12,r2
80003d7e:	e0 80 00 83 	breq	80003e84 <fat_cluster_list+0x290>
         return false; // error, end of cluster list

      if (0xFF == MSB0(fs_g_seg.u32_addr))
80003d82:	01 89       	ld.ub	r9,r0[0x0]
80003d84:	3f f8       	mov	r8,-1
80003d86:	f0 09 18 00 	cp.b	r9,r8
80003d8a:	c4 61       	brne	80003e16 <fat_cluster_list+0x222>
      {
         // The beginning of the segment isn't found
         if (FS_CLUS_END == u8_cluster_status)
80003d8c:	e2 0c 18 00 	cp.b	r12,r1
80003d90:	c2 b1       	brne	80003de6 <fat_cluster_list+0x1f2>
         {
            u32_tmp = fs_g_seg.u32_size_or_pos;       // Save number of sector remaining
80003d92:	4c 28       	lddpc	r8,80003e98 <fat_cluster_list+0x2a4>
80003d94:	70 17       	ld.w	r7,r8[0x4]

            // Compute the sector address of this last cluster to take time during a future request with the same cluster list
            fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start -= fs_g_seg.u32_size_or_pos;
80003d96:	4c b9       	lddpc	r9,80003ec0 <fat_cluster_list+0x2cc>
80003d98:	13 89       	ld.ub	r9,r9[0x0]
80003d9a:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003d9e:	4c aa       	lddpc	r10,80003ec4 <fat_cluster_list+0x2d0>
80003da0:	f4 09 00 29 	add	r9,r10,r9<<0x2
80003da4:	72 2a       	ld.w	r10,r9[0x8]
80003da6:	0e 1a       	sub	r10,r7
80003da8:	93 2a       	st.w	r9[0x8],r10
            fs_g_seg.u32_addr = ((fs_g_cluster.u32_pos - 2) * fs_g_nav.u8_BPB_SecPerClus)
80003daa:	4b d9       	lddpc	r9,80003e9c <fat_cluster_list+0x2a8>
80003dac:	72 5b       	ld.w	r11,r9[0x14]
80003dae:	72 4a       	ld.w	r10,r9[0x10]
80003db0:	14 0b       	add	r11,r10
80003db2:	13 99       	ld.ub	r9,r9[0x1]
80003db4:	4b ba       	lddpc	r10,80003ea0 <fat_cluster_list+0x2ac>
80003db6:	74 0a       	ld.w	r10,r10[0x0]
80003db8:	20 2a       	sub	r10,2
80003dba:	f2 0a 02 4a 	mul	r10,r9,r10
80003dbe:	f6 0a 00 0a 	add	r10,r11,r10
80003dc2:	91 0a       	st.w	r8[0x0],r10
                              + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
            fs_g_seg.u32_size_or_pos = fs_g_nav.u8_BPB_SecPerClus;
80003dc4:	91 19       	st.w	r8[0x4],r9
            if (FS_CLUST_ACT_CLR != opt_action)
80003dc6:	30 38       	mov	r8,3
80003dc8:	f0 03 18 00 	cp.b	r3,r8
80003dcc:	c0 30       	breq	80003dd2 <fat_cluster_list+0x1de>
               fat_cache_clusterlist_update_finish();
80003dce:	f0 1f 00 39 	mcall	80003eb0 <fat_cluster_list+0x2bc>

            // The position is outside the cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_pos; // Send the last cluster value
80003dd2:	4b 28       	lddpc	r8,80003e98 <fat_cluster_list+0x2a4>
80003dd4:	4b 39       	lddpc	r9,80003ea0 <fat_cluster_list+0x2ac>
80003dd6:	72 09       	ld.w	r9,r9[0x0]
80003dd8:	91 09       	st.w	r8[0x0],r9
            fs_g_seg.u32_size_or_pos = u32_tmp;       // Restore number of sector remaining
80003dda:	91 17       	st.w	r8[0x4],r7
            fs_g_status = FS_ERR_OUT_LIST;
80003ddc:	31 a9       	mov	r9,26
80003dde:	4a c8       	lddpc	r8,80003e8c <fat_cluster_list+0x298>
80003de0:	b0 89       	st.b	r8[0x0],r9
80003de2:	30 0c       	mov	r12,0
            return false;
80003de4:	c5 18       	rjmp	80003e86 <fat_cluster_list+0x292>
         }
         // Good cluster then continue
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
80003de6:	0b 98       	ld.ub	r8,r5[0x1]
80003de8:	6c 19       	ld.w	r9,r6[0x4]
80003dea:	f2 08 01 08 	sub	r8,r9,r8
80003dee:	8d 18       	st.w	r6[0x4],r8
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80003df0:	40 0a       	lddsp	r10,sp[0x0]
80003df2:	58 0a       	cp.w	r10,0
80003df4:	c4 50       	breq	80003e7e <fat_cluster_list+0x28a>
         {
            if( fs_g_seg.u32_size_or_pos == 0)
80003df6:	58 08       	cp.w	r8,0
80003df8:	c4 31       	brne	80003e7e <fat_cluster_list+0x28a>
            {
               // At cluster position, set the flag end of cluster list
               fs_g_seg.u32_addr = fs_g_cluster.u32_val; // Save the next cluster
80003dfa:	6e 18       	ld.w	r8,r7[0x4]
80003dfc:	8d 08       	st.w	r6[0x0],r8
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;
80003dfe:	e0 68 ff ff 	mov	r8,65535
80003e02:	ea 18 0f ff 	orh	r8,0xfff
80003e06:	8f 18       	st.w	r7[0x4],r8
               if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80003e08:	30 1c       	mov	r12,1
80003e0a:	f0 1f 00 2b 	mcall	80003eb4 <fat_cluster_list+0x2c0>
80003e0e:	c3 b0       	breq	80003e84 <fat_cluster_list+0x290>
                  return false;
               fs_g_cluster.u32_val = fs_g_seg.u32_addr; // Restore the next cluster
80003e10:	6c 08       	ld.w	r8,r6[0x0]
80003e12:	8f 18       	st.w	r7[0x4],r8
80003e14:	c3 58       	rjmp	80003e7e <fat_cluster_list+0x28a>
#endif  // FS_LEVEL_FEATURES
      }
      else
      {
         // The beginning of segment is found
         if (FS_CLUST_ACT_SEG == opt_action)
80003e16:	e4 03 18 00 	cp.b	r3,r2
80003e1a:	c0 a1       	brne	80003e2e <fat_cluster_list+0x23a>
         {
            if ( (fs_g_cluster.u32_pos+1) != fs_g_cluster.u32_val )
80003e1c:	6e 09       	ld.w	r9,r7[0x0]
80003e1e:	2f f9       	sub	r9,-1
80003e20:	6e 18       	ld.w	r8,r7[0x4]
80003e22:	10 39       	cp.w	r9,r8
80003e24:	c1 b0       	breq	80003e5a <fat_cluster_list+0x266>
            {
               // The cluster is not a continue cluster or a invalid cluster
               fat_cache_clusterlist_update_finish();
80003e26:	f0 1f 00 23 	mcall	80003eb0 <fat_cluster_list+0x2bc>
80003e2a:	30 1c       	mov	r12,1
               return true;                              // End of segment
80003e2c:	c2 d8       	rjmp	80003e86 <fat_cluster_list+0x292>
            }
         }
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
         if (FS_CLUST_ACT_CLR == opt_action)
80003e2e:	40 09       	lddsp	r9,sp[0x0]
80003e30:	58 09       	cp.w	r9,0
80003e32:	c1 40       	breq	80003e5a <fat_cluster_list+0x266>
         {
            //** Clear cluster position
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // Save the next cluster
80003e34:	6e 18       	ld.w	r8,r7[0x4]
80003e36:	8d 08       	st.w	r6[0x0],r8
            fs_g_cluster.u32_val = 0;                    // by default free cluster
80003e38:	30 08       	mov	r8,0
80003e3a:	8f 18       	st.w	r7[0x4],r8
            // If it is the first cluster (fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus)
            // and doesn't start at the beginning of cluster (fs_g_seg.u32_size_or_pos != fs_g_nav.u8_BPB_SecPerClus)
            if (fs_g_seg.u32_size_or_pos < fs_g_nav.u8_BPB_SecPerClus)
80003e3c:	0b 98       	ld.ub	r8,r5[0x1]
80003e3e:	6c 19       	ld.w	r9,r6[0x4]
80003e40:	10 39       	cp.w	r9,r8
80003e42:	c0 62       	brcc	80003e4e <fat_cluster_list+0x25a>
            {
               fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;  // End of cluster list allocated
80003e44:	e0 68 ff ff 	mov	r8,65535
80003e48:	ea 18 0f ff 	orh	r8,0xfff
80003e4c:	8f 18       	st.w	r7[0x4],r8
            }
            if( !fat_cluster_val( FS_CLUST_VAL_WRITE ))
80003e4e:	30 1c       	mov	r12,1
80003e50:	f0 1f 00 19 	mcall	80003eb4 <fat_cluster_list+0x2c0>
80003e54:	c1 80       	breq	80003e84 <fat_cluster_list+0x290>
               return false;
            fs_g_cluster.u32_val = fs_g_seg.u32_addr;    // Restore the next cluster
80003e56:	6c 08       	ld.w	r8,r6[0x0]
80003e58:	8f 18       	st.w	r7[0x4],r8
            // !!!! because it isn't possible that MSB0( fs_g_cluster.val ) = 0xFF.
         }
#endif  // FS_LEVEL_FEATURES

         // Check the end of cluster list
         if (FS_CLUS_END == u8_cluster_status)
80003e5a:	e2 04 18 00 	cp.b	r4,r1
80003e5e:	c0 b1       	brne	80003e74 <fat_cluster_list+0x280>
         {
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
            if (FS_CLUST_ACT_CLR == opt_action)
80003e60:	40 0a       	lddsp	r10,sp[0x0]
80003e62:	58 0a       	cp.w	r10,0
80003e64:	c0 40       	breq	80003e6c <fat_cluster_list+0x278>
            {
               return fat_update_fat2();
80003e66:	f0 1f 00 19 	mcall	80003ec8 <fat_cluster_list+0x2d4>
80003e6a:	c0 e8       	rjmp	80003e86 <fat_cluster_list+0x292>
            }
#endif  // FS_LEVEL_FEATURES
            fat_cache_clusterlist_update_finish();
80003e6c:	f0 1f 00 11 	mcall	80003eb0 <fat_cluster_list+0x2bc>
80003e70:	30 1c       	mov	r12,1
            return true; // End of segment
80003e72:	c0 a8       	rjmp	80003e86 <fat_cluster_list+0x292>
         }

         // Update the segment size
         fs_g_seg.u32_size_or_pos += fs_g_nav.u8_BPB_SecPerClus;
80003e74:	0b 99       	ld.ub	r9,r5[0x1]
80003e76:	6c 18       	ld.w	r8,r6[0x4]
80003e78:	f2 08 00 08 	add	r8,r9,r8
80003e7c:	8d 18       	st.w	r6[0x4],r8
      }
      // HERE, Continue to read the cluster list
      // The next cluster is the value of previous cluster
      fs_g_cluster.u32_pos = fs_g_cluster.u32_val;
80003e7e:	6e 18       	ld.w	r8,r7[0x4]
80003e80:	8f 08       	st.w	r7[0x0],r8
   }  // End of main loop
80003e82:	c2 eb       	rjmp	80003cde <fat_cluster_list+0xea>
80003e84:	30 0c       	mov	r12,0
}
80003e86:	2f ed       	sub	sp,-8
80003e88:	d8 32       	popm	r0-r7,pc
80003e8a:	00 00       	add	r0,r0
80003e8c:	00 00       	add	r0,r0
80003e8e:	0c 84       	andn	r4,r6
80003e90:	00 00       	add	r0,r0
80003e92:	0c 80       	andn	r0,r6
80003e94:	80 00       	ld.sh	r0,r0[0x0]
80003e96:	47 74       	lddsp	r4,sp[0x1dc]
80003e98:	00 00       	add	r0,r0
80003e9a:	0c dc       	st.w	--r6,r12
80003e9c:	00 00       	add	r0,r0
80003e9e:	0c 34       	cp.w	r4,r6
80003ea0:	00 00       	add	r0,r0
80003ea2:	0c d4       	st.w	--r6,r4
80003ea4:	80 00       	ld.sh	r0,r0[0x0]
80003ea6:	31 6c       	mov	r12,22
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	30 3c       	mov	r12,3
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	43 d0       	lddsp	r0,sp[0xf4]
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	31 14       	mov	r4,17
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	39 b0       	mov	r0,-101
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	39 1c       	mov	r12,-111
80003ebc:	80 00       	ld.sh	r0,r0[0x0]
80003ebe:	2f dc       	sub	r12,-3
80003ec0:	00 00       	add	r0,r0
80003ec2:	0c 86       	andn	r6,r6
80003ec4:	00 00       	add	r0,r0
80003ec6:	0a 08       	add	r8,r5
80003ec8:	80 00       	ld.sh	r0,r0[0x0]
80003eca:	44 5c       	lddsp	r12,sp[0x114]

80003ecc <fat_read_dir>:
//!   fs_g_nav.u32_cluster_sel_dir           First cluster of current directory
//!   fs_g_nav_fast.u16_entry_pos_sel_file   Position in directory (unit entry)
//! @endverbatim
//!
bool  fat_read_dir( void )
{
80003ecc:	eb cd 40 80 	pushm	r7,lr
   uint32_t u32_cluster_pos;

   // Compute the cluster list position corresponding of the current entry
   u32_cluster_pos = fs_g_nav_fast.u16_entry_pos_sel_file >> (FS_512B_SHIFT_BIT - FS_SHIFT_B_TO_FILE_ENTRY);
80003ed0:	49 98       	lddpc	r8,80003f34 <fat_read_dir+0x68>
80003ed2:	90 97       	ld.uh	r7,r8[0x2]
80003ed4:	a5 87       	lsr	r7,0x4

   if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80003ed6:	49 98       	lddpc	r8,80003f38 <fat_read_dir+0x6c>
80003ed8:	11 89       	ld.ub	r9,r8[0x0]
80003eda:	49 98       	lddpc	r8,80003f3c <fat_read_dir+0x70>
80003edc:	11 88       	ld.ub	r8,r8[0x0]
80003ede:	f0 09 18 00 	cp.b	r9,r8
80003ee2:	c0 d1       	brne	80003efc <fat_read_dir+0x30>
80003ee4:	49 58       	lddpc	r8,80003f38 <fat_read_dir+0x6c>
80003ee6:	70 39       	ld.w	r9,r8[0xc]
80003ee8:	49 58       	lddpc	r8,80003f3c <fat_read_dir+0x70>
80003eea:	70 88       	ld.w	r8,r8[0x20]
80003eec:	10 39       	cp.w	r9,r8
80003eee:	c0 71       	brne	80003efc <fat_read_dir+0x30>
80003ef0:	49 28       	lddpc	r8,80003f38 <fat_read_dir+0x6c>
80003ef2:	70 48       	ld.w	r8,r8[0x10]
80003ef4:	0e 38       	cp.w	r8,r7
80003ef6:	c0 31       	brne	80003efc <fat_read_dir+0x30>
80003ef8:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
         return true;      // The internal cache contains the sector asked
   }

   // Get sector address corresponding at cluster list position
   fs_g_seg.u32_addr = fs_g_nav.u32_cluster_sel_dir;
80003efc:	49 18       	lddpc	r8,80003f40 <fat_read_dir+0x74>
80003efe:	49 09       	lddpc	r9,80003f3c <fat_read_dir+0x70>
80003f00:	72 89       	ld.w	r9,r9[0x20]
80003f02:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_cluster_pos;
80003f04:	91 17       	st.w	r8[0x4],r7
   if( fat_cluster_list( FS_CLUST_ACT_ONE, false ) )
80003f06:	30 0b       	mov	r11,0
80003f08:	30 2c       	mov	r12,2
80003f0a:	f0 1f 00 0f 	mcall	80003f44 <fat_read_dir+0x78>
80003f0e:	c1 00       	breq	80003f2e <fat_read_dir+0x62>
   {
      // Read the sector
      fs_gu32_addrsector = fs_g_seg.u32_addr;
80003f10:	48 c8       	lddpc	r8,80003f40 <fat_read_dir+0x74>
80003f12:	70 09       	ld.w	r9,r8[0x0]
80003f14:	48 d8       	lddpc	r8,80003f48 <fat_read_dir+0x7c>
80003f16:	91 09       	st.w	r8[0x0],r9
      if( fat_cache_read_sector( true ) )
80003f18:	30 1c       	mov	r12,1
80003f1a:	f0 1f 00 0d 	mcall	80003f4c <fat_read_dir+0x80>
80003f1e:	c0 80       	breq	80003f2e <fat_read_dir+0x62>
      {
         // Update information about internal sector cache
         fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav.u32_cluster_sel_dir;
80003f20:	48 68       	lddpc	r8,80003f38 <fat_read_dir+0x6c>
80003f22:	48 79       	lddpc	r9,80003f3c <fat_read_dir+0x70>
80003f24:	72 89       	ld.w	r9,r9[0x20]
80003f26:	91 39       	st.w	r8[0xc],r9
         fs_g_sectorcache.u32_clusterlist_pos    = u32_cluster_pos;
80003f28:	91 47       	st.w	r8[0x10],r7
80003f2a:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
         return true;
80003f2e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80003f32:	00 00       	add	r0,r0
80003f34:	00 00       	add	r0,r0
80003f36:	0c 80       	andn	r0,r6
80003f38:	00 00       	add	r0,r0
80003f3a:	0c bc       	st.h	r6++,r12
80003f3c:	00 00       	add	r0,r0
80003f3e:	0c 34       	cp.w	r4,r6
80003f40:	00 00       	add	r0,r0
80003f42:	0c dc       	st.w	--r6,r12
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	3b f4       	mov	r4,-65
80003f48:	00 00       	add	r0,r0
80003f4a:	09 f0       	ld.ub	r0,r4[0x7]
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	38 9c       	mov	r12,-119

80003f50 <fat_read_file>:
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
{
80003f50:	eb cd 40 c0 	pushm	r6-r7,lr
80003f54:	18 97       	mov	r7,r12
   uint32_t   u32_sector_pos;

   // Compute sector position
   u32_sector_pos = fs_g_nav_entry.u32_pos_in_file >> FS_512B_SHIFT_BIT;
80003f56:	4a e8       	lddpc	r8,8000400c <fat_read_file+0xbc>
80003f58:	70 38       	ld.w	r8,r8[0xc]
80003f5a:	f0 06 16 09 	lsr	r6,r8,0x9

   if(FS_CLUST_ACT_ONE  == mode)
80003f5e:	30 29       	mov	r9,2
80003f60:	f2 0c 18 00 	cp.b	r12,r9
80003f64:	c1 31       	brne	80003f8a <fat_read_file+0x3a>
   {
      if( (fs_g_sectorcache.u8_lun                 == fs_g_nav.u8_lun )
80003f66:	4a b8       	lddpc	r8,80004010 <fat_read_file+0xc0>
80003f68:	11 89       	ld.ub	r9,r8[0x0]
80003f6a:	4a b8       	lddpc	r8,80004014 <fat_read_file+0xc4>
80003f6c:	11 88       	ld.ub	r8,r8[0x0]
80003f6e:	f0 09 18 00 	cp.b	r9,r8
80003f72:	c1 91       	brne	80003fa4 <fat_read_file+0x54>
80003f74:	4a 78       	lddpc	r8,80004010 <fat_read_file+0xc0>
80003f76:	70 39       	ld.w	r9,r8[0xc]
80003f78:	4a 58       	lddpc	r8,8000400c <fat_read_file+0xbc>
80003f7a:	70 18       	ld.w	r8,r8[0x4]
80003f7c:	10 39       	cp.w	r9,r8
80003f7e:	c1 31       	brne	80003fa4 <fat_read_file+0x54>
80003f80:	4a 48       	lddpc	r8,80004010 <fat_read_file+0xc0>
80003f82:	70 48       	ld.w	r8,r8[0x10]
80003f84:	0c 38       	cp.w	r8,r6
80003f86:	c0 f1       	brne	80003fa4 <fat_read_file+0x54>
80003f88:	c3 38       	rjmp	80003fee <fat_read_file+0x9e>
         return true;      // The internal cache contains the sector requested
      }
   }
   else
   {
      if( FS_CLUST_ACT_CLR == mode )
80003f8a:	30 39       	mov	r9,3
80003f8c:	f2 0c 18 00 	cp.b	r12,r9
80003f90:	c3 31       	brne	80003ff6 <fat_read_file+0xa6>
      {
         // Clear cluster list
         if( 0 == fs_g_nav_entry.u32_cluster )
80003f92:	49 f9       	lddpc	r9,8000400c <fat_read_file+0xbc>
80003f94:	72 19       	ld.w	r9,r9[0x4]
80003f96:	58 09       	cp.w	r9,0
80003f98:	c2 b0       	breq	80003fee <fat_read_file+0x9e>
            return true;   // No cluster list is linked with the file, then no clear is necessary

         if(0 != (fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK) )
80003f9a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80003f9e:	c2 c0       	breq	80003ff6 <fat_read_file+0xa6>
         {
            // The actual sector is used, then start clear on the next sector
            u32_sector_pos++;
80003fa0:	2f f6       	sub	r6,-1
80003fa2:	c2 a8       	rjmp	80003ff6 <fat_read_file+0xa6>
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
80003fa4:	49 d8       	lddpc	r8,80004018 <fat_read_file+0xc8>
80003fa6:	49 a9       	lddpc	r9,8000400c <fat_read_file+0xbc>
80003fa8:	72 19       	ld.w	r9,r9[0x4]
80003faa:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
80003fac:	91 16       	st.w	r8[0x4],r6
      if( fat_cluster_list( mode, true ) )
         return true;      // Get or clear segment OK
   }
   else
   {
      if( fat_cluster_list( FS_CLUST_ACT_SEG, true ) )   // Read all segment
80003fae:	30 1b       	mov	r11,1
80003fb0:	16 9c       	mov	r12,r11
80003fb2:	f0 1f 00 1b 	mcall	8000401c <fat_read_file+0xcc>
80003fb6:	c1 e0       	breq	80003ff2 <fat_read_file+0xa2>
      {
         // Read the sector corresponding at the position file (= first sector of segment)
         fs_gu32_addrsector = fs_g_seg.u32_addr ;
80003fb8:	49 88       	lddpc	r8,80004018 <fat_read_file+0xc8>
80003fba:	70 09       	ld.w	r9,r8[0x0]
80003fbc:	49 98       	lddpc	r8,80004020 <fat_read_file+0xd0>
80003fbe:	91 09       	st.w	r8[0x0],r9
         if( fat_cache_read_sector( true ) )
80003fc0:	30 1c       	mov	r12,1
80003fc2:	f0 1f 00 19 	mcall	80004024 <fat_read_file+0xd4>
80003fc6:	c1 60       	breq	80003ff2 <fat_read_file+0xa2>
         {
            fs_g_sectorcache.u32_clusterlist_start  = fs_g_nav_entry.u32_cluster;
80003fc8:	49 28       	lddpc	r8,80004010 <fat_read_file+0xc0>
80003fca:	49 19       	lddpc	r9,8000400c <fat_read_file+0xbc>
80003fcc:	72 19       	ld.w	r9,r9[0x4]
80003fce:	91 39       	st.w	r8[0xc],r9
            fs_g_sectorcache.u32_clusterlist_pos    = u32_sector_pos;
80003fd0:	91 46       	st.w	r8[0x10],r6
80003fd2:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
            return true;
         }
      }
   }
   if( (FS_CLUST_ACT_CLR == mode       )
80003fd6:	30 38       	mov	r8,3
80003fd8:	f0 07 18 00 	cp.b	r7,r8
80003fdc:	c0 b1       	brne	80003ff2 <fat_read_file+0xa2>
//! IN :
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in file (unit byte)
//! @endverbatim
//!
bool  fat_read_file( uint8_t mode )
80003fde:	49 38       	lddpc	r8,80004028 <fat_read_file+0xd8>
80003fe0:	11 89       	ld.ub	r9,r8[0x0]
80003fe2:	31 a8       	mov	r8,26
80003fe4:	f0 09 18 00 	cp.b	r9,r8
80003fe8:	5f 0c       	sreq	r12
80003fea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003fee:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003ff2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         }
      }
   }

   // Get the segment which start at the current position
   fs_g_seg.u32_addr = fs_g_nav_entry.u32_cluster;
80003ff6:	48 98       	lddpc	r8,80004018 <fat_read_file+0xc8>
80003ff8:	48 59       	lddpc	r9,8000400c <fat_read_file+0xbc>
80003ffa:	72 19       	ld.w	r9,r9[0x4]
80003ffc:	91 09       	st.w	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = u32_sector_pos;
80003ffe:	91 16       	st.w	r8[0x4],r6
   if( FS_CLUST_ACT_ONE != mode )
   {
      if( fat_cluster_list( mode, true ) )
80004000:	30 1b       	mov	r11,1
80004002:	0e 9c       	mov	r12,r7
80004004:	f0 1f 00 06 	mcall	8000401c <fat_read_file+0xcc>
80004008:	ce 70       	breq	80003fd6 <fat_read_file+0x86>
8000400a:	cf 2b       	rjmp	80003fee <fat_read_file+0x9e>
8000400c:	00 00       	add	r0,r0
8000400e:	09 f4       	ld.ub	r4,r4[0x7]
80004010:	00 00       	add	r0,r0
80004012:	0c bc       	st.h	r6++,r12
80004014:	00 00       	add	r0,r0
80004016:	0c 34       	cp.w	r4,r6
80004018:	00 00       	add	r0,r0
8000401a:	0c dc       	st.w	--r6,r12
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	3b f4       	mov	r4,-65
80004020:	00 00       	add	r0,r0
80004022:	09 f0       	ld.ub	r0,r4[0x7]
80004024:	80 00       	ld.sh	r0,r0[0x0]
80004026:	38 9c       	mov	r12,-119
80004028:	00 00       	add	r0,r0
8000402a:	0c 84       	andn	r4,r6

8000402c <fat_write_file>:
//!   fs_g_nav_entry.u32_cluster       First cluster of selected file
//!   fs_g_nav_entry.u32_pos_in_file   Position in the file (unit byte)
//! @endverbatim
//!
bool  fat_write_file( uint8_t mode , uint32_t u32_nb_sector_write )
{
8000402c:	eb cd 40 c0 	pushm	r6-r7,lr
80004030:	18 97       	mov	r7,r12
80004032:	16 96       	mov	r6,r11
   if( 0 == fs_g_nav_entry.u32_cluster )
80004034:	4b 68       	lddpc	r8,8000410c <fat_write_file+0xe0>
80004036:	70 18       	ld.w	r8,r8[0x4]
80004038:	58 08       	cp.w	r8,0
8000403a:	c0 a1       	brne	8000404e <fat_write_file+0x22>
   {
      // File don't have a cluster list, then alloc the first cluster list of the file
      MSB0(fs_g_seg.u32_addr)    = 0xFF;     // It is a new cluster list
8000403c:	4b 58       	lddpc	r8,80004110 <fat_write_file+0xe4>
8000403e:	3f f9       	mov	r9,-1
80004040:	b0 89       	st.b	r8[0x0],r9
      // Update cluster list caches
      // fs_g_cluster.u32_pos    = ?         // To fill after alloc
      fs_g_seg.u32_size_or_pos   = 0;
80004042:	30 09       	mov	r9,0
80004044:	91 19       	st.w	r8[0x4],r9
      fat_cache_clusterlist_update_start(true);
80004046:	30 1c       	mov	r12,1
80004048:	f0 1f 00 33 	mcall	80004114 <fat_write_file+0xe8>
8000404c:	c1 c8       	rjmp	80004084 <fat_write_file+0x58>
   }
   else
   {
      if( fat_read_file( mode ) )
8000404e:	f0 1f 00 33 	mcall	80004118 <fat_write_file+0xec>
80004052:	c0 30       	breq	80004058 <fat_write_file+0x2c>
80004054:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
         return true;      // A segment is available (no alloc necessary)

      if( FS_ERR_OUT_LIST != fs_g_status )
80004058:	4b 18       	lddpc	r8,8000411c <fat_write_file+0xf0>
8000405a:	11 89       	ld.ub	r9,r8[0x0]
8000405c:	31 a8       	mov	r8,26
8000405e:	f0 09 18 00 	cp.b	r9,r8
80004062:	c5 21       	brne	80004106 <fat_write_file+0xda>
         return false;     // Error system
      }
      // fat_read_file is outsize the list then the current cluster list cache contains the last cluster

      // Initialize cluster list caches before alloc routine
      fs_g_cache_clusterlist[fs_g_u8_current_cache].u8_lun       = 0xFF;                     // invalid cache
80004064:	4a f8       	lddpc	r8,80004120 <fat_write_file+0xf4>
80004066:	11 88       	ld.ub	r8,r8[0x0]
80004068:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000406c:	4a e9       	lddpc	r9,80004124 <fat_write_file+0xf8>
8000406e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80004072:	3f f9       	mov	r9,-1
80004074:	b0 a9       	st.b	r8[0x2],r9
      // fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster  = fs_g_cluster.u32_pos;  // it is the same
      fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_start += fs_g_nav.u8_BPB_SecPerClus; // Position of next cluster (the first new)
80004076:	2f 88       	sub	r8,-8
80004078:	4a c9       	lddpc	r9,80004128 <fat_write_file+0xfc>
8000407a:	13 9a       	ld.ub	r10,r9[0x1]
8000407c:	70 09       	ld.w	r9,r8[0x0]
8000407e:	f4 09 00 09 	add	r9,r10,r9
80004082:	91 09       	st.w	r8[0x0],r9
   }

   // Alloc a cluster list
   if( FS_CLUST_ACT_SEG == mode )
80004084:	30 18       	mov	r8,1
80004086:	f0 07 18 00 	cp.b	r7,r8
8000408a:	c0 41       	brne	80004092 <fat_write_file+0x66>
   {
      fs_g_seg.u32_size_or_pos = u32_nb_sector_write;
8000408c:	4a 18       	lddpc	r8,80004110 <fat_write_file+0xe4>
8000408e:	91 16       	st.w	r8[0x4],r6
80004090:	c0 48       	rjmp	80004098 <fat_write_file+0x6c>
   }else{
      fs_g_seg.u32_size_or_pos = 1;                                                          // only one sector
80004092:	30 19       	mov	r9,1
80004094:	49 f8       	lddpc	r8,80004110 <fat_write_file+0xe4>
80004096:	91 19       	st.w	r8[0x4],r9
   }

   //note: fs_g_seg.u32_addr is already initialized with the last cluster value (see fat_cluster_list())
   if( !fat_allocfreespace())
80004098:	f0 1f 00 25 	mcall	8000412c <fat_write_file+0x100>
8000409c:	c3 50       	breq	80004106 <fat_write_file+0xda>
      return false;
   //note: fs_g_seg.u32_addr is the first cluster of the cluster list allocated by alloc_free_space()
   //note: fs_g_seg.u32_size_or_pos = number of sectors remaining

   if( 0 == fs_g_nav_entry.u32_cluster )
8000409e:	49 c8       	lddpc	r8,8000410c <fat_write_file+0xe0>
800040a0:	70 18       	ld.w	r8,r8[0x4]
800040a2:	58 08       	cp.w	r8,0
800040a4:	c0 d1       	brne	800040be <fat_write_file+0x92>
   {
      // It is the first cluster list of file, then update following values in cluster list cache
      // fs_g_seg.u32_addr = already contains the first cluster of the file (see alloc_free_space())
      fs_g_cache_clusterlist[fs_g_u8_current_cache].u32_cluster = fs_g_seg.u32_addr;
800040a6:	49 b8       	lddpc	r8,80004110 <fat_write_file+0xe4>
800040a8:	70 08       	ld.w	r8,r8[0x0]
800040aa:	49 e9       	lddpc	r9,80004120 <fat_write_file+0xf4>
800040ac:	13 89       	ld.ub	r9,r9[0x0]
800040ae:	f2 09 00 29 	add	r9,r9,r9<<0x2
800040b2:	2f f9       	sub	r9,-1
800040b4:	49 ca       	lddpc	r10,80004124 <fat_write_file+0xf8>
800040b6:	f4 09 09 28 	st.w	r10[r9<<0x2],r8
      // Update file entry
      fs_g_nav_entry.u32_cluster = fs_g_seg.u32_addr;
800040ba:	49 59       	lddpc	r9,8000410c <fat_write_file+0xe0>
800040bc:	93 18       	st.w	r9[0x4],r8
   }

   // Update cluster list cache
   if( FS_CLUST_ACT_SEG == mode )
800040be:	30 18       	mov	r8,1
800040c0:	f0 07 18 00 	cp.b	r7,r8
800040c4:	c0 71       	brne	800040d2 <fat_write_file+0xa6>
   {
      fs_g_seg.u32_size_or_pos = u32_nb_sector_write - fs_g_seg.u32_size_or_pos;
800040c6:	49 38       	lddpc	r8,80004110 <fat_write_file+0xe4>
800040c8:	70 19       	ld.w	r9,r8[0x4]
800040ca:	ec 09 01 09 	sub	r9,r6,r9
800040ce:	91 19       	st.w	r8[0x4],r9
800040d0:	c0 68       	rjmp	800040dc <fat_write_file+0xb0>
   }else{
      fs_g_seg.u32_size_or_pos = 1 - fs_g_seg.u32_size_or_pos;
800040d2:	49 08       	lddpc	r8,80004110 <fat_write_file+0xe4>
800040d4:	70 19       	ld.w	r9,r8[0x4]
800040d6:	f2 09 11 01 	rsub	r9,r9,1
800040da:	91 19       	st.w	r8[0x4],r9
   }
   fs_g_seg.u32_addr = ((fs_g_seg.u32_addr - 2) * fs_g_nav.u8_BPB_SecPerClus)
800040dc:	48 d9       	lddpc	r9,80004110 <fat_write_file+0xe4>
800040de:	49 38       	lddpc	r8,80004128 <fat_write_file+0xfc>
800040e0:	70 5b       	ld.w	r11,r8[0x14]
800040e2:	70 4a       	ld.w	r10,r8[0x10]
800040e4:	f6 0a 00 0a 	add	r10,r11,r10
800040e8:	11 9b       	ld.ub	r11,r8[0x1]
800040ea:	72 08       	ld.w	r8,r9[0x0]
800040ec:	20 28       	sub	r8,2
800040ee:	f6 08 02 48 	mul	r8,r11,r8
800040f2:	f4 08 00 08 	add	r8,r10,r8
800040f6:	93 08       	st.w	r9[0x0],r8
                     + fs_g_nav.u32_ptr_fat + fs_g_nav.u32_offset_data;
   fat_cache_clusterlist_update_finish();
800040f8:	f0 1f 00 0e 	mcall	80004130 <fat_write_file+0x104>

   return fat_read_file( mode );    // load the new cluster list
800040fc:	0e 9c       	mov	r12,r7
800040fe:	f0 1f 00 07 	mcall	80004118 <fat_write_file+0xec>
80004102:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004106:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
8000410a:	00 00       	add	r0,r0
8000410c:	00 00       	add	r0,r0
8000410e:	09 f4       	ld.ub	r4,r4[0x7]
80004110:	00 00       	add	r0,r0
80004112:	0c dc       	st.w	--r6,r12
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	30 64       	mov	r4,6
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	3f 50       	mov	r0,-11
8000411c:	00 00       	add	r0,r0
8000411e:	0c 84       	andn	r4,r6
80004120:	00 00       	add	r0,r0
80004122:	0c 86       	andn	r6,r6
80004124:	00 00       	add	r0,r0
80004126:	0a 08       	add	r8,r5
80004128:	00 00       	add	r0,r0
8000412a:	0c 34       	cp.w	r4,r6
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	48 14       	lddpc	r4,80004130 <fat_write_file+0x104>
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	31 14       	mov	r4,17

80004134 <fat_check_device>:
//! @verbatim
//! This function updates all navigator data when the device state change.
//! @endverbatim
//!
bool  fat_check_device( void )
{
80004134:	d4 31       	pushm	r0-r7,lr
   uint8_t i;
#endif
   Ctrl_status status;

   // Possibility to ignore the disk check. Used to take time during multi read/write access
   if( g_b_no_check_disk )
80004136:	4a 28       	lddpc	r8,800041bc <fat_check_device+0x88>
80004138:	11 89       	ld.ub	r9,r8[0x0]
8000413a:	30 08       	mov	r8,0
8000413c:	f0 09 18 00 	cp.b	r9,r8
80004140:	c3 c1       	brne	800041b8 <fat_check_device+0x84>
      return true;

   if( 0xFF == fs_g_nav.u8_lun )
80004142:	4a 08       	lddpc	r8,800041c0 <fat_check_device+0x8c>
80004144:	11 89       	ld.ub	r9,r8[0x0]
80004146:	3f f8       	mov	r8,-1
80004148:	f0 09 18 00 	cp.b	r9,r8
8000414c:	c0 51       	brne	80004156 <fat_check_device+0x22>
   {
      fs_g_status = FS_ERR_HW;
8000414e:	30 19       	mov	r9,1
80004150:	49 d8       	lddpc	r8,800041c4 <fat_check_device+0x90>
80004152:	b0 89       	st.b	r8[0x0],r9
80004154:	d8 3a       	popm	r0-r7,pc,r12=0
      return false;                                // No device selected
80004156:	30 02       	mov	r2,0
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80004158:	49 a5       	lddpc	r5,800041c0 <fat_check_device+0x8c>
      if( CTRL_GOOD       == status )
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000415a:	49 c1       	lddpc	r1,800041c8 <fat_check_device+0x94>
8000415c:	30 06       	mov	r6,0
      Fat_file_close();                            // By default the file is not open
8000415e:	49 c0       	lddpc	r0,800041cc <fat_check_device+0x98>
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004160:	49 c4       	lddpc	r4,800041d0 <fat_check_device+0x9c>
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
80004162:	49 d3       	lddpc	r3,800041d4 <fat_check_device+0xa0>
   }

   for( retry=0 ; retry<100 ; retry++ )
   {
      // Check device
      status = mem_test_unit_ready( fs_g_nav.u8_lun );
80004164:	0b 8c       	ld.ub	r12,r5[0x0]
80004166:	f0 1f 00 1d 	mcall	800041d8 <fat_check_device+0xa4>
8000416a:	18 97       	mov	r7,r12
      if( CTRL_GOOD       == status )
8000416c:	c2 60       	breq	800041b8 <fat_check_device+0x84>
         return true;                              // drive ready

      //* HERE error or state change
      // Clean all navigator data which use this device
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
8000416e:	a2 86       	st.b	r1[0x0],r6
      Fat_file_close();                            // By default the file is not open
80004170:	a0 86       	st.b	r0[0x0],r6
#if (FS_NB_NAVIGATOR > 1)
      for( i=0 ; i!=(FS_NB_NAVIGATOR-1) ; i++ )
      {
         if( fs_g_nav.u8_lun == fs_g_navext[i].u8_lun )
80004172:	0b 88       	ld.ub	r8,r5[0x0]
80004174:	09 89       	ld.ub	r9,r4[0x0]
80004176:	f0 09 18 00 	cp.b	r9,r8
8000417a:	c0 51       	brne	80004184 <fat_check_device+0x50>
         {
            fs_g_navext_fast[i].u8_type_fat     = FS_TYPE_FAT_UNM;   // By default the fat isn't mounted
8000417c:	49 89       	lddpc	r9,800041dc <fat_check_device+0xa8>
8000417e:	b2 86       	st.b	r9[0x0],r6
            fs_g_navext_entry[i].u8_open_mode   = 0;                 // By default the file is not open
80004180:	49 89       	lddpc	r9,800041e0 <fat_check_device+0xac>
80004182:	b2 86       	st.b	r9[0x0],r6
         }
      }
#endif
      // If the internal cache corresponding at device then clean it
      if( fs_g_nav.u8_lun == fs_g_sectorcache.u8_lun )
80004184:	07 89       	ld.ub	r9,r3[0x0]
80004186:	f0 09 18 00 	cp.b	r9,r8
8000418a:	c0 31       	brne	80004190 <fat_check_device+0x5c>
      {
         fat_cache_reset();
8000418c:	f0 1f 00 16 	mcall	800041e4 <fat_check_device+0xb0>
      }
      fat_cache_clusterlist_reset();
80004190:	f0 1f 00 16 	mcall	800041e8 <fat_check_device+0xb4>

      fs_g_status = FS_ERR_HW;                     // By default HW error
80004194:	30 18       	mov	r8,1
80004196:	48 c9       	lddpc	r9,800041c4 <fat_check_device+0x90>
80004198:	b2 88       	st.b	r9[0x0],r8
      if( CTRL_BUSY == status )
8000419a:	58 37       	cp.w	r7,3
8000419c:	c0 81       	brne	800041ac <fat_check_device+0x78>
   {
      fs_g_status = FS_ERR_HW;
      return false;                                // No device selected
   }

   for( retry=0 ; retry<100 ; retry++ )
8000419e:	10 02       	add	r2,r8
800041a0:	5c 52       	castu.b	r2
800041a2:	36 48       	mov	r8,100
800041a4:	f0 02 18 00 	cp.b	r2,r8
800041a8:	cd e1       	brne	80004164 <fat_check_device+0x30>
800041aa:	c0 88       	rjmp	800041ba <fat_check_device+0x86>

      fs_g_status = FS_ERR_HW;                     // By default HW error
      if( CTRL_BUSY == status )
         continue;                                 // If device busy then retry

      if( CTRL_NO_PRESENT == status )
800041ac:	58 27       	cp.w	r7,2
800041ae:	c0 61       	brne	800041ba <fat_check_device+0x86>
         fs_g_status = FS_ERR_HW_NO_PRESENT;       // Update error flag
800041b0:	31 89       	mov	r9,24
800041b2:	48 58       	lddpc	r8,800041c4 <fat_check_device+0x90>
800041b4:	b0 89       	st.b	r8[0x0],r9
800041b6:	d8 3a       	popm	r0-r7,pc,r12=0
800041b8:	da 3a       	popm	r0-r7,pc,r12=1
800041ba:	d8 3a       	popm	r0-r7,pc,r12=0
800041bc:	00 00       	add	r0,r0
800041be:	0a 06       	add	r6,r5
800041c0:	00 00       	add	r0,r0
800041c2:	0c 34       	cp.w	r4,r6
800041c4:	00 00       	add	r0,r0
800041c6:	0c 84       	andn	r4,r6
800041c8:	00 00       	add	r0,r0
800041ca:	0c 80       	andn	r0,r6
800041cc:	00 00       	add	r0,r0
800041ce:	09 f4       	ld.ub	r4,r4[0x7]
800041d0:	00 00       	add	r0,r0
800041d2:	0c 88       	andn	r8,r6
800041d4:	00 00       	add	r0,r0
800041d6:	0c bc       	st.h	r6++,r12
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	42 dc       	lddsp	r12,sp[0xb4]
800041dc:	00 00       	add	r0,r0
800041de:	0c 7c       	tst	r12,r6
800041e0:	00 00       	add	r0,r0
800041e2:	0c 6c       	and	r12,r6
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	36 64       	mov	r4,102
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	30 3c       	mov	r12,3

800041ec <fat_check_noopen>:
//!
//! @return    true  no file opened
//! @return    false otherwise
//!
bool  fat_check_noopen( void )
{
800041ec:	d4 01       	pushm	lr
   if( !fat_check_device() )
800041ee:	f0 1f 00 0b 	mcall	80004218 <fat_check_noopen+0x2c>
800041f2:	c1 10       	breq	80004214 <fat_check_noopen+0x28>
      return true;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
800041f4:	48 a8       	lddpc	r8,8000421c <fat_check_noopen+0x30>
800041f6:	11 89       	ld.ub	r9,r8[0x0]
800041f8:	30 08       	mov	r8,0
800041fa:	f0 09 18 00 	cp.b	r9,r8
800041fe:	c0 b0       	breq	80004214 <fat_check_noopen+0x28>
      return true;
   if( Fat_file_is_open() )
80004200:	48 88       	lddpc	r8,80004220 <fat_check_noopen+0x34>
80004202:	11 89       	ld.ub	r9,r8[0x0]
80004204:	30 08       	mov	r8,0
80004206:	f0 09 18 00 	cp.b	r9,r8
8000420a:	c0 50       	breq	80004214 <fat_check_noopen+0x28>
   {
      fs_g_status = FS_ERR_TOO_FILE_OPEN;  // The navigation have already open a file
8000420c:	30 59       	mov	r9,5
8000420e:	48 68       	lddpc	r8,80004224 <fat_check_noopen+0x38>
80004210:	b0 89       	st.b	r8[0x0],r9
80004212:	d8 0a       	popm	pc,r12=0
      return false;
80004214:	da 0a       	popm	pc,r12=1
80004216:	00 00       	add	r0,r0
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	41 34       	lddsp	r4,sp[0x4c]
8000421c:	00 00       	add	r0,r0
8000421e:	0c 80       	andn	r0,r6
80004220:	00 00       	add	r0,r0
80004222:	09 f4       	ld.ub	r4,r4[0x7]
80004224:	00 00       	add	r0,r0
80004226:	0c 84       	andn	r4,r6

80004228 <fat_check_mount>:
//!
//! @return    true  partition mounted
//! @return    false otherwise
//!
bool  fat_check_mount( void )
{
80004228:	d4 01       	pushm	lr
   if( !fat_check_device() )
8000422a:	f0 1f 00 0a 	mcall	80004250 <fat_check_mount+0x28>
8000422e:	c0 f0       	breq	8000424c <fat_check_mount+0x24>
      return false;
   if (FS_TYPE_FAT_UNM == fs_g_nav_fast.u8_type_fat)
80004230:	48 98       	lddpc	r8,80004254 <fat_check_mount+0x2c>
80004232:	11 89       	ld.ub	r9,r8[0x0]
80004234:	30 08       	mov	r8,0
80004236:	f0 09 18 00 	cp.b	r9,r8
8000423a:	c0 81       	brne	8000424a <fat_check_mount+0x22>
   {
      if( !fat_mount() )
8000423c:	f0 1f 00 07 	mcall	80004258 <fat_check_mount+0x30>
80004240:	c0 51       	brne	8000424a <fat_check_mount+0x22>
      {
         fs_g_status = FS_ERR_NO_MOUNT;
80004242:	30 e9       	mov	r9,14
80004244:	48 68       	lddpc	r8,8000425c <fat_check_mount+0x34>
80004246:	b0 89       	st.b	r8[0x0],r9
         return false;
80004248:	d8 02       	popm	pc
8000424a:	30 1c       	mov	r12,1
      }
   }
   return true;
}
8000424c:	d8 02       	popm	pc
8000424e:	00 00       	add	r0,r0
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	41 34       	lddsp	r4,sp[0x4c]
80004254:	00 00       	add	r0,r0
80004256:	0c 80       	andn	r0,r6
80004258:	80 00       	ld.sh	r0,r0[0x0]
8000425a:	4d ac       	lddpc	r12,800043c0 <fat_translate_char_shortname+0x3c>
8000425c:	00 00       	add	r0,r0
8000425e:	0c 84       	andn	r4,r6

80004260 <fat_check_mount_select>:
//!
//! @return    true  partition mounted and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select( void )
{
80004260:	d4 01       	pushm	lr
   if( !fat_check_mount() )
80004262:	f0 1f 00 04 	mcall	80004270 <fat_check_mount_select+0x10>
80004266:	c0 30       	breq	8000426c <fat_check_mount_select+0xc>
      return false;
   return fat_check_select();
80004268:	f0 1f 00 03 	mcall	80004274 <fat_check_mount_select+0x14>
}
8000426c:	d8 02       	popm	pc
8000426e:	00 00       	add	r0,r0
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	42 28       	lddsp	r8,sp[0x88]
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	2f a0       	sub	r0,-6

80004278 <fat_check_mount_select_open>:
//!
//! @return    true  partition mounted and a file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_select_open( void )
{
80004278:	d4 01       	pushm	lr
   if( !fat_check_mount() )
8000427a:	f0 1f 00 06 	mcall	80004290 <fat_check_mount_select_open+0x18>
8000427e:	c0 70       	breq	8000428c <fat_check_mount_select_open+0x14>
      return false;
   if( !fat_check_select() )
80004280:	f0 1f 00 05 	mcall	80004294 <fat_check_mount_select_open+0x1c>
80004284:	c0 40       	breq	8000428c <fat_check_mount_select_open+0x14>
      return false;
   return fat_check_open();
80004286:	f0 1f 00 05 	mcall	80004298 <fat_check_mount_select_open+0x20>
8000428a:	d8 02       	popm	pc
8000428c:	d8 0a       	popm	pc,r12=0
8000428e:	00 00       	add	r0,r0
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	42 28       	lddsp	r8,sp[0x88]
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	2f a0       	sub	r0,-6
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	2f 80       	sub	r0,-8

8000429c <fat_check_mount_select_noopen>:
//!
//! @return    true  partition mounted and no file is opened and a file is selected
//! @return    false otherwise
//!
bool  fat_check_mount_select_noopen( void )
{
8000429c:	d4 01       	pushm	lr
   if( !fat_check_mount() )
8000429e:	f0 1f 00 06 	mcall	800042b4 <fat_check_mount_select_noopen+0x18>
800042a2:	c0 70       	breq	800042b0 <fat_check_mount_select_noopen+0x14>
      return false;
   if( !fat_check_select() )
800042a4:	f0 1f 00 05 	mcall	800042b8 <fat_check_mount_select_noopen+0x1c>
800042a8:	c0 40       	breq	800042b0 <fat_check_mount_select_noopen+0x14>
      return false;
   return fat_check_noopen();
800042aa:	f0 1f 00 05 	mcall	800042bc <fat_check_mount_select_noopen+0x20>
800042ae:	d8 02       	popm	pc
800042b0:	d8 0a       	popm	pc,r12=0
800042b2:	00 00       	add	r0,r0
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	42 28       	lddsp	r8,sp[0x88]
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	2f a0       	sub	r0,-6
800042bc:	80 00       	ld.sh	r0,r0[0x0]
800042be:	41 ec       	lddsp	r12,sp[0x78]

800042c0 <fat_check_mount_noopen>:
//!
//! @return    true  partition mounted and no file is opened
//! @return    false otherwise
//!
bool  fat_check_mount_noopen( void )
{
800042c0:	d4 01       	pushm	lr
   if( !fat_check_mount() )
800042c2:	f0 1f 00 04 	mcall	800042d0 <fat_check_mount_noopen+0x10>
800042c6:	c0 30       	breq	800042cc <fat_check_mount_noopen+0xc>
      return false;
   return fat_check_noopen();
800042c8:	f0 1f 00 03 	mcall	800042d4 <fat_check_mount_noopen+0x14>
}
800042cc:	d8 02       	popm	pc
800042ce:	00 00       	add	r0,r0
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	42 28       	lddsp	r8,sp[0x88]
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	41 ec       	lddsp	r12,sp[0x78]

800042d8 <get_nb_lun>:

  return nb_lun;
#else
  return MAX_LUN;
#endif
}
800042d8:	5e ff       	retal	1
800042da:	d7 03       	nop

800042dc <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
800042dc:	d4 01       	pushm	lr
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
800042de:	58 0c       	cp.w	r12,0
800042e0:	c0 20       	breq	800042e4 <mem_test_unit_ready+0x8>
800042e2:	da 0a       	popm	pc,r12=1
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
800042e4:	48 28       	lddpc	r8,800042ec <mem_test_unit_ready+0x10>
800042e6:	70 0c       	ld.w	r12,r8[0x0]
800042e8:	5d 1c       	icall	r12
#endif

  Ctrl_access_unlock();

  return status;
}
800042ea:	d8 02       	popm	pc
800042ec:	80 01       	ld.sh	r1,r0[0x0]
800042ee:	dc 00       	acall	0xc0

800042f0 <mem_sector_size>:
  return status;
}


U8 mem_sector_size(U8 lun)
{
800042f0:	58 0c       	cp.w	r12,0
#endif

  Ctrl_access_unlock();

  return sector_size;
}
800042f2:	5f 0c       	sreq	r12
800042f4:	5e fc       	retal	r12
800042f6:	d7 03       	nop

800042f8 <mem_wr_protect>:

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
800042f8:	d4 01       	pushm	lr
  bool wr_protect;

  if (!Ctrl_access_lock()) return true;

  wr_protect =
800042fa:	58 0c       	cp.w	r12,0
800042fc:	c0 20       	breq	80004300 <mem_wr_protect+0x8>
800042fe:	da 0a       	popm	pc,r12=1
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
80004300:	48 28       	lddpc	r8,80004308 <mem_wr_protect+0x10>
80004302:	70 3c       	ld.w	r12,r8[0xc]
80004304:	5d 1c       	icall	r12
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
80004306:	d8 02       	popm	pc
80004308:	80 01       	ld.sh	r1,r0[0x0]
8000430a:	dc 00       	acall	0xc0

8000430c <ram_2_memory>:
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
8000430c:	eb cd 40 e0 	pushm	r5-r7,lr
80004310:	18 97       	mov	r7,r12
80004312:	16 95       	mov	r5,r11
80004314:	14 96       	mov	r6,r10
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
80004316:	30 2c       	mov	r12,2
80004318:	f0 1f 00 09 	mcall	8000433c <ram_2_memory+0x30>
  status =
8000431c:	58 07       	cp.w	r7,0
8000431e:	c0 30       	breq	80004324 <ram_2_memory+0x18>
80004320:	30 17       	mov	r7,1
80004322:	c0 78       	rjmp	80004330 <ram_2_memory+0x24>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
80004324:	48 78       	lddpc	r8,80004340 <ram_2_memory+0x34>
80004326:	70 68       	ld.w	r8,r8[0x18]
80004328:	0c 9b       	mov	r11,r6
8000432a:	0a 9c       	mov	r12,r5
8000432c:	5d 18       	icall	r8
8000432e:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_ram_2_mem(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_write_action();
80004330:	30 2c       	mov	r12,2
80004332:	f0 1f 00 05 	mcall	80004344 <ram_2_memory+0x38>

  Ctrl_access_unlock();

  return status;
}
80004336:	0e 9c       	mov	r12,r7
80004338:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	5e d4       	retvc	r4
80004340:	80 01       	ld.sh	r1,r0[0x0]
80004342:	dc 00       	acall	0xc0
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	5f 24       	srhs	r4

80004348 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
80004348:	eb cd 40 e0 	pushm	r5-r7,lr
8000434c:	18 97       	mov	r7,r12
8000434e:	16 95       	mov	r5,r11
80004350:	14 96       	mov	r6,r10
  UNUSED(lun);
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
80004352:	30 1c       	mov	r12,1
80004354:	f0 1f 00 09 	mcall	80004378 <memory_2_ram+0x30>
  status =
80004358:	58 07       	cp.w	r7,0
8000435a:	c0 30       	breq	80004360 <memory_2_ram+0x18>
8000435c:	30 17       	mov	r7,1
8000435e:	c0 78       	rjmp	8000436c <memory_2_ram+0x24>
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
80004360:	48 78       	lddpc	r8,8000437c <memory_2_ram+0x34>
80004362:	70 58       	ld.w	r8,r8[0x14]
80004364:	0c 9b       	mov	r11,r6
80004366:	0a 9c       	mov	r12,r5
80004368:	5d 18       	icall	r8
8000436a:	18 97       	mov	r7,r12
#if LUN_USB == ENABLE
                             Lun_usb_mem_2_ram(addr, ram);
#else
                             CTRL_FAIL;
#endif
  memory_stop_read_action();
8000436c:	30 1c       	mov	r12,1
8000436e:	f0 1f 00 05 	mcall	80004380 <memory_2_ram+0x38>

  Ctrl_access_unlock();

  return status;
}
80004372:	0e 9c       	mov	r12,r7
80004374:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	5e d4       	retvc	r4
8000437c:	80 01       	ld.sh	r1,r0[0x0]
8000437e:	dc 00       	acall	0xc0
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	5f 24       	srhs	r4

80004384 <fat_translate_char_shortname>:
//!
uint8_t    fat_translate_char_shortname( uint8_t character )
{
   uint8_t u8_j;

   if( (character<=' ') || ('~'<character) )
80004384:	f8 c9 00 21 	sub	r9,r12,33
80004388:	35 d8       	mov	r8,93
8000438a:	f0 09 18 00 	cp.b	r9,r8
8000438e:	e0 8b 00 1d 	brhi	800043c8 <fat_translate_char_shortname+0x44>
      return 0;
   if( ('a'<=character) && (character<='z') )
80004392:	f8 c9 00 61 	sub	r9,r12,97
80004396:	31 98       	mov	r8,25
80004398:	f0 09 18 00 	cp.b	r9,r8
8000439c:	e0 88 00 07 	brls	800043aa <fat_translate_char_shortname+0x26>
   {
      return (character - ('a'-'A'));  // Change to upper case
   }
   for( u8_j = 0 ; u8_j < sizeof(fs_s_execption_char) ; u8_j++ )
   {
      if( character == fs_s_execption_char[u8_j] )
800043a0:	32 b8       	mov	r8,43
800043a2:	f0 0c 18 00 	cp.b	r12,r8
800043a6:	c0 51       	brne	800043b0 <fat_translate_char_shortname+0x2c>
800043a8:	c1 08       	rjmp	800043c8 <fat_translate_char_shortname+0x44>

   if( (character<=' ') || ('~'<character) )
      return 0;
   if( ('a'<=character) && (character<='z') )
   {
      return (character - ('a'-'A'));  // Change to upper case
800043aa:	22 0c       	sub	r12,32
800043ac:	5c 5c       	castu.b	r12
800043ae:	5e fc       	retal	r12
800043b0:	48 7a       	lddpc	r10,800043cc <fat_translate_char_shortname+0x48>
800043b2:	f4 c8 ff ff 	sub	r8,r10,-1
//! @param     character   character to translate
//!
//! @return    character translated <br>
//!            if no supported then 0
//!
uint8_t    fat_translate_char_shortname( uint8_t character )
800043b6:	2f 9a       	sub	r10,-7
   {
      return (character - ('a'-'A'));  // Change to upper case
   }
   for( u8_j = 0 ; u8_j < sizeof(fs_s_execption_char) ; u8_j++ )
   {
      if( character == fs_s_execption_char[u8_j] )
800043b8:	11 89       	ld.ub	r9,r8[0x0]
800043ba:	f8 09 18 00 	cp.b	r9,r12
800043be:	c0 50       	breq	800043c8 <fat_translate_char_shortname+0x44>
800043c0:	2f f8       	sub	r8,-1
      return 0;
   if( ('a'<=character) && (character<='z') )
   {
      return (character - ('a'-'A'));  // Change to upper case
   }
   for( u8_j = 0 ; u8_j < sizeof(fs_s_execption_char) ; u8_j++ )
800043c2:	14 38       	cp.w	r8,r10
800043c4:	cf a1       	brne	800043b8 <fat_translate_char_shortname+0x34>
800043c6:	5e fc       	retal	r12
800043c8:	5e fd       	retal	0
800043ca:	00 00       	add	r0,r0
800043cc:	80 01       	ld.sh	r1,r0[0x0]
800043ce:	dc 44       	*unknown*

800043d0 <fat_clear_info_fat_mod>:
#if (FS_LEVEL_FEATURES > FSFEATURE_READ)
//! This function clears the cache information about FAT modifications
//!
void  fat_clear_info_fat_mod( void )
{
   fs_g_u32_first_mod_fat = 0xFFFFFFFF;
800043d0:	3f f9       	mov	r9,-1
800043d2:	48 48       	lddpc	r8,800043e0 <fat_clear_info_fat_mod+0x10>
800043d4:	91 09       	st.w	r8[0x0],r9
   fs_g_u32_last_mod_fat = 0;
800043d6:	30 09       	mov	r9,0
800043d8:	48 38       	lddpc	r8,800043e4 <fat_clear_info_fat_mod+0x14>
800043da:	91 09       	st.w	r8[0x0],r9
}
800043dc:	5e fc       	retal	r12
800043de:	00 00       	add	r0,r0
800043e0:	00 00       	add	r0,r0
800043e2:	0c 68       	and	r8,r6
800043e4:	00 00       	add	r0,r0
800043e6:	0a 30       	cp.w	r0,r5

800043e8 <fat_clear_cluster>:
//! IN :
//!   fs_g_seg.u32_addr          Cluster value to clear
//! @endverbatim
//!
bool  fat_clear_cluster( void )
{
800043e8:	d4 21       	pushm	r4-r7,lr
   uint8_t u8_loop;

   // Compute the cluster sector address
   fs_g_seg.u32_size_or_pos  = 0;   // Select the beginning of cluster
800043ea:	30 0b       	mov	r11,0
800043ec:	49 58       	lddpc	r8,80004440 <fat_clear_cluster+0x58>
800043ee:	91 1b       	st.w	r8[0x4],r11
   if( !fat_cluster_list( FS_CLUST_ACT_ONE, false ))
800043f0:	30 2c       	mov	r12,2
800043f2:	f0 1f 00 15 	mcall	80004444 <fat_clear_cluster+0x5c>
800043f6:	c2 30       	breq	8000443c <fat_clear_cluster+0x54>
      return false;

   // Loop in the cluster (start at the end of cluster)
   fs_gu32_addrsector = fs_g_seg.u32_addr + (fs_g_nav.u8_BPB_SecPerClus -1);
800043f8:	49 48       	lddpc	r8,80004448 <fat_clear_cluster+0x60>
800043fa:	11 98       	ld.ub	r8,r8[0x1]
800043fc:	49 19       	lddpc	r9,80004440 <fat_clear_cluster+0x58>
800043fe:	72 0a       	ld.w	r10,r9[0x0]
80004400:	20 1a       	sub	r10,1
80004402:	10 0a       	add	r10,r8
80004404:	49 29       	lddpc	r9,8000444c <fat_clear_cluster+0x64>
80004406:	93 0a       	st.w	r9[0x0],r10
   for(  u8_loop = 0
80004408:	58 08       	cp.w	r8,0
8000440a:	c1 a0       	breq	8000443e <fat_clear_cluster+0x56>
8000440c:	30 07       	mov	r7,0
   ;     fs_g_nav.u8_BPB_SecPerClus != u8_loop
   ;     u8_loop++ )
   {
      // Update internal cache with cluster sector information but don't read data from memory
      if( !fat_cache_read_sector( false ))
8000440e:	0e 94       	mov	r4,r7
      if(0 == u8_loop)
      {  // Clean internal cache (just for the sector)
         fat_cache_clear();
      }
      fat_cache_mark_sector_as_dirty();
      fs_gu32_addrsector--;         // go to previous sector
80004410:	12 96       	mov	r6,r9
   if( !fat_cluster_list( FS_CLUST_ACT_ONE, false ))
      return false;

   // Loop in the cluster (start at the end of cluster)
   fs_gu32_addrsector = fs_g_seg.u32_addr + (fs_g_nav.u8_BPB_SecPerClus -1);
   for(  u8_loop = 0
80004412:	48 e5       	lddpc	r5,80004448 <fat_clear_cluster+0x60>
   ;     fs_g_nav.u8_BPB_SecPerClus != u8_loop
   ;     u8_loop++ )
   {
      // Update internal cache with cluster sector information but don't read data from memory
      if( !fat_cache_read_sector( false ))
80004414:	08 9c       	mov	r12,r4
80004416:	f0 1f 00 0f 	mcall	80004450 <fat_clear_cluster+0x68>
8000441a:	c1 10       	breq	8000443c <fat_clear_cluster+0x54>
         return false;

      if(0 == u8_loop)
8000441c:	58 07       	cp.w	r7,0
8000441e:	c0 31       	brne	80004424 <fat_clear_cluster+0x3c>
      {  // Clean internal cache (just for the sector)
         fat_cache_clear();
80004420:	f0 1f 00 0d 	mcall	80004454 <fat_clear_cluster+0x6c>
      }
      fat_cache_mark_sector_as_dirty();
80004424:	f0 1f 00 0d 	mcall	80004458 <fat_clear_cluster+0x70>
      fs_gu32_addrsector--;         // go to previous sector
80004428:	6c 08       	ld.w	r8,r6[0x0]
8000442a:	20 18       	sub	r8,1
8000442c:	8d 08       	st.w	r6[0x0],r8

   // Loop in the cluster (start at the end of cluster)
   fs_gu32_addrsector = fs_g_seg.u32_addr + (fs_g_nav.u8_BPB_SecPerClus -1);
   for(  u8_loop = 0
   ;     fs_g_nav.u8_BPB_SecPerClus != u8_loop
   ;     u8_loop++ )
8000442e:	2f f7       	sub	r7,-1
80004430:	5c 57       	castu.b	r7
   if( !fat_cluster_list( FS_CLUST_ACT_ONE, false ))
      return false;

   // Loop in the cluster (start at the end of cluster)
   fs_gu32_addrsector = fs_g_seg.u32_addr + (fs_g_nav.u8_BPB_SecPerClus -1);
   for(  u8_loop = 0
80004432:	0b 98       	ld.ub	r8,r5[0x1]
80004434:	ee 08 18 00 	cp.b	r8,r7
80004438:	ce e1       	brne	80004414 <fat_clear_cluster+0x2c>
8000443a:	c0 28       	rjmp	8000443e <fat_clear_cluster+0x56>
8000443c:	d8 2a       	popm	r4-r7,pc,r12=0
8000443e:	da 2a       	popm	r4-r7,pc,r12=1
80004440:	00 00       	add	r0,r0
80004442:	0c dc       	st.w	--r6,r12
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	3b f4       	mov	r4,-65
80004448:	00 00       	add	r0,r0
8000444a:	0c 34       	cp.w	r4,r6
8000444c:	00 00       	add	r0,r0
8000444e:	09 f0       	ld.ub	r0,r4[0x7]
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	38 9c       	mov	r12,-119
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	38 84       	mov	r4,-120
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	36 7c       	mov	r12,103

8000445c <fat_update_fat2>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
8000445c:	eb cd 40 fc 	pushm	r2-r7,lr
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004460:	49 68       	lddpc	r8,800044b8 <fat_update_fat2+0x5c>
80004462:	70 08       	ld.w	r8,r8[0x0]
80004464:	49 69       	lddpc	r9,800044bc <fat_update_fat2+0x60>
80004466:	72 09       	ld.w	r9,r9[0x0]
80004468:	12 38       	cp.w	r8,r9
8000446a:	e0 8b 00 25 	brhi	800044b4 <fat_update_fat2+0x58>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000446e:	49 55       	lddpc	r5,800044c0 <fat_update_fat2+0x64>
80004470:	49 57       	lddpc	r7,800044c4 <fat_update_fat2+0x68>
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80004472:	30 13       	mov	r3,1
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80004474:	49 16       	lddpc	r6,800044b8 <fat_update_fat2+0x5c>
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80004476:	30 02       	mov	r2,0
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
80004478:	49 14       	lddpc	r4,800044bc <fat_update_fat2+0x60>
  {
     // Compute the modification position of FAT 1
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + fs_g_u32_first_mod_fat;
8000447a:	6e 49       	ld.w	r9,r7[0x10]
8000447c:	12 08       	add	r8,r9
8000447e:	8b 08       	st.w	r5[0x0],r8
     // Read FAT1
      if( !fat_cache_read_sector( true ))
80004480:	06 9c       	mov	r12,r3
80004482:	f0 1f 00 12 	mcall	800044c8 <fat_update_fat2+0x6c>
80004486:	c1 50       	breq	800044b0 <fat_update_fat2+0x54>
         return false;
     // Compute the modification position of FAT 2
     fs_gu32_addrsector = fs_g_nav.u32_ptr_fat + (fs_g_u32_first_mod_fat + fs_g_nav.u32_fat_size);
80004488:	6e 19       	ld.w	r9,r7[0x4]
8000448a:	6e 48       	ld.w	r8,r7[0x10]
8000448c:	f2 08 00 08 	add	r8,r9,r8
80004490:	6c 09       	ld.w	r9,r6[0x0]
80004492:	12 08       	add	r8,r9
80004494:	8b 08       	st.w	r5[0x0],r8
     // Init the sector FAT2 with the previous sector of the FAT1
     if( !fat_cache_read_sector( false ))
80004496:	04 9c       	mov	r12,r2
80004498:	f0 1f 00 0c 	mcall	800044c8 <fat_update_fat2+0x6c>
8000449c:	c0 a0       	breq	800044b0 <fat_update_fat2+0x54>
         return false;
     // Flag the sector FAT2 like modify
     fat_cache_mark_sector_as_dirty();
8000449e:	f0 1f 00 0c 	mcall	800044cc <fat_update_fat2+0x70>
     fs_g_u32_first_mod_fat++;
800044a2:	6c 08       	ld.w	r8,r6[0x0]
800044a4:	2f f8       	sub	r8,-1
800044a6:	8d 08       	st.w	r6[0x0],r8
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_update_fat2( void )
{
  while( fs_g_u32_first_mod_fat <= fs_g_u32_last_mod_fat )
800044a8:	68 09       	ld.w	r9,r4[0x0]
800044aa:	10 39       	cp.w	r9,r8
800044ac:	ce 72       	brcc	8000447a <fat_update_fat2+0x1e>
800044ae:	c0 38       	rjmp	800044b4 <fat_update_fat2+0x58>
800044b0:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
800044b4:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
800044b8:	00 00       	add	r0,r0
800044ba:	0c 68       	and	r8,r6
800044bc:	00 00       	add	r0,r0
800044be:	0a 30       	cp.w	r0,r5
800044c0:	00 00       	add	r0,r0
800044c2:	09 f0       	ld.ub	r0,r4[0x7]
800044c4:	00 00       	add	r0,r0
800044c6:	0c 34       	cp.w	r4,r6
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	38 9c       	mov	r12,-119
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	36 7c       	mov	r12,103

800044d0 <fat_initialize_dir>:
//! OUT:
//!   update the sector cache with init directory data
//! @endverbatim
//!
bool  fat_initialize_dir( void )
{
800044d0:	d4 01       	pushm	lr
   uint8_t u8_i;

   // Clear the cluster corresponding at directory
   if( !fat_clear_cluster())
800044d2:	f0 1f 00 21 	mcall	80004554 <fat_initialize_dir+0x84>
800044d6:	c3 e0       	breq	80004552 <fat_initialize_dir+0x82>
      return false;
   fat_cache_mark_sector_as_dirty();
800044d8:	f0 1f 00 20 	mcall	80004558 <fat_initialize_dir+0x88>
   // here, the internal cache is the first sector of the cluster

   // Create the dot "." entry, this one is a directory that points to itself
   fs_g_sector[0]='.';
800044dc:	4a 0b       	lddpc	r11,8000455c <fat_initialize_dir+0x8c>
800044de:	16 98       	mov	r8,r11
800044e0:	32 e9       	mov	r9,46
800044e2:	10 c9       	st.b	r8++,r9
//!   fs_g_seg.u32_addr          cluster value of a directory
//! OUT:
//!   update the sector cache with init directory data
//! @endverbatim
//!
bool  fat_initialize_dir( void )
800044e4:	f6 ca ff f5 	sub	r10,r11,-11
   // here, the internal cache is the first sector of the cluster

   // Create the dot "." entry, this one is a directory that points to itself
   fs_g_sector[0]='.';
   for( u8_i=1 ; u8_i<11 ; u8_i++ )
      fs_g_sector[u8_i]=' ';
800044e8:	32 09       	mov	r9,32
800044ea:	10 c9       	st.b	r8++,r9
   fat_cache_mark_sector_as_dirty();
   // here, the internal cache is the first sector of the cluster

   // Create the dot "." entry, this one is a directory that points to itself
   fs_g_sector[0]='.';
   for( u8_i=1 ; u8_i<11 ; u8_i++ )
800044ec:	14 38       	cp.w	r8,r10
800044ee:	cf e1       	brne	800044ea <fat_initialize_dir+0x1a>
      fs_g_sector[u8_i]=' ';
   fs_g_sector[11]=FS_ATTR_DIRECTORY;
800044f0:	49 b8       	lddpc	r8,8000455c <fat_initialize_dir+0x8c>
800044f2:	31 09       	mov	r9,16
800044f4:	f1 69 00 0b 	st.b	r8[11],r9
   fs_g_sector[26]= LSB0( fs_g_nav_entry.u32_cluster );
800044f8:	49 a9       	lddpc	r9,80004560 <fat_initialize_dir+0x90>
800044fa:	2f c9       	sub	r9,-4
800044fc:	13 ba       	ld.ub	r10,r9[0x3]
800044fe:	f1 6a 00 1a 	st.b	r8[26],r10
   fs_g_sector[27]= LSB1( fs_g_nav_entry.u32_cluster );
80004502:	13 aa       	ld.ub	r10,r9[0x2]
80004504:	f1 6a 00 1b 	st.b	r8[27],r10
   fs_g_sector[20]= LSB2( fs_g_nav_entry.u32_cluster );
80004508:	13 9a       	ld.ub	r10,r9[0x1]
8000450a:	f1 6a 00 14 	st.b	r8[20],r10
   fs_g_sector[21]= LSB3( fs_g_nav_entry.u32_cluster );
8000450e:	13 89       	ld.ub	r9,r9[0x0]
80004510:	f1 69 00 15 	st.b	r8[21],r9
   // Create the dotdot ".." entry, this one points to the starting cluster of the parent directory
   fs_g_sector[FS_SIZE_FILE_ENTRY+0]='.';
80004514:	32 e9       	mov	r9,46
80004516:	f1 69 00 20 	st.b	r8[32],r9
   fs_g_sector[FS_SIZE_FILE_ENTRY+1]='.';
8000451a:	f1 69 00 21 	st.b	r8[33],r9
8000451e:	2d e8       	sub	r8,-34
//!   fs_g_seg.u32_addr          cluster value of a directory
//! OUT:
//!   update the sector cache with init directory data
//! @endverbatim
//!
bool  fat_initialize_dir( void )
80004520:	f6 ca ff d5 	sub	r10,r11,-43
   fs_g_sector[21]= LSB3( fs_g_nav_entry.u32_cluster );
   // Create the dotdot ".." entry, this one points to the starting cluster of the parent directory
   fs_g_sector[FS_SIZE_FILE_ENTRY+0]='.';
   fs_g_sector[FS_SIZE_FILE_ENTRY+1]='.';
   for( u8_i=2 ; u8_i<11 ; u8_i++ )
      fs_g_sector[FS_SIZE_FILE_ENTRY+u8_i]=' ';
80004524:	32 09       	mov	r9,32
80004526:	10 c9       	st.b	r8++,r9
   fs_g_sector[20]= LSB2( fs_g_nav_entry.u32_cluster );
   fs_g_sector[21]= LSB3( fs_g_nav_entry.u32_cluster );
   // Create the dotdot ".." entry, this one points to the starting cluster of the parent directory
   fs_g_sector[FS_SIZE_FILE_ENTRY+0]='.';
   fs_g_sector[FS_SIZE_FILE_ENTRY+1]='.';
   for( u8_i=2 ; u8_i<11 ; u8_i++ )
80004528:	14 38       	cp.w	r8,r10
8000452a:	cf e1       	brne	80004526 <fat_initialize_dir+0x56>
      fs_g_sector[FS_SIZE_FILE_ENTRY+u8_i]=' ';
   fs_g_sector[FS_SIZE_FILE_ENTRY+11]=FS_ATTR_DIRECTORY;
8000452c:	48 c8       	lddpc	r8,8000455c <fat_initialize_dir+0x8c>
8000452e:	31 09       	mov	r9,16
80004530:	f1 69 00 2b 	st.b	r8[43],r9
   fs_g_sector[FS_SIZE_FILE_ENTRY+26]= LSB0( fs_g_nav.u32_cluster_sel_dir );
80004534:	48 c9       	lddpc	r9,80004564 <fat_initialize_dir+0x94>
80004536:	2e 09       	sub	r9,-32
80004538:	13 ba       	ld.ub	r10,r9[0x3]
8000453a:	f1 6a 00 3a 	st.b	r8[58],r10
   fs_g_sector[FS_SIZE_FILE_ENTRY+27]= LSB1( fs_g_nav.u32_cluster_sel_dir );
8000453e:	13 aa       	ld.ub	r10,r9[0x2]
80004540:	f1 6a 00 3b 	st.b	r8[59],r10
   fs_g_sector[FS_SIZE_FILE_ENTRY+20]= LSB2( fs_g_nav.u32_cluster_sel_dir );
80004544:	13 9a       	ld.ub	r10,r9[0x1]
80004546:	f1 6a 00 34 	st.b	r8[52],r10
   fs_g_sector[FS_SIZE_FILE_ENTRY+21]= LSB3( fs_g_nav.u32_cluster_sel_dir );
8000454a:	13 89       	ld.ub	r9,r9[0x0]
8000454c:	f1 69 00 35 	st.b	r8[53],r9
80004550:	30 1c       	mov	r12,1

   return true;
}
80004552:	d8 02       	popm	pc
80004554:	80 00       	ld.sh	r0,r0[0x0]
80004556:	43 e8       	lddsp	r8,sp[0xf8]
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	36 7c       	mov	r12,103
8000455c:	00 00       	add	r0,r0
8000455e:	0a 34       	cp.w	r4,r5
80004560:	00 00       	add	r0,r0
80004562:	09 f4       	ld.ub	r4,r4[0x7]
80004564:	00 00       	add	r0,r0
80004566:	0c 34       	cp.w	r4,r6

80004568 <fat_create_long_name_entry>:
//! @verbatim
//! OUT: Update the entry in internal cache sector with a new long name entry
//! @endverbatim
//!
void  fat_create_long_name_entry( FS_STRING sz_name , uint8_t u8_crc , uint8_t u8_id  )
{
80004568:	d4 31       	pushm	r0-r7,lr
8000456a:	20 5d       	sub	sp,20
8000456c:	18 97       	mov	r7,r12
8000456e:	50 3b       	stdsp	sp[0xc],r11
80004570:	14 96       	mov	r6,r10
   PTR_CACHE ptr_entry;
   bool b_end_of_name = false;

   fat_cache_mark_sector_as_dirty();
80004572:	f0 1f 00 30 	mcall	80004630 <fat_create_long_name_entry+0xc8>
   ptr_entry = fat_get_ptr_entry();
80004576:	f0 1f 00 30 	mcall	80004634 <fat_create_long_name_entry+0xcc>
   *ptr_entry = u8_id;
8000457a:	18 c6       	st.b	r12++,r6
   ptr_entry++;   // The long name start at offset 1 of the entry file
8000457c:	30 01       	mov	r1,0
8000457e:	30 18       	mov	r8,1

   for( u8_id=1; u8_id<FS_SIZE_FILE_ENTRY ; u8_id++ , ptr_entry++ )
   {
      // fields with no character
      if( 11 == u8_id)
80004580:	30 b9       	mov	r9,11
      {
         *ptr_entry = FS_ATTR_LFN_ENTRY;  // Attribute field
80004582:	30 f3       	mov	r3,15
         continue;
      }
      if( (12 == u8_id)
80004584:	30 c6       	mov	r6,12
80004586:	31 ab       	mov	r11,26
80004588:	30 0a       	mov	r10,0
   fat_cache_mark_sector_as_dirty();
   ptr_entry = fat_get_ptr_entry();
   *ptr_entry = u8_id;
   ptr_entry++;   // The long name start at offset 1 of the entry file

   for( u8_id=1; u8_id<FS_SIZE_FILE_ENTRY ; u8_id++ , ptr_entry++ )
8000458a:	31 fe       	mov	lr,31
      if( 11 == u8_id)
      {
         *ptr_entry = FS_ATTR_LFN_ENTRY;  // Attribute field
         continue;
      }
      if( (12 == u8_id)
8000458c:	31 b5       	mov	r5,27
      {
         // Reserved field
         // *ptr_entry = 0x00;            // No necessary because the cache must be clean
         continue;
      }
      if( 13 == u8_id)
8000458e:	30 d2       	mov	r2,13
         u8_id++;
         sz_name += (Is_unicode? 2 : 1 );
      }
      else
      {  // end of name
         *ptr_entry = 0xFF;               // Padding mandatory
80004590:	50 01       	stdsp	sp[0x0],r1
   ptr_entry++;   // The long name start at offset 1 of the entry file

   for( u8_id=1; u8_id<FS_SIZE_FILE_ENTRY ; u8_id++ , ptr_entry++ )
   {
      // fields with no character
      if( 11 == u8_id)
80004592:	f2 08 18 00 	cp.b	r8,r9
80004596:	c0 31       	brne	8000459c <fat_create_long_name_entry+0x34>
      {
         *ptr_entry = FS_ATTR_LFN_ENTRY;  // Attribute field
80004598:	b8 83       	st.b	r12[0x0],r3
         continue;
8000459a:	c4 58       	rjmp	80004624 <fat_create_long_name_entry+0xbc>
      }
      if( (12 == u8_id)
8000459c:	ec 08 18 00 	cp.b	r8,r6
800045a0:	5f 00       	sreq	r0
800045a2:	f6 08 18 00 	cp.b	r8,r11
800045a6:	5f 04       	sreq	r4
800045a8:	08 40       	or	r0,r4
800045aa:	00 94       	mov	r4,r0
800045ac:	f4 00 18 00 	cp.b	r0,r10
800045b0:	c3 21       	brne	80004614 <fat_create_long_name_entry+0xac>
800045b2:	ea 08 18 00 	cp.b	r8,r5
800045b6:	c3 70       	breq	80004624 <fat_create_long_name_entry+0xbc>
      {
         // Reserved field
         // *ptr_entry = 0x00;            // No necessary because the cache must be clean
         continue;
      }
      if( 13 == u8_id)
800045b8:	e4 08 18 00 	cp.b	r8,r2
800045bc:	c0 41       	brne	800045c4 <fat_create_long_name_entry+0x5c>
      {
         *ptr_entry = u8_crc;             // CRC field
800045be:	40 34       	lddsp	r4,sp[0xc]
800045c0:	b8 84       	st.b	r12[0x0],r4
         continue;
800045c2:	c3 18       	rjmp	80004624 <fat_create_long_name_entry+0xbc>
      }

      // fields with a character
      if( !b_end_of_name )
800045c4:	40 01       	lddsp	r1,sp[0x0]
800045c6:	58 01       	cp.w	r1,0
800045c8:	c2 41       	brne	80004610 <fat_create_long_name_entry+0xa8>
         uint16_t u16_tmp;
         if( Is_unicode )
         {
            u16_tmp = ((FS_STR_UNICODE)sz_name)[0];
         }else{
            u16_tmp = sz_name[0];
800045ca:	0f 84       	ld.ub	r4,r7[0x0]
800045cc:	fb 54 00 12 	st.h	sp[18],r4
         }
         if(('\\' == u16_tmp )
800045d0:	35 c1       	mov	r1,92
800045d2:	e2 04 19 00 	cp.h	r4,r1
800045d6:	5f 00       	sreq	r0
800045d8:	50 20       	stdsp	sp[0x8],r0
800045da:	32 f0       	mov	r0,47
800045dc:	e0 04 19 00 	cp.h	r4,r0
800045e0:	5f 01       	sreq	r1
800045e2:	40 20       	lddsp	r0,sp[0x8]
800045e4:	02 40       	or	r0,r1
800045e6:	f4 00 18 00 	cp.b	r0,r10
800045ea:	c0 50       	breq	800045f4 <fat_create_long_name_entry+0x8c>
         || ('/'  == u16_tmp ) )
         {  // end of name
            u16_tmp = 0;                  // Set a end of name flag
800045ec:	30 04       	mov	r4,0
800045ee:	fb 54 00 12 	st.h	sp[18],r4
800045f2:	c0 38       	rjmp	800045f8 <fat_create_long_name_entry+0x90>
         }
         if( 0 == u16_tmp )
800045f4:	58 04       	cp.w	r4,0
800045f6:	c0 31       	brne	800045fc <fat_create_long_name_entry+0x94>
800045f8:	30 14       	mov	r4,1
800045fa:	50 04       	stdsp	sp[0x0],r4
         {
            b_end_of_name = true;
         }
         *ptr_entry = LSB(u16_tmp);
800045fc:	fa c4 ff ee 	sub	r4,sp,-18
80004600:	09 90       	ld.ub	r0,r4[0x1]
80004602:	18 c0       	st.b	r12++,r0
         ptr_entry++;
         *ptr_entry = MSB(u16_tmp);
80004604:	09 84       	ld.ub	r4,r4[0x0]
80004606:	b8 84       	st.b	r12[0x0],r4
         u8_id++;
80004608:	2f f8       	sub	r8,-1
8000460a:	5c 58       	castu.b	r8
         sz_name += (Is_unicode? 2 : 1 );
8000460c:	2f f7       	sub	r7,-1
8000460e:	c0 38       	rjmp	80004614 <fat_create_long_name_entry+0xac>
      }
      else
      {  // end of name
         *ptr_entry = 0xFF;               // Padding mandatory
80004610:	3f f1       	mov	r1,-1
80004612:	b8 81       	st.b	r12[0x0],r1
   fat_cache_mark_sector_as_dirty();
   ptr_entry = fat_get_ptr_entry();
   *ptr_entry = u8_id;
   ptr_entry++;   // The long name start at offset 1 of the entry file

   for( u8_id=1; u8_id<FS_SIZE_FILE_ENTRY ; u8_id++ , ptr_entry++ )
80004614:	2f f8       	sub	r8,-1
80004616:	5c 58       	castu.b	r8
80004618:	fc 08 18 00 	cp.b	r8,lr
8000461c:	e0 8b 00 08 	brhi	8000462c <fat_create_long_name_entry+0xc4>
80004620:	2f fc       	sub	r12,-1
80004622:	cb 8b       	rjmp	80004592 <fat_create_long_name_entry+0x2a>
80004624:	2f f8       	sub	r8,-1
80004626:	5c 58       	castu.b	r8
80004628:	2f fc       	sub	r12,-1
8000462a:	cb 4b       	rjmp	80004592 <fat_create_long_name_entry+0x2a>
      else
      {  // end of name
         *ptr_entry = 0xFF;               // Padding mandatory
      }
   } // end of loop
}
8000462c:	2f bd       	sub	sp,-20
8000462e:	d8 32       	popm	r0-r7,pc
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	36 7c       	mov	r12,103
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	33 0c       	mov	r12,48

80004638 <fat_delete_file>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_delete_file( bool b_cluster_list )
{
80004638:	d4 31       	pushm	r0-r7,lr
8000463a:	18 90       	mov	r0,r12
8000463c:	30 04       	mov	r4,0

      // Get pointer on the current entry
      ptr_entry = fat_get_ptr_entry();
      u8_tmp = ptr_entry[0];

      if( (FS_ATTR_LFN_ENTRY != ptr_entry[11])
8000463e:	30 f5       	mov	r5,15
         break;   // Go to delete cluster list
      }

      // Delete entry
      b_short_del = true;
      ptr_entry[0] = FS_ENTRY_DEL;
80004640:	3e 53       	mov	r3,-27
         // It is the last entry of long name
         break;   // Go to delete cluster list
      }

      // Go to previous entry
      fs_g_nav_fast.u16_entry_pos_sel_file--;
80004642:	49 56       	lddpc	r6,80004694 <fat_delete_file+0x5c>
80004644:	30 11       	mov	r1,1

   // loop in directory
   while( 1 )
   {
      // Fill internal cache with a sector from directory
      if( !fat_read_dir() )
80004646:	f0 1f 00 15 	mcall	80004698 <fat_delete_file+0x60>
8000464a:	c2 40       	breq	80004692 <fat_delete_file+0x5a>
         return false;

      // Get pointer on the current entry
      ptr_entry = fat_get_ptr_entry();
8000464c:	f0 1f 00 14 	mcall	8000469c <fat_delete_file+0x64>
      u8_tmp = ptr_entry[0];
80004650:	19 82       	ld.ub	r2,r12[0x0]

      if( (FS_ATTR_LFN_ENTRY != ptr_entry[11])
80004652:	f8 c7 ff f5 	sub	r7,r12,-11
80004656:	0f 88       	ld.ub	r8,r7[0x0]
80004658:	ea 08 18 00 	cp.b	r8,r5
8000465c:	c0 30       	breq	80004662 <fat_delete_file+0x2a>
8000465e:	58 04       	cp.w	r4,0
80004660:	c1 01       	brne	80004680 <fat_delete_file+0x48>
         break;   // Go to delete cluster list
      }

      // Delete entry
      b_short_del = true;
      ptr_entry[0] = FS_ENTRY_DEL;
80004662:	b8 83       	st.b	r12[0x0],r3
      fat_cache_mark_sector_as_dirty();
80004664:	f0 1f 00 0f 	mcall	800046a0 <fat_delete_file+0x68>

      if( (FS_ATTR_LFN_ENTRY == ptr_entry[11])
80004668:	0f 88       	ld.ub	r8,r7[0x0]
8000466a:	ea 08 18 00 	cp.b	r8,r5
8000466e:	c0 41       	brne	80004676 <fat_delete_file+0x3e>
80004670:	e2 12 00 40 	andl	r2,0x40,COH
80004674:	c0 61       	brne	80004680 <fat_delete_file+0x48>
         // It is the last entry of long name
         break;   // Go to delete cluster list
      }

      // Go to previous entry
      fs_g_nav_fast.u16_entry_pos_sel_file--;
80004676:	8c 18       	ld.sh	r8,r6[0x2]
80004678:	20 18       	sub	r8,1
8000467a:	ac 18       	st.h	r6[0x2],r8
8000467c:	02 94       	mov	r4,r1
   }  // end of while(1)
8000467e:	ce 4b       	rjmp	80004646 <fat_delete_file+0xe>

   if( b_cluster_list )
80004680:	58 00       	cp.w	r0,0
80004682:	c0 21       	brne	80004686 <fat_delete_file+0x4e>
80004684:	da 3a       	popm	r0-r7,pc,r12=1
   {
      // Delete cluster list
      fs_g_nav_entry.u32_pos_in_file=0;      // Delete ALL list (start at begining)
80004686:	30 09       	mov	r9,0
80004688:	48 78       	lddpc	r8,800046a4 <fat_delete_file+0x6c>
8000468a:	91 39       	st.w	r8[0xc],r9
      if( !fat_read_file( FS_CLUST_ACT_CLR ))
8000468c:	30 3c       	mov	r12,3
8000468e:	f0 1f 00 07 	mcall	800046a8 <fat_delete_file+0x70>
         return false;
   }

   return true;
}
80004692:	d8 32       	popm	r0-r7,pc
80004694:	00 00       	add	r0,r0
80004696:	0c 80       	andn	r0,r6
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	3e cc       	mov	r12,-20
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	33 0c       	mov	r12,48
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	36 7c       	mov	r12,103
800046a4:	00 00       	add	r0,r0
800046a6:	09 f4       	ld.ub	r4,r4[0x7]
800046a8:	80 00       	ld.sh	r0,r0[0x0]
800046aa:	3f 50       	mov	r0,-11

800046ac <fat_garbage_collector_entry>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool fat_garbage_collector_entry( void )
{
800046ac:	eb cd 40 fc 	pushm	r2-r7,lr
800046b0:	20 8d       	sub	sp,32
800046b2:	30 06       	mov	r6,0
800046b4:	0c 97       	mov	r7,r6

   // Loop in directory
   while( 1 )
   {
      // Go to old entry list
      fs_g_nav_fast.u16_entry_pos_sel_file=u16_pos_old;
800046b6:	4a 95       	lddpc	r5,80004758 <fat_garbage_collector_entry+0xac>
            fs_g_nav_fast.u16_entry_pos_sel_file++;
         }
         return true;  // End of garbage
      }

      if ( FS_ENTRY_DEL != *ptr_entry )
800046b8:	3e 54       	mov	r4,-27
      {
         // entry valid
         if( u16_pos_old != u16_pos_new )
         {
            // A free space exist then move entry
            memcpy_ram2ram( entry, ptr_entry, FS_SIZE_FILE_ENTRY );
800046ba:	1a 93       	mov	r3,sp
800046bc:	32 02       	mov	r2,32

   // Loop in directory
   while( 1 )
   {
      // Go to old entry list
      fs_g_nav_fast.u16_entry_pos_sel_file=u16_pos_old;
800046be:	aa 17       	st.h	r5[0x2],r7
      // Fill internal cache with a sector from directory
      if( !fat_read_dir() )
800046c0:	f0 1f 00 27 	mcall	8000475c <fat_garbage_collector_entry+0xb0>
800046c4:	c0 81       	brne	800046d4 <fat_garbage_collector_entry+0x28>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
800046c6:	4a 78       	lddpc	r8,80004760 <fat_garbage_collector_entry+0xb4>
800046c8:	11 89       	ld.ub	r9,r8[0x0]
800046ca:	31 a8       	mov	r8,26
800046cc:	f0 09 18 00 	cp.b	r9,r8
800046d0:	c3 d1       	brne	8000474a <fat_garbage_collector_entry+0x9e>
800046d2:	c0 68       	rjmp	800046de <fat_garbage_collector_entry+0x32>
            return false;
         goto fat_garbage_collector_entry_endofdir;
      }

      // Check entry
      ptr_entry = fat_get_ptr_entry();
800046d4:	f0 1f 00 24 	mcall	80004764 <fat_garbage_collector_entry+0xb8>

      if ( FS_ENTRY_END == *ptr_entry )
800046d8:	19 88       	ld.ub	r8,r12[0x0]
800046da:	58 08       	cp.w	r8,0
800046dc:	c1 b1       	brne	80004712 <fat_garbage_collector_entry+0x66>
      {
         // The entry is free, then it is the end of entry list
fat_garbage_collector_entry_endofdir:
         // Fill empty entry in old list
         fs_g_nav_fast.u16_entry_pos_sel_file=u16_pos_new;
800046de:	49 f8       	lddpc	r8,80004758 <fat_garbage_collector_entry+0xac>
800046e0:	b0 16       	st.h	r8[0x2],r6
         while( fs_g_nav_fast.u16_entry_pos_sel_file != u16_pos_old )
800046e2:	ec 07 19 00 	cp.h	r7,r6
800046e6:	c3 40       	breq	8000474e <fat_garbage_collector_entry+0xa2>
         {
            // Fill internal cache with a sector from directory
            if( !fat_read_dir() )
               return false;
            memset( fat_get_ptr_entry() , 0 , 32 );
800046e8:	32 05       	mov	r5,32
800046ea:	30 04       	mov	r4,0
            fat_cache_mark_sector_as_dirty();
            fs_g_nav_fast.u16_entry_pos_sel_file++;
800046ec:	49 b6       	lddpc	r6,80004758 <fat_garbage_collector_entry+0xac>
         // Fill empty entry in old list
         fs_g_nav_fast.u16_entry_pos_sel_file=u16_pos_new;
         while( fs_g_nav_fast.u16_entry_pos_sel_file != u16_pos_old )
         {
            // Fill internal cache with a sector from directory
            if( !fat_read_dir() )
800046ee:	f0 1f 00 1c 	mcall	8000475c <fat_garbage_collector_entry+0xb0>
800046f2:	c2 c0       	breq	8000474a <fat_garbage_collector_entry+0x9e>
               return false;
            memset( fat_get_ptr_entry() , 0 , 32 );
800046f4:	f0 1f 00 1c 	mcall	80004764 <fat_garbage_collector_entry+0xb8>
800046f8:	0a 9a       	mov	r10,r5
800046fa:	08 9b       	mov	r11,r4
800046fc:	f0 1f 00 1b 	mcall	80004768 <fat_garbage_collector_entry+0xbc>
            fat_cache_mark_sector_as_dirty();
80004700:	f0 1f 00 1b 	mcall	8000476c <fat_garbage_collector_entry+0xc0>
            fs_g_nav_fast.u16_entry_pos_sel_file++;
80004704:	8c 18       	ld.sh	r8,r6[0x2]
80004706:	2f f8       	sub	r8,-1
80004708:	ac 18       	st.h	r6[0x2],r8
      {
         // The entry is free, then it is the end of entry list
fat_garbage_collector_entry_endofdir:
         // Fill empty entry in old list
         fs_g_nav_fast.u16_entry_pos_sel_file=u16_pos_new;
         while( fs_g_nav_fast.u16_entry_pos_sel_file != u16_pos_old )
8000470a:	f0 07 19 00 	cp.h	r7,r8
8000470e:	cf 01       	brne	800046ee <fat_garbage_collector_entry+0x42>
80004710:	c1 f8       	rjmp	8000474e <fat_garbage_collector_entry+0xa2>
            fs_g_nav_fast.u16_entry_pos_sel_file++;
         }
         return true;  // End of garbage
      }

      if ( FS_ENTRY_DEL != *ptr_entry )
80004712:	e8 08 18 00 	cp.b	r8,r4
80004716:	c1 70       	breq	80004744 <fat_garbage_collector_entry+0x98>
      {
         // entry valid
         if( u16_pos_old != u16_pos_new )
80004718:	ec 07 19 00 	cp.h	r7,r6
8000471c:	c1 20       	breq	80004740 <fat_garbage_collector_entry+0x94>
         {
            // A free space exist then move entry
            memcpy_ram2ram( entry, ptr_entry, FS_SIZE_FILE_ENTRY );
8000471e:	04 9a       	mov	r10,r2
80004720:	18 9b       	mov	r11,r12
80004722:	1a 9c       	mov	r12,sp
80004724:	f0 1f 00 13 	mcall	80004770 <fat_garbage_collector_entry+0xc4>
            fs_g_nav_fast.u16_entry_pos_sel_file=u16_pos_new;
80004728:	aa 16       	st.h	r5[0x2],r6
            // Fill internal cache with a sector from directory
            if( !fat_read_dir() )
8000472a:	f0 1f 00 0d 	mcall	8000475c <fat_garbage_collector_entry+0xb0>
8000472e:	c0 e0       	breq	8000474a <fat_garbage_collector_entry+0x9e>
               return false;
            memcpy_ram2ram( fat_get_ptr_entry(), entry, FS_SIZE_FILE_ENTRY );
80004730:	f0 1f 00 0d 	mcall	80004764 <fat_garbage_collector_entry+0xb8>
80004734:	04 9a       	mov	r10,r2
80004736:	1a 9b       	mov	r11,sp
80004738:	f0 1f 00 0e 	mcall	80004770 <fat_garbage_collector_entry+0xc4>
            fat_cache_mark_sector_as_dirty();
8000473c:	f0 1f 00 0c 	mcall	8000476c <fat_garbage_collector_entry+0xc0>
         }
         u16_pos_new++;
80004740:	2f f6       	sub	r6,-1
80004742:	5c 86       	casts.h	r6
      }
      u16_pos_old++;
80004744:	2f f7       	sub	r7,-1
80004746:	5c 87       	casts.h	r7
   }  // end of while(1)
80004748:	cb bb       	rjmp	800046be <fat_garbage_collector_entry+0x12>
8000474a:	30 0c       	mov	r12,0
8000474c:	c0 28       	rjmp	80004750 <fat_garbage_collector_entry+0xa4>
8000474e:	30 1c       	mov	r12,1
}
80004750:	2f 8d       	sub	sp,-32
80004752:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004756:	00 00       	add	r0,r0
80004758:	00 00       	add	r0,r0
8000475a:	0c 80       	andn	r0,r6
8000475c:	80 00       	ld.sh	r0,r0[0x0]
8000475e:	3e cc       	mov	r12,-20
80004760:	00 00       	add	r0,r0
80004762:	0c 84       	andn	r4,r6
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	33 0c       	mov	r12,48
80004768:	80 01       	ld.sh	r1,r0[0x0]
8000476a:	56 02       	stdsp	sp[0x180],r2
8000476c:	80 00       	ld.sh	r0,r0[0x0]
8000476e:	36 7c       	mov	r12,103
80004770:	80 01       	ld.sh	r1,r0[0x0]
80004772:	54 ba       	stdsp	sp[0x12c],r10

80004774 <fat_write_fat32_FSInfo>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  fat_write_fat32_FSInfo( uint32_t u32_nb_free_cluster )
{
80004774:	eb cd 40 c0 	pushm	r6-r7,lr
80004778:	20 1d       	sub	sp,4
8000477a:	50 0c       	stdsp	sp[0x0],r12
   // Init sector
   fs_gu32_addrsector = fs_g_nav.u32_ptr_fat - fs_g_nav.u16_offset_FSInfo;
8000477c:	49 c8       	lddpc	r8,800047ec <fat_write_fat32_FSInfo+0x78>
8000477e:	90 c9       	ld.uh	r9,r8[0x8]
80004780:	70 4a       	ld.w	r10,r8[0x10]
80004782:	49 c8       	lddpc	r8,800047f0 <fat_write_fat32_FSInfo+0x7c>
80004784:	12 1a       	sub	r10,r9
80004786:	91 0a       	st.w	r8[0x0],r10

   if( !fat_cache_read_sector( false ))
80004788:	30 0c       	mov	r12,0
8000478a:	f0 1f 00 1b 	mcall	800047f4 <fat_write_fat32_FSInfo+0x80>
8000478e:	c2 c0       	breq	800047e6 <fat_write_fat32_FSInfo+0x72>
      return false;
   fat_cache_mark_sector_as_dirty();
80004790:	f0 1f 00 1a 	mcall	800047f8 <fat_write_fat32_FSInfo+0x84>
   fat_cache_clear();
80004794:	f0 1f 00 1a 	mcall	800047fc <fat_write_fat32_FSInfo+0x88>

   // Fill sector
   // offset 00-04, This lead signature
   memcpy_code2ram( &fs_g_sector[0], const_FSI_LeadSig, sizeof(const_FSI_LeadSig) );
80004798:	49 a7       	lddpc	r7,80004800 <fat_write_fat32_FSInfo+0x8c>
8000479a:	30 46       	mov	r6,4
8000479c:	0c 9a       	mov	r10,r6
8000479e:	49 ab       	lddpc	r11,80004804 <fat_write_fat32_FSInfo+0x90>
800047a0:	0e 9c       	mov	r12,r7
800047a2:	f0 1f 00 1a 	mcall	80004808 <fat_write_fat32_FSInfo+0x94>
   // offset 004-483, reserved (fill with 0)
   // offset 484-487, signature
   memcpy_code2ram( &fs_g_sector[484], const_FSI_StrucSig, sizeof(const_FSI_StrucSig) );
800047a6:	0c 9a       	mov	r10,r6
800047a8:	49 9b       	lddpc	r11,8000480c <fat_write_fat32_FSInfo+0x98>
800047aa:	ee cc fe 1c 	sub	r12,r7,-484
800047ae:	f0 1f 00 17 	mcall	80004808 <fat_write_fat32_FSInfo+0x94>
   // offset 488-491, free cluster count (by default NO value)
   fs_g_sector[488] = LSB0(u32_nb_free_cluster);
800047b2:	1b b9       	ld.ub	r9,sp[0x3]
800047b4:	ef 69 01 e8 	st.b	r7[488],r9
   fs_g_sector[489] = LSB1(u32_nb_free_cluster);
800047b8:	1b a9       	ld.ub	r9,sp[0x2]
800047ba:	ef 69 01 e9 	st.b	r7[489],r9
   fs_g_sector[490] = LSB2(u32_nb_free_cluster);
800047be:	1b 99       	ld.ub	r9,sp[0x1]
800047c0:	ef 69 01 ea 	st.b	r7[490],r9
   fs_g_sector[491] = LSB3(u32_nb_free_cluster);
800047c4:	1b 88       	ld.ub	r8,sp[0x0]
800047c6:	ef 68 01 eb 	st.b	r7[491],r8
   // offset 492-495, indicates the cluster number at which the driver should start looking for free clusters (by default NO value)
   memset( &fs_g_sector[492] , 0xFF , 4 );
800047ca:	0c 9a       	mov	r10,r6
800047cc:	e0 6b 00 ff 	mov	r11,255
800047d0:	ee cc fe 14 	sub	r12,r7,-492
800047d4:	f0 1f 00 0f 	mcall	80004810 <fat_write_fat32_FSInfo+0x9c>
   // offset 496-509, reserved (fill with 0)
   // offset 510-511, Signature
   fs_g_sector[510] = FS_BR_SIGNATURE_LOW;
800047d8:	35 58       	mov	r8,85
800047da:	ef 68 01 fe 	st.b	r7[510],r8
   fs_g_sector[511] = FS_BR_SIGNATURE_HIGH;
800047de:	3a a8       	mov	r8,-86
800047e0:	ef 68 01 ff 	st.b	r7[511],r8
800047e4:	30 1c       	mov	r12,1
   return true;
}
800047e6:	2f fd       	sub	sp,-4
800047e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047ec:	00 00       	add	r0,r0
800047ee:	0c 34       	cp.w	r4,r6
800047f0:	00 00       	add	r0,r0
800047f2:	09 f0       	ld.ub	r0,r4[0x7]
800047f4:	80 00       	ld.sh	r0,r0[0x0]
800047f6:	38 9c       	mov	r12,-119
800047f8:	80 00       	ld.sh	r0,r0[0x0]
800047fa:	36 7c       	mov	r12,103
800047fc:	80 00       	ld.sh	r0,r0[0x0]
800047fe:	38 84       	mov	r4,-120
80004800:	00 00       	add	r0,r0
80004802:	0a 34       	cp.w	r4,r5
80004804:	80 01       	ld.sh	r1,r0[0x0]
80004806:	dc 38       	*unknown*
80004808:	80 01       	ld.sh	r1,r0[0x0]
8000480a:	54 ba       	stdsp	sp[0x12c],r10
8000480c:	80 01       	ld.sh	r1,r0[0x0]
8000480e:	dc 4c       	*unknown*
80004810:	80 01       	ld.sh	r1,r0[0x0]
80004812:	56 02       	stdsp	sp[0x180],r2

80004814 <fat_allocfreespace>:
//!   fs_g_seg.u32_addr          Return the first cluster value of the new cluster list
//!   fs_g_seg.u32_size_or_pos   The number of sector remaining (no allocated sectors, because disk fragmented or disk full)
//! @endverbatim
//!
bool  fat_allocfreespace( void )
{
80004814:	d4 31       	pushm	r0-r7,lr
   // Flag to signal the first step which search the first free cluster of the new list
   bool first_cluster_free_is_found = false;
   // If true then use a quick procedure but don't scan all FAT else use a slow procedure but scan all FAT
   bool b_quick_find = true;

   if( Is_fat32 )
80004816:	4c 78       	lddpc	r8,80004930 <fat_allocfreespace+0x11c>
80004818:	11 89       	ld.ub	r9,r8[0x0]
8000481a:	30 38       	mov	r8,3
8000481c:	f0 09 18 00 	cp.b	r9,r8
80004820:	c0 61       	brne	8000482c <fat_allocfreespace+0x18>
   {
      // Clear info about free space
      if( !fat_write_fat32_FSInfo( 0xFFFFFFFF ))
80004822:	3f fc       	mov	r12,-1
80004824:	f0 1f 00 44 	mcall	80004934 <fat_allocfreespace+0x120>
80004828:	e0 80 00 83 	breq	8000492e <fat_allocfreespace+0x11a>
         return false;
   }

   if( 0xFF == MSB0(fs_g_seg.u32_addr) )
8000482c:	4c 31       	lddpc	r1,80004938 <fat_allocfreespace+0x124>
8000482e:	03 89       	ld.ub	r9,r1[0x0]
80004830:	3f f8       	mov	r8,-1
80004832:	f0 09 18 00 	cp.b	r9,r8
80004836:	c0 61       	brne	80004842 <fat_allocfreespace+0x2e>
80004838:	30 10       	mov	r0,1
   {
fat_allocfreespace_start:
      // New cluster list, then research at the beginning of FAT
      fs_g_cluster.u32_pos = 2;
8000483a:	30 29       	mov	r9,2
8000483c:	4c 08       	lddpc	r8,8000493c <fat_allocfreespace+0x128>
8000483e:	91 09       	st.w	r8[0x0],r9
80004840:	c0 78       	rjmp	8000484e <fat_allocfreespace+0x3a>
   }else{
      // Continue the cluster list then start after the end of the cluster list
      fs_g_cluster.u32_pos = fs_g_seg.u32_addr+1;
80004842:	4b e8       	lddpc	r8,80004938 <fat_allocfreespace+0x124>
80004844:	70 09       	ld.w	r9,r8[0x0]
80004846:	2f f9       	sub	r9,-1
80004848:	4b d8       	lddpc	r8,8000493c <fat_allocfreespace+0x128>
8000484a:	91 09       	st.w	r8[0x0],r9
8000484c:	30 10       	mov	r0,1
   }

   fat_clear_info_fat_mod();
8000484e:	f0 1f 00 3d 	mcall	80004940 <fat_allocfreespace+0x12c>

   // Read ALL FAT1
   for(
80004852:	4b b8       	lddpc	r8,8000493c <fat_allocfreespace+0x128>
80004854:	70 09       	ld.w	r9,r8[0x0]
80004856:	4b c8       	lddpc	r8,80004944 <fat_allocfreespace+0x130>
80004858:	70 38       	ld.w	r8,r8[0xc]
8000485a:	10 39       	cp.w	r9,r8
8000485c:	c5 e2       	brcc	80004918 <fat_allocfreespace+0x104>
8000485e:	30 04       	mov	r4,0
   ;     fs_g_cluster.u32_pos < fs_g_nav.u32_CountofCluster
   ;     fs_g_cluster.u32_pos++ )
   {
      // Get the value of the cluster
      if ( !fat_cluster_val( FS_CLUST_VAL_READ ) )
80004860:	08 92       	mov	r2,r4
         return false;

      if ( 0 == fs_g_cluster.u32_val )
80004862:	4b 77       	lddpc	r7,8000493c <fat_allocfreespace+0x128>
         }

         // At the new cluster position, set the flag end of list
         fs_g_cluster.u32_pos = fs_g_cluster.u32_val;    // Select the new cluster
         fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;        // Cluster value is the flag end of list
         if ( !fat_cluster_val( FS_CLUST_VAL_WRITE ) )
80004864:	30 13       	mov	r3,1
            return false;

         // Compute the remaining sectors
         if ( fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus )
80004866:	4b 55       	lddpc	r5,80004938 <fat_allocfreespace+0x124>
80004868:	4b 76       	lddpc	r6,80004944 <fat_allocfreespace+0x130>
   for(
   ;     fs_g_cluster.u32_pos < fs_g_nav.u32_CountofCluster
   ;     fs_g_cluster.u32_pos++ )
   {
      // Get the value of the cluster
      if ( !fat_cluster_val( FS_CLUST_VAL_READ ) )
8000486a:	04 9c       	mov	r12,r2
8000486c:	f0 1f 00 37 	mcall	80004948 <fat_allocfreespace+0x134>
80004870:	c5 f0       	breq	8000492e <fat_allocfreespace+0x11a>
         return false;

      if ( 0 == fs_g_cluster.u32_val )
80004872:	6e 18       	ld.w	r8,r7[0x4]
80004874:	58 08       	cp.w	r8,0
80004876:	c4 01       	brne	800048f6 <fat_allocfreespace+0xe2>
      {
         // A free cluster is found
         fs_g_cluster.u32_val = fs_g_cluster.u32_pos;    // value of the cluster is the new free cluster
80004878:	6e 08       	ld.w	r8,r7[0x0]
8000487a:	8f 18       	st.w	r7[0x4],r8
         if( true == first_cluster_free_is_found )
8000487c:	58 04       	cp.w	r4,0
8000487e:	c0 80       	breq	8000488e <fat_allocfreespace+0x7a>
         {
            // Link the new cluster with previous cluster
            fs_g_cluster.u32_pos--;                      // select the previous cluster
80004880:	20 18       	sub	r8,1
80004882:	8f 08       	st.w	r7[0x0],r8
            if ( !fat_cluster_val( FS_CLUST_VAL_WRITE ) )
80004884:	06 9c       	mov	r12,r3
80004886:	f0 1f 00 31 	mcall	80004948 <fat_allocfreespace+0x134>
8000488a:	c1 e1       	brne	800048c6 <fat_allocfreespace+0xb2>
8000488c:	c5 18       	rjmp	8000492e <fat_allocfreespace+0x11a>
         else
         {
            // It is the first cluster of the new list
            first_cluster_free_is_found = true;

            if( 0xFF != MSB0(fs_g_seg.u32_addr) )
8000488e:	03 88       	ld.ub	r8,r1[0x0]
80004890:	3f f9       	mov	r9,-1
80004892:	f2 08 18 00 	cp.b	r8,r9
80004896:	c1 60       	breq	800048c2 <fat_allocfreespace+0xae>
            {
               // Link this new cluster with the current cluster list
               // Select the last cluster of the current list
               if( 0 == fs_g_seg.u32_addr )
80004898:	6a 08       	ld.w	r8,r5[0x0]
8000489a:	58 08       	cp.w	r8,0
8000489c:	c0 e1       	brne	800048b8 <fat_allocfreespace+0xa4>
               {  // The current cluster list is the cluster list of root directory
                  if( FS_TYPE_FAT_32 != fs_g_nav_fast.u8_type_fat )
8000489e:	4a 59       	lddpc	r9,80004930 <fat_allocfreespace+0x11c>
800048a0:	13 88       	ld.ub	r8,r9[0x0]
800048a2:	30 39       	mov	r9,3
800048a4:	f2 08 18 00 	cp.b	r8,r9
800048a8:	c0 50       	breq	800048b2 <fat_allocfreespace+0x9e>
                  {
                     // Impossible to increment ROOT DIR size of FAT12 or FAT16
                     fs_g_status = FS_ERR_NO_FREE_SPACE;
800048aa:	31 b9       	mov	r9,27
800048ac:	4a 88       	lddpc	r8,8000494c <fat_allocfreespace+0x138>
800048ae:	b0 89       	st.b	r8[0x0],r9
800048b0:	d8 3a       	popm	r0-r7,pc,r12=0
                     return false;
                  }
                  fs_g_cluster.u32_pos = fs_g_nav.rootdir.u32_cluster;
800048b2:	6c 68       	ld.w	r8,r6[0x18]
800048b4:	8f 08       	st.w	r7[0x0],r8
800048b6:	c0 28       	rjmp	800048ba <fat_allocfreespace+0xa6>
               }
               else
               {
                  fs_g_cluster.u32_pos = fs_g_seg.u32_addr;
800048b8:	8f 08       	st.w	r7[0x0],r8
               }
               if ( !fat_cluster_val( FS_CLUST_VAL_WRITE ) )
800048ba:	06 9c       	mov	r12,r3
800048bc:	f0 1f 00 23 	mcall	80004948 <fat_allocfreespace+0x134>
800048c0:	c3 70       	breq	8000492e <fat_allocfreespace+0x11a>
                  return false;
            }  // else no writing the first cluster value in FAT because no current cluster list
            fs_g_seg.u32_addr = fs_g_cluster.u32_val;    // save the first cluster value
800048c2:	6e 18       	ld.w	r8,r7[0x4]
800048c4:	8b 08       	st.w	r5[0x0],r8
         }

         // At the new cluster position, set the flag end of list
         fs_g_cluster.u32_pos = fs_g_cluster.u32_val;    // Select the new cluster
800048c6:	6e 18       	ld.w	r8,r7[0x4]
800048c8:	8f 08       	st.w	r7[0x0],r8
         fs_g_cluster.u32_val = FS_CLUST_VAL_EOL;        // Cluster value is the flag end of list
800048ca:	e0 68 ff ff 	mov	r8,65535
800048ce:	ea 18 0f ff 	orh	r8,0xfff
800048d2:	8f 18       	st.w	r7[0x4],r8
         if ( !fat_cluster_val( FS_CLUST_VAL_WRITE ) )
800048d4:	06 9c       	mov	r12,r3
800048d6:	f0 1f 00 1d 	mcall	80004948 <fat_allocfreespace+0x134>
800048da:	c2 a0       	breq	8000492e <fat_allocfreespace+0x11a>
            return false;

         // Compute the remaining sectors
         if ( fs_g_seg.u32_size_or_pos <= fs_g_nav.u8_BPB_SecPerClus )
800048dc:	6a 19       	ld.w	r9,r5[0x4]
800048de:	0d 98       	ld.ub	r8,r6[0x1]
800048e0:	10 39       	cp.w	r9,r8
800048e2:	e0 8b 00 06 	brhi	800048ee <fat_allocfreespace+0xda>
         {
            fs_g_seg.u32_size_or_pos = 0; // All space found
800048e6:	30 09       	mov	r9,0
800048e8:	49 48       	lddpc	r8,80004938 <fat_allocfreespace+0x124>
800048ea:	91 19       	st.w	r8[0x4],r9
            break;                        // Stop loop
800048ec:	c1 e8       	rjmp	80004928 <fat_allocfreespace+0x114>
         }
         fs_g_seg.u32_size_or_pos -= fs_g_nav.u8_BPB_SecPerClus;
800048ee:	10 19       	sub	r9,r8
800048f0:	8b 19       	st.w	r5[0x4],r9
800048f2:	06 94       	mov	r4,r3
800048f4:	c0 98       	rjmp	80004906 <fat_allocfreespace+0xf2>
      }
      else
      {
         // The next cluster is not free
         if( true == first_cluster_free_is_found )
800048f6:	58 04       	cp.w	r4,0
800048f8:	c1 81       	brne	80004928 <fat_allocfreespace+0x114>
         }
         else
         {
            // It is the first step to search the first free cluster
            // then ignore this cluster no free and continue search
            if( b_quick_find )
800048fa:	58 00       	cp.w	r0,0
800048fc:	c0 50       	breq	80004906 <fat_allocfreespace+0xf2>
            {
               fs_g_cluster.u32_pos += 500;
800048fe:	6e 08       	ld.w	r8,r7[0x0]
80004900:	f0 c8 fe 0c 	sub	r8,r8,-500
80004904:	8f 08       	st.w	r7[0x0],r8
   fat_clear_info_fat_mod();

   // Read ALL FAT1
   for(
   ;     fs_g_cluster.u32_pos < fs_g_nav.u32_CountofCluster
   ;     fs_g_cluster.u32_pos++ )
80004906:	6e 08       	ld.w	r8,r7[0x0]
80004908:	2f f8       	sub	r8,-1
8000490a:	8f 08       	st.w	r7[0x0],r8
   }

   fat_clear_info_fat_mod();

   // Read ALL FAT1
   for(
8000490c:	6c 39       	ld.w	r9,r6[0xc]
8000490e:	10 39       	cp.w	r9,r8
80004910:	fe 9b ff ad 	brhi	8000486a <fat_allocfreespace+0x56>
         }
      }
   }

   // End of alloc
   if( false == first_cluster_free_is_found )
80004914:	58 04       	cp.w	r4,0
80004916:	c0 91       	brne	80004928 <fat_allocfreespace+0x114>
   {
      if( b_quick_find )
80004918:	58 00       	cp.w	r0,0
8000491a:	c0 30       	breq	80004920 <fat_allocfreespace+0x10c>
8000491c:	30 00       	mov	r0,0
8000491e:	c8 eb       	rjmp	8000483a <fat_allocfreespace+0x26>
      {
         // Retry in normal mode to scan all FAT (= no quick mode)
         b_quick_find = false;
         goto fat_allocfreespace_start;
      }
      fs_g_status = FS_ERR_NO_FREE_SPACE; // NO FREE CLUSTER FIND
80004920:	31 b9       	mov	r9,27
80004922:	48 b8       	lddpc	r8,8000494c <fat_allocfreespace+0x138>
80004924:	b0 89       	st.b	r8[0x0],r9
80004926:	d8 3a       	popm	r0-r7,pc,r12=0
      return false;
   }

   return fat_update_fat2();
80004928:	f0 1f 00 0a 	mcall	80004950 <fat_allocfreespace+0x13c>
8000492c:	d8 32       	popm	r0-r7,pc
8000492e:	d8 3a       	popm	r0-r7,pc,r12=0
80004930:	00 00       	add	r0,r0
80004932:	0c 80       	andn	r0,r6
80004934:	80 00       	ld.sh	r0,r0[0x0]
80004936:	47 74       	lddsp	r4,sp[0x1dc]
80004938:	00 00       	add	r0,r0
8000493a:	0c dc       	st.w	--r6,r12
8000493c:	00 00       	add	r0,r0
8000493e:	0c d4       	st.w	--r6,r4
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	43 d0       	lddsp	r0,sp[0xf4]
80004944:	00 00       	add	r0,r0
80004946:	0c 34       	cp.w	r4,r6
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	39 b0       	mov	r0,-101
8000494c:	00 00       	add	r0,r0
8000494e:	0c 84       	andn	r4,r6
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	44 5c       	lddsp	r12,sp[0x114]

80004954 <fat_alloc_entry_free>:
//! @verbatim
//! OUT: Initialize the system on the last alloced free entry
//! @endverbatim
//!
bool  fat_alloc_entry_free( uint8_t u8_nb_entry )
{
80004954:	d4 31       	pushm	r0-r7,lr
80004956:	20 1d       	sub	sp,4
   uint8_t u8_nb_entry_save;

   u8_nb_entry_save = u8_nb_entry;

   // Start at the beginning of dir
   fs_g_nav_fast.u16_entry_pos_sel_file=0;
80004958:	30 09       	mov	r9,0
8000495a:	4a 38       	lddpc	r8,800049e4 <fat_alloc_entry_free+0x90>
8000495c:	b0 19       	st.h	r8[0x2],r9
8000495e:	18 92       	mov	r2,r12
80004960:	30 04       	mov	r4,0
   while( 1 )
   {
      // Fill internal cache with a sector from directory
      if( !fat_read_dir() )
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
80004962:	4a 26       	lddpc	r6,800049e8 <fat_alloc_entry_free+0x94>
80004964:	31 a3       	mov	r3,26
            return false;

         // The position is outside the cluster list
         // then alloc a new sector (= new cluster)
         // Remark: The fs_g_seg.u32_addr contains the last cluster value of a directory list to link with the new list
         fs_g_seg.u32_size_or_pos = 1;
80004966:	4a 21       	lddpc	r1,800049ec <fat_alloc_entry_free+0x98>
80004968:	30 15       	mov	r5,1
            if( b_garbage_collector_used )
               return false;
            if( !fat_garbage_collector_entry())
               return false;
            b_garbage_collector_used = true;
            fs_g_nav_fast.u16_entry_pos_sel_file=0;
8000496a:	10 97       	mov	r7,r8
8000496c:	12 90       	mov	r0,r9
8000496e:	50 0c       	stdsp	sp[0x0],r12
   fs_g_nav_fast.u16_entry_pos_sel_file=0;
   // Loop in directory
   while( 1 )
   {
      // Fill internal cache with a sector from directory
      if( !fat_read_dir() )
80004970:	f0 1f 00 20 	mcall	800049f0 <fat_alloc_entry_free+0x9c>
80004974:	c1 61       	brne	800049a0 <fat_alloc_entry_free+0x4c>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
80004976:	0d 88       	ld.ub	r8,r6[0x0]
80004978:	e6 08 18 00 	cp.b	r8,r3
8000497c:	c3 11       	brne	800049de <fat_alloc_entry_free+0x8a>
            return false;

         // The position is outside the cluster list
         // then alloc a new sector (= new cluster)
         // Remark: The fs_g_seg.u32_addr contains the last cluster value of a directory list to link with the new list
         fs_g_seg.u32_size_or_pos = 1;
8000497e:	83 15       	st.w	r1[0x4],r5
         if( !fat_allocfreespace())
80004980:	f0 1f 00 1d 	mcall	800049f4 <fat_alloc_entry_free+0xa0>
80004984:	c0 a1       	brne	80004998 <fat_alloc_entry_free+0x44>
         {
            // Garbage collector on entry file
            if( b_garbage_collector_used )
80004986:	58 04       	cp.w	r4,0
80004988:	c2 b1       	brne	800049de <fat_alloc_entry_free+0x8a>
               return false;
            if( !fat_garbage_collector_entry())
8000498a:	f0 1f 00 1c 	mcall	800049f8 <fat_alloc_entry_free+0xa4>
8000498e:	c2 80       	breq	800049de <fat_alloc_entry_free+0x8a>
               return false;
            b_garbage_collector_used = true;
            fs_g_nav_fast.u16_entry_pos_sel_file=0;
80004990:	ae 10       	st.h	r7[0x2],r0
80004992:	40 02       	lddsp	r2,sp[0x0]
80004994:	0a 94       	mov	r4,r5
            u8_nb_entry = u8_nb_entry_save;
            continue;
80004996:	ce db       	rjmp	80004970 <fat_alloc_entry_free+0x1c>
         }

         // Clean this new cluster
         // Remark: The fs_g_seg.u32_addr contains the new cluster value
         if( !fat_clear_cluster())
80004998:	f0 1f 00 19 	mcall	800049fc <fat_alloc_entry_free+0xa8>
8000499c:	ce a1       	brne	80004970 <fat_alloc_entry_free+0x1c>
8000499e:	c2 08       	rjmp	800049de <fat_alloc_entry_free+0x8a>

         continue;  // Rescan the directory list to find the new allocated sector
      }

      // Check entry
      ptr_entry = fat_get_ptr_entry();
800049a0:	f0 1f 00 18 	mcall	80004a00 <fat_alloc_entry_free+0xac>
      if ( FS_ENTRY_END == *ptr_entry )
800049a4:	19 88       	ld.ub	r8,r12[0x0]
800049a6:	30 09       	mov	r9,0
800049a8:	f2 08 18 00 	cp.b	r8,r9
800049ac:	c0 61       	brne	800049b8 <fat_alloc_entry_free+0x64>
      {  // The entry is free
         u8_nb_entry--;
800049ae:	20 12       	sub	r2,1
800049b0:	5c 52       	castu.b	r2
         if( 0 == u8_nb_entry )
800049b2:	c0 31       	brne	800049b8 <fat_alloc_entry_free+0x64>
800049b4:	30 1c       	mov	r12,1
800049b6:	c1 58       	rjmp	800049e0 <fat_alloc_entry_free+0x8c>
            return true;  // All free entry is found
         }
      }

      // go to next entry
      fs_g_nav_fast.u16_entry_pos_sel_file++;
800049b8:	8e 18       	ld.sh	r8,r7[0x2]
800049ba:	2f f8       	sub	r8,-1
800049bc:	5c 88       	casts.h	r8
800049be:	ae 18       	st.h	r7[0x2],r8
      if( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
800049c0:	cd 81       	brne	80004970 <fat_alloc_entry_free+0x1c>
      {
         // Here, the directory have the maximum size
         // Garbage collector on entry file
         if( b_garbage_collector_used )
800049c2:	58 04       	cp.w	r4,0
800049c4:	c0 60       	breq	800049d0 <fat_alloc_entry_free+0x7c>
         {
            // Directory full (FAT Norm limit directory to 65535 entrys)
            fs_g_status = FS_ERR_NO_FREE_SPACE;
800049c6:	31 b9       	mov	r9,27
800049c8:	48 88       	lddpc	r8,800049e8 <fat_alloc_entry_free+0x94>
800049ca:	b0 89       	st.b	r8[0x0],r9
800049cc:	30 0c       	mov	r12,0
            return false;
800049ce:	c0 98       	rjmp	800049e0 <fat_alloc_entry_free+0x8c>
         }
         if( !fat_garbage_collector_entry())
800049d0:	f0 1f 00 0a 	mcall	800049f8 <fat_alloc_entry_free+0xa4>
800049d4:	c0 50       	breq	800049de <fat_alloc_entry_free+0x8a>
            return false;
         b_garbage_collector_used = true;
         fs_g_nav_fast.u16_entry_pos_sel_file=0;
800049d6:	ae 10       	st.h	r7[0x2],r0
800049d8:	40 02       	lddsp	r2,sp[0x0]
800049da:	0a 94       	mov	r4,r5
800049dc:	cc ab       	rjmp	80004970 <fat_alloc_entry_free+0x1c>
800049de:	30 0c       	mov	r12,0
         u8_nb_entry = u8_nb_entry_save;
         continue;
      }
   }  // end of while(1)
}
800049e0:	2f fd       	sub	sp,-4
800049e2:	d8 32       	popm	r0-r7,pc
800049e4:	00 00       	add	r0,r0
800049e6:	0c 80       	andn	r0,r6
800049e8:	00 00       	add	r0,r0
800049ea:	0c 84       	andn	r4,r6
800049ec:	00 00       	add	r0,r0
800049ee:	0c dc       	st.w	--r6,r12
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	3e cc       	mov	r12,-20
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	48 14       	lddpc	r4,800049f8 <fat_alloc_entry_free+0xa4>
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	46 ac       	lddsp	r12,sp[0x1a8]
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	43 e8       	lddsp	r8,sp[0xf8]
80004a00:	80 00       	ld.sh	r0,r0[0x0]
80004a02:	33 0c       	mov	r12,48

80004a04 <fat_check_name>:
//!
//! @return    number of entry file to store the name (short + long name) <br>
//!            if name incorrect then 0 is returned.
//!
uint8_t    fat_check_name( FS_STRING sz_name  )
{
80004a04:	d4 31       	pushm	r0-r7,lr
80004a06:	18 94       	mov	r4,r12
      if( fat_check_eof_name( u16_character ) )
         break;

      for( u8_j = 0 ; u8_j < sizeof(fs_s_tab_incorrect_char) ; u8_j++ )
      {
         if( u16_character == fs_s_tab_incorrect_char[u8_j] )
80004a08:	33 a2       	mov	r2,58
80004a0a:	30 d5       	mov	r5,13
80004a0c:	30 23       	mov	r3,2
80004a0e:	49 86       	lddpc	r6,80004a6c <fat_check_name+0x68>
80004a10:	ec c1 ff ff 	sub	r1,r6,-1
//! @param     sz_name     original name to create
//!
//! @return    number of entry file to store the name (short + long name) <br>
//!            if name incorrect then 0 is returned.
//!
uint8_t    fat_check_name( FS_STRING sz_name  )
80004a14:	2f 96       	sub	r6,-7
            return 0;      // incorrect character
         }
      }
      if( 0 == u8_i )
      {
         u8_nb_entry++;
80004a16:	0a 90       	mov	r0,r5
   {
      if( Is_unicode )
      {
         u16_character = ((FS_STR_UNICODE)sz_name)[0];
      }else{
         u16_character = sz_name[0];
80004a18:	09 87       	ld.ub	r7,r4[0x0]
      }
      if( fat_check_eof_name( u16_character ) )
80004a1a:	0e 9c       	mov	r12,r7
80004a1c:	f0 1f 00 15 	mcall	80004a70 <fat_check_name+0x6c>
80004a20:	c1 a1       	brne	80004a54 <fat_check_name+0x50>
         break;

      for( u8_j = 0 ; u8_j < sizeof(fs_s_tab_incorrect_char) ; u8_j++ )
      {
         if( u16_character == fs_s_tab_incorrect_char[u8_j] )
80004a22:	ee 02 19 00 	cp.h	r2,r7
80004a26:	c0 60       	breq	80004a32 <fat_check_name+0x2e>
80004a28:	02 98       	mov	r8,r1
80004a2a:	11 89       	ld.ub	r9,r8[0x0]
80004a2c:	ee 09 19 00 	cp.h	r9,r7
80004a30:	c0 61       	brne	80004a3c <fat_check_name+0x38>
         {
            fs_g_status = FS_ERR_INCORRECT_NAME;
80004a32:	31 c9       	mov	r9,28
80004a34:	49 08       	lddpc	r8,80004a74 <fat_check_name+0x70>
80004a36:	b0 89       	st.b	r8[0x0],r9
80004a38:	30 03       	mov	r3,0
            return 0;      // incorrect character
80004a3a:	c1 68       	rjmp	80004a66 <fat_check_name+0x62>
80004a3c:	2f f8       	sub	r8,-1
         u16_character = sz_name[0];
      }
      if( fat_check_eof_name( u16_character ) )
         break;

      for( u8_j = 0 ; u8_j < sizeof(fs_s_tab_incorrect_char) ; u8_j++ )
80004a3e:	0c 38       	cp.w	r8,r6
80004a40:	cf 51       	brne	80004a2a <fat_check_name+0x26>
         {
            fs_g_status = FS_ERR_INCORRECT_NAME;
            return 0;      // incorrect character
         }
      }
      if( 0 == u8_i )
80004a42:	58 05       	cp.w	r5,0
80004a44:	c0 41       	brne	80004a4c <fat_check_name+0x48>
      {
         u8_nb_entry++;
80004a46:	2f f3       	sub	r3,-1
80004a48:	5c 53       	castu.b	r3
80004a4a:	00 95       	mov	r5,r0
         u8_i = FS_SIZE_LFN_ENTRY;
      }
      u8_i--;
80004a4c:	20 15       	sub	r5,1
80004a4e:	5c 55       	castu.b	r5
      sz_name += (Is_unicode? 2 : 1 );
80004a50:	2f f4       	sub	r4,-1
   }
80004a52:	ce 3b       	rjmp	80004a18 <fat_check_name+0x14>
   if( 0x14 < u8_nb_entry )
80004a54:	31 48       	mov	r8,20
80004a56:	f0 03 18 00 	cp.b	r3,r8
80004a5a:	e0 88 00 06 	brls	80004a66 <fat_check_name+0x62>
   {
      fs_g_status = FS_ERR_NAME_TOO_LARGE;
80004a5e:	32 b9       	mov	r9,43
80004a60:	48 58       	lddpc	r8,80004a74 <fat_check_name+0x70>
80004a62:	b0 89       	st.b	r8[0x0],r9
80004a64:	30 03       	mov	r3,0
      return 0;            // Name too large
   }
   return u8_nb_entry;
}
80004a66:	06 9c       	mov	r12,r3
80004a68:	d8 32       	popm	r0-r7,pc
80004a6a:	00 00       	add	r0,r0
80004a6c:	80 01       	ld.sh	r1,r0[0x0]
80004a6e:	dc 3c       	*unknown*
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	32 e4       	mov	r4,46
80004a74:	00 00       	add	r0,r0
80004a76:	0c 84       	andn	r4,r6

80004a78 <fat_create_short_entry_name>:
//!                           false to write in internal cache
//!
//! @return    short name CRC
//!
uint8_t    fat_create_short_entry_name( FS_STRING sz_name , FS_STRING short_name , uint8_t nb , bool mode  )
{
80004a78:	d4 31       	pushm	r0-r7,lr
80004a7a:	20 8d       	sub	sp,32
80004a7c:	18 94       	mov	r4,r12
80004a7e:	50 2b       	stdsp	sp[0x8],r11
80004a80:	14 97       	mov	r7,r10
80004a82:	50 09       	stdsp	sp[0x0],r9
   PTR_CACHE ptr_entry = 0;
   uint8_t u8_i, u8_step, character;
   uint8_t crc;
   uint8_t nb_digit;

   if( !mode )
80004a84:	58 09       	cp.w	r9,0
80004a86:	c0 40       	breq	80004a8e <fat_create_short_entry_name+0x16>
80004a88:	30 09       	mov	r9,0
80004a8a:	50 19       	stdsp	sp[0x4],r9
80004a8c:	c0 68       	rjmp	80004a98 <fat_create_short_entry_name+0x20>
   {
      // Modify internal cache to create short name entry in the current entry
      fat_cache_mark_sector_as_dirty();
80004a8e:	f0 1f 00 66 	mcall	80004c24 <fat_create_short_entry_name+0x1ac>
      // Get pointer on current entry
      ptr_entry = fat_get_ptr_entry();
80004a92:	f0 1f 00 66 	mcall	80004c28 <fat_create_short_entry_name+0x1b0>
80004a96:	50 1c       	stdsp	sp[0x4],r12
   }

   // Compute the digit number
   if( nb < 10 )        nb_digit = 1;
80004a98:	30 98       	mov	r8,9
80004a9a:	f0 07 18 00 	cp.b	r7,r8
80004a9e:	e0 8b 00 04 	brhi	80004aa6 <fat_create_short_entry_name+0x2e>
80004aa2:	30 18       	mov	r8,1
80004aa4:	c0 88       	rjmp	80004ab4 <fat_create_short_entry_name+0x3c>
   else if( nb < 100 )  nb_digit = 2;
80004aa6:	36 38       	mov	r8,99
80004aa8:	ee 08 18 00 	cp.b	r8,r7
80004aac:	f9 b8 02 02 	movhs	r8,2
80004ab0:	f9 b8 03 03 	movlo	r8,3
         }
         character = ' ';
      }
      if( 5 == u8_step )
      {  // step 4 = add unit 1 of number
         character = '0'+(nb%10);
80004ab4:	e0 6a cc cd 	mov	r10,52429
80004ab8:	ea 1a cc cc 	orh	r10,0xcccc
80004abc:	ee 0a 06 42 	mulu.d	r2,r7,r10
80004ac0:	e6 09 16 03 	lsr	r9,r3,0x3
80004ac4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80004ac8:	ee 09 01 19 	sub	r9,r7,r9<<0x1
80004acc:	2d 09       	sub	r9,-48
80004ace:	5c 59       	castu.b	r9
80004ad0:	50 69       	stdsp	sp[0x18],r9
         u8_step++;                                      // go to next step
      }
      if( 4 == u8_step )
      {  // step 3 = add unit 10 of number
         character = '0'+((nb%100)/10);
80004ad2:	e0 63 85 1f 	mov	r3,34079
80004ad6:	ea 13 51 eb 	orh	r3,0x51eb
80004ada:	ee 03 06 42 	mulu.d	r2,r7,r3
80004ade:	e6 09 16 05 	lsr	r9,r3,0x5
80004ae2:	f2 0b 10 64 	mul	r11,r9,100
80004ae6:	ee 0b 01 0b 	sub	r11,r7,r11
80004aea:	5c 5b       	castu.b	r11
80004aec:	f6 0a 06 4a 	mulu.d	r10,r11,r10
80004af0:	f6 0a 16 03 	lsr	r10,r11,0x3
80004af4:	2d 0a       	sub	r10,-48
80004af6:	5c 5a       	castu.b	r10
80004af8:	50 5a       	stdsp	sp[0x14],r10
         u8_step++;                                      // go to next step
      }
      if( 3 == u8_step )
      {  // step 2 = add unit 100 of number
         character = '0'+(nb/100);
80004afa:	2d 09       	sub	r9,-48
80004afc:	5c 59       	castu.b	r9
80004afe:	50 49       	stdsp	sp[0x10],r9
80004b00:	30 01       	mov	r1,0
80004b02:	30 17       	mov	r7,1
80004b04:	02 95       	mov	r5,r1
         character = ((FS_STR_UNICODE)sz_name)[0];
      }else{
         character = sz_name[0];
      }

      if( 1 == u8_step )
80004b06:	30 13       	mov	r3,1
      {  // step 1 = translate the name
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT-(1+nb_digit)) == u8_i)    // name field is full (-2 for "~1")
80004b08:	f0 09 11 ff 	rsub	r9,r8,-1
80004b0c:	2f 89       	sub	r9,-8
80004b0e:	50 39       	stdsp	sp[0xc],r9
80004b10:	32 e0       	mov	r0,46
         {
            u8_step++;                                   // go to next step
            continue;
         }
      }
      if( 8 == u8_step )
80004b12:	30 82       	mov	r2,8
         u8_step++;                                      // go to next step
      }
      if( 2 == u8_step )
      {  // step 2 = add character '~'
         character = '~';
         u8_step+=(4-nb_digit);                          // go to next step
80004b14:	f0 08 11 06 	rsub	r8,r8,6
80004b18:	5c 58       	castu.b	r8
80004b1a:	50 78       	stdsp	sp[0x1c],r8
80004b1c:	c0 28       	rjmp	80004b20 <fat_create_short_entry_name+0xa8>
         character = '0'+((nb%100)/10);
         u8_step++;                                      // go to next step
      }
      if( 3 == u8_step )
      {  // step 2 = add unit 100 of number
         character = '0'+(nb/100);
80004b1e:	30 77       	mov	r7,7
   {
      if( Is_unicode )
      {
         character = ((FS_STR_UNICODE)sz_name)[0];
      }else{
         character = sz_name[0];
80004b20:	09 86       	ld.ub	r6,r4[0x0]
      }

      if( 1 == u8_step )
80004b22:	e6 07 18 00 	cp.b	r7,r3
80004b26:	c1 41       	brne	80004b4e <fat_create_short_entry_name+0xd6>
      {  // step 1 = translate the name
         if( ((FS_SIZE_SFNAME_WITHOUT_EXT-(1+nb_digit)) == u8_i)    // name field is full (-2 for "~1")
80004b28:	40 39       	lddsp	r9,sp[0xc]
80004b2a:	0a 39       	cp.w	r9,r5
80004b2c:	5f 09       	sreq	r9
80004b2e:	e0 06 18 00 	cp.b	r6,r0
80004b32:	5f 08       	sreq	r8
80004b34:	f3 e8 10 08 	or	r8,r9,r8
80004b38:	30 09       	mov	r9,0
80004b3a:	f2 08 18 00 	cp.b	r8,r9
80004b3e:	c0 51       	brne	80004b48 <fat_create_short_entry_name+0xd0>
80004b40:	0c 9c       	mov	r12,r6
80004b42:	f0 1f 00 3b 	mcall	80004c2c <fat_create_short_entry_name+0x1b4>
80004b46:	c1 10       	breq	80004b68 <fat_create_short_entry_name+0xf0>
         ||  ('.'    == character)                       // is the end of name without extension
         ||  fat_check_eof_name(character)            )  // is the end of name
         {
            u8_step++;                                   // go to next step
80004b48:	2f f7       	sub	r7,-1
80004b4a:	5c 57       	castu.b	r7
            continue;
80004b4c:	ce ab       	rjmp	80004b20 <fat_create_short_entry_name+0xa8>
         }
      }
      if( 8 == u8_step )
80004b4e:	e4 07 18 00 	cp.b	r7,r2
80004b52:	c1 21       	brne	80004b76 <fat_create_short_entry_name+0xfe>
      {  // step 8 = translate the extension
         if( (u8_i == FS_SIZE_SFNAME)                    // name field is full
80004b54:	30 b9       	mov	r9,11
80004b56:	f2 05 18 00 	cp.b	r5,r9
80004b5a:	c0 50       	breq	80004b64 <fat_create_short_entry_name+0xec>
80004b5c:	0c 9c       	mov	r12,r6
80004b5e:	f0 1f 00 34 	mcall	80004c2c <fat_create_short_entry_name+0x1b4>
80004b62:	c0 30       	breq	80004b68 <fat_create_short_entry_name+0xf0>
80004b64:	30 97       	mov	r7,9
         ||  fat_check_eof_name(character)            )  // is the end of name
         {
            u8_step++;                                   // go to next step
            continue;
80004b66:	cd db       	rjmp	80004b20 <fat_create_short_entry_name+0xa8>
         }
      }
      if( (1==u8_step) || (8==u8_step) )
      {  // steps to translate name
         character = fat_translate_char_shortname( character );
80004b68:	0c 9c       	mov	r12,r6
80004b6a:	f0 1f 00 32 	mcall	80004c30 <fat_create_short_entry_name+0x1b8>
80004b6e:	18 96       	mov	r6,r12
         sz_name += (Is_unicode? 2 : 1 );
80004b70:	2f f4       	sub	r4,-1
         if( 0 == character )
80004b72:	58 0c       	cp.w	r12,0
80004b74:	cd 60       	breq	80004b20 <fat_create_short_entry_name+0xa8>
         {
            continue;                                    // Bad character, ignore this one
         }
      }
      if( 7 == u8_step )
80004b76:	30 78       	mov	r8,7
80004b78:	f0 07 18 00 	cp.b	r7,r8
80004b7c:	c0 c1       	brne	80004b94 <fat_create_short_entry_name+0x11c>
      {  // step 5 = find character '.'
         if( ('.'    == character)                       // is the end of name without extension
80004b7e:	e0 06 18 00 	cp.b	r6,r0
80004b82:	c0 50       	breq	80004b8c <fat_create_short_entry_name+0x114>
80004b84:	0c 9c       	mov	r12,r6
80004b86:	f0 1f 00 2a 	mcall	80004c2c <fat_create_short_entry_name+0x1b4>
80004b8a:	c0 30       	breq	80004b90 <fat_create_short_entry_name+0x118>
80004b8c:	30 87       	mov	r7,8
80004b8e:	cc 9b       	rjmp	80004b20 <fat_create_short_entry_name+0xa8>
         ||  fat_check_eof_name(character)            )  // is the end of name
         {
            u8_step++;                                   // go to next step
         } else {
            sz_name += (Is_unicode? 2 : 1 );
80004b90:	2f f4       	sub	r4,-1
80004b92:	cc 7b       	rjmp	80004b20 <fat_create_short_entry_name+0xa8>
         }
         continue;                                       // this step don't add a character in the short name
      }
      if( 6 == u8_step )
80004b94:	30 68       	mov	r8,6
80004b96:	f0 07 18 00 	cp.b	r7,r8
80004b9a:	c0 61       	brne	80004ba6 <fat_create_short_entry_name+0x12e>
      {  // step 4 = add padding
         if( u8_i == FS_SIZE_SFNAME_WITHOUT_EXT )        // end of field name without extension
80004b9c:	e4 05 18 00 	cp.b	r5,r2
80004ba0:	cb f0       	breq	80004b1e <fat_create_short_entry_name+0xa6>
80004ba2:	32 06       	mov	r6,32
80004ba4:	c1 28       	rjmp	80004bc8 <fat_create_short_entry_name+0x150>
            u8_step++;                                   // go to next step
            continue;
         }
         character = ' ';
      }
      if( 9 == u8_step )
80004ba6:	30 98       	mov	r8,9
80004ba8:	f0 07 18 00 	cp.b	r7,r8
80004bac:	c0 71       	brne	80004bba <fat_create_short_entry_name+0x142>
      {  // step 7 = add padding in extension name
         if( u8_i == FS_SIZE_SFNAME )                    // end of field name with extension
80004bae:	30 b8       	mov	r8,11
80004bb0:	f0 05 18 00 	cp.b	r5,r8
80004bb4:	c3 50       	breq	80004c1e <fat_create_short_entry_name+0x1a6>
80004bb6:	32 06       	mov	r6,32
80004bb8:	c0 f8       	rjmp	80004bd6 <fat_create_short_entry_name+0x15e>
         {
            break;                                       // end of loop while(1)
         }
         character = ' ';
      }
      if( 5 == u8_step )
80004bba:	30 58       	mov	r8,5
80004bbc:	f0 07 18 00 	cp.b	r7,r8
80004bc0:	c0 41       	brne	80004bc8 <fat_create_short_entry_name+0x150>
80004bc2:	40 66       	lddsp	r6,sp[0x18]
80004bc4:	30 67       	mov	r7,6
80004bc6:	c0 f8       	rjmp	80004be4 <fat_create_short_entry_name+0x16c>
      {  // step 4 = add unit 1 of number
         character = '0'+(nb%10);
         u8_step++;                                      // go to next step
      }
      if( 4 == u8_step )
80004bc8:	30 48       	mov	r8,4
80004bca:	f0 07 18 00 	cp.b	r7,r8
80004bce:	c0 41       	brne	80004bd6 <fat_create_short_entry_name+0x15e>
80004bd0:	40 56       	lddsp	r6,sp[0x14]
80004bd2:	30 57       	mov	r7,5
80004bd4:	c1 28       	rjmp	80004bf8 <fat_create_short_entry_name+0x180>
      {  // step 3 = add unit 10 of number
         character = '0'+((nb%100)/10);
         u8_step++;                                      // go to next step
      }
      if( 3 == u8_step )
80004bd6:	30 38       	mov	r8,3
80004bd8:	f0 07 18 00 	cp.b	r7,r8
80004bdc:	c0 41       	brne	80004be4 <fat_create_short_entry_name+0x16c>
80004bde:	40 46       	lddsp	r6,sp[0x10]
80004be0:	30 47       	mov	r7,4
80004be2:	c0 b8       	rjmp	80004bf8 <fat_create_short_entry_name+0x180>
      {  // step 2 = add unit 100 of number
         character = '0'+(nb/100);
         u8_step++;                                      // go to next step
      }
      if( 2 == u8_step )
80004be4:	30 28       	mov	r8,2
80004be6:	0e 99       	mov	r9,r7
      {  // step 2 = add character '~'
         character = '~';
         u8_step+=(4-nb_digit);                          // go to next step
80004be8:	f0 07 18 00 	cp.b	r7,r8
80004bec:	fb f7 00 07 	ld.weq	r7,sp[0x1c]
80004bf0:	f0 09 18 00 	cp.b	r9,r8
80004bf4:	f9 b6 00 7e 	moveq	r6,126
      }

      if( mode )
80004bf8:	40 08       	lddsp	r8,sp[0x0]
80004bfa:	58 08       	cp.w	r8,0
80004bfc:	c0 50       	breq	80004c06 <fat_create_short_entry_name+0x18e>
      {
         // Record the short name in buffer
         *short_name = character;
80004bfe:	40 29       	lddsp	r9,sp[0x8]
80004c00:	12 c6       	st.b	r9++,r6
80004c02:	50 29       	stdsp	sp[0x8],r9
80004c04:	c0 48       	rjmp	80004c0c <fat_create_short_entry_name+0x194>
         short_name++;
      }else{
         // Record the character in short entry file
         *ptr_entry = character;
80004c06:	40 18       	lddsp	r8,sp[0x4]
80004c08:	10 c6       	st.b	r8++,r6
80004c0a:	50 18       	stdsp	sp[0x4],r8
         ptr_entry++;
      }
      u8_i++;
80004c0c:	2f f5       	sub	r5,-1
80004c0e:	5c 55       	castu.b	r5

      // Compute the CRC of the short name
      crc = (crc >> 1) + ((crc & 1) << 7);               // rotate
80004c10:	e2 08 16 01 	lsr	r8,r1,0x1
80004c14:	a7 71       	lsl	r1,0x7
80004c16:	10 01       	add	r1,r8
      crc += character;                                  // add next char
80004c18:	0c 01       	add	r1,r6
80004c1a:	5c 51       	castu.b	r1
80004c1c:	c8 2b       	rjmp	80004b20 <fat_create_short_entry_name+0xa8>
   } // End of loop while
   return crc;
}
80004c1e:	02 9c       	mov	r12,r1
80004c20:	2f 8d       	sub	sp,-32
80004c22:	d8 32       	popm	r0-r7,pc
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	36 7c       	mov	r12,103
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	33 0c       	mov	r12,48
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	32 e4       	mov	r4,46
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	43 84       	lddsp	r4,sp[0xe0]

80004c34 <fat_entry_shortname_compare>:
//!
//! @return    true it is the same
//! @return    false in case of error, see global value "fs_g_status" for more detail
//!
bool  fat_entry_shortname_compare( FS_STRING short_name )
{
80004c34:	eb cd 40 80 	pushm	r7,lr
80004c38:	18 97       	mov	r7,r12
   PTR_CACHE ptr_entry;

   ptr_entry = fat_get_ptr_entry();
80004c3a:	f0 1f 00 12 	mcall	80004c80 <fat_entry_shortname_compare+0x4c>
   if( FS_ENTRY_END == *ptr_entry )             // end of directory
80004c3e:	19 88       	ld.ub	r8,r12[0x0]
80004c40:	58 08       	cp.w	r8,0
80004c42:	c0 61       	brne	80004c4e <fat_entry_shortname_compare+0x1a>
   {
      fs_g_status = FS_ERR_ENTRY_EMPTY;
80004c44:	30 a9       	mov	r9,10
80004c46:	49 08       	lddpc	r8,80004c84 <fat_entry_shortname_compare+0x50>
80004c48:	b0 89       	st.b	r8[0x0],r9
80004c4a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
   if( (FS_ENTRY_DEL == *ptr_entry )            // deleted entry
80004c4e:	3e 59       	mov	r9,-27
80004c50:	f2 08 18 00 	cp.b	r8,r9
80004c54:	c0 70       	breq	80004c62 <fat_entry_shortname_compare+0x2e>
   ||  (FS_ATTR_LFN_ENTRY == ptr_entry[11]) )   // long file name
80004c56:	f9 39 00 0b 	ld.ub	r9,r12[11]
80004c5a:	30 f8       	mov	r8,15
80004c5c:	f0 09 18 00 	cp.b	r9,r8
80004c60:	c0 61       	brne	80004c6c <fat_entry_shortname_compare+0x38>
   {
      fs_g_status = FS_ERR_ENTRY_BAD;
80004c62:	30 b9       	mov	r9,11
80004c64:	48 88       	lddpc	r8,80004c84 <fat_entry_shortname_compare+0x50>
80004c66:	b0 89       	st.b	r8[0x0],r9
80004c68:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
   fs_g_status = FS_ERR_ENTRY_BAD;              // by default this entry is different then bad
80004c6c:	30 b9       	mov	r9,11
80004c6e:	48 68       	lddpc	r8,80004c84 <fat_entry_shortname_compare+0x50>
80004c70:	b0 89       	st.b	r8[0x0],r9
   return (0==memcmp_ram2ram(ptr_entry , short_name , 8+3 ));
80004c72:	30 ba       	mov	r10,11
80004c74:	0e 9b       	mov	r11,r7
80004c76:	f0 1f 00 05 	mcall	80004c88 <fat_entry_shortname_compare+0x54>
80004c7a:	5f 0c       	sreq	r12
}
80004c7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	33 0c       	mov	r12,48
80004c84:	00 00       	add	r0,r0
80004c86:	0c 84       	andn	r4,r6
80004c88:	80 01       	ld.sh	r1,r0[0x0]
80004c8a:	54 94       	stdsp	sp[0x124],r4

80004c8c <fat_find_short_entry_name>:
//!
//! @return the number used to create the short name
//! @return 0 in case of error
//!
uint8_t    fat_find_short_entry_name( FS_STRING sz_name  )
{
80004c8c:	d4 31       	pushm	r0-r7,lr
80004c8e:	20 3d       	sub	sp,12
80004c90:	18 93       	mov	r3,r12
80004c92:	30 07       	mov	r7,0
   {
      if( 0xFF == u8_nb )
         return 0;                                       // All short name exist

      u8_nb++;                                           // Try next short name
      fat_create_short_entry_name( sz_name , short_name , u8_nb , true  ); // Compute the short name
80004c94:	1a 96       	mov	r6,sp
80004c96:	30 12       	mov	r2,1
      fs_g_nav_fast.u16_entry_pos_sel_file = 0;          // Go to beginning of directory
80004c98:	49 65       	lddpc	r5,80004cf0 <fat_find_short_entry_name+0x64>
80004c9a:	30 04       	mov	r4,0
               return u8_nb;                             // short name don't exist, then good number
            return 0;                                    // System or Disk Error
         }
         if( fat_entry_shortname_compare( short_name ) ) // Check entry
            break;                                       // Short name exist
         if( FS_ERR_ENTRY_EMPTY == fs_g_status )
80004c9c:	49 61       	lddpc	r1,80004cf4 <fat_find_short_entry_name+0x68>
80004c9e:	30 a0       	mov	r0,10
80004ca0:	c0 58       	rjmp	80004caa <fat_find_short_entry_name+0x1e>
   uint8_t u8_nb;

   u8_nb = 0;
   while(1)
   {
      if( 0xFF == u8_nb )
80004ca2:	3f f8       	mov	r8,-1
80004ca4:	f0 07 18 00 	cp.b	r7,r8
80004ca8:	c2 00       	breq	80004ce8 <fat_find_short_entry_name+0x5c>
         return 0;                                       // All short name exist

      u8_nb++;                                           // Try next short name
80004caa:	2f f7       	sub	r7,-1
80004cac:	5c 57       	castu.b	r7
      fat_create_short_entry_name( sz_name , short_name , u8_nb , true  ); // Compute the short name
80004cae:	04 99       	mov	r9,r2
80004cb0:	0e 9a       	mov	r10,r7
80004cb2:	1a 9b       	mov	r11,sp
80004cb4:	06 9c       	mov	r12,r3
80004cb6:	f0 1f 00 11 	mcall	80004cf8 <fat_find_short_entry_name+0x6c>
      fs_g_nav_fast.u16_entry_pos_sel_file = 0;          // Go to beginning of directory
80004cba:	aa 14       	st.h	r5[0x2],r4
      // Scan directory to find a short entry
      while(1)
      {
         if ( !fat_read_dir())                           // Read directory
80004cbc:	f0 1f 00 10 	mcall	80004cfc <fat_find_short_entry_name+0x70>
80004cc0:	c0 81       	brne	80004cd0 <fat_find_short_entry_name+0x44>
         {
            if( FS_ERR_OUT_LIST == fs_g_status )
80004cc2:	48 d8       	lddpc	r8,80004cf4 <fat_find_short_entry_name+0x68>
80004cc4:	11 89       	ld.ub	r9,r8[0x0]
80004cc6:	31 a8       	mov	r8,26
80004cc8:	f0 09 18 00 	cp.b	r9,r8
80004ccc:	c0 e1       	brne	80004ce8 <fat_find_short_entry_name+0x5c>
80004cce:	c0 e8       	rjmp	80004cea <fat_find_short_entry_name+0x5e>
               return u8_nb;                             // short name don't exist, then good number
            return 0;                                    // System or Disk Error
         }
         if( fat_entry_shortname_compare( short_name ) ) // Check entry
80004cd0:	1a 9c       	mov	r12,sp
80004cd2:	f0 1f 00 0c 	mcall	80004d00 <fat_find_short_entry_name+0x74>
80004cd6:	ce 61       	brne	80004ca2 <fat_find_short_entry_name+0x16>
            break;                                       // Short name exist
         if( FS_ERR_ENTRY_EMPTY == fs_g_status )
80004cd8:	03 88       	ld.ub	r8,r1[0x0]
80004cda:	e0 08 18 00 	cp.b	r8,r0
80004cde:	c0 60       	breq	80004cea <fat_find_short_entry_name+0x5e>
            return u8_nb;                                // Short name don't exist, then good number
         fs_g_nav_fast.u16_entry_pos_sel_file++;         // Go to next entry
80004ce0:	8a 18       	ld.sh	r8,r5[0x2]
80004ce2:	2f f8       	sub	r8,-1
80004ce4:	aa 18       	st.h	r5[0x2],r8
      }
80004ce6:	ce bb       	rjmp	80004cbc <fat_find_short_entry_name+0x30>
80004ce8:	30 07       	mov	r7,0
   }
}
80004cea:	0e 9c       	mov	r12,r7
80004cec:	2f dd       	sub	sp,-12
80004cee:	d8 32       	popm	r0-r7,pc
80004cf0:	00 00       	add	r0,r0
80004cf2:	0c 80       	andn	r0,r6
80004cf4:	00 00       	add	r0,r0
80004cf6:	0c 84       	andn	r4,r6
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	4a 78       	lddpc	r8,80004d94 <fat_create_entry_file_name+0x90>
80004cfc:	80 00       	ld.sh	r0,r0[0x0]
80004cfe:	3e cc       	mov	r12,-20
80004d00:	80 00       	ld.sh	r0,r0[0x0]
80004d02:	4c 34       	lddpc	r4,80004e0c <fat_mount+0x60>

80004d04 <fat_create_entry_file_name>:
//! b_unicode is a global flag to select UNICODE or ASCII
//! The name must be terminated by NULL and it can't have two dot characters.
//! @endverbatim
//!
bool  fat_create_entry_file_name( FS_STRING sz_name )
{
80004d04:	eb cd 40 fc 	pushm	r2-r7,lr
80004d08:	18 96       	mov	r6,r12
   uint8_t u8_i, u8_nb;
   uint8_t u8_crc, u8_nb_entry;

   // Compute the number of entry for this name
   u8_nb_entry = fat_check_name( sz_name  );
80004d0a:	f0 1f 00 21 	mcall	80004d8c <fat_create_entry_file_name+0x88>
80004d0e:	18 95       	mov	r5,r12
   if( 0 == u8_nb_entry )
80004d10:	c3 b0       	breq	80004d86 <fat_create_entry_file_name+0x82>
      return false;

   // Search a unique short entry
   u8_nb = fat_find_short_entry_name( sz_name  );
80004d12:	0c 9c       	mov	r12,r6
80004d14:	f0 1f 00 1f 	mcall	80004d90 <fat_create_entry_file_name+0x8c>
80004d18:	18 97       	mov	r7,r12
   if( 0 == u8_nb )
80004d1a:	c0 61       	brne	80004d26 <fat_create_entry_file_name+0x22>
   {
      fs_g_status = FS_ERR_FILE_EXIST;
80004d1c:	32 a9       	mov	r9,42
80004d1e:	49 e8       	lddpc	r8,80004d94 <fat_create_entry_file_name+0x90>
80004d20:	b0 89       	st.b	r8[0x0],r9
80004d22:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
      return false;  // All short name exist
   }

   // Alloc a space for entries
   if( !fat_alloc_entry_free( u8_nb_entry ))
80004d26:	0a 9c       	mov	r12,r5
80004d28:	f0 1f 00 1c 	mcall	80004d98 <fat_create_entry_file_name+0x94>
80004d2c:	c2 d0       	breq	80004d86 <fat_create_entry_file_name+0x82>
      return false;
   // Remark: here the pointer of entry is on the last free entry of new space allocated

   // Add short name entry
   u8_crc = fat_create_short_entry_name( sz_name , 0 , u8_nb, false  );
80004d2e:	30 09       	mov	r9,0
80004d30:	0e 9a       	mov	r10,r7
80004d32:	12 9b       	mov	r11,r9
80004d34:	0c 9c       	mov	r12,r6
80004d36:	f0 1f 00 1a 	mcall	80004d9c <fat_create_entry_file_name+0x98>
80004d3a:	18 92       	mov	r2,r12
   u8_nb_entry--;
80004d3c:	20 15       	sub	r5,1
80004d3e:	5c 55       	castu.b	r5

   // For each long name entry
   for( u8_i=1 ; u8_i<=u8_nb_entry ; u8_i++ )
80004d40:	c1 c0       	breq	80004d78 <fat_create_entry_file_name+0x74>
80004d42:	30 17       	mov	r7,1
   {
      // Go to previous entry
      fs_g_nav_fast.u16_entry_pos_sel_file--;
80004d44:	49 74       	lddpc	r4,80004da0 <fat_create_entry_file_name+0x9c>
      if( !fat_read_dir())
         return false;
      // Write a long name entry
      if( u8_i == u8_nb_entry )
      {
         u8_i += FS_ENTRY_LFN_LAST;
80004d46:	ea c3 ff c0 	sub	r3,r5,-64
80004d4a:	5c 53       	castu.b	r3

   // For each long name entry
   for( u8_i=1 ; u8_i<=u8_nb_entry ; u8_i++ )
   {
      // Go to previous entry
      fs_g_nav_fast.u16_entry_pos_sel_file--;
80004d4c:	88 18       	ld.sh	r8,r4[0x2]
80004d4e:	20 18       	sub	r8,1
80004d50:	a8 18       	st.h	r4[0x2],r8
      if( !fat_read_dir())
80004d52:	f0 1f 00 15 	mcall	80004da4 <fat_create_entry_file_name+0xa0>
80004d56:	c1 80       	breq	80004d86 <fat_create_entry_file_name+0x82>
         return false;
      // Write a long name entry
      if( u8_i == u8_nb_entry )
      {
         u8_i += FS_ENTRY_LFN_LAST;
80004d58:	ea 07 18 00 	cp.b	r7,r5
80004d5c:	e6 07 17 00 	moveq	r7,r3
      }
      fat_create_long_name_entry( sz_name , u8_crc , u8_i );
80004d60:	0e 9a       	mov	r10,r7
80004d62:	04 9b       	mov	r11,r2
80004d64:	0c 9c       	mov	r12,r6
80004d66:	f0 1f 00 11 	mcall	80004da8 <fat_create_entry_file_name+0xa4>
   // Add short name entry
   u8_crc = fat_create_short_entry_name( sz_name , 0 , u8_nb, false  );
   u8_nb_entry--;

   // For each long name entry
   for( u8_i=1 ; u8_i<=u8_nb_entry ; u8_i++ )
80004d6a:	2f f7       	sub	r7,-1
80004d6c:	5c 57       	castu.b	r7
80004d6e:	ee 05 18 00 	cp.b	r5,r7
80004d72:	c0 33       	brcs	80004d78 <fat_create_entry_file_name+0x74>
      if( u8_i == u8_nb_entry )
      {
         u8_i += FS_ENTRY_LFN_LAST;
      }
      fat_create_long_name_entry( sz_name , u8_crc , u8_i );
      sz_name += FS_SIZE_LFN_ENTRY*(Is_unicode? 2 : 1 );
80004d74:	2f 36       	sub	r6,-13
80004d76:	ce bb       	rjmp	80004d4c <fat_create_entry_file_name+0x48>
  }
  // Go back to the short name entry
  fs_g_nav_fast.u16_entry_pos_sel_file += u8_nb_entry;
80004d78:	48 a8       	lddpc	r8,80004da0 <fat_create_entry_file_name+0x9c>
80004d7a:	90 19       	ld.sh	r9,r8[0x2]
80004d7c:	f2 05 00 05 	add	r5,r9,r5
80004d80:	b0 15       	st.h	r8[0x2],r5
80004d82:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
  return true;
80004d86:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004d8a:	00 00       	add	r0,r0
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	4a 04       	lddpc	r4,80004e0c <fat_mount+0x60>
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	4c 8c       	lddpc	r12,80004eb0 <fat_mount+0x104>
80004d94:	00 00       	add	r0,r0
80004d96:	0c 84       	andn	r4,r6
80004d98:	80 00       	ld.sh	r0,r0[0x0]
80004d9a:	49 54       	lddpc	r4,80004dec <fat_mount+0x40>
80004d9c:	80 00       	ld.sh	r0,r0[0x0]
80004d9e:	4a 78       	lddpc	r8,80004e38 <fat_mount+0x8c>
80004da0:	00 00       	add	r0,r0
80004da2:	0c 80       	andn	r0,r6
80004da4:	80 00       	ld.sh	r0,r0[0x0]
80004da6:	3e cc       	mov	r12,-20
80004da8:	80 00       	ld.sh	r0,r0[0x0]
80004daa:	45 68       	lddsp	r8,sp[0x158]

80004dac <fat_mount>:
//! If the FS_MULTI_PARTITION option is disabled
//! then the mount routine selects the first partition supported by file system. <br>
//! @endverbatim
//!
bool  fat_mount( void )
{
80004dac:	d4 31       	pushm	r0-r7,lr
80004dae:	20 3d       	sub	sp,12
   uint8_t  u8_tmp;
   uint16_t u16_tmp;
   uint32_t u32_tmp;

   // Select the root directory
   fs_g_nav.u32_cluster_sel_dir   = 0;
80004db0:	30 07       	mov	r7,0
80004db2:	fe f8 02 d2 	ld.w	r8,pc[722]
80004db6:	91 87       	st.w	r8[0x20],r7
   // No selected file
   fat_clear_entry_info_and_ptr();
80004db8:	f0 1f 00 b4 	mcall	80005088 <fat_mount+0x2dc>

   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
80004dbc:	fe f8 02 d0 	ld.w	r8,pc[720]
80004dc0:	b0 87       	st.b	r8[0x0],r7
   fs_gu32_addrsector = 0;    // Start read at the beginning of memory
80004dc2:	fe f8 02 ce 	ld.w	r8,pc[718]
80004dc6:	91 07       	st.w	r8[0x0],r7

   // Check if the drive is available
   if( !fat_check_device() )
80004dc8:	f0 1f 00 b3 	mcall	80005094 <fat_mount+0x2e8>
80004dcc:	e0 80 01 58 	breq	8000507c <fat_mount+0x2d0>
      // Read one sector
      if( !fat_cache_read_sector( true ))
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80004dd0:	fe f5 02 c8 	ld.w	r5,pc[712]
      {
         fs_g_status = FS_ERR_NO_FORMAT;
         return false;
      }

      if ( 0 == fs_gu32_addrsector )
80004dd4:	ea c8 fe 42 	sub	r8,r5,-446
80004dd8:	50 08       	stdsp	sp[0x0],r8
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80004dda:	38 04       	mov	r4,-128
80004ddc:	30 46       	mov	r6,4
      return false;

   while( 1 )  // Search a valid partition
   {
      // Read one sector
      if( !fat_cache_read_sector( true ))
80004dde:	30 1c       	mov	r12,1
80004de0:	f0 1f 00 af 	mcall	8000509c <fat_mount+0x2f0>
80004de4:	e0 80 01 4c 	breq	8000507c <fat_mount+0x2d0>
         return false;

      // Check PBR/MBR signature
      if ( (fs_g_sector[510] != FS_BR_SIGNATURE_LOW  )
80004de8:	eb 39 01 fe 	ld.ub	r9,r5[510]
80004dec:	35 58       	mov	r8,85
80004dee:	f0 09 18 00 	cp.b	r9,r8
80004df2:	c0 d0       	breq	80004e0c <fat_mount+0x60>
      &&   (fs_g_sector[511] != FS_BR_SIGNATURE_HIGH ) )
80004df4:	eb 39 01 ff 	ld.ub	r9,r5[511]
80004df8:	3a a8       	mov	r8,-86
80004dfa:	f0 09 18 00 	cp.b	r9,r8
80004dfe:	c0 70       	breq	80004e0c <fat_mount+0x60>
      {
         fs_g_status = FS_ERR_NO_FORMAT;
80004e00:	30 29       	mov	r9,2
80004e02:	fe f8 02 9e 	ld.w	r8,pc[670]
80004e06:	b0 89       	st.b	r8[0x0],r9
80004e08:	30 0c       	mov	r12,0
         return false;
80004e0a:	c3 a9       	rjmp	8000507e <fat_mount+0x2d2>
      }

      if ( 0 == fs_gu32_addrsector )
80004e0c:	fe f8 02 84 	ld.w	r8,pc[644]
80004e10:	70 08       	ld.w	r8,r8[0x0]
80004e12:	58 08       	cp.w	r8,0
80004e14:	c5 21       	brne	80004eb8 <fat_mount+0x10c>
80004e16:	40 08       	lddsp	r8,sp[0x0]
80004e18:	30 0a       	mov	r10,0
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80004e1a:	30 1e       	mov	lr,1
80004e1c:	30 63       	mov	r3,6
80004e1e:	30 e2       	mov	r2,14
80004e20:	30 b1       	mov	r1,11
80004e22:	30 c0       	mov	r0,12
80004e24:	11 89       	ld.ub	r9,r8[0x0]
80004e26:	e8 09 18 00 	cp.b	r9,r4
80004e2a:	5f 0b       	sreq	r11
80004e2c:	ee 09 18 00 	cp.b	r9,r7
80004e30:	5f 09       	sreq	r9
80004e32:	f7 e9 10 09 	or	r9,r11,r9
80004e36:	ee 09 18 00 	cp.b	r9,r7
80004e3a:	c1 90       	breq	80004e6c <fat_mount+0xc0>
                  (fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_NO_BOOTABLE          )  )
            &&   ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+4] == FS_PART_TYPE_FAT12           )||
80004e3c:	11 c9       	ld.ub	r9,r8[0x4]
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
         {
            // The first sector must be a MBR, then check the partition entry in the MBR
            if ( ((fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+0] == FS_PART_BOOTABLE             )||
80004e3e:	fc 09 18 00 	cp.b	r9,lr
80004e42:	5f 0c       	sreq	r12
80004e44:	ec 09 18 00 	cp.b	r9,r6
80004e48:	5f 0b       	sreq	r11
80004e4a:	f9 eb 10 0b 	or	r11,r12,r11
80004e4e:	ee 0b 18 00 	cp.b	r11,r7
80004e52:	c1 41       	brne	80004e7a <fat_mount+0xce>
80004e54:	e6 09 18 00 	cp.b	r9,r3
80004e58:	c1 10       	breq	80004e7a <fat_mount+0xce>
80004e5a:	e4 09 18 00 	cp.b	r9,r2
80004e5e:	c0 e0       	breq	80004e7a <fat_mount+0xce>
80004e60:	e2 09 18 00 	cp.b	r9,r1
80004e64:	c0 b0       	breq	80004e7a <fat_mount+0xce>
80004e66:	e0 09 18 00 	cp.b	r9,r0
80004e6a:	c0 80       	breq	80004e7a <fat_mount+0xce>
         //** first sector then check a MBR structure
         // Search the first partition supported
#if (FS_MULTI_PARTITION == true)
         u16_tmp=0;  // Init to "no valid partition found"
#endif
         for( u8_tmp=0 ; u8_tmp!=4 ; u8_tmp++ )
80004e6c:	2f fa       	sub	r10,-1
80004e6e:	5c 5a       	castu.b	r10
80004e70:	2f 08       	sub	r8,-16
80004e72:	ec 0a 18 00 	cp.b	r10,r6
80004e76:	cd 71       	brne	80004e24 <fat_mount+0x78>
80004e78:	c2 08       	rjmp	80004eb8 <fat_mount+0x10c>
#else
               break;
#endif
            }
         }
         if( u8_tmp != 4 )
80004e7a:	ec 0a 18 00 	cp.b	r10,r6
80004e7e:	c1 d0       	breq	80004eb8 <fat_mount+0x10c>
         {
            // Partition found -> Get partition position (unit sector) at offset 8
            LSB0(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+8];
80004e80:	fe f3 02 10 	ld.w	r3,pc[528]
80004e84:	a5 6a       	lsl	r10,0x4
80004e86:	f4 ca fe 42 	sub	r10,r10,-446
80004e8a:	ea 0a 00 0a 	add	r10,r5,r10
80004e8e:	f5 38 00 08 	ld.ub	r8,r10[8]
80004e92:	a6 b8       	st.b	r3[0x3],r8
            LSB1(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+9];
80004e94:	f5 38 00 09 	ld.ub	r8,r10[9]
80004e98:	a6 a8       	st.b	r3[0x2],r8
            LSB2(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+10];
80004e9a:	f5 38 00 0a 	ld.ub	r8,r10[10]
80004e9e:	a6 98       	st.b	r3[0x1],r8
            LSB3(fs_gu32_addrsector) = fs_g_sector[FS_MBR_OFFSET_PART_ENTRY(u8_tmp)+11];
80004ea0:	f5 38 00 0b 	ld.ub	r8,r10[11]
80004ea4:	a6 88       	st.b	r3[0x0],r8
            fs_gu32_addrsector *= mem_sector_size( fs_g_nav.u8_lun );
80004ea6:	4f 88       	lddpc	r8,80005084 <fat_mount+0x2d8>
80004ea8:	11 8c       	ld.ub	r12,r8[0x0]
80004eaa:	f0 1f 00 7f 	mcall	800050a4 <fat_mount+0x2f8>
80004eae:	66 08       	ld.w	r8,r3[0x0]
80004eb0:	f8 08 02 48 	mul	r8,r12,r8
80004eb4:	87 08       	st.w	r3[0x0],r8
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
      return false;
   }
80004eb6:	c9 4b       	rjmp	80004dde <fat_mount+0x32>
         }
#endif
      }

      //** Check a PBR structure
      if ( (fs_g_sector[0] == 0xEB) &&          // PBR Byte 0
80004eb8:	4f 88       	lddpc	r8,80005098 <fat_mount+0x2ec>
80004eba:	11 89       	ld.ub	r9,r8[0x0]
80004ebc:	3e b8       	mov	r8,-21
80004ebe:	f0 09 18 00 	cp.b	r9,r8
80004ec2:	c0 f1       	brne	80004ee0 <fat_mount+0x134>
           (fs_g_sector[2] == 0x90) &&          // PBR Byte 2
80004ec4:	4f 58       	lddpc	r8,80005098 <fat_mount+0x2ec>
80004ec6:	11 a9       	ld.ub	r9,r8[0x2]
80004ec8:	39 08       	mov	r8,-112
80004eca:	f0 09 18 00 	cp.b	r9,r8
80004ece:	c0 91       	brne	80004ee0 <fat_mount+0x134>
           ((fs_g_sector[21] & 0xF0) == 0xF0) ) // PBR Byte 21 : Media byte
80004ed0:	4f 28       	lddpc	r8,80005098 <fat_mount+0x2ec>
80004ed2:	f1 38 00 15 	ld.ub	r8,r8[21]
80004ed6:	e2 18 00 f0 	andl	r8,0xf0,COH
80004eda:	e0 48 00 f0 	cp.w	r8,240
80004ede:	c0 60       	breq	80004eea <fat_mount+0x13e>
      {
         break;   // valid PBR found
      }
      // PBR not found
      fs_g_status = FS_ERR_NO_PART;
80004ee0:	30 39       	mov	r9,3
80004ee2:	4f 08       	lddpc	r8,800050a0 <fat_mount+0x2f4>
80004ee4:	b0 89       	st.b	r8[0x0],r9
80004ee6:	30 0c       	mov	r12,0
      return false;
80004ee8:	cc b8       	rjmp	8000507e <fat_mount+0x2d2>
   }

   fs_g_status = FS_ERR_NO_SUPPORT_PART;  // by default partition no supported
80004eea:	30 49       	mov	r9,4
80004eec:	4e d8       	lddpc	r8,800050a0 <fat_mount+0x2f4>
80004eee:	b0 89       	st.b	r8[0x0],r9

   // Get sector size of File System (unit 512B)
   // To translate from sector disk unit to sector 512B unit
   u8_sector_size = HIGH_16_BPB_BytsPerSec/2;
80004ef0:	4e aa       	lddpc	r10,80005098 <fat_mount+0x2ec>
80004ef2:	f5 39 00 0c 	ld.ub	r9,r10[12]
80004ef6:	a1 99       	lsr	r9,0x1

   // Read BPB_SecPerClus (unit sector)
   fs_g_nav.u8_BPB_SecPerClus = U8_BPB_SecPerClus * u8_sector_size;
80004ef8:	f5 38 00 0d 	ld.ub	r8,r10[13]
80004efc:	b3 38       	mul	r8,r9
80004efe:	5c 58       	castu.b	r8
80004f00:	4e 1b       	lddpc	r11,80005084 <fat_mount+0x2d8>
80004f02:	b6 98       	st.b	r11[0x1],r8

   //** FAT Type determination (algorithm of "Hardware White Paper FAT")
   // Get FAT size (unit sector)
   u32_tmp=0;
80004f04:	30 0b       	mov	r11,0
80004f06:	50 1b       	stdsp	sp[0x4],r11
   LSB0( u32_tmp ) = LOW_16_BPB_FATSz16;
80004f08:	fa cb ff fc 	sub	r11,sp,-4
80004f0c:	fa c7 ff f9 	sub	r7,sp,-7
80004f10:	f5 3c 00 16 	ld.ub	r12,r10[22]
80004f14:	ae 8c       	st.b	r7[0x0],r12
   LSB1( u32_tmp ) = HIGH_16_BPB_FATSz16;
80004f16:	fa ce ff fa 	sub	lr,sp,-6
80004f1a:	f5 3a 00 17 	ld.ub	r10,r10[23]
80004f1e:	bc 8a       	st.b	lr[0x0],r10
   if ( 0==u32_tmp )
80004f20:	40 1a       	lddsp	r10,sp[0x4]
80004f22:	58 0a       	cp.w	r10,0
80004f24:	c0 e1       	brne	80004f40 <fat_mount+0x194>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_FATSz32;
80004f26:	4d da       	lddpc	r10,80005098 <fat_mount+0x2ec>
80004f28:	f5 3c 00 24 	ld.ub	r12,r10[36]
80004f2c:	ae 8c       	st.b	r7[0x0],r12
      LSB1( u32_tmp ) = LOW1_32_BPB_FATSz32;
80004f2e:	f5 3c 00 25 	ld.ub	r12,r10[37]
80004f32:	bc 8c       	st.b	lr[0x0],r12
      LSB2( u32_tmp ) = LOW2_32_BPB_FATSz32;
80004f34:	f5 3c 00 26 	ld.ub	r12,r10[38]
80004f38:	b6 9c       	st.b	r11[0x1],r12
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
80004f3a:	f5 3a 00 27 	ld.ub	r10,r10[39]
80004f3e:	b6 8a       	st.b	r11[0x0],r10
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;
80004f40:	12 95       	mov	r5,r9
80004f42:	40 1c       	lddsp	r12,sp[0x4]
80004f44:	f2 0c 02 4c 	mul	r12,r9,r12
80004f48:	4c fa       	lddpc	r10,80005084 <fat_mount+0x2d8>
80004f4a:	95 1c       	st.w	r10[0x4],r12

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80004f4c:	4d 3a       	lddpc	r10,80005098 <fat_mount+0x2ec>
80004f4e:	f5 3a 00 13 	ld.ub	r10,r10[19]
80004f52:	58 0a       	cp.w	r10,0
80004f54:	c1 61       	brne	80004f80 <fat_mount+0x1d4>
80004f56:	4d 16       	lddpc	r6,80005098 <fat_mount+0x2ec>
80004f58:	ed 34 00 14 	ld.ub	r4,r6[20]
80004f5c:	30 06       	mov	r6,0
80004f5e:	ec 04 18 00 	cp.b	r4,r6
80004f62:	c0 f1       	brne	80004f80 <fat_mount+0x1d4>
   {
      LSB0( u32_tmp ) = LOW0_32_BPB_TotSec32;
80004f64:	4c da       	lddpc	r10,80005098 <fat_mount+0x2ec>
80004f66:	f5 36 00 20 	ld.ub	r6,r10[32]
80004f6a:	ae 86       	st.b	r7[0x0],r6
      LSB1( u32_tmp ) = LOW1_32_BPB_TotSec32;
80004f6c:	f5 37 00 21 	ld.ub	r7,r10[33]
80004f70:	bc 87       	st.b	lr[0x0],r7
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
80004f72:	f5 3e 00 22 	ld.ub	lr,r10[34]
80004f76:	b6 9e       	st.b	r11[0x1],lr
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
80004f78:	f5 3a 00 23 	ld.ub	r10,r10[35]
80004f7c:	b6 8a       	st.b	r11[0x0],r10
      LSB3( u32_tmp ) = LOW3_32_BPB_FATSz32;
   }
   fs_g_nav.u32_fat_size = u32_tmp * u8_sector_size;

   // Get total count of sectors in partition
   if ( (0==LOW_16_BPB_TotSec16) && (0==HIGH_16_BPB_TotSec16) )
80004f7e:	c0 98       	rjmp	80004f90 <fat_mount+0x1e4>
      LSB2( u32_tmp ) = LOW2_32_BPB_TotSec32;
      LSB3( u32_tmp ) = LOW3_32_BPB_TotSec32;
   }
   else
   {
      LSB0( u32_tmp ) = LOW_16_BPB_TotSec16;
80004f80:	ae 8a       	st.b	r7[0x0],r10
      LSB1( u32_tmp ) = HIGH_16_BPB_TotSec16;
80004f82:	4c 6a       	lddpc	r10,80005098 <fat_mount+0x2ec>
80004f84:	f5 3a 00 14 	ld.ub	r10,r10[20]
80004f88:	bc 8a       	st.b	lr[0x0],r10
      LSB2( u32_tmp ) = 0;
80004f8a:	30 0a       	mov	r10,0
80004f8c:	b6 9a       	st.b	r11[0x1],r10
      LSB3( u32_tmp ) = 0;
80004f8e:	b6 8a       	st.b	r11[0x0],r10
   }
   u32_tmp *= u8_sector_size;   // Translate from sector disk unit to sector 512B unit
80004f90:	40 14       	lddsp	r4,sp[0x4]

   // Compute the offset (unit 512B) between the end of FAT (beginning of root dir in FAT1x) and the beginning of PBR
   fs_g_nav.rootdir.seg.u16_pos = FS_NB_FAT * (uint16_t)fs_g_nav.u32_fat_size;
80004f92:	4b da       	lddpc	r10,80005084 <fat_mount+0x2d8>
80004f94:	f8 0b 15 01 	lsl	r11,r12,0x1
80004f98:	f5 5b 00 18 	st.h	r10[24],r11

   // Compute the root directory size (unit sector), for FAT32 is always 0
   LSB( u16_tmp ) = LOW_16_BPB_RootEntCnt;
80004f9c:	fa c6 ff f6 	sub	r6,sp,-10
80004fa0:	fa c7 ff f4 	sub	r7,sp,-12
80004fa4:	4b db       	lddpc	r11,80005098 <fat_mount+0x2ec>
80004fa6:	f7 3e 00 11 	ld.ub	lr,r11[17]
80004faa:	0e fe       	st.b	--r7,lr
   MSB( u16_tmp ) = HIGH_16_BPB_RootEntCnt;
80004fac:	f7 3e 00 12 	ld.ub	lr,r11[18]
80004fb0:	ac 8e       	st.b	r6[0x0],lr
   fs_g_nav.rootdir.seg.u16_size = ((u16_tmp * FS_SIZE_FILE_ENTRY) + ((FS_512B*u8_sector_size)-1)) / (FS_512B*u8_sector_size);
   fs_g_nav.rootdir.seg.u16_size *= u8_sector_size;
80004fb2:	f2 03 15 04 	lsl	r3,r9,0x4
80004fb6:	9a de       	ld.uh	lr,sp[0xa]
80004fb8:	e6 0e 00 0e 	add	lr,r3,lr
80004fbc:	a5 7e       	lsl	lr,0x5
80004fbe:	20 1e       	sub	lr,1
80004fc0:	f2 03 15 09 	lsl	r3,r9,0x9
80004fc4:	fc 03 0c 02 	divs	r2,lr,r3
80004fc8:	e4 09 02 4e 	mul	lr,r2,r9
80004fcc:	f5 5e 00 1a 	st.h	r10[26],lr

   // Get number of reserved sector
   LSB( u16_tmp ) = LOW_16_BPB_ResvSecCnt;
80004fd0:	f7 33 00 0e 	ld.ub	r3,r11[14]
80004fd4:	ae 83       	st.b	r7[0x0],r3
   MSB( u16_tmp ) = HIGH_16_BPB_ResvSecCnt;
80004fd6:	f7 37 00 0f 	ld.ub	r7,r11[15]
80004fda:	ac 87       	st.b	r6[0x0],r7
   // Get FSInfo position
   fs_g_nav.u16_offset_FSInfo = (u16_tmp-LOW_16_BPB_FSInfo)*u8_sector_size;
80004fdc:	9a 57       	ld.sh	r7,sp[0xa]
80004fde:	f7 3b 00 30 	ld.ub	r11,r11[48]
80004fe2:	0e 96       	mov	r6,r7
80004fe4:	ee 0b 01 0b 	sub	r11,r7,r11
80004fe8:	b3 3b       	mul	r11,r9
80004fea:	b4 4b       	st.h	r10[0x8],r11
   u16_tmp *= u8_sector_size; // number of reserved sector translated in unit 512B

   // Compute the FAT address (unit 512B)
   fs_g_nav.u32_ptr_fat = fs_gu32_addrsector + u16_tmp;
80004fec:	ee 09 02 49 	mul	r9,r7,r9
80004ff0:	5c 79       	castu.h	r9
80004ff2:	4a 8b       	lddpc	r11,80005090 <fat_mount+0x2e4>
80004ff4:	76 0b       	ld.w	r11,r11[0x0]
80004ff6:	f2 0b 00 0b 	add	r11,r9,r11
80004ffa:	95 4b       	st.w	r10[0x10],r11

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;
80004ffc:	5c 7e       	castu.h	lr
80004ffe:	fc 0c 00 1c 	add	r12,lr,r12<<0x1
80005002:	95 5c       	st.w	r10[0x14],r12
   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
80005004:	58 08       	cp.w	r8,0
80005006:	c3 b0       	breq	8000507c <fat_mount+0x2d0>

   // Compute the offset (unit 512B) between the first data cluster and the FAT beginning
   fs_g_nav.u32_offset_data = (FS_NB_FAT * fs_g_nav.u32_fat_size) + (uint32_t)fs_g_nav.rootdir.seg.u16_size;

   // Compute the data region (clusters space = Total - Sector used) size (unit 512B)
   u32_tmp -= ((uint32_t)u16_tmp + fs_g_nav.u32_offset_data);
80005008:	a9 35       	mul	r5,r4
8000500a:	ea 09 01 09 	sub	r9,r5,r9
8000500e:	18 19       	sub	r9,r12
80005010:	50 19       	stdsp	sp[0x4],r9

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
80005012:	30 1a       	mov	r10,1
80005014:	f4 08 18 00 	cp.b	r8,r10
80005018:	c0 70       	breq	80005026 <fat_mount+0x27a>
   {
     u32_tmp  >>= 1;   // This computation round down
8000501a:	a1 99       	lsr	r9,0x1

   // Compute the count of CLUSTER in the data region
   // !!!Optimization -> u32_CountofCluster (unit 512B)/ fs_g_nav.u8_BPB_SecPerClus (unit 512B & power of 2)
   if (!fs_g_nav.u8_BPB_SecPerClus)
     return false;
   for( u8_tmp = fs_g_nav.u8_BPB_SecPerClus; u8_tmp!=1 ; u8_tmp >>= 1 )
8000501c:	a1 98       	lsr	r8,0x1
8000501e:	f4 08 18 00 	cp.b	r8,r10
80005022:	cf c1       	brne	8000501a <fat_mount+0x26e>
80005024:	50 19       	stdsp	sp[0x4],r9
   {
     u32_tmp  >>= 1;   // This computation round down
   }
   fs_g_nav.u32_CountofCluster = u32_tmp+2; // The total of cluster include the two reserved clusters
80005026:	40 18       	lddsp	r8,sp[0x4]
80005028:	f0 ca ff fe 	sub	r10,r8,-2
8000502c:	49 69       	lddpc	r9,80005084 <fat_mount+0x2d8>
8000502e:	93 3a       	st.w	r9[0xc],r10

   // Determine the FAT type
   if (u32_tmp < FS_FAT12_MAX_CLUSTERS)
80005030:	e0 48 0f f4 	cp.w	r8,4084
80005034:	e0 8b 00 07 	brhi	80005042 <fat_mount+0x296>
   {
      // Is FAT 12
#if (FS_FAT_12 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_12;
80005038:	30 19       	mov	r9,1
8000503a:	49 58       	lddpc	r8,8000508c <fat_mount+0x2e0>
8000503c:	b0 89       	st.b	r8[0x0],r9
8000503e:	30 1c       	mov	r12,1
80005040:	c1 f8       	rjmp	8000507e <fat_mount+0x2d2>
   } else {
   if (u32_tmp < FS_FAT16_MAX_CLUSTERS)
80005042:	e0 48 ff f4 	cp.w	r8,65524
80005046:	e0 8b 00 07 	brhi	80005054 <fat_mount+0x2a8>
   {
      // Is FAT 16
#if (FS_FAT_16 == false)
      return FS_NO_SUPPORT_PART;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_16;
8000504a:	30 29       	mov	r9,2
8000504c:	49 08       	lddpc	r8,8000508c <fat_mount+0x2e0>
8000504e:	b0 89       	st.b	r8[0x0],r9
80005050:	30 1c       	mov	r12,1
80005052:	c1 68       	rjmp	8000507e <fat_mount+0x2d2>
   } else {
      // Is FAT 32
#if (FS_FAT_32 == false)
      return false;
#endif
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_32;
80005054:	30 39       	mov	r9,3
80005056:	48 e8       	lddpc	r8,8000508c <fat_mount+0x2e0>
80005058:	b0 89       	st.b	r8[0x0],r9
      // In FAT32, the root dir is like another directory, this one have a cluster list
      // Get the first cluster number of root
      LSB0( fs_g_nav.rootdir.u32_cluster ) = LOW0_32_BPB_RootClus;
8000505a:	48 b8       	lddpc	r8,80005084 <fat_mount+0x2d8>
8000505c:	2e 88       	sub	r8,-24
8000505e:	48 f9       	lddpc	r9,80005098 <fat_mount+0x2ec>
80005060:	f3 3a 00 2c 	ld.ub	r10,r9[44]
80005064:	b0 ba       	st.b	r8[0x3],r10
      LSB1( fs_g_nav.rootdir.u32_cluster ) = LOW1_32_BPB_RootClus;
80005066:	f3 3a 00 2d 	ld.ub	r10,r9[45]
8000506a:	b0 aa       	st.b	r8[0x2],r10
      LSB2( fs_g_nav.rootdir.u32_cluster ) = LOW2_32_BPB_RootClus;
8000506c:	f3 3a 00 2e 	ld.ub	r10,r9[46]
80005070:	b0 9a       	st.b	r8[0x1],r10
      LSB3( fs_g_nav.rootdir.u32_cluster ) = LOW3_32_BPB_RootClus;
80005072:	f3 39 00 2f 	ld.ub	r9,r9[47]
80005076:	b0 89       	st.b	r8[0x0],r9
80005078:	30 1c       	mov	r12,1
8000507a:	c0 28       	rjmp	8000507e <fat_mount+0x2d2>
8000507c:	30 0c       	mov	r12,0
   }
   }

   return true;
}
8000507e:	2f dd       	sub	sp,-12
80005080:	d8 32       	popm	r0-r7,pc
80005082:	00 00       	add	r0,r0
80005084:	00 00       	add	r0,r0
80005086:	0c 34       	cp.w	r4,r6
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	32 a8       	mov	r8,42
8000508c:	00 00       	add	r0,r0
8000508e:	0c 80       	andn	r0,r6
80005090:	00 00       	add	r0,r0
80005092:	09 f0       	ld.ub	r0,r4[0x7]
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	41 34       	lddsp	r4,sp[0x4c]
80005098:	00 00       	add	r0,r0
8000509a:	0a 34       	cp.w	r4,r5
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	38 9c       	mov	r12,-119
800050a0:	00 00       	add	r0,r0
800050a2:	0c 84       	andn	r4,r6
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	42 f0       	lddsp	r0,sp[0xbc]

800050a8 <file_eof>:
//! @return    1     the position is at the end of file
//! @return    0     the position isn't at the end of file
//! @return    FFh   error
//!
uint8_t    file_eof( void )
{
800050a8:	d4 01       	pushm	lr
   if( !fat_check_mount_select_open() )
800050aa:	f0 1f 00 07 	mcall	800050c4 <file_eof+0x1c>
800050ae:	c0 41       	brne	800050b6 <file_eof+0xe>
800050b0:	e0 6c 00 ff 	mov	r12,255
800050b4:	d8 02       	popm	pc
      return 0xFF;
   return (fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file );
800050b6:	48 58       	lddpc	r8,800050c8 <file_eof+0x20>
800050b8:	70 29       	ld.w	r9,r8[0x8]
800050ba:	70 38       	ld.w	r8,r8[0xc]
800050bc:	10 39       	cp.w	r9,r8
800050be:	5f 8c       	srls	r12
}
800050c0:	d8 02       	popm	pc
800050c2:	00 00       	add	r0,r0
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	42 78       	lddsp	r8,sp[0x9c]
800050c8:	00 00       	add	r0,r0
800050ca:	09 f4       	ld.ub	r4,r4[0x7]

800050cc <file_close>:


//! This function closes the file
//!
void  file_close( void )
{
800050cc:	d4 01       	pushm	lr
   // If a file is opened, then close this one
   if( fat_check_mount_select_open() )
800050ce:	f0 1f 00 0a 	mcall	800050f4 <file_close+0x28>
800050d2:	c1 00       	breq	800050f2 <file_close+0x26>
   {

#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if( FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode )
800050d4:	48 98       	lddpc	r8,800050f8 <file_close+0x2c>
800050d6:	11 88       	ld.ub	r8,r8[0x0]
800050d8:	e2 18 00 02 	andl	r8,0x2,COH
800050dc:	c0 80       	breq	800050ec <file_close+0x20>
      {
         // Write file information
         if( !fat_read_dir() )
800050de:	f0 1f 00 08 	mcall	800050fc <file_close+0x30>
800050e2:	c0 80       	breq	800050f2 <file_close+0x26>
            return;           // error
         fat_write_entry_file();
800050e4:	f0 1f 00 07 	mcall	80005100 <file_close+0x34>
         fat_cache_flush();   // In case of error during writing data, flush the data before exit function
800050e8:	f0 1f 00 07 	mcall	80005104 <file_close+0x38>
      }
#endif  // FS_LEVEL_FEATURES
      Fat_file_close();
800050ec:	30 09       	mov	r9,0
800050ee:	48 38       	lddpc	r8,800050f8 <file_close+0x2c>
800050f0:	b0 89       	st.b	r8[0x0],r9
800050f2:	d8 02       	popm	pc
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	42 78       	lddsp	r8,sp[0x9c]
800050f8:	00 00       	add	r0,r0
800050fa:	09 f4       	ld.ub	r4,r4[0x7]
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	3e cc       	mov	r12,-20
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	36 8c       	mov	r12,104
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	38 30       	mov	r0,-125

80005108 <file_putc>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_putc( uint8_t u8_byte )
{
80005108:	eb cd 40 80 	pushm	r7,lr
8000510c:	18 97       	mov	r7,r12
   if( !fat_check_mount_select_open())
8000510e:	f0 1f 00 15 	mcall	80005160 <file_putc+0x58>
80005112:	c2 50       	breq	8000515c <file_putc+0x54>
      return false;

   if(!(FOPEN_WRITE_ACCESS & fs_g_nav_entry.u8_open_mode))
80005114:	49 48       	lddpc	r8,80005164 <file_putc+0x5c>
80005116:	11 88       	ld.ub	r8,r8[0x0]
80005118:	e2 18 00 02 	andl	r8,0x2,COH
8000511c:	c0 61       	brne	80005128 <file_putc+0x20>
   {
      fs_g_status = FS_ERR_READ_ONLY;
8000511e:	31 59       	mov	r9,21
80005120:	49 28       	lddpc	r8,80005168 <file_putc+0x60>
80005122:	b0 89       	st.b	r8[0x0],r9
80005124:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   if( !fat_write_file( FS_CLUST_ACT_ONE  , 1 ))
80005128:	30 1b       	mov	r11,1
8000512a:	30 2c       	mov	r12,2
8000512c:	f0 1f 00 10 	mcall	8000516c <file_putc+0x64>
80005130:	c1 60       	breq	8000515c <file_putc+0x54>
      return false;

   // Write the data in the internal cache
   fat_cache_mark_sector_as_dirty();
80005132:	f0 1f 00 10 	mcall	80005170 <file_putc+0x68>
   fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ]    = u8_byte;
80005136:	48 c8       	lddpc	r8,80005164 <file_putc+0x5c>
80005138:	70 39       	ld.w	r9,r8[0xc]
8000513a:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
8000513e:	48 eb       	lddpc	r11,80005174 <file_putc+0x6c>
80005140:	f6 0a 0b 07 	st.b	r11[r10],r7
   fs_g_nav_entry.u32_pos_in_file++;
80005144:	2f f9       	sub	r9,-1
80005146:	91 39       	st.w	r8[0xc],r9

   // Update the file size
   if( fs_g_nav_entry.u32_pos_in_file > fs_g_nav_entry.u32_size )
80005148:	70 28       	ld.w	r8,r8[0x8]
8000514a:	10 39       	cp.w	r9,r8
8000514c:	e0 8b 00 04 	brhi	80005154 <file_putc+0x4c>
80005150:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      fs_g_nav_entry.u32_size = fs_g_nav_entry.u32_pos_in_file;
80005154:	48 48       	lddpc	r8,80005164 <file_putc+0x5c>
80005156:	91 29       	st.w	r8[0x8],r9
80005158:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
8000515c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	42 78       	lddsp	r8,sp[0x9c]
80005164:	00 00       	add	r0,r0
80005166:	09 f4       	ld.ub	r4,r4[0x7]
80005168:	00 00       	add	r0,r0
8000516a:	0c 84       	andn	r4,r6
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	40 2c       	lddsp	r12,sp[0x8]
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	36 7c       	mov	r12,103
80005174:	00 00       	add	r0,r0
80005176:	0a 34       	cp.w	r4,r5

80005178 <file_getc>:
//!
//! @return    The byte read
//! @return    EOF, in case of error or end of file
//!
uint16_t   file_getc( void )
{
80005178:	d4 01       	pushm	lr
   uint16_t   u16_byte;

   while(1)
   {
      if(!(FOPEN_READ_ACCESS & fs_g_nav_entry.u8_open_mode))
8000517a:	49 78       	lddpc	r8,800051d4 <file_getc+0x5c>
8000517c:	11 88       	ld.ub	r8,r8[0x0]
8000517e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005182:	c0 51       	brne	8000518c <file_getc+0x14>
      {
         fs_g_status = FS_ERR_WRITE_ONLY;
80005184:	31 e9       	mov	r9,30
80005186:	49 58       	lddpc	r8,800051d8 <file_getc+0x60>
80005188:	b0 89       	st.b	r8[0x0],r9
8000518a:	dc 0a       	popm	pc,r12=-1
         break;
      }
      if( fs_g_nav_entry.u32_size <= fs_g_nav_entry.u32_pos_in_file )
8000518c:	49 28       	lddpc	r8,800051d4 <file_getc+0x5c>
8000518e:	70 29       	ld.w	r9,r8[0x8]
80005190:	70 38       	ld.w	r8,r8[0xc]
80005192:	10 39       	cp.w	r9,r8
80005194:	e0 8b 00 06 	brhi	800051a0 <file_getc+0x28>
      {
         fs_g_status = FS_ERR_EOF;
80005198:	32 09       	mov	r9,32
8000519a:	49 08       	lddpc	r8,800051d8 <file_getc+0x60>
8000519c:	b0 89       	st.b	r8[0x0],r9
8000519e:	dc 0a       	popm	pc,r12=-1
         break;
      }

      if( !fat_read_file( FS_CLUST_ACT_ONE ))
800051a0:	30 2c       	mov	r12,2
800051a2:	f0 1f 00 0f 	mcall	800051dc <file_getc+0x64>
800051a6:	c0 c1       	brne	800051be <file_getc+0x46>
      {
         if( FS_ERR_OUT_LIST == fs_g_status )
800051a8:	48 c8       	lddpc	r8,800051d8 <file_getc+0x60>
800051aa:	11 89       	ld.ub	r9,r8[0x0]
800051ac:	31 a8       	mov	r8,26
800051ae:	f0 09 18 00 	cp.b	r9,r8
800051b2:	c0 20       	breq	800051b6 <file_getc+0x3e>
800051b4:	dc 0a       	popm	pc,r12=-1
         {  // Translate the error
            fs_g_status = FS_ERR_EOF;   // End of file
800051b6:	32 09       	mov	r9,32
800051b8:	48 88       	lddpc	r8,800051d8 <file_getc+0x60>
800051ba:	b0 89       	st.b	r8[0x0],r9
800051bc:	dc 0a       	popm	pc,r12=-1
         }
         break;
      }

      u16_byte = fs_g_sector[ fs_g_nav_entry.u32_pos_in_file & FS_512B_MASK ];
800051be:	48 68       	lddpc	r8,800051d4 <file_getc+0x5c>
800051c0:	70 39       	ld.w	r9,r8[0xc]
800051c2:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
800051c6:	48 7b       	lddpc	r11,800051e0 <file_getc+0x68>
800051c8:	f6 0a 07 0c 	ld.ub	r12,r11[r10]
      fs_g_nav_entry.u32_pos_in_file++;
800051cc:	2f f9       	sub	r9,-1
800051ce:	91 39       	st.w	r8[0xc],r9
      return u16_byte;
   }
   return FS_EOF;   // No data read
}
800051d0:	d8 02       	popm	pc
800051d2:	00 00       	add	r0,r0
800051d4:	00 00       	add	r0,r0
800051d6:	09 f4       	ld.ub	r4,r4[0x7]
800051d8:	00 00       	add	r0,r0
800051da:	0c 84       	andn	r4,r6
800051dc:	80 00       	ld.sh	r0,r0[0x0]
800051de:	3f 50       	mov	r0,-11
800051e0:	00 00       	add	r0,r0
800051e2:	0a 34       	cp.w	r4,r5

800051e4 <file_open>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  file_open( uint8_t fopen_mode )
{
800051e4:	eb cd 40 c0 	pushm	r6-r7,lr
800051e8:	18 97       	mov	r7,r12
   if( !fat_check_mount_select_noopen())
800051ea:	f0 1f 00 20 	mcall	80005268 <file_open+0x84>
800051ee:	c3 a0       	breq	80005262 <file_open+0x7e>
      return false;

   if( !fat_check_is_file())
800051f0:	f0 1f 00 1f 	mcall	8000526c <file_open+0x88>
800051f4:	c3 70       	breq	80005262 <file_open+0x7e>
      return false;

   if(FOPEN_WRITE_ACCESS & fopen_mode)
800051f6:	0e 96       	mov	r6,r7
800051f8:	0e 98       	mov	r8,r7
800051fa:	e2 18 00 02 	andl	r8,0x2,COH
800051fe:	c1 90       	breq	80005230 <file_open+0x4c>
   {
      if( !fat_check_nav_access_file( true ) )
80005200:	30 1c       	mov	r12,1
80005202:	f0 1f 00 1c 	mcall	80005270 <file_open+0x8c>
80005206:	c2 e0       	breq	80005262 <file_open+0x7e>
         return false;
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
      if (FS_ATTR_READ_ONLY & fs_g_nav_entry.u8_attr)
80005208:	49 b8       	lddpc	r8,80005274 <file_open+0x90>
8000520a:	11 a8       	ld.ub	r8,r8[0x2]
8000520c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005210:	c0 60       	breq	8000521c <file_open+0x38>
      {
         fs_g_status = FS_ERR_READ_ONLY;  // File is read only
80005212:	31 59       	mov	r9,21
80005214:	49 98       	lddpc	r8,80005278 <file_open+0x94>
80005216:	b0 89       	st.b	r8[0x0],r9
80005218:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
         return false;
      }
      if( mem_wr_protect( fs_g_nav.u8_lun  ))
8000521c:	49 88       	lddpc	r8,8000527c <file_open+0x98>
8000521e:	11 8c       	ld.ub	r12,r8[0x0]
80005220:	f0 1f 00 18 	mcall	80005280 <file_open+0x9c>
80005224:	c0 a0       	breq	80005238 <file_open+0x54>
      {
         fs_g_status = FS_LUN_WP;  // Disk read only
80005226:	31 49       	mov	r9,20
80005228:	49 48       	lddpc	r8,80005278 <file_open+0x94>
8000522a:	b0 89       	st.b	r8[0x0],r9
8000522c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      return false;
#endif  // FS_LEVEL_FEATURES
   }
   else
   {
      if( !fat_check_nav_access_file( false ) )
80005230:	30 0c       	mov	r12,0
80005232:	f0 1f 00 10 	mcall	80005270 <file_open+0x8c>
80005236:	c1 60       	breq	80005262 <file_open+0x7e>
         return false;
   }

   if(FOPEN_CLEAR_SIZE & fopen_mode)
80005238:	0c 98       	mov	r8,r6
8000523a:	e2 18 00 04 	andl	r8,0x4,COH
8000523e:	c0 40       	breq	80005246 <file_open+0x62>
   {
      fs_g_nav_entry.u32_size    = 0;     // The size is null
80005240:	30 09       	mov	r9,0
80005242:	48 d8       	lddpc	r8,80005274 <file_open+0x90>
80005244:	91 29       	st.w	r8[0x8],r9
   }
   if(FOPEN_CLEAR_PTR & fopen_mode)
80005246:	e2 16 00 08 	andl	r6,0x8,COH
8000524a:	c0 50       	breq	80005254 <file_open+0x70>
   {
      fs_g_nav_entry.u32_pos_in_file = 0;
8000524c:	30 09       	mov	r9,0
8000524e:	48 a8       	lddpc	r8,80005274 <file_open+0x90>
80005250:	91 39       	st.w	r8[0xc],r9
80005252:	c0 48       	rjmp	8000525a <file_open+0x76>
   }
   else
   {  // Go to at the end of file
      fs_g_nav_entry.u32_pos_in_file = fs_g_nav_entry.u32_size;
80005254:	48 88       	lddpc	r8,80005274 <file_open+0x90>
80005256:	70 29       	ld.w	r9,r8[0x8]
80005258:	91 39       	st.w	r8[0xc],r9
   }
   fs_g_nav_entry.u8_open_mode = fopen_mode;
8000525a:	48 78       	lddpc	r8,80005274 <file_open+0x90>
8000525c:	b0 87       	st.b	r8[0x0],r7
8000525e:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
   return true;
80005262:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80005266:	00 00       	add	r0,r0
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	42 9c       	lddsp	r12,sp[0xa4]
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	2f c0       	sub	r0,-4
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	36 dc       	mov	r12,109
80005274:	00 00       	add	r0,r0
80005276:	09 f4       	ld.ub	r4,r4[0x7]
80005278:	00 00       	add	r0,r0
8000527a:	0c 84       	andn	r4,r6
8000527c:	00 00       	add	r0,r0
8000527e:	0c 34       	cp.w	r4,r6
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	42 f8       	lddsp	r8,sp[0xbc]

80005284 <nav_drive_get>:
      return 0xFF;
   return ((fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return (fs_g_nav.u8_lun);
#endif
}
80005284:	48 28       	lddpc	r8,8000528c <nav_drive_get+0x8>
80005286:	11 8c       	ld.ub	r12,r8[0x0]
80005288:	5e fc       	retal	r12
8000528a:	00 00       	add	r0,r0
8000528c:	00 00       	add	r0,r0
8000528e:	0c 34       	cp.w	r4,r6

80005290 <nav_drive_getname>:
//! @return    'A','B',...
//! @return    'X', in case of no drive selected
//!
uint8_t    nav_drive_getname( void )
{
   if(0xFF == fs_g_nav.u8_lun)
80005290:	48 68       	lddpc	r8,800052a8 <nav_drive_getname+0x18>
80005292:	11 8c       	ld.ub	r12,r8[0x0]
80005294:	3f f8       	mov	r8,-1
80005296:	f0 0c 18 00 	cp.b	r12,r8
8000529a:	c0 31       	brne	800052a0 <nav_drive_getname+0x10>
8000529c:	35 8c       	mov	r12,88
8000529e:	5e fc       	retal	r12
      return 'X';
#if (FS_MULTI_PARTITION  ==  true)
   return ('A' + (fs_g_nav.u8_lun*4) + fs_g_nav.u8_partition); // Maximum 4 partitions per device
#else
   return ('A' + fs_g_nav.u8_lun);
800052a0:	2b fc       	sub	r12,-65
800052a2:	5c 5c       	castu.b	r12
#endif
}
800052a4:	5e fc       	retal	r12
800052a6:	00 00       	add	r0,r0
800052a8:	00 00       	add	r0,r0
800052aa:	0c 34       	cp.w	r4,r6

800052ac <nav_getindex>:
//! This routine is interesting to save a file position in small variable.
//! This pointer allow to reinit a navigator quickly with nav_gotoindex() routine.
//! @endverbatim
//!
Fs_index nav_getindex( void )
{
800052ac:	20 3d       	sub	sp,12
   // Fill index structure
   index.u8_lun                  = fs_g_nav.u8_lun;
#if (FS_MULTI_PARTITION  ==  true)
   index.u8_partition            = fs_g_nav.u8_partition;
#endif
   index.u32_cluster_sel_dir     = fs_g_nav.u32_cluster_sel_dir;
800052ae:	48 69       	lddpc	r9,800052c4 <nav_getindex+0x18>
800052b0:	72 8b       	ld.w	r11,r9[0x20]
   index.u16_entry_pos_sel_file  = fs_g_nav_fast.u16_entry_pos_sel_file;
800052b2:	48 6a       	lddpc	r10,800052c8 <nav_getindex+0x1c>
800052b4:	94 1a       	ld.sh	r10,r10[0x2]
   return index;
800052b6:	13 89       	ld.ub	r9,r9[0x0]
800052b8:	b8 89       	st.b	r12[0x0],r9
800052ba:	99 1b       	st.w	r12[0x4],r11
800052bc:	b8 4a       	st.h	r12[0x8],r10
}
800052be:	2f dd       	sub	sp,-12
800052c0:	5e fc       	retal	r12
800052c2:	00 00       	add	r0,r0
800052c4:	00 00       	add	r0,r0
800052c6:	0c 34       	cp.w	r4,r6
800052c8:	00 00       	add	r0,r0
800052ca:	0c 80       	andn	r0,r6

800052cc <nav_file_lgt>:
//! @return    Size of selected file (unit byte)
//!
uint32_t   nav_file_lgt( void )
{
   return fs_g_nav_entry.u32_size;
}
800052cc:	48 28       	lddpc	r8,800052d4 <nav_file_lgt+0x8>
800052ce:	70 2c       	ld.w	r12,r8[0x8]
800052d0:	5e fc       	retal	r12
800052d2:	00 00       	add	r0,r0
800052d4:	00 00       	add	r0,r0
800052d6:	09 f4       	ld.ub	r4,r4[0x7]

800052d8 <nav_file_name>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_file_name( FS_STRING sz_name , uint8_t u8_size_max , bool b_mode , bool b_match_case  )
{
800052d8:	d4 31       	pushm	r0-r7,lr
800052da:	20 1d       	sub	sp,4
800052dc:	18 95       	mov	r5,r12
800052de:	16 96       	mov	r6,r11
800052e0:	14 97       	mov	r7,r10
800052e2:	12 93       	mov	r3,r9
   _MEM_TYPE_SLOW_   uint16_t u16_lgt;   // Only used if LENGTH string mode enabled
   uint16_t  u16_ptr_save_entry;
   bool  b_readshortname = false;

   if ( !fat_check_mount_select())
800052e4:	f0 1f 00 2f 	mcall	800053a0 <nav_file_name+0xc8>
800052e8:	c5 80       	breq	80005398 <nav_file_name+0xc0>
      return false;

   // Check if the string size is not 0
   if( (FS_NAME_GET == b_mode)
800052ea:	58 07       	cp.w	r7,0
800052ec:	c0 50       	breq	800052f6 <nav_file_name+0x1e>
800052ee:	58 06       	cp.w	r6,0
800052f0:	c0 31       	brne	800052f6 <nav_file_name+0x1e>
800052f2:	30 1c       	mov	r12,1
800052f4:	c5 38       	rjmp	8000539a <nav_file_name+0xc2>
   {
      return true;
   }

   // Save the current entry position
   u16_ptr_save_entry = fs_g_nav_fast.u16_entry_pos_sel_file;
800052f6:	4a c8       	lddpc	r8,800053a4 <nav_file_name+0xcc>
800052f8:	90 14       	ld.sh	r4,r8[0x2]
   // if it is the beginning of the directory
   if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
800052fa:	58 04       	cp.w	r4,0
800052fc:	c0 31       	brne	80005302 <nav_file_name+0x2a>
800052fe:	30 10       	mov	r0,1
80005300:	c0 68       	rjmp	8000530c <nav_file_name+0x34>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
80005302:	08 99       	mov	r9,r4
80005304:	20 19       	sub	r9,1
80005306:	4a 88       	lddpc	r8,800053a4 <nav_file_name+0xcc>
80005308:	b0 19       	st.h	r8[0x2],r9
8000530a:	30 00       	mov	r0,0
8000530c:	30 09       	mov	r9,0
8000530e:	50 09       	stdsp	sp[0x0],r9
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
         return true;
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
80005310:	31 01       	mov	r1,16
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
         u8_size_max -= FS_SIZE_LFN_ENTRY;
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80005312:	4a 52       	lddpc	r2,800053a4 <nav_file_name+0xcc>
80005314:	c0 28       	rjmp	80005318 <nav_file_name+0x40>
   {
      b_readshortname = true;                   // It isn't possible to have a long name
   }
   else
   {
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Initialize entry position to search the first long name entry
80005316:	30 10       	mov	r0,1

   // Loop in directory entry
   u16_lgt = 0;
   while( 1 )
   {
      if ( !fat_read_dir())
80005318:	f0 1f 00 24 	mcall	800053a8 <nav_file_name+0xd0>
8000531c:	c3 e0       	breq	80005398 <nav_file_name+0xc0>
         break; // error

      if ( b_readshortname )
8000531e:	58 00       	cp.w	r0,0
80005320:	c0 70       	breq	8000532e <nav_file_name+0x56>
      {
         // No long name present then read short name
         return fat_entry_shortname( sz_name , u8_size_max , b_mode  );
80005322:	0e 9a       	mov	r10,r7
80005324:	0c 9b       	mov	r11,r6
80005326:	0a 9c       	mov	r12,r5
80005328:	f0 1f 00 21 	mcall	800053ac <nav_file_name+0xd4>
8000532c:	c3 78       	rjmp	8000539a <nav_file_name+0xc2>
      }

      // Check or read the part of long file name in this entry
      if ( fat_entry_longname( sz_name , u8_size_max , b_mode , b_match_case  ))
8000532e:	06 99       	mov	r9,r3
80005330:	0e 9a       	mov	r10,r7
80005332:	0c 9b       	mov	r11,r6
80005334:	0a 9c       	mov	r12,r5
80005336:	f0 1f 00 1f 	mcall	800053b0 <nav_file_name+0xd8>
8000533a:	c1 20       	breq	8000535e <nav_file_name+0x86>
      {
         if( g_b_string_length )
8000533c:	49 e8       	lddpc	r8,800053b4 <nav_file_name+0xdc>
8000533e:	11 89       	ld.ub	r9,r8[0x0]
80005340:	30 08       	mov	r8,0
         {
            ((FS_STR_UNICODE)sz_name )[0] += u16_lgt;
80005342:	f0 09 18 00 	cp.b	r9,r8
80005346:	eb f8 12 00 	ld.shne	r8,r5[0x0]
8000534a:	fb f9 10 00 	ld.wne	r9,sp[0x0]
8000534e:	f1 d9 e1 08 	addne	r8,r8,r9
80005352:	eb f8 1c 00 	st.hne	r5[0x0],r8
         }
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
80005356:	49 48       	lddpc	r8,800053a4 <nav_file_name+0xcc>
80005358:	b0 14       	st.h	r8[0x2],r4
8000535a:	30 1c       	mov	r12,1
         return true;
8000535c:	c1 f8       	rjmp	8000539a <nav_file_name+0xc2>
      }

      if ( FS_NO_LAST_LFN_ENTRY != fs_g_status )
8000535e:	49 79       	lddpc	r9,800053b8 <nav_file_name+0xe0>
80005360:	13 88       	ld.ub	r8,r9[0x0]
80005362:	e2 08 18 00 	cp.b	r8,r1
80005366:	c0 70       	breq	80005374 <nav_file_name+0x9c>
      {
         // Go to the main entry file (=short name entry)
         fs_g_nav_fast.u16_entry_pos_sel_file = u16_ptr_save_entry;
80005368:	a4 14       	st.h	r2[0x2],r4

         if ( FS_ERR_ENTRY_BAD == fs_g_status )
8000536a:	30 b9       	mov	r9,11
8000536c:	f2 08 18 00 	cp.b	r8,r9
80005370:	c1 41       	brne	80005398 <nav_file_name+0xc0>
80005372:	cd 2b       	rjmp	80005316 <nav_file_name+0x3e>
            continue;                 // restart the loop
         }
         // here, it is a error system or the string don't match with the file name
         break;
      }
      if( g_b_string_length )
80005374:	49 09       	lddpc	r9,800053b4 <nav_file_name+0xdc>
80005376:	13 88       	ld.ub	r8,r9[0x0]
80005378:	30 09       	mov	r9,0
8000537a:	f2 08 18 00 	cp.b	r8,r9
8000537e:	c0 60       	breq	8000538a <nav_file_name+0xb2>
      {
         u16_lgt += FS_SIZE_LFN_ENTRY;
80005380:	40 08       	lddsp	r8,sp[0x0]
80005382:	2f 38       	sub	r8,-13
80005384:	5c 88       	casts.h	r8
80005386:	50 08       	stdsp	sp[0x0],r8
80005388:	c0 48       	rjmp	80005390 <nav_file_name+0xb8>
      }
      else
      {
         // Increment the string to store the next part of file name
         sz_name += FS_SIZE_LFN_ENTRY * (Is_unicode? 2 : 1 );
8000538a:	2f 35       	sub	r5,-13
         u8_size_max -= FS_SIZE_LFN_ENTRY;
8000538c:	20 d6       	sub	r6,13
8000538e:	5c 56       	castu.b	r6
      }
      fs_g_nav_fast.u16_entry_pos_sel_file--;   // Go to the next part of long file name
80005390:	84 18       	ld.sh	r8,r2[0x2]
80005392:	20 18       	sub	r8,1
80005394:	a4 18       	st.h	r2[0x2],r8
80005396:	cc 1b       	rjmp	80005318 <nav_file_name+0x40>
80005398:	30 0c       	mov	r12,0

   }  // end of loop while(1)
   return false;
}
8000539a:	2f fd       	sub	sp,-4
8000539c:	d8 32       	popm	r0-r7,pc
8000539e:	00 00       	add	r0,r0
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	42 60       	lddsp	r0,sp[0x98]
800053a4:	00 00       	add	r0,r0
800053a6:	0c 80       	andn	r0,r6
800053a8:	80 00       	ld.sh	r0,r0[0x0]
800053aa:	3e cc       	mov	r12,-20
800053ac:	80 00       	ld.sh	r0,r0[0x0]
800053ae:	34 b8       	mov	r8,75
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	33 24       	mov	r4,50
800053b4:	00 00       	add	r0,r0
800053b6:	0c 85       	andn	r5,r6
800053b8:	00 00       	add	r0,r0
800053ba:	0c 84       	andn	r4,r6

800053bc <nav_filelist_set>:
//! @verbatim
//! Note: if no file is selected then nav_filelist_set( 0 , FS_NEXT ) goes to the first entry of the file list.
//! @endverbatim
//!
bool  nav_filelist_set( uint16_t u16_nb , bool b_direction )
{
800053bc:	d4 31       	pushm	r0-r7,lr
800053be:	20 4d       	sub	sp,16
800053c0:	50 0c       	stdsp	sp[0x0],r12
800053c2:	16 92       	mov	r2,r11
   uint16_t   u16_ptr_save_entry;
   uint16_t   u16_save_pos_sel_file;
   bool  b_save_entry_type;
   bool  b_find_last_entry = false;

   if ( !fat_check_mount_noopen())
800053c4:	f0 1f 00 51 	mcall	80005508 <nav_filelist_set+0x14c>
800053c8:	e0 80 00 9e 	breq	80005504 <nav_filelist_set+0x148>
      return false;

   // Save the current selection
   u16_ptr_save_entry      = fs_g_nav_fast.u16_entry_pos_sel_file;
800053cc:	4d 08       	lddpc	r8,8000550c <nav_filelist_set+0x150>
800053ce:	90 18       	ld.sh	r8,r8[0x2]
800053d0:	50 28       	stdsp	sp[0x8],r8
   u16_save_pos_sel_file   = fs_g_nav.u16_pos_sel_file;
800053d2:	4d 08       	lddpc	r8,80005510 <nav_filelist_set+0x154>
800053d4:	f1 0a 00 24 	ld.sh	r10,r8[36]
800053d8:	50 1a       	stdsp	sp[0x4],r10
   b_save_entry_type       = fs_g_nav.b_mode_nav;
800053da:	f1 38 00 2c 	ld.ub	r8,r8[44]
800053de:	50 38       	stdsp	sp[0xc],r8
800053e0:	30 03       	mov	r3,0
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
800053e2:	4c b7       	lddpc	r7,8000550c <nav_filelist_set+0x150>
800053e4:	3f f0       	mov	r0,-1
            break;
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
800053e6:	4c b6       	lddpc	r6,80005510 <nav_filelist_set+0x154>
800053e8:	30 04       	mov	r4,0
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
800053ea:	3f e1       	mov	r1,-2
           continue;
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
800053ec:	4c a5       	lddpc	r5,80005514 <nav_filelist_set+0x158>
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
800053ee:	58 02       	cp.w	r2,0
800053f0:	c0 31       	brne	800053f6 <nav_filelist_set+0x3a>
800053f2:	58 03       	cp.w	r3,0
800053f4:	c0 c0       	breq	8000540c <nav_filelist_set+0x50>
      || ( b_find_last_entry ) )
      {
         if ( FS_END_FIND == fs_g_nav_fast.u16_entry_pos_sel_file )
800053f6:	8e 18       	ld.sh	r8,r7[0x2]
800053f8:	e2 08 19 00 	cp.h	r8,r1
800053fc:	c0 51       	brne	80005406 <nav_filelist_set+0x4a>
         {
            // Too many files in directory (case impossible)
            fs_g_status = FS_ERR_FS;
800053fe:	30 89       	mov	r9,8
80005400:	4c 58       	lddpc	r8,80005514 <nav_filelist_set+0x158>
80005402:	b0 89       	st.b	r8[0x0],r9
            break;
80005404:	c7 38       	rjmp	800054ea <nav_filelist_set+0x12e>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
80005406:	2f f8       	sub	r8,-1
80005408:	ae 18       	st.h	r7[0x2],r8
   b_save_entry_type       = fs_g_nav.b_mode_nav;

   // Loop in directory
   while( 1 )
   {
      if(( FS_FIND_NEXT == b_direction )
8000540a:	c1 d8       	rjmp	80005444 <nav_filelist_set+0x88>
         }
         fs_g_nav_fast.u16_entry_pos_sel_file++;      // Update entry position
      }
      else
      {
         if ( FS_NO_SEL == fs_g_nav_fast.u16_entry_pos_sel_file )
8000540c:	8e 18       	ld.sh	r8,r7[0x2]
8000540e:	e0 08 19 00 	cp.h	r8,r0
80005412:	c0 51       	brne	8000541c <nav_filelist_set+0x60>
         {
            // No selected file then previous action impossible
            fs_g_status = FS_ERR_NO_FIND;
80005414:	30 99       	mov	r9,9
80005416:	4c 08       	lddpc	r8,80005514 <nav_filelist_set+0x158>
80005418:	b0 89       	st.b	r8[0x0],r9
            break;
8000541a:	c6 88       	rjmp	800054ea <nav_filelist_set+0x12e>
         }
         if ( 0 == fs_g_nav_fast.u16_entry_pos_sel_file )
8000541c:	58 08       	cp.w	r8,0
8000541e:	c1 11       	brne	80005440 <nav_filelist_set+0x84>
         {
            // beginning of directory
            if ( (FS_DIR == fs_g_nav.b_mode_nav ) || fs_g_nav.b_mode_nav_single )
80005420:	ed 38 00 2c 	ld.ub	r8,r6[44]
80005424:	e8 08 18 00 	cp.b	r8,r4
80005428:	c0 80       	breq	80005438 <nav_filelist_set+0x7c>
8000542a:	ed 38 00 2d 	ld.ub	r8,r6[45]
8000542e:	e8 08 18 00 	cp.b	r8,r4
80005432:	c0 31       	brne	80005438 <nav_filelist_set+0x7c>
80005434:	30 13       	mov	r3,1
80005436:	c0 78       	rjmp	80005444 <nav_filelist_set+0x88>
            {
               // End of directory scan, then no previous action possible
               fs_g_status = FS_ERR_NO_FIND;
80005438:	30 99       	mov	r9,9
8000543a:	4b 78       	lddpc	r8,80005514 <nav_filelist_set+0x158>
8000543c:	b0 89       	st.b	r8[0x0],r9
               break;
8000543e:	c5 68       	rjmp	800054ea <nav_filelist_set+0x12e>
            }
            // End of file scan, then find last directory
            b_find_last_entry = true;
         }else{
            fs_g_nav_fast.u16_entry_pos_sel_file--;   // Update entry position
80005440:	20 18       	sub	r8,1
80005442:	ae 18       	st.h	r7[0x2],r8
         }
      }

      if( !fat_read_dir())
80005444:	f0 1f 00 35 	mcall	80005518 <nav_filelist_set+0x15c>
80005448:	c0 71       	brne	80005456 <nav_filelist_set+0x9a>
      {
         if( FS_ERR_OUT_LIST != fs_g_status )
8000544a:	0b 89       	ld.ub	r9,r5[0x0]
8000544c:	31 a8       	mov	r8,26
8000544e:	f0 09 18 00 	cp.b	r9,r8
80005452:	c3 20       	breq	800054b6 <nav_filelist_set+0xfa>
80005454:	c4 b8       	rjmp	800054ea <nav_filelist_set+0x12e>
            break; // Error
      }else{
         if ( fat_entry_check( fs_g_nav.b_mode_nav ) )
80005456:	ed 38 00 2c 	ld.ub	r8,r6[44]
8000545a:	e8 08 18 00 	cp.b	r8,r4
8000545e:	5f 1c       	srne	r12
80005460:	f0 1f 00 2f 	mcall	8000551c <nav_filelist_set+0x160>
80005464:	c1 c0       	breq	8000549c <nav_filelist_set+0xe0>
         {
           // HERE, the file entry match with the type searched

           if( b_find_last_entry )
80005466:	58 03       	cp.w	r3,0
80005468:	cc 31       	brne	800053ee <nav_filelist_set+0x32>
             continue;  // The search of last directory is on going then continue the search

           // Update position in directory
           if ( FS_FIND_NEXT == b_direction )
              fs_g_nav.u16_pos_sel_file++;
8000546a:	58 02       	cp.w	r2,0
8000546c:	ed f8 12 12 	ld.shne	r8,r6[0x24]
80005470:	f7 b8 01 ff 	subne	r8,-1
80005474:	ed f8 1c 12 	st.hne	r6[0x24],r8
           else
              fs_g_nav.u16_pos_sel_file--;
80005478:	ed f8 02 12 	ld.sheq	r8,r6[0x24]
8000547c:	f7 b8 00 01 	subeq	r8,1
80005480:	ed f8 0c 12 	st.heq	r6[0x24],r8

           if (0 == u16_nb)
80005484:	40 09       	lddsp	r9,sp[0x0]
80005486:	58 09       	cp.w	r9,0
80005488:	c0 51       	brne	80005492 <nav_filelist_set+0xd6>
           {
              // It is the end of move then update file information
              fat_get_entry_info();
8000548a:	f0 1f 00 26 	mcall	80005520 <nav_filelist_set+0x164>
8000548e:	30 1c       	mov	r12,1
              return true;         // NB FILE FIND
80005490:	c3 a8       	rjmp	80005504 <nav_filelist_set+0x148>
           }
           u16_nb--;
80005492:	40 08       	lddsp	r8,sp[0x0]
80005494:	20 18       	sub	r8,1
80005496:	5c 88       	casts.h	r8
80005498:	50 08       	stdsp	sp[0x0],r8
           continue;
8000549a:	ca ab       	rjmp	800053ee <nav_filelist_set+0x32>
         }
      }

      // Here error, check type of error
      if(( FS_ERR_ENTRY_EMPTY == fs_g_status )
8000549c:	0b 88       	ld.ub	r8,r5[0x0]
8000549e:	30 a9       	mov	r9,10
800054a0:	f2 08 18 00 	cp.b	r8,r9
800054a4:	5f 09       	sreq	r9
800054a6:	31 aa       	mov	r10,26
800054a8:	f4 08 18 00 	cp.b	r8,r10
800054ac:	5f 08       	sreq	r8
800054ae:	10 49       	or	r9,r8
800054b0:	e8 09 18 00 	cp.b	r9,r4
800054b4:	c9 d0       	breq	800053ee <nav_filelist_set+0x32>
      || ( FS_ERR_OUT_LIST    == fs_g_status ) )
      {
         // Here, end of the directory
         if( b_find_last_entry )
800054b6:	58 03       	cp.w	r3,0
800054b8:	c0 50       	breq	800054c2 <nav_filelist_set+0x106>
         {
            // Re enable the previous command at the end of directory to find the last directory entry
            b_find_last_entry = false;
            fs_g_nav.b_mode_nav = FS_DIR;
800054ba:	ed 64 00 2c 	st.b	r6[44],r4
800054be:	30 03       	mov	r3,0
            continue;
800054c0:	c9 7b       	rjmp	800053ee <nav_filelist_set+0x32>
         }
         // Here, a next action is on going
         if ( (FS_FILE == fs_g_nav.b_mode_nav) || fs_g_nav.b_mode_nav_single )
800054c2:	ed 38 00 2c 	ld.ub	r8,r6[44]
800054c6:	30 1a       	mov	r10,1
800054c8:	f4 08 18 00 	cp.b	r8,r10
800054cc:	c0 60       	breq	800054d8 <nav_filelist_set+0x11c>
800054ce:	ed 38 00 2d 	ld.ub	r8,r6[45]
800054d2:	e8 08 18 00 	cp.b	r8,r4
800054d6:	c0 50       	breq	800054e0 <nav_filelist_set+0x124>
         {
            // End of next file action then end of next action
            fs_g_status = FS_ERR_NO_FIND; // No file found
800054d8:	30 99       	mov	r9,9
800054da:	48 f8       	lddpc	r8,80005514 <nav_filelist_set+0x158>
800054dc:	b0 89       	st.b	r8[0x0],r9
            break;                        // end of search
800054de:	c0 68       	rjmp	800054ea <nav_filelist_set+0x12e>
         }else{
            // End of next dir action then starts the next file action at the beginning of directory
            fs_g_nav_fast.u16_entry_pos_sel_file = 0xFFFF;
800054e0:	ae 10       	st.h	r7[0x2],r0
            fs_g_nav.b_mode_nav = FS_FILE;
800054e2:	30 19       	mov	r9,1
800054e4:	ed 69 00 2c 	st.b	r6[44],r9
800054e8:	c8 3b       	rjmp	800053ee <nav_filelist_set+0x32>
         }
      }
   }  // end of loop while(1)

   fs_g_nav.b_mode_nav                    = b_save_entry_type;
800054ea:	48 a8       	lddpc	r8,80005510 <nav_filelist_set+0x154>
800054ec:	40 3a       	lddsp	r10,sp[0xc]
800054ee:	58 0a       	cp.w	r10,0
800054f0:	5f 19       	srne	r9
800054f2:	f1 69 00 2c 	st.b	r8[44],r9
   fs_g_nav_fast.u16_entry_pos_sel_file   = u16_ptr_save_entry;
800054f6:	48 69       	lddpc	r9,8000550c <nav_filelist_set+0x150>
800054f8:	40 2a       	lddsp	r10,sp[0x8]
800054fa:	b2 1a       	st.h	r9[0x2],r10
   fs_g_nav.u16_pos_sel_file              = u16_save_pos_sel_file;
800054fc:	40 19       	lddsp	r9,sp[0x4]
800054fe:	f1 59 00 24 	st.h	r8[36],r9
80005502:	30 0c       	mov	r12,0
   return false;
}
80005504:	2f cd       	sub	sp,-16
80005506:	d8 32       	popm	r0-r7,pc
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	42 c0       	lddsp	r0,sp[0xb0]
8000550c:	00 00       	add	r0,r0
8000550e:	0c 80       	andn	r0,r6
80005510:	00 00       	add	r0,r0
80005512:	0c 34       	cp.w	r4,r6
80005514:	00 00       	add	r0,r0
80005516:	0c 84       	andn	r4,r6
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	3e cc       	mov	r12,-20
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	36 08       	mov	r8,96
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	35 c0       	mov	r0,92

80005524 <nav_filelist_findname>:
//! @verbatim
//! This function starts a search at the next position of the current in file list
//! @endverbatim
//!
bool  nav_filelist_findname( const FS_STRING sz_name , bool b_match_case )
{
80005524:	d4 21       	pushm	r4-r7,lr
80005526:	18 95       	mov	r5,r12
80005528:	16 94       	mov	r4,r11
   while( 1 )
   {
      if ( !nav_filelist_set( 0, FS_FIND_NEXT ))
8000552a:	30 16       	mov	r6,1
8000552c:	30 07       	mov	r7,0
8000552e:	0c 9b       	mov	r11,r6
80005530:	0e 9c       	mov	r12,r7
80005532:	f0 1f 00 07 	mcall	8000554c <nav_filelist_findname+0x28>
80005536:	c0 90       	breq	80005548 <nav_filelist_findname+0x24>
         return false;
      if ( nav_file_name( sz_name , 0 , FS_NAME_CHECK , b_match_case ))
80005538:	08 99       	mov	r9,r4
8000553a:	0e 9a       	mov	r10,r7
8000553c:	0e 9b       	mov	r11,r7
8000553e:	0a 9c       	mov	r12,r5
80005540:	f0 1f 00 04 	mcall	80005550 <nav_filelist_findname+0x2c>
80005544:	cf 50       	breq	8000552e <nav_filelist_findname+0xa>
80005546:	30 1c       	mov	r12,1
         return true;
   }
}
80005548:	d8 22       	popm	r4-r7,pc
8000554a:	00 00       	add	r0,r0
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	53 bc       	stdsp	sp[0xec],r12
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	52 d8       	stdsp	sp[0xb4],r8

80005554 <nav_filelist_reset>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_reset( void )
{
80005554:	d4 01       	pushm	lr
   if ( !fat_check_mount_noopen())
80005556:	f0 1f 00 04 	mcall	80005564 <nav_filelist_reset+0x10>
8000555a:	c0 40       	breq	80005562 <nav_filelist_reset+0xe>
      return false;

   // No file selected and reset navigation
   fat_clear_entry_info_and_ptr();
8000555c:	f0 1f 00 03 	mcall	80005568 <nav_filelist_reset+0x14>
80005560:	30 1c       	mov	r12,1
   return true;
}
80005562:	d8 02       	popm	pc
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	42 c0       	lddsp	r0,sp[0xb0]
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	32 a8       	mov	r8,42

8000556c <nav_file_create>:
//! @verbatim
//! If you use this routine to create a file, then you must called file_open() to open this new file
//! @endverbatim
//!
bool  nav_file_create( const FS_STRING sz_name  )
{
8000556c:	eb cd 40 80 	pushm	r7,lr
80005570:	18 97       	mov	r7,r12
   // Check if the name already exists
   if (!nav_filelist_reset())
80005572:	f0 1f 00 13 	mcall	800055bc <nav_file_create+0x50>
80005576:	c2 10       	breq	800055b8 <nav_file_create+0x4c>
      return false;
   if (nav_filelist_findname(sz_name , false))
80005578:	30 0b       	mov	r11,0
8000557a:	0e 9c       	mov	r12,r7
8000557c:	f0 1f 00 11 	mcall	800055c0 <nav_file_create+0x54>
80005580:	c0 60       	breq	8000558c <nav_file_create+0x20>
   {
      fs_g_status = FS_ERR_FILE_EXIST;
80005582:	32 a9       	mov	r9,42
80005584:	49 08       	lddpc	r8,800055c4 <nav_file_create+0x58>
80005586:	b0 89       	st.b	r8[0x0],r9
80005588:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;  // File exist -> it is not possible to create this name
   }
   // FYC: here, the selection is at the end of the list
   // Create name entries
   if ( !fat_create_entry_file_name( sz_name ))
8000558c:	0e 9c       	mov	r12,r7
8000558e:	f0 1f 00 0f 	mcall	800055c8 <nav_file_create+0x5c>
80005592:	c1 30       	breq	800055b8 <nav_file_create+0x4c>
      return false; // error
   // By default the information about the new file is NULL
   fs_g_nav_entry.u32_cluster = 0;     // No first cluster
80005594:	48 e8       	lddpc	r8,800055cc <nav_file_create+0x60>
80005596:	30 09       	mov	r9,0
80005598:	91 19       	st.w	r8[0x4],r9
   fs_g_nav_entry.u32_size    = 0;     // The size is null
8000559a:	91 29       	st.w	r8[0x8],r9
   fs_g_nav_entry.u8_attr     = 0;     // Attribute is a file
8000559c:	b0 a9       	st.b	r8[0x2],r9

   // It is the last FILE of the list
   fs_g_nav.u16_pos_sel_file++;
8000559e:	48 d8       	lddpc	r8,800055d0 <nav_file_create+0x64>
800055a0:	f1 09 00 24 	ld.sh	r9,r8[36]
800055a4:	2f f9       	sub	r9,-1
800055a6:	f1 59 00 24 	st.h	r8[36],r9
   fs_g_nav.b_mode_nav = FS_FILE;
800055aa:	30 19       	mov	r9,1
800055ac:	f1 69 00 2c 	st.b	r8[44],r9
   return fat_cache_flush();
800055b0:	f0 1f 00 09 	mcall	800055d4 <nav_file_create+0x68>
800055b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800055b8:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	55 54       	stdsp	sp[0x154],r4
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	55 24       	stdsp	sp[0x148],r4
800055c4:	00 00       	add	r0,r0
800055c6:	0c 84       	andn	r4,r6
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	4d 04       	lddpc	r4,80005708 <nav_dir_name+0x90>
800055cc:	00 00       	add	r0,r0
800055ce:	09 f4       	ld.ub	r4,r4[0x7]
800055d0:	00 00       	add	r0,r0
800055d2:	0c 34       	cp.w	r4,r6
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	38 30       	mov	r0,-125

800055d8 <nav_dir_gotoparent>:
//! After, the file list changes and contains the files and directories of the new directory.
//! By default, the file selected in file list is the previous (children) directory.
//! @endverbatim
//!
bool  nav_dir_gotoparent( void )
{
800055d8:	d4 21       	pushm	r4-r7,lr
   uint32_t u32_cluster_old_dir;

   if (!fat_check_mount_noopen())
800055da:	f0 1f 00 1f 	mcall	80005654 <nav_dir_gotoparent+0x7c>
800055de:	c3 80       	breq	8000564e <nav_dir_gotoparent+0x76>
      return false;

   if (0 == fs_g_nav.u32_cluster_sel_dir)
800055e0:	49 e8       	lddpc	r8,80005658 <nav_dir_gotoparent+0x80>
800055e2:	70 88       	ld.w	r8,r8[0x20]
800055e4:	58 08       	cp.w	r8,0
800055e6:	c0 51       	brne	800055f0 <nav_dir_gotoparent+0x18>
   {
      fs_g_status = FS_ERR_IS_ROOT;        // There aren't parent
800055e8:	31 99       	mov	r9,25
800055ea:	49 d8       	lddpc	r8,8000565c <nav_dir_gotoparent+0x84>
800055ec:	b0 89       	st.b	r8[0x0],r9
800055ee:	d8 2a       	popm	r4-r7,pc,r12=0
      return false;
   }

   // Select and read information about directory ".."
   fs_g_nav_fast.u16_entry_pos_sel_file = 1;
800055f0:	30 19       	mov	r9,1
800055f2:	49 c8       	lddpc	r8,80005660 <nav_dir_gotoparent+0x88>
800055f4:	b0 19       	st.h	r8[0x2],r9
   if ( !fat_read_dir())
800055f6:	f0 1f 00 1c 	mcall	80005664 <nav_dir_gotoparent+0x8c>
800055fa:	c2 a0       	breq	8000564e <nav_dir_gotoparent+0x76>
      return false;
   fat_get_entry_info();
800055fc:	f0 1f 00 1b 	mcall	80005668 <nav_dir_gotoparent+0x90>
   // Save the children directory cluster
   u32_cluster_old_dir = fs_g_nav.u32_cluster_sel_dir;
80005600:	49 68       	lddpc	r8,80005658 <nav_dir_gotoparent+0x80>
80005602:	70 87       	ld.w	r7,r8[0x20]

   // Select the parent directory via information present in the current directory ".."
   fs_g_nav.u32_cluster_sel_dir = fs_g_nav_entry.u32_cluster;
80005604:	49 a9       	lddpc	r9,8000566c <nav_dir_gotoparent+0x94>
80005606:	72 19       	ld.w	r9,r9[0x4]
80005608:	91 89       	st.w	r8[0x20],r9

   // Select the children directory in new directory (=parent directory)
   if( false == nav_filelist_reset())
8000560a:	f0 1f 00 1a 	mcall	80005670 <nav_dir_gotoparent+0x98>
8000560e:	c2 00       	breq	8000564e <nav_dir_gotoparent+0x76>
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
80005610:	49 28       	lddpc	r8,80005658 <nav_dir_gotoparent+0x80>
80005612:	f1 39 00 2d 	ld.ub	r9,r8[45]
80005616:	30 08       	mov	r8,0
80005618:	f0 09 18 00 	cp.b	r9,r8
8000561c:	c0 d0       	breq	80005636 <nav_dir_gotoparent+0x5e>
8000561e:	48 f8       	lddpc	r8,80005658 <nav_dir_gotoparent+0x80>
80005620:	f1 39 00 2c 	ld.ub	r9,r8[44]
80005624:	30 08       	mov	r8,0
80005626:	f0 09 18 00 	cp.b	r9,r8
8000562a:	c0 60       	breq	80005636 <nav_dir_gotoparent+0x5e>
8000562c:	c1 28       	rjmp	80005650 <nav_dir_gotoparent+0x78>
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
8000562e:	6c 18       	ld.w	r8,r6[0x4]
80005630:	0e 38       	cp.w	r8,r7
80005632:	c0 51       	brne	8000563c <nav_dir_gotoparent+0x64>
80005634:	c0 e8       	rjmp	80005650 <nav_dir_gotoparent+0x78>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005636:	30 15       	mov	r5,1
80005638:	30 04       	mov	r4,0
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
8000563a:	48 d6       	lddpc	r6,8000566c <nav_dir_gotoparent+0x94>
   if( false == nav_filelist_reset())
      return false;
   if( fs_g_nav.b_mode_nav_single && (FS_DIR != fs_g_nav.b_mode_nav) )
      return true;

   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
8000563c:	0a 9b       	mov	r11,r5
8000563e:	08 9c       	mov	r12,r4
80005640:	f0 1f 00 0d 	mcall	80005674 <nav_dir_gotoparent+0x9c>
80005644:	cf 51       	brne	8000562e <nav_dir_gotoparent+0x56>
   {
      if (fs_g_nav_entry.u32_cluster == u32_cluster_old_dir)
         return true;         // It is the children directory
   }
   fs_g_status = FS_ERR_FS;
80005646:	30 89       	mov	r9,8
80005648:	48 58       	lddpc	r8,8000565c <nav_dir_gotoparent+0x84>
8000564a:	b0 89       	st.b	r8[0x0],r9
   return false;
8000564c:	d8 22       	popm	r4-r7,pc
8000564e:	d8 2a       	popm	r4-r7,pc,r12=0
80005650:	da 2a       	popm	r4-r7,pc,r12=1
80005652:	00 00       	add	r0,r0
80005654:	80 00       	ld.sh	r0,r0[0x0]
80005656:	42 c0       	lddsp	r0,sp[0xb0]
80005658:	00 00       	add	r0,r0
8000565a:	0c 34       	cp.w	r4,r6
8000565c:	00 00       	add	r0,r0
8000565e:	0c 84       	andn	r4,r6
80005660:	00 00       	add	r0,r0
80005662:	0c 80       	andn	r0,r6
80005664:	80 00       	ld.sh	r0,r0[0x0]
80005666:	3e cc       	mov	r12,-20
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	35 c0       	mov	r0,92
8000566c:	00 00       	add	r0,r0
8000566e:	09 f4       	ld.ub	r4,r4[0x7]
80005670:	80 00       	ld.sh	r0,r0[0x0]
80005672:	55 54       	stdsp	sp[0x154],r4
80005674:	80 00       	ld.sh	r0,r0[0x0]
80005676:	53 bc       	stdsp	sp[0xec],r12

80005678 <nav_dir_name>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_dir_name( FS_STRING sz_path  , uint8_t u8_size_max  )
{
80005678:	d4 31       	pushm	r0-r7,lr
8000567a:	20 2d       	sub	sp,8
8000567c:	18 96       	mov	r6,r12
8000567e:	16 95       	mov	r5,r11
   uint32_t save_u32_cluster      ;
   uint32_t save_u32_size         ;
   bool b_mode_nav_single_save;
   bool b_mode_nav_mode_save;

   if ( !fat_check_mount_noopen())
80005680:	f0 1f 00 37 	mcall	8000575c <nav_dir_name+0xe4>
80005684:	c6 a0       	breq	80005758 <nav_dir_name+0xe0>
      return false;

   if (0 != fs_g_nav.u32_cluster_sel_dir)
80005686:	4b 78       	lddpc	r8,80005760 <nav_dir_name+0xe8>
80005688:	70 87       	ld.w	r7,r8[0x20]
8000568a:	58 07       	cp.w	r7,0
8000568c:	c3 b0       	breq	80005702 <nav_dir_name+0x8a>
   {
      // Save context
      save_u16_entry_pos_sel_file= fs_g_nav_fast.u16_entry_pos_sel_file;
8000568e:	4b 68       	lddpc	r8,80005764 <nav_dir_name+0xec>
80005690:	90 11       	ld.sh	r1,r8[0x2]
      save_u32_cluster_sel_dir   = fs_g_nav.u32_cluster_sel_dir        ;
      save_u8_attr               = fs_g_nav_entry.u8_attr              ;
80005692:	4b 68       	lddpc	r8,80005768 <nav_dir_name+0xf0>
80005694:	11 a0       	ld.ub	r0,r8[0x2]
      save_u32_cluster           = fs_g_nav_entry.u32_cluster          ;
80005696:	70 19       	ld.w	r9,r8[0x4]
80005698:	50 19       	stdsp	sp[0x4],r9
      save_u32_size              = fs_g_nav_entry.u32_size             ;
8000569a:	70 28       	ld.w	r8,r8[0x8]
8000569c:	50 08       	stdsp	sp[0x0],r8
      b_mode_nav_single_save = fs_g_nav.b_mode_nav_single;
8000569e:	4b 18       	lddpc	r8,80005760 <nav_dir_name+0xe8>
800056a0:	f1 3a 00 2d 	ld.ub	r10,r8[45]
800056a4:	30 09       	mov	r9,0
800056a6:	f2 0a 18 00 	cp.b	r10,r9
800056aa:	5f 14       	srne	r4
      b_mode_nav_mode_save   = fs_g_nav.b_mode_nav;
800056ac:	f1 3a 00 2c 	ld.ub	r10,r8[44]
800056b0:	f2 0a 18 00 	cp.b	r10,r9
800056b4:	5f 13       	srne	r3
      fs_g_nav.b_mode_nav_single = true;
800056b6:	30 19       	mov	r9,1
800056b8:	f1 69 00 2d 	st.b	r8[45],r9
      fs_g_nav.b_mode_nav = FS_FILE;
800056bc:	f1 69 00 2c 	st.b	r8[44],r9
      // Go to parent directory and select the children directory
      if( !nav_dir_gotoparent() )
800056c0:	f0 1f 00 2b 	mcall	8000576c <nav_dir_name+0xf4>
800056c4:	c0 71       	brne	800056d2 <nav_dir_name+0x5a>
      {
         fs_g_nav.b_mode_nav_single = b_mode_nav_single_save;
800056c6:	4a 78       	lddpc	r8,80005760 <nav_dir_name+0xe8>
800056c8:	f1 64 00 2d 	st.b	r8[45],r4
         fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
800056cc:	f1 63 00 2c 	st.b	r8[44],r3
         return false;
800056d0:	c4 48       	rjmp	80005758 <nav_dir_name+0xe0>
      }
      fs_g_nav.b_mode_nav_single = b_mode_nav_single_save ;
800056d2:	4a 42       	lddpc	r2,80005760 <nav_dir_name+0xe8>
800056d4:	e5 64 00 2d 	st.b	r2[45],r4
      fs_g_nav.b_mode_nav = b_mode_nav_mode_save;
800056d8:	e5 63 00 2c 	st.b	r2[44],r3
      // Go to directory name position
      fs_g_nav_fast.u16_entry_pos_sel_file = fs_g_nav.u16_entry_pos_sel_dir;
800056dc:	4a 24       	lddpc	r4,80005764 <nav_dir_name+0xec>
800056de:	e5 08 00 1c 	ld.sh	r8,r2[28]
800056e2:	a8 18       	st.h	r4[0x2],r8
      status = nav_file_name( sz_path  , u8_size_max , FS_NAME_GET , false  );
800056e4:	30 09       	mov	r9,0
800056e6:	30 1a       	mov	r10,1
800056e8:	0a 9b       	mov	r11,r5
800056ea:	0c 9c       	mov	r12,r6
800056ec:	f0 1f 00 21 	mcall	80005770 <nav_dir_name+0xf8>
      // Restore previous context
      fs_g_nav_fast.u16_entry_pos_sel_file= save_u16_entry_pos_sel_file;
800056f0:	a8 11       	st.h	r4[0x2],r1
      fs_g_nav.u32_cluster_sel_dir        = save_u32_cluster_sel_dir   ;
800056f2:	85 87       	st.w	r2[0x20],r7
      fs_g_nav_entry.u8_attr              = save_u8_attr               ;
800056f4:	49 d8       	lddpc	r8,80005768 <nav_dir_name+0xf0>
800056f6:	b0 a0       	st.b	r8[0x2],r0
      fs_g_nav_entry.u32_cluster          = save_u32_cluster           ;
800056f8:	40 19       	lddsp	r9,sp[0x4]
800056fa:	91 19       	st.w	r8[0x4],r9
      fs_g_nav_entry.u32_size             = save_u32_size              ;
800056fc:	40 09       	lddsp	r9,sp[0x0]
800056fe:	91 29       	st.w	r8[0x8],r9
80005700:	c2 c8       	rjmp	80005758 <nav_dir_name+0xe0>
   }
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
80005702:	49 d8       	lddpc	r8,80005774 <nav_dir_name+0xfc>
80005704:	11 89       	ld.ub	r9,r8[0x0]
80005706:	30 08       	mov	r8,0
80005708:	f0 09 18 00 	cp.b	r9,r8
8000570c:	c0 50       	breq	80005716 <nav_dir_name+0x9e>
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
8000570e:	30 38       	mov	r8,3
80005710:	ac 08       	st.h	r6[0x0],r8
80005712:	30 1c       	mov	r12,1
80005714:	c2 28       	rjmp	80005758 <nav_dir_name+0xe0>
80005716:	2f f6       	sub	r6,-1
80005718:	30 17       	mov	r7,1
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
8000571a:	30 04       	mov	r4,0
8000571c:	30 15       	mov	r5,1
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
8000571e:	30 23       	mov	r3,2
80005720:	c0 48       	rjmp	80005728 <nav_dir_name+0xb0>
   else
   {
      // No parent directory, then it is the root directory
      if( g_b_string_length )
      {
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
80005722:	2f f6       	sub	r6,-1
80005724:	2f f7       	sub	r7,-1
80005726:	5c 57       	castu.b	r7
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
      {
         switch( u8_i )
80005728:	0e 98       	mov	r8,r7
8000572a:	20 18       	sub	r8,1
8000572c:	e8 08 18 00 	cp.b	r8,r4
80005730:	c0 e0       	breq	8000574c <nav_dir_name+0xd4>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
80005732:	ea 08 18 00 	cp.b	r8,r5
80005736:	f9 b8 00 3a 	moveq	r8,58
8000573a:	f9 b8 01 00 	movne	r8,0
8000573e:	ed 68 ff ff 	st.b	r6[-1],r8
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
80005742:	e6 07 18 00 	cp.b	r7,r3
80005746:	fe 98 ff ee 	brls	80005722 <nav_dir_name+0xaa>
8000574a:	c0 68       	rjmp	80005756 <nav_dir_name+0xde>
      {
         switch( u8_i )
         {
            case 0:
            u8_character = nav_drive_getname();    // Letter
8000574c:	f0 1f 00 0b 	mcall	80005778 <nav_dir_name+0x100>
         }
         if( Is_unicode )
         {
            ((FS_STR_UNICODE)sz_path )[0] = u8_character;
         }else{
            sz_path [0] = u8_character;
80005750:	ed 6c ff ff 	st.b	r6[-1],r12
80005754:	ce 7b       	rjmp	80005722 <nav_dir_name+0xaa>
         ((FS_STR_UNICODE)sz_path )[0] = 3;  // 3 chars for path "x:"
         status = true;
      }else

      // Create a device name
      for( u8_i = 0 ; u8_i<3 ; u8_i++ )
80005756:	30 1c       	mov	r12,1
      }
      status = true;

   }
   return status;
}
80005758:	2f ed       	sub	sp,-8
8000575a:	d8 32       	popm	r0-r7,pc
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	42 c0       	lddsp	r0,sp[0xb0]
80005760:	00 00       	add	r0,r0
80005762:	0c 34       	cp.w	r4,r6
80005764:	00 00       	add	r0,r0
80005766:	0c 80       	andn	r0,r6
80005768:	00 00       	add	r0,r0
8000576a:	09 f4       	ld.ub	r4,r4[0x7]
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	55 d8       	stdsp	sp[0x174],r8
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	52 d8       	stdsp	sp[0xb4],r8
80005774:	00 00       	add	r0,r0
80005776:	0c 85       	andn	r5,r6
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	52 90       	stdsp	sp[0xa4],r0

8000577c <nav_dir_cd>:
//! After this routine the file list changes and contains the files and directories of the new directory.
//! By default no file is selected.
//! @endverbatim
//!
bool  nav_dir_cd( void )
{
8000577c:	d4 01       	pushm	lr
   if ( !fat_check_mount_select_noopen())
8000577e:	f0 1f 00 0a 	mcall	800057a4 <nav_dir_cd+0x28>
80005782:	c0 f0       	breq	800057a0 <nav_dir_cd+0x24>
      return false;

   // The current selection, is it a directory ?
   if ( !fat_entry_is_dir())
80005784:	f0 1f 00 09 	mcall	800057a8 <nav_dir_cd+0x2c>
80005788:	c0 c0       	breq	800057a0 <nav_dir_cd+0x24>
      return false;

   // Select the current directory
   fs_g_nav.u16_entry_pos_sel_dir = fs_g_nav_fast.u16_entry_pos_sel_file;
8000578a:	48 98       	lddpc	r8,800057ac <nav_dir_cd+0x30>
8000578c:	48 99       	lddpc	r9,800057b0 <nav_dir_cd+0x34>
8000578e:	92 19       	ld.sh	r9,r9[0x2]
80005790:	f1 59 00 1c 	st.h	r8[28],r9
   fs_g_nav.u32_cluster_sel_dir = fs_g_nav_entry.u32_cluster;
80005794:	48 89       	lddpc	r9,800057b4 <nav_dir_cd+0x38>
80005796:	72 19       	ld.w	r9,r9[0x4]
80005798:	91 89       	st.w	r8[0x20],r9

   // Reset file list
   if( false == nav_filelist_reset())
8000579a:	f0 1f 00 08 	mcall	800057b8 <nav_dir_cd+0x3c>
8000579e:	d8 02       	popm	pc
800057a0:	d8 0a       	popm	pc,r12=0
800057a2:	00 00       	add	r0,r0
800057a4:	80 00       	ld.sh	r0,r0[0x0]
800057a6:	42 9c       	lddsp	r12,sp[0xa4]
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	32 90       	mov	r0,41
800057ac:	00 00       	add	r0,r0
800057ae:	0c 34       	cp.w	r4,r6
800057b0:	00 00       	add	r0,r0
800057b2:	0c 80       	andn	r0,r6
800057b4:	00 00       	add	r0,r0
800057b6:	09 f4       	ld.ub	r4,r4[0x7]
800057b8:	80 00       	ld.sh	r0,r0[0x0]
800057ba:	55 54       	stdsp	sp[0x154],r4

800057bc <nav_filelist_first>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_first( bool b_type )
{
800057bc:	d4 21       	pushm	r4-r7,lr
800057be:	18 97       	mov	r7,r12
   // Reset position
   if ( !nav_filelist_reset())
800057c0:	f0 1f 00 0b 	mcall	800057ec <nav_filelist_first+0x30>
800057c4:	c0 71       	brne	800057d2 <nav_filelist_first+0x16>
800057c6:	d8 22       	popm	r4-r7,pc
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
   {
      if( b_type == fs_g_nav.b_mode_nav )
800057c8:	e9 38 00 2c 	ld.ub	r8,r4[44]
800057cc:	10 37       	cp.w	r7,r8
800057ce:	c0 51       	brne	800057d8 <nav_filelist_first+0x1c>
800057d0:	da 2a       	popm	r4-r7,pc,r12=1
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800057d2:	30 16       	mov	r6,1
800057d4:	30 05       	mov	r5,0
   {
      if( b_type == fs_g_nav.b_mode_nav )
800057d6:	48 74       	lddpc	r4,800057f0 <nav_filelist_first+0x34>
{
   // Reset position
   if ( !nav_filelist_reset())
      return false;
   // Find the first file or directory
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
800057d8:	0c 9b       	mov	r11,r6
800057da:	0a 9c       	mov	r12,r5
800057dc:	f0 1f 00 06 	mcall	800057f4 <nav_filelist_first+0x38>
800057e0:	cf 41       	brne	800057c8 <nav_filelist_first+0xc>
   {
      if( b_type == fs_g_nav.b_mode_nav )
         return true;   // First file or directory found
   }
   fs_g_status = FS_ERR_NO_FIND;
800057e2:	30 99       	mov	r9,9
800057e4:	48 58       	lddpc	r8,800057f8 <nav_filelist_first+0x3c>
800057e6:	b0 89       	st.b	r8[0x0],r9
   return false;
}
800057e8:	d8 22       	popm	r4-r7,pc
800057ea:	00 00       	add	r0,r0
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	55 54       	stdsp	sp[0x154],r4
800057f0:	00 00       	add	r0,r0
800057f2:	0c 34       	cp.w	r4,r6
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	53 bc       	stdsp	sp[0xec],r12
800057f8:	00 00       	add	r0,r0
800057fa:	0c 84       	andn	r4,r6

800057fc <nav_filelist_nb>:
//!                     FS_FILE to compute the number of files <br>
//!
//! @return    number of files or directories in file list
//!
uint16_t   nav_filelist_nb( bool b_type )
{
800057fc:	d4 31       	pushm	r0-r7,lr
800057fe:	18 90       	mov	r0,r12
   uint16_t   u16_save_position;
   uint16_t   u16_save_number_dir;
   uint16_t   u16_save_number_file;

   // Save current position
   u16_save_position = fs_g_nav.u16_pos_sel_file;
80005800:	49 88       	lddpc	r8,80005860 <nav_filelist_nb+0x64>
80005802:	f1 01 00 24 	ld.sh	r1,r8[36]
   // Reset position
   if ( !nav_filelist_reset())
80005806:	f0 1f 00 18 	mcall	80005864 <nav_filelist_nb+0x68>
8000580a:	c0 31       	brne	80005810 <nav_filelist_nb+0x14>
8000580c:	30 02       	mov	r2,0
8000580e:	c2 68       	rjmp	8000585a <nav_filelist_nb+0x5e>
80005810:	30 02       	mov	r2,0
80005812:	04 97       	mov	r7,r2
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005814:	30 14       	mov	r4,1
80005816:	04 93       	mov	r3,r2
   {
      if( FS_FILE == fs_g_nav.b_mode_nav )
80005818:	49 26       	lddpc	r6,80005860 <nav_filelist_nb+0x64>
8000581a:	30 15       	mov	r5,1
8000581c:	c0 b8       	rjmp	80005832 <nav_filelist_nb+0x36>
8000581e:	ed 38 00 2c 	ld.ub	r8,r6[44]
80005822:	ea 08 18 00 	cp.b	r8,r5
80005826:	c0 41       	brne	8000582e <nav_filelist_nb+0x32>
         u16_save_number_file++;    // It is a file
80005828:	2f f2       	sub	r2,-1
8000582a:	5c 82       	casts.h	r2
8000582c:	c0 38       	rjmp	80005832 <nav_filelist_nb+0x36>
      else
         u16_save_number_dir++;     // It is a directory
8000582e:	2f f7       	sub	r7,-1
80005830:	5c 87       	casts.h	r7
   if ( !nav_filelist_reset())
      return 0;
   // Scan all directory
   u16_save_number_dir  = 0;
   u16_save_number_file = 0;
   while( nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005832:	08 9b       	mov	r11,r4
80005834:	06 9c       	mov	r12,r3
80005836:	f0 1f 00 0d 	mcall	80005868 <nav_filelist_nb+0x6c>
8000583a:	cf 21       	brne	8000581e <nav_filelist_nb+0x22>
         u16_save_number_file++;    // It is a file
      else
         u16_save_number_dir++;     // It is a directory
   }
   // Restore previous position
   nav_filelist_reset();
8000583c:	f0 1f 00 0a 	mcall	80005864 <nav_filelist_nb+0x68>
   if ( u16_save_position != FS_NO_SEL )
80005840:	3f f8       	mov	r8,-1
80005842:	f0 01 19 00 	cp.h	r1,r8
80005846:	c0 60       	breq	80005852 <nav_filelist_nb+0x56>
   {
      nav_filelist_set( u16_save_position , FS_FIND_NEXT );
80005848:	30 1b       	mov	r11,1
8000584a:	f9 d1 c0 10 	bfextu	r12,r1,0x0,0x10
8000584e:	f0 1f 00 07 	mcall	80005868 <nav_filelist_nb+0x6c>
   }
   // Return the value asked
   if( FS_FILE == b_type )
80005852:	58 00       	cp.w	r0,0
80005854:	c0 31       	brne	8000585a <nav_filelist_nb+0x5e>
80005856:	0e 92       	mov	r2,r7
80005858:	5c 82       	casts.h	r2
      return u16_save_number_file;
   else
      return u16_save_number_dir;
}
8000585a:	04 9c       	mov	r12,r2
8000585c:	d8 32       	popm	r0-r7,pc
8000585e:	00 00       	add	r0,r0
80005860:	00 00       	add	r0,r0
80005862:	0c 34       	cp.w	r4,r6
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	55 54       	stdsp	sp[0x154],r4
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	53 bc       	stdsp	sp[0xec],r12

8000586c <nav_filelist_last>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_filelist_last( bool b_type )
{
8000586c:	eb cd 40 c0 	pushm	r6-r7,lr
80005870:	18 96       	mov	r6,r12
   uint16_t u16_nb;

   // Get number of file or directory
   u16_nb = nav_filelist_nb( b_type  );
80005872:	f0 1f 00 0f 	mcall	800058ac <nav_filelist_last+0x40>
80005876:	ef dc b0 10 	bfexts	r7,r12,0x0,0x10
   if( 0 == u16_nb )
8000587a:	c0 61       	brne	80005886 <nav_filelist_last+0x1a>
   {
      fs_g_status = FS_ERR_NO_FIND;
8000587c:	30 99       	mov	r9,9
8000587e:	48 d8       	lddpc	r8,800058b0 <nav_filelist_last+0x44>
80005880:	b0 89       	st.b	r8[0x0],r9
80005882:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      return false;  // NO FILE FOUND
   }
   // Go to the first file or directory
   if ( !nav_filelist_first( b_type ))
80005886:	0c 9c       	mov	r12,r6
80005888:	f0 1f 00 0b 	mcall	800058b4 <nav_filelist_last+0x48>
8000588c:	c0 d0       	breq	800058a6 <nav_filelist_last+0x3a>
      return false;
   // If there are more one file or directory, then go to at the last of list
   if( 1 == u16_nb )
8000588e:	30 18       	mov	r8,1
80005890:	f0 07 19 00 	cp.h	r7,r8
80005894:	c0 31       	brne	8000589a <nav_filelist_last+0x2e>
80005896:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      return true;
   u16_nb -= 2;
   return nav_filelist_set( u16_nb , FS_FIND_NEXT );
8000589a:	0e 9c       	mov	r12,r7
8000589c:	20 2c       	sub	r12,2
8000589e:	30 1b       	mov	r11,1
800058a0:	5c 7c       	castu.h	r12
800058a2:	f0 1f 00 06 	mcall	800058b8 <nav_filelist_last+0x4c>
}
800058a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058aa:	00 00       	add	r0,r0
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	57 fc       	stdsp	sp[0x1fc],r12
800058b0:	00 00       	add	r0,r0
800058b2:	0c 84       	andn	r4,r6
800058b4:	80 00       	ld.sh	r0,r0[0x0]
800058b6:	57 bc       	stdsp	sp[0x1ec],r12
800058b8:	80 00       	ld.sh	r0,r0[0x0]
800058ba:	53 bc       	stdsp	sp[0xec],r12

800058bc <nav_dir_make>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_dir_make( const FS_STRING sz_name  )
{
800058bc:	eb cd 40 80 	pushm	r7,lr
800058c0:	18 97       	mov	r7,r12
   if ( !fat_check_mount_noopen())
800058c2:	f0 1f 00 18 	mcall	80005920 <nav_dir_make+0x64>
800058c6:	c2 b0       	breq	8000591c <nav_dir_make+0x60>
      return false;

   // Create an entry file
   if ( !nav_file_create( sz_name ))
800058c8:	0e 9c       	mov	r12,r7
800058ca:	f0 1f 00 17 	mcall	80005924 <nav_dir_make+0x68>
800058ce:	c2 70       	breq	8000591c <nav_dir_make+0x60>
      return false;

   // Allocate one cluster for the new directory
   MSB0(fs_g_seg.u32_addr)=0xFF;    // It is a new cluster list
800058d0:	49 68       	lddpc	r8,80005928 <nav_dir_make+0x6c>
800058d2:	3f f9       	mov	r9,-1
800058d4:	b0 89       	st.b	r8[0x0],r9
   fs_g_seg.u32_size_or_pos = 1;    // Only one sector (= one cluster)
800058d6:	30 19       	mov	r9,1
800058d8:	91 19       	st.w	r8[0x4],r9
   if ( !fat_allocfreespace())
800058da:	f0 1f 00 15 	mcall	8000592c <nav_dir_make+0x70>
800058de:	c0 71       	brne	800058ec <nav_dir_make+0x30>
   {
      fat_delete_file( false );
800058e0:	f0 1f 00 14 	mcall	80005930 <nav_dir_make+0x74>
      fat_cache_flush();
800058e4:	f0 1f 00 14 	mcall	80005934 <nav_dir_make+0x78>
800058e8:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   // Save information about the new directory
   fs_g_nav_entry.u32_cluster = fs_g_seg.u32_addr; // First cluster of the directory returned by alloc_free_space
800058ec:	49 38       	lddpc	r8,80005938 <nav_dir_make+0x7c>
800058ee:	48 f9       	lddpc	r9,80005928 <nav_dir_make+0x6c>
800058f0:	72 09       	ld.w	r9,r9[0x0]
800058f2:	91 19       	st.w	r8[0x4],r9
   fs_g_nav_entry.u32_size    = 0;                 // The directory size is null
800058f4:	30 09       	mov	r9,0
800058f6:	91 29       	st.w	r8[0x8],r9
   fs_g_nav_entry.u8_attr     = FS_ATTR_DIRECTORY; // Directory Attribute
800058f8:	31 09       	mov	r9,16
800058fa:	b0 a9       	st.b	r8[0x2],r9

   // Initialize the values in the new directory
   if ( !fat_initialize_dir())
800058fc:	f0 1f 00 10 	mcall	8000593c <nav_dir_make+0x80>
80005900:	c0 e0       	breq	8000591c <nav_dir_make+0x60>
      return false;

   // Write directory information in her entry file
   if ( !fat_read_dir())
80005902:	f0 1f 00 10 	mcall	80005940 <nav_dir_make+0x84>
80005906:	c0 b0       	breq	8000591c <nav_dir_make+0x60>
      return false;
   fat_write_entry_file();
80005908:	f0 1f 00 0f 	mcall	80005944 <nav_dir_make+0x88>
   if( !fat_cache_flush())
8000590c:	f0 1f 00 0a 	mcall	80005934 <nav_dir_make+0x78>
80005910:	c0 60       	breq	8000591c <nav_dir_make+0x60>
      return false;

   // Go to position of new directory (it is the last directory)
   return nav_filelist_last( FS_DIR );
80005912:	30 0c       	mov	r12,0
80005914:	f0 1f 00 0d 	mcall	80005948 <nav_dir_make+0x8c>
80005918:	e3 cd 80 80 	ldm	sp++,r7,pc
8000591c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005920:	80 00       	ld.sh	r0,r0[0x0]
80005922:	42 c0       	lddsp	r0,sp[0xb0]
80005924:	80 00       	ld.sh	r0,r0[0x0]
80005926:	55 6c       	stdsp	sp[0x158],r12
80005928:	00 00       	add	r0,r0
8000592a:	0c dc       	st.w	--r6,r12
8000592c:	80 00       	ld.sh	r0,r0[0x0]
8000592e:	48 14       	lddpc	r4,80005930 <nav_dir_make+0x74>
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	46 38       	lddsp	r8,sp[0x18c]
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	38 30       	mov	r0,-125
80005938:	00 00       	add	r0,r0
8000593a:	09 f4       	ld.ub	r4,r4[0x7]
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	44 d0       	lddsp	r0,sp[0x134]
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	3e cc       	mov	r12,-20
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	36 8c       	mov	r12,104
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	58 6c       	cp.w	r12,6

8000594c <nav_partition_mount>:
//! then the mount routine selects the first partition supported by file system. <br>
//! After mount, the file list contains files and directories of ROOT directory
//! @endverbatim
//!
bool  nav_partition_mount( void )
{
8000594c:	d4 01       	pushm	lr
   if ( !fat_check_noopen() )
8000594e:	f0 1f 00 0a 	mcall	80005974 <nav_partition_mount+0x28>
80005952:	c0 f0       	breq	80005970 <nav_partition_mount+0x24>
      return false;

   if( FS_TYPE_FAT_UNM != fs_g_nav_fast.u8_type_fat)
80005954:	48 98       	lddpc	r8,80005978 <nav_partition_mount+0x2c>
80005956:	11 89       	ld.ub	r9,r8[0x0]
80005958:	30 08       	mov	r8,0
8000595a:	f0 09 18 00 	cp.b	r9,r8
8000595e:	c0 70       	breq	8000596c <nav_partition_mount+0x20>
   {
      // Already mounted
      // Go to root directory
      fs_g_nav.u32_cluster_sel_dir   = 0;
80005960:	30 09       	mov	r9,0
80005962:	48 78       	lddpc	r8,8000597c <nav_partition_mount+0x30>
80005964:	91 89       	st.w	r8[0x20],r9
      // No file is selected by default
      fat_clear_entry_info_and_ptr();
80005966:	f0 1f 00 07 	mcall	80005980 <nav_partition_mount+0x34>
8000596a:	da 0a       	popm	pc,r12=1
      return true;
   }

   return fat_mount();
8000596c:	f0 1f 00 06 	mcall	80005984 <nav_partition_mount+0x38>
}
80005970:	d8 02       	popm	pc
80005972:	00 00       	add	r0,r0
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	41 ec       	lddsp	r12,sp[0x78]
80005978:	00 00       	add	r0,r0
8000597a:	0c 80       	andn	r0,r6
8000597c:	00 00       	add	r0,r0
8000597e:	0c 34       	cp.w	r4,r6
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	32 a8       	mov	r8,42
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	4d ac       	lddpc	r12,80005aec <nav_setcwd+0xa8>

80005988 <nav_dir_root>:
//!
//! @return  false in case of error, see global value "fs_g_status" for more detail
//! @return  true otherwise
//!
bool  nav_dir_root( void )
{
80005988:	d4 01       	pushm	lr
   return nav_partition_mount();
8000598a:	f0 1f 00 02 	mcall	80005990 <nav_dir_root+0x8>
}
8000598e:	d8 02       	popm	pc
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	59 4c       	cp.w	r12,20

80005994 <nav_drive_set>:
//!
//! @return    false in case of error, see global value "fs_g_status" for more detail
//! @return    true otherwise
//!
bool  nav_drive_set( uint8_t u8_number )
{
80005994:	eb cd 40 80 	pushm	r7,lr
80005998:	18 97       	mov	r7,r12
   if ( !fat_check_noopen() )
8000599a:	f0 1f 00 0f 	mcall	800059d4 <nav_drive_set+0x40>
8000599e:	c1 90       	breq	800059d0 <nav_drive_set+0x3c>
      return false;

   if (u8_number >= get_nb_lun() )
800059a0:	f0 1f 00 0e 	mcall	800059d8 <nav_drive_set+0x44>
800059a4:	ee 0c 18 00 	cp.b	r12,r7
800059a8:	e0 8b 00 07 	brhi	800059b6 <nav_drive_set+0x22>
   {
      fs_g_status = FS_ERR_END_OF_DRIVE;   // The drive number is bad
800059ac:	30 69       	mov	r9,6
800059ae:	48 c8       	lddpc	r8,800059dc <nav_drive_set+0x48>
800059b0:	b0 89       	st.b	r8[0x0],r9
800059b2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }

   if ( fs_g_nav.u8_lun == u8_number)
800059b6:	48 b8       	lddpc	r8,800059e0 <nav_drive_set+0x4c>
800059b8:	11 88       	ld.ub	r8,r8[0x0]
800059ba:	ee 08 18 00 	cp.b	r8,r7
800059be:	c0 31       	brne	800059c4 <nav_drive_set+0x30>
800059c0:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
      return true;   // It is the same drive number

   // Go to the device
   fs_g_nav.u8_lun = u8_number;
800059c4:	48 78       	lddpc	r8,800059e0 <nav_drive_set+0x4c>
800059c6:	b0 87       	st.b	r8[0x0],r7
   fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM;
800059c8:	30 09       	mov	r9,0
800059ca:	48 78       	lddpc	r8,800059e4 <nav_drive_set+0x50>
800059cc:	b0 89       	st.b	r8[0x0],r9
800059ce:	30 1c       	mov	r12,1
#if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;   // by default select the first partition
#endif
   return true;
}
800059d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800059d4:	80 00       	ld.sh	r0,r0[0x0]
800059d6:	41 ec       	lddsp	r12,sp[0x78]
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	42 d8       	lddsp	r8,sp[0xb4]
800059dc:	00 00       	add	r0,r0
800059de:	0c 84       	andn	r4,r6
800059e0:	00 00       	add	r0,r0
800059e2:	0c 34       	cp.w	r4,r6
800059e4:	00 00       	add	r0,r0
800059e6:	0c 80       	andn	r0,r6

800059e8 <nav_gotoindex>:
//! This routine allow to reinit a navigator quickly via a file index (disk, partition, dir, file/dir selected )
//! To get a file index, you shall used the routine nav_getindex().
//! @endverbatim
//!
bool  nav_gotoindex( const Fs_index _MEM_TYPE_SLOW_ *index )
{
800059e8:	d4 21       	pushm	r4-r7,lr
800059ea:	18 97       	mov	r7,r12
   // Select the drive and partition corresponding at file index
   if( !nav_drive_set( index->u8_lun ))
800059ec:	19 8c       	ld.ub	r12,r12[0x0]
800059ee:	f0 1f 00 10 	mcall	80005a2c <nav_gotoindex+0x44>
800059f2:	c1 c0       	breq	80005a2a <nav_gotoindex+0x42>
      return false;
#if (FS_MULTI_PARTITION  ==  true)
   if( !nav_partition_set(index->u8_partition))
      return false;
#endif
   if( !nav_partition_mount())
800059f4:	f0 1f 00 0f 	mcall	80005a30 <nav_gotoindex+0x48>
800059f8:	c1 90       	breq	80005a2a <nav_gotoindex+0x42>
      return false;

   // Select the directory corresponding at file index
   fs_g_nav.u32_cluster_sel_dir   = index->u32_cluster_sel_dir;
800059fa:	6e 19       	ld.w	r9,r7[0x4]
800059fc:	48 e8       	lddpc	r8,80005a34 <nav_gotoindex+0x4c>
800059fe:	91 89       	st.w	r8[0x20],r9

   // Search the file position corresponding at file index
   if ( !nav_filelist_reset())
80005a00:	f0 1f 00 0e 	mcall	80005a38 <nav_gotoindex+0x50>
80005a04:	c0 a1       	brne	80005a18 <nav_gotoindex+0x30>
80005a06:	c1 28       	rjmp	80005a2a <nav_gotoindex+0x42>
      return false;
   while( fs_g_nav_fast.u16_entry_pos_sel_file != index->u16_entry_pos_sel_file )
   {
      if( !nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005a08:	0a 9b       	mov	r11,r5
80005a0a:	08 9c       	mov	r12,r4
80005a0c:	f0 1f 00 0c 	mcall	80005a3c <nav_gotoindex+0x54>
80005a10:	c0 71       	brne	80005a1e <nav_gotoindex+0x36>
      {
         nav_filelist_reset();
80005a12:	f0 1f 00 0a 	mcall	80005a38 <nav_gotoindex+0x50>
80005a16:	d8 2a       	popm	r4-r7,pc,r12=0
   fs_g_nav.u32_cluster_sel_dir   = index->u32_cluster_sel_dir;

   // Search the file position corresponding at file index
   if ( !nav_filelist_reset())
      return false;
   while( fs_g_nav_fast.u16_entry_pos_sel_file != index->u16_entry_pos_sel_file )
80005a18:	48 a6       	lddpc	r6,80005a40 <nav_gotoindex+0x58>
   {
      if( !nav_filelist_set( 0 , FS_FIND_NEXT ) )
80005a1a:	30 15       	mov	r5,1
80005a1c:	30 04       	mov	r4,0
   fs_g_nav.u32_cluster_sel_dir   = index->u32_cluster_sel_dir;

   // Search the file position corresponding at file index
   if ( !nav_filelist_reset())
      return false;
   while( fs_g_nav_fast.u16_entry_pos_sel_file != index->u16_entry_pos_sel_file )
80005a1e:	8c 19       	ld.sh	r9,r6[0x2]
80005a20:	8e 48       	ld.sh	r8,r7[0x8]
80005a22:	f0 09 19 00 	cp.h	r9,r8
80005a26:	cf 11       	brne	80005a08 <nav_gotoindex+0x20>
80005a28:	da 2a       	popm	r4-r7,pc,r12=1
80005a2a:	d8 2a       	popm	r4-r7,pc,r12=0
80005a2c:	80 00       	ld.sh	r0,r0[0x0]
80005a2e:	59 94       	cp.w	r4,25
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	59 4c       	cp.w	r12,20
80005a34:	00 00       	add	r0,r0
80005a36:	0c 34       	cp.w	r4,r6
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	55 54       	stdsp	sp[0x154],r4
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	53 bc       	stdsp	sp[0xec],r12
80005a40:	00 00       	add	r0,r0
80005a42:	0c 80       	andn	r0,r6

80005a44 <nav_setcwd>:
//! With syntax "./dir_parent/directory_name"  the file list corresponding at "dir_parent" and "directory_name" is selected.
//! With syntax "./dir_parent/directory_name/" the file list corresponding at "directory_name" and no file is selected.
//! @endverbatim
//!
bool  nav_setcwd( FS_STRING sz_path , bool b_match_case , bool b_create )
{
80005a44:	d4 31       	pushm	r0-r7,lr
80005a46:	20 6d       	sub	sp,24
80005a48:	18 97       	mov	r7,r12
80005a4a:	16 91       	mov	r1,r11
80005a4c:	14 90       	mov	r0,r10
    (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET))
   FS_STRING sz_save_path = 0;
#endif
   bool b_create_name = false;

   if ( !fat_check_noopen())
80005a4e:	f0 1f 00 61 	mcall	80005bd0 <nav_setcwd+0x18c>
80005a52:	e0 80 00 bd 	breq	80005bcc <nav_setcwd+0x188>
      return false;

   index = nav_getindex();             // Save current position
80005a56:	1a 96       	mov	r6,sp
80005a58:	1a 9c       	mov	r12,sp
80005a5a:	f0 1f 00 5f 	mcall	80005bd4 <nav_setcwd+0x190>
80005a5e:	fa c8 ff f4 	sub	r8,sp,-12
80005a62:	fa ea 00 00 	ld.d	r10,sp[0]
80005a66:	f0 eb 00 00 	st.d	r8[0],r10
80005a6a:	40 29       	lddsp	r9,sp[0x8]
80005a6c:	91 29       	st.w	r8[0x8],r9

   // Check syntax "\path..."
   if( (( Is_unicode) && (('\\'  == ((FS_STR_UNICODE)sz_path )[0]) || ('/'  == ((FS_STR_UNICODE)sz_path )[0])) )
   ||  ((!Is_unicode) && (('\\'  == sz_path [0]) || ('/'  == sz_path [0])) ) )
80005a6e:	0f 88       	ld.ub	r8,r7[0x0]
      return false;

   index = nav_getindex();             // Save current position

   // Check syntax "\path..."
   if( (( Is_unicode) && (('\\'  == ((FS_STR_UNICODE)sz_path )[0]) || ('/'  == ((FS_STR_UNICODE)sz_path )[0])) )
80005a70:	35 c9       	mov	r9,92
80005a72:	f2 08 18 00 	cp.b	r8,r9
80005a76:	5f 0a       	sreq	r10
80005a78:	32 f9       	mov	r9,47
80005a7a:	f2 08 18 00 	cp.b	r8,r9
80005a7e:	5f 09       	sreq	r9
80005a80:	f5 e9 10 09 	or	r9,r10,r9
80005a84:	c0 70       	breq	80005a92 <nav_setcwd+0x4e>
   ||  ((!Is_unicode) && (('\\'  == sz_path [0]) || ('/'  == sz_path [0])) ) )
   {
      // Go to the root of current drive
      if( !nav_dir_root())
80005a86:	f0 1f 00 55 	mcall	80005bd8 <nav_setcwd+0x194>
80005a8a:	e0 80 00 9c 	breq	80005bc2 <nav_setcwd+0x17e>
         goto nav_setcwd_fail;
      sz_path  += (Is_unicode? 2 : 1 );
80005a8e:	2f f7       	sub	r7,-1
80005a90:	c5 e8       	rjmp	80005b4c <nav_setcwd+0x108>
   }else

   // Check syntax "x:\path..."
   if( (( Is_unicode) && (( ':'  == ((FS_STR_UNICODE)sz_path )[1] ) && (('\\'  == ((FS_STR_UNICODE)sz_path )[2] ) || ('/'  == ((FS_STR_UNICODE)sz_path )[2]))) )
   ||  ((!Is_unicode) && (( ':'  == sz_path [1] ) && (('\\'  == sz_path [2] ) || ('/'  == sz_path [2]))) ) )
80005a92:	0f 99       	ld.ub	r9,r7[0x1]
         goto nav_setcwd_fail;
      sz_path  += (Is_unicode? 2 : 1 );
   }else

   // Check syntax "x:\path..."
   if( (( Is_unicode) && (( ':'  == ((FS_STR_UNICODE)sz_path )[1] ) && (('\\'  == ((FS_STR_UNICODE)sz_path )[2] ) || ('/'  == ((FS_STR_UNICODE)sz_path )[2]))) )
80005a94:	33 aa       	mov	r10,58
80005a96:	f4 09 18 00 	cp.b	r9,r10
80005a9a:	c2 01       	brne	80005ada <nav_setcwd+0x96>
   ||  ((!Is_unicode) && (( ':'  == sz_path [1] ) && (('\\'  == sz_path [2] ) || ('/'  == sz_path [2]))) ) )
80005a9c:	0f aa       	ld.ub	r10,r7[0x2]
         goto nav_setcwd_fail;
      sz_path  += (Is_unicode? 2 : 1 );
   }else

   // Check syntax "x:\path..."
   if( (( Is_unicode) && (( ':'  == ((FS_STR_UNICODE)sz_path )[1] ) && (('\\'  == ((FS_STR_UNICODE)sz_path )[2] ) || ('/'  == ((FS_STR_UNICODE)sz_path )[2]))) )
80005a9e:	35 cb       	mov	r11,92
80005aa0:	f6 0a 18 00 	cp.b	r10,r11
80005aa4:	5f 0b       	sreq	r11
80005aa6:	32 fc       	mov	r12,47
80005aa8:	f8 0a 18 00 	cp.b	r10,r12
80005aac:	5f 0a       	sreq	r10
80005aae:	f7 ea 10 0a 	or	r10,r11,r10
80005ab2:	c1 40       	breq	80005ada <nav_setcwd+0x96>
      if( Is_unicode )
      {
         if( !nav_drive_set( toupper(((FS_STR_UNICODE)sz_path )[0])-'A' ) )
            goto nav_setcwd_fail;
      }else{
         if( !nav_drive_set( toupper(sz_path [0])-'A' ) )
80005ab4:	4c a9       	lddpc	r9,80005bdc <nav_setcwd+0x198>
80005ab6:	72 09       	ld.w	r9,r9[0x0]
80005ab8:	f2 08 07 09 	ld.ub	r9,r9[r8]
80005abc:	e2 19 00 02 	andl	r9,0x2,COH
80005ac0:	f7 b8 01 20 	subne	r8,32
80005ac4:	24 18       	sub	r8,65
80005ac6:	f9 d8 c0 08 	bfextu	r12,r8,0x0,0x8
80005aca:	f0 1f 00 46 	mcall	80005be0 <nav_setcwd+0x19c>
80005ace:	c7 a0       	breq	80005bc2 <nav_setcwd+0x17e>
            goto nav_setcwd_fail;
      }
      if( !nav_partition_mount())
80005ad0:	f0 1f 00 45 	mcall	80005be4 <nav_setcwd+0x1a0>
80005ad4:	c7 70       	breq	80005bc2 <nav_setcwd+0x17e>
         goto nav_setcwd_fail;
      sz_path  += 3*(Is_unicode? 2 : 1 );
80005ad6:	2f d7       	sub	r7,-3
         goto nav_setcwd_fail;
      sz_path  += (Is_unicode? 2 : 1 );
   }else

   // Check syntax "x:\path..."
   if( (( Is_unicode) && (( ':'  == ((FS_STR_UNICODE)sz_path )[1] ) && (('\\'  == ((FS_STR_UNICODE)sz_path )[2] ) || ('/'  == ((FS_STR_UNICODE)sz_path )[2]))) )
80005ad8:	c3 a8       	rjmp	80005b4c <nav_setcwd+0x108>
         goto nav_setcwd_fail;
      sz_path  += 3*(Is_unicode? 2 : 1 );
   }else

   // Check syntax ".\path..."
   if( (( Is_unicode) && (( '.'  == ((FS_STR_UNICODE)sz_path )[0] ) && (('\\'  == ((FS_STR_UNICODE)sz_path )[1] ) || ('/'  == ((FS_STR_UNICODE)sz_path )[1] ))) )
80005ada:	32 ea       	mov	r10,46
80005adc:	f4 08 18 00 	cp.b	r8,r10
80005ae0:	c1 a1       	brne	80005b14 <nav_setcwd+0xd0>
80005ae2:	35 c8       	mov	r8,92
80005ae4:	f0 09 18 00 	cp.b	r9,r8
80005ae8:	5f 0a       	sreq	r10
80005aea:	32 f8       	mov	r8,47
80005aec:	f0 09 18 00 	cp.b	r9,r8
80005af0:	5f 08       	sreq	r8
80005af2:	f5 e8 10 08 	or	r8,r10,r8
80005af6:	c0 f0       	breq	80005b14 <nav_setcwd+0xd0>
   ||  ((!Is_unicode) && (( '.'  == sz_path [0] ) && (('\\'  == sz_path [1] ) || ('/'  == sz_path [1] ))) ) )
   {
      // Search in current directory
      sz_path  += 2*(Is_unicode? 2 : 1 );
80005af8:	2f e7       	sub	r7,-2
         goto nav_setcwd_fail;
      sz_path  += 3*(Is_unicode? 2 : 1 );
   }else

   // Check syntax ".\path..."
   if( (( Is_unicode) && (( '.'  == ((FS_STR_UNICODE)sz_path )[0] ) && (('\\'  == ((FS_STR_UNICODE)sz_path )[1] ) || ('/'  == ((FS_STR_UNICODE)sz_path )[1] ))) )
80005afa:	c2 98       	rjmp	80005b4c <nav_setcwd+0x108>
         while(( '.'  == sz_path [0] )
         &&    ( '.'  == sz_path [1] )
         &&    (('\\'  == sz_path [2]) || ('/'  == sz_path [2]) || (0  == sz_path [2])) )
         {
         // Go to parent directory
         if( !nav_dir_gotoparent() )
80005afc:	f0 1f 00 3b 	mcall	80005be8 <nav_setcwd+0x1a4>
80005b00:	c6 10       	breq	80005bc2 <nav_setcwd+0x17e>
            goto nav_setcwd_fail;
            sz_path  += 2; // jump ".."
            if( 0 != sz_path [0])
80005b02:	0d 88       	ld.ub	r8,r6[0x0]
80005b04:	e8 08 18 00 	cp.b	r8,r4
80005b08:	c0 31       	brne	80005b0e <nav_setcwd+0xca>
80005b0a:	0c 97       	mov	r7,r6
80005b0c:	c0 88       	rjmp	80005b1c <nav_setcwd+0xd8>
               sz_path  +=1; // jump "/"
80005b0e:	ec c7 ff ff 	sub	r7,r6,-1
80005b12:	c0 58       	rjmp	80005b1c <nav_setcwd+0xd8>
            sz_path  += (2*2); // jump ".."
            if( 0 != ((FS_STR_UNICODE)sz_path )[0])
               sz_path  += (2*1); // jump "/"
         }
      }else{
         while(( '.'  == sz_path [0] )
80005b14:	32 e5       	mov	r5,46
80005b16:	35 c3       	mov	r3,92
80005b18:	32 f2       	mov	r2,47
80005b1a:	30 04       	mov	r4,0
80005b1c:	0f 88       	ld.ub	r8,r7[0x0]
80005b1e:	ea 08 18 00 	cp.b	r8,r5
80005b22:	c1 51       	brne	80005b4c <nav_setcwd+0x108>
         &&    ( '.'  == sz_path [1] )
80005b24:	0f 98       	ld.ub	r8,r7[0x1]
80005b26:	ea 08 18 00 	cp.b	r8,r5
80005b2a:	c1 11       	brne	80005b4c <nav_setcwd+0x108>
         &&    (('\\'  == sz_path [2]) || ('/'  == sz_path [2]) || (0  == sz_path [2])) )
80005b2c:	ee c6 ff fe 	sub	r6,r7,-2
80005b30:	0d 88       	ld.ub	r8,r6[0x0]
            sz_path  += (2*2); // jump ".."
            if( 0 != ((FS_STR_UNICODE)sz_path )[0])
               sz_path  += (2*1); // jump "/"
         }
      }else{
         while(( '.'  == sz_path [0] )
80005b32:	e6 08 18 00 	cp.b	r8,r3
80005b36:	5f 0a       	sreq	r10
80005b38:	e4 08 18 00 	cp.b	r8,r2
80005b3c:	5f 09       	sreq	r9
80005b3e:	f5 e9 10 09 	or	r9,r10,r9
80005b42:	e8 09 18 00 	cp.b	r9,r4
80005b46:	cd b1       	brne	80005afc <nav_setcwd+0xb8>
80005b48:	58 08       	cp.w	r8,0
80005b4a:	cd 90       	breq	80005afc <nav_setcwd+0xb8>
         }
      }
   }

   // Reset list to start the search at the beginning
   if( !nav_filelist_reset())
80005b4c:	f0 1f 00 28 	mcall	80005bec <nav_setcwd+0x1a8>
80005b50:	c3 90       	breq	80005bc2 <nav_setcwd+0x17e>
80005b52:	30 03       	mov	r3,0
80005b54:	06 92       	mov	r2,r3
      goto nav_setcwd_fail;

   while( 1 )
   {
      if( (( Is_unicode) && ( 0 == ((FS_STR_UNICODE)sz_path )[0] ) )
      ||  ((!Is_unicode) && ( 0 == sz_path [0] ) ) )
80005b56:	30 06       	mov	r6,0
#endif
            }
            break;   // The file include in path is found or created, then end of set_cwd
         }

         if( (( Is_unicode) && (('\\' == ((FS_STR_UNICODE)sz_path )[0] ) || ('/' == ((FS_STR_UNICODE)sz_path )[0] )) )
80005b58:	35 c5       	mov	r5,92
80005b5a:	32 f4       	mov	r4,47
      goto nav_setcwd_fail;

   while( 1 )
   {
      if( (( Is_unicode) && ( 0 == ((FS_STR_UNICODE)sz_path )[0] ) )
      ||  ((!Is_unicode) && ( 0 == sz_path [0] ) ) )
80005b5c:	0f 88       	ld.ub	r8,r7[0x0]
80005b5e:	ec 08 18 00 	cp.b	r8,r6
80005b62:	c0 31       	brne	80005b68 <nav_setcwd+0x124>
80005b64:	30 1c       	mov	r12,1
80005b66:	c3 38       	rjmp	80005bcc <nav_setcwd+0x188>
      {
         return true;   // path (without file) is found or create
      }
      if( !nav_filelist_findname( sz_path  , b_match_case  ))
80005b68:	02 9b       	mov	r11,r1
80005b6a:	0e 9c       	mov	r12,r7
80005b6c:	f0 1f 00 21 	mcall	80005bf0 <nav_setcwd+0x1ac>
80005b70:	c0 51       	brne	80005b7a <nav_setcwd+0x136>
      {
         // The file or directory is not found
         if( !b_create )
80005b72:	58 00       	cp.w	r0,0
80005b74:	c2 70       	breq	80005bc2 <nav_setcwd+0x17e>
80005b76:	0e 92       	mov	r2,r7
80005b78:	30 13       	mov	r3,1
#endif
      }

      while( 1 )
      {
         sz_path  += (Is_unicode? 2 : 1 );
80005b7a:	2f f7       	sub	r7,-1
         if( (( Is_unicode) && ( 0 == ((FS_STR_UNICODE)sz_path )[0] ) )
         ||  ((!Is_unicode) && ( 0 == sz_path [0] ) ) )
80005b7c:	0f 88       	ld.ub	r8,r7[0x0]
      }

      while( 1 )
      {
         sz_path  += (Is_unicode? 2 : 1 );
         if( (( Is_unicode) && ( 0 == ((FS_STR_UNICODE)sz_path )[0] ) )
80005b7e:	58 08       	cp.w	r8,0
80005b80:	c0 81       	brne	80005b90 <nav_setcwd+0x14c>
         ||  ((!Is_unicode) && ( 0 == sz_path [0] ) ) )
         {
            // Is it the last name of path and it is a file
            if( b_create_name )
80005b82:	58 03       	cp.w	r3,0
80005b84:	ce c0       	breq	80005b5c <nav_setcwd+0x118>
            {
#if (FSFEATURE_WRITE == (FS_LEVEL_FEATURES & FSFEATURE_WRITE))
               // The file must be created
               if( !nav_file_create( sz_save_path ) )
80005b86:	04 9c       	mov	r12,r2
80005b88:	f0 1f 00 1b 	mcall	80005bf4 <nav_setcwd+0x1b0>
80005b8c:	ce 81       	brne	80005b5c <nav_setcwd+0x118>
80005b8e:	c1 a8       	rjmp	80005bc2 <nav_setcwd+0x17e>
#endif
            }
            break;   // The file include in path is found or created, then end of set_cwd
         }

         if( (( Is_unicode) && (('\\' == ((FS_STR_UNICODE)sz_path )[0] ) || ('/' == ((FS_STR_UNICODE)sz_path )[0] )) )
80005b90:	ea 08 18 00 	cp.b	r8,r5
80005b94:	5f 09       	sreq	r9
80005b96:	e8 08 18 00 	cp.b	r8,r4
80005b9a:	5f 08       	sreq	r8
80005b9c:	f3 e8 10 08 	or	r8,r9,r8
80005ba0:	ec 08 18 00 	cp.b	r8,r6
80005ba4:	ce b0       	breq	80005b7a <nav_setcwd+0x136>
         ||  ((!Is_unicode) && (('\\' == sz_path [0] ) || ('/' == sz_path [0] )) ) )
         {
            // Is it a folder name
            if( b_create_name )
80005ba6:	58 03       	cp.w	r3,0
80005ba8:	c0 50       	breq	80005bb2 <nav_setcwd+0x16e>
            {
#if (FSFEATURE_WRITE_COMPLET == (FS_LEVEL_FEATURES & FSFEATURE_WRITE_COMPLET))
               // The folder doesn't exist and it must be created
               if( !nav_dir_make( sz_save_path ))
80005baa:	04 9c       	mov	r12,r2
80005bac:	f0 1f 00 13 	mcall	80005bf8 <nav_setcwd+0x1b4>
80005bb0:	c0 90       	breq	80005bc2 <nav_setcwd+0x17e>
                  goto nav_setcwd_fail;
#else
               goto nav_setcwd_fail;
#endif
            }
            if( !fat_entry_is_dir() )
80005bb2:	f0 1f 00 13 	mcall	80005bfc <nav_setcwd+0x1b8>
80005bb6:	c0 60       	breq	80005bc2 <nav_setcwd+0x17e>
               goto nav_setcwd_fail;
            // jump '\'
            sz_path  += (Is_unicode? 2 : 1 );
            if( !nav_dir_cd())
80005bb8:	f0 1f 00 12 	mcall	80005c00 <nav_setcwd+0x1bc>
80005bbc:	c0 30       	breq	80005bc2 <nav_setcwd+0x17e>
#endif
            }
            if( !fat_entry_is_dir() )
               goto nav_setcwd_fail;
            // jump '\'
            sz_path  += (Is_unicode? 2 : 1 );
80005bbe:	2f f7       	sub	r7,-1
80005bc0:	cc eb       	rjmp	80005b5c <nav_setcwd+0x118>
      }

   }

nav_setcwd_fail:
   nav_gotoindex( &index );   // Restore the position
80005bc2:	fa cc ff f4 	sub	r12,sp,-12
80005bc6:	f0 1f 00 10 	mcall	80005c04 <nav_setcwd+0x1c0>
80005bca:	30 0c       	mov	r12,0
   return false;
}
80005bcc:	2f ad       	sub	sp,-24
80005bce:	d8 32       	popm	r0-r7,pc
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	41 ec       	lddsp	r12,sp[0x78]
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	52 ac       	stdsp	sp[0xa8],r12
80005bd8:	80 00       	ld.sh	r0,r0[0x0]
80005bda:	59 88       	cp.w	r8,24
80005bdc:	00 00       	add	r0,r0
80005bde:	00 2c       	rsub	r12,r0
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	59 94       	cp.w	r4,25
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	59 4c       	cp.w	r12,20
80005be8:	80 00       	ld.sh	r0,r0[0x0]
80005bea:	55 d8       	stdsp	sp[0x174],r8
80005bec:	80 00       	ld.sh	r0,r0[0x0]
80005bee:	55 54       	stdsp	sp[0x154],r4
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	55 24       	stdsp	sp[0x148],r4
80005bf4:	80 00       	ld.sh	r0,r0[0x0]
80005bf6:	55 6c       	stdsp	sp[0x158],r12
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	58 bc       	cp.w	r12,11
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	32 90       	mov	r0,41
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	57 7c       	stdsp	sp[0x1dc],r12
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	59 e8       	cp.w	r8,30

80005c08 <nav_drive_nb>:
//! @verbatim
//! This value may be dynamic because it depends of memory drivers (e.g. Mass Storage disk on USB host mode)
//! @endverbatim
//!
uint8_t    nav_drive_nb( void )
{
80005c08:	d4 01       	pushm	lr
   return get_nb_lun(); // Number of devices = Number of lun
80005c0a:	f0 1f 00 02 	mcall	80005c10 <nav_drive_nb+0x8>
}
80005c0e:	d8 02       	popm	pc
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	42 d8       	lddsp	r8,sp[0xb4]

80005c14 <nav_select>:
//!
//! @return    false if ID navigator don't exist
//! @return    true otherwise
//!
bool  nav_select( uint8_t u8_idnav )
{
80005c14:	eb cd 40 80 	pushm	r7,lr
80005c18:	18 97       	mov	r7,r12
   if( FS_NB_NAVIGATOR <= u8_idnav )
80005c1a:	30 18       	mov	r8,1
80005c1c:	f0 0c 18 00 	cp.b	r12,r8
80005c20:	e0 88 00 07 	brls	80005c2e <nav_select+0x1a>
   {
      fs_g_status = FS_ERR_BAD_NAV;             // The navigator doesn't exist
80005c24:	32 79       	mov	r9,39
80005c26:	48 b8       	lddpc	r8,80005c50 <nav_select+0x3c>
80005c28:	b0 89       	st.b	r8[0x0],r9
80005c2a:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
      return false;
   }
#if (FS_NB_NAVIGATOR > 1)
   if( fs_g_u8_nav_selected != u8_idnav )
80005c2e:	48 a8       	lddpc	r8,80005c54 <nav_select+0x40>
80005c30:	11 8c       	ld.ub	r12,r8[0x0]
80005c32:	ee 0c 18 00 	cp.b	r12,r7
80005c36:	c0 31       	brne	80005c3c <nav_select+0x28>
80005c38:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
   {
      fat_invert_nav( fs_g_u8_nav_selected );   // Deselect previous navigator = Select default navigator
80005c3c:	f0 1f 00 07 	mcall	80005c58 <nav_select+0x44>
      fat_invert_nav( u8_idnav );               // Select new navigator
80005c40:	0e 9c       	mov	r12,r7
80005c42:	f0 1f 00 06 	mcall	80005c58 <nav_select+0x44>
      fs_g_u8_nav_selected = u8_idnav;
80005c46:	48 48       	lddpc	r8,80005c54 <nav_select+0x40>
80005c48:	b0 87       	st.b	r8[0x0],r7
80005c4a:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80005c4e:	00 00       	add	r0,r0
80005c50:	00 00       	add	r0,r0
80005c52:	0c 84       	andn	r4,r6
80005c54:	00 00       	add	r0,r0
80005c56:	0c fc       	st.b	--r6,r12
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	37 54       	mov	r4,117

80005c5c <nav_reset>:
//! @verbatim
//! Call this at the program startup or before a new session (e.g. USB Device exit)
//! @endverbatim
//!
void  nav_reset( void )
{
80005c5c:	eb cd 40 f8 	pushm	r3-r7,lr
#if ( (FS_ASCII   == true) && (FS_UNICODE == true))
   g_b_unicode = true;
#endif
   g_b_string_length = false;
80005c60:	30 07       	mov	r7,0
80005c62:	49 18       	lddpc	r8,80005ca4 <nav_reset+0x48>
80005c64:	b0 87       	st.b	r8[0x0],r7
   g_b_no_check_disk = false;
80005c66:	49 18       	lddpc	r8,80005ca8 <nav_reset+0x4c>
80005c68:	b0 87       	st.b	r8[0x0],r7

   fat_cache_reset();
80005c6a:	f0 1f 00 11 	mcall	80005cac <nav_reset+0x50>
   fat_cache_clusterlist_reset();
80005c6e:	f0 1f 00 11 	mcall	80005cb0 <nav_reset+0x54>
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
80005c72:	30 0c       	mov	r12,0
80005c74:	f0 1f 00 10 	mcall	80005cb4 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005c78:	49 03       	lddpc	r3,80005cb8 <nav_reset+0x5c>
80005c7a:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80005c7c:	49 05       	lddpc	r5,80005cbc <nav_reset+0x60>
80005c7e:	3f f4       	mov	r4,-1
80005c80:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80005c82:	49 06       	lddpc	r6,80005cc0 <nav_reset+0x64>
80005c84:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
80005c86:	eb 67 00 2d 	st.b	r5[45],r7
   {
   uint8_t i;
   // Reset variables of each navigators
   for( i=0 ; i!=FS_NB_NAVIGATOR ; i++ )
   {
      nav_select(i);
80005c8a:	30 1c       	mov	r12,1
80005c8c:	f0 1f 00 0a 	mcall	80005cb4 <nav_reset+0x58>
      fs_g_nav_fast.u8_type_fat = FS_TYPE_FAT_UNM; // By default the fat isn't mounted
80005c90:	a6 87       	st.b	r3[0x0],r7
      fs_g_nav.u8_lun = 0xFF;                      // By default don't select a drive
80005c92:	aa 84       	st.b	r5[0x0],r4
#if (FS_MULTI_PARTITION  ==  true)
      fs_g_nav.u8_partition=0;                     // By default select the first partition
#endif
      Fat_file_close();                            // By default no file is opened
80005c94:	ac 87       	st.b	r6[0x0],r7
      fs_g_nav.b_mode_nav_single = false;          // By default display files and directories
80005c96:	eb 67 00 2d 	st.b	r5[45],r7
   }
   // By default select the navigator 0
   fs_g_u8_nav_selected = 0;
80005c9a:	48 b8       	lddpc	r8,80005cc4 <nav_reset+0x68>
80005c9c:	b0 87       	st.b	r8[0x0],r7
#  if (FS_MULTI_PARTITION  ==  true)
   fs_g_nav.u8_partition=0;                        // By default select the first partition
#  endif
   Fat_file_close();                               // By default no file is opened
#endif // (FS_NB_NAVIGATOR > 1)
}
80005c9e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005ca2:	00 00       	add	r0,r0
80005ca4:	00 00       	add	r0,r0
80005ca6:	0c 85       	andn	r5,r6
80005ca8:	00 00       	add	r0,r0
80005caa:	0a 06       	add	r6,r5
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	36 64       	mov	r4,102
80005cb0:	80 00       	ld.sh	r0,r0[0x0]
80005cb2:	30 3c       	mov	r12,3
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	5c 14       	scr	r4
80005cb8:	00 00       	add	r0,r0
80005cba:	0c 80       	andn	r0,r6
80005cbc:	00 00       	add	r0,r0
80005cbe:	0c 34       	cp.w	r4,r6
80005cc0:	00 00       	add	r0,r0
80005cc2:	09 f4       	ld.ub	r4,r4[0x7]
80005cc4:	00 00       	add	r0,r0
80005cc6:	0c fc       	st.b	--r6,r12

80005cc8 <sd_mmc_spi_wr_protect>:
//! @return false  -> the memory is not write-protected (always)
//!/
bool  sd_mmc_spi_wr_protect(void)
{
   return false;
}
80005cc8:	5e fd       	retal	0

80005cca <sd_mmc_spi_removal>:
//!/
bool  sd_mmc_spi_removal(void)
{
  return false;
//  return ((sd_mmc_spi_check_presence()) ? false : true);
}
80005cca:	5e fd       	retal	0

80005ccc <sd_mmc_spi_test_unit_ready>:
}



Ctrl_status sd_mmc_spi_test_unit_ready(void)
{
80005ccc:	d4 01       	pushm	lr
  Sd_mmc_spi_access_signal_on();
  switch (sd_mmc_spi_presence_status)
80005cce:	49 88       	lddpc	r8,80005d2c <sd_mmc_spi_test_unit_ready+0x60>
80005cd0:	11 88       	ld.ub	r8,r8[0x0]
80005cd2:	30 19       	mov	r9,1
80005cd4:	f2 08 18 00 	cp.b	r8,r9
80005cd8:	c1 40       	breq	80005d00 <sd_mmc_spi_test_unit_ready+0x34>
80005cda:	c0 63       	brcs	80005ce6 <sd_mmc_spi_test_unit_ready+0x1a>
80005cdc:	30 29       	mov	r9,2
80005cde:	f2 08 18 00 	cp.b	r8,r9
80005ce2:	c2 01       	brne	80005d22 <sd_mmc_spi_test_unit_ready+0x56>
80005ce4:	c1 a8       	rjmp	80005d18 <sd_mmc_spi_test_unit_ready+0x4c>
  {
    case SD_MMC_REMOVED:
      sd_mmc_spi_init_done = false;
80005ce6:	30 09       	mov	r9,0
80005ce8:	49 28       	lddpc	r8,80005d30 <sd_mmc_spi_test_unit_ready+0x64>
80005cea:	b0 89       	st.b	r8[0x0],r9
      if (sd_mmc_spi_mem_check())
80005cec:	f0 1f 00 12 	mcall	80005d34 <sd_mmc_spi_test_unit_ready+0x68>
80005cf0:	c0 31       	brne	80005cf6 <sd_mmc_spi_test_unit_ready+0x2a>
80005cf2:	30 2c       	mov	r12,2
80005cf4:	d8 02       	popm	pc
      {
        sd_mmc_spi_presence_status = SD_MMC_INSERTED;
80005cf6:	30 19       	mov	r9,1
80005cf8:	48 d8       	lddpc	r8,80005d2c <sd_mmc_spi_test_unit_ready+0x60>
80005cfa:	b0 89       	st.b	r8[0x0],r9
80005cfc:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
80005cfe:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;

    case SD_MMC_INSERTED:
      if (!sd_mmc_spi_mem_check())
80005d00:	f0 1f 00 0d 	mcall	80005d34 <sd_mmc_spi_test_unit_ready+0x68>
80005d04:	c0 20       	breq	80005d08 <sd_mmc_spi_test_unit_ready+0x3c>
80005d06:	d8 0a       	popm	pc,r12=0
      {
        sd_mmc_spi_presence_status = SD_MMC_REMOVING;
80005d08:	30 29       	mov	r9,2
80005d0a:	48 98       	lddpc	r8,80005d2c <sd_mmc_spi_test_unit_ready+0x60>
80005d0c:	b0 89       	st.b	r8[0x0],r9
        sd_mmc_spi_init_done = false;
80005d0e:	30 09       	mov	r9,0
80005d10:	48 88       	lddpc	r8,80005d30 <sd_mmc_spi_test_unit_ready+0x64>
80005d12:	b0 89       	st.b	r8[0x0],r9
80005d14:	30 3c       	mov	r12,3
        Sd_mmc_spi_access_signal_off();
        return CTRL_BUSY;
80005d16:	d8 02       	popm	pc
      }
      Sd_mmc_spi_access_signal_off();
      return CTRL_GOOD;

    case SD_MMC_REMOVING:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
80005d18:	30 09       	mov	r9,0
80005d1a:	48 58       	lddpc	r8,80005d2c <sd_mmc_spi_test_unit_ready+0x60>
80005d1c:	b0 89       	st.b	r8[0x0],r9
80005d1e:	30 2c       	mov	r12,2
      Sd_mmc_spi_access_signal_off();
      return CTRL_NO_PRESENT;
80005d20:	d8 02       	popm	pc

    default:
      sd_mmc_spi_presence_status = SD_MMC_REMOVED;
80005d22:	30 09       	mov	r9,0
80005d24:	48 28       	lddpc	r8,80005d2c <sd_mmc_spi_test_unit_ready+0x60>
80005d26:	b0 89       	st.b	r8[0x0],r9
80005d28:	30 3c       	mov	r12,3
    }
    else
      return CTRL_NO_PRESENT;
  }
*/
}
80005d2a:	d8 02       	popm	pc
80005d2c:	00 00       	add	r0,r0
80005d2e:	00 08       	add	r8,r0
80005d30:	00 00       	add	r0,r0
80005d32:	05 80       	ld.ub	r0,r2[0x0]
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	2a e8       	sub	r8,-82

80005d38 <sd_mmc_spi_mem_init>:

//_____ D E C L A R A T I O N ______________________________________________


void sd_mmc_spi_mem_init(void)
{
80005d38:	d4 01       	pushm	lr
  sd_mmc_spi_internal_init();        // Restart Init of SD/MMC card after previous first init
80005d3a:	f0 1f 00 02 	mcall	80005d40 <sd_mmc_spi_mem_init+0x8>
}
80005d3e:	d8 02       	popm	pc
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	28 44       	sub	r4,-124

80005d44 <sd_mmc_spi_ram_2_mem>:
//! @return                Ctrl_status
//!   It is ready      ->    CTRL_GOOD
//!   An error occurs  ->    CTRL_FAIL
//!
Ctrl_status    sd_mmc_spi_ram_2_mem(uint32_t addr, const void *ram)
{
80005d44:	eb cd 40 c0 	pushm	r6-r7,lr
80005d48:	18 96       	mov	r6,r12
80005d4a:	16 97       	mov	r7,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
80005d4c:	f0 1f 00 12 	mcall	80005d94 <sd_mmc_spi_ram_2_mem+0x50>

   if (!sd_mmc_spi_init_done)
80005d50:	49 28       	lddpc	r8,80005d98 <sd_mmc_spi_ram_2_mem+0x54>
80005d52:	11 89       	ld.ub	r9,r8[0x0]
80005d54:	30 08       	mov	r8,0
80005d56:	f0 09 18 00 	cp.b	r9,r8
80005d5a:	c0 c1       	brne	80005d72 <sd_mmc_spi_ram_2_mem+0x2e>
   {
      sd_mmc_spi_mem_init();
80005d5c:	f0 1f 00 10 	mcall	80005d9c <sd_mmc_spi_ram_2_mem+0x58>
   }

   if (sd_mmc_spi_init_done)
80005d60:	48 e8       	lddpc	r8,80005d98 <sd_mmc_spi_ram_2_mem+0x54>
80005d62:	11 89       	ld.ub	r9,r8[0x0]
80005d64:	30 08       	mov	r8,0
80005d66:	f0 09 18 00 	cp.b	r9,r8
80005d6a:	c0 41       	brne	80005d72 <sd_mmc_spi_ram_2_mem+0x2e>
80005d6c:	30 2c       	mov	r12,2
80005d6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
   {
     sd_mmc_spi_write_open(addr);
80005d72:	0c 9c       	mov	r12,r6
80005d74:	f0 1f 00 0b 	mcall	80005da0 <sd_mmc_spi_ram_2_mem+0x5c>
     if (!sd_mmc_spi_write_sector_from_ram(ram))
80005d78:	0e 9c       	mov	r12,r7
80005d7a:	f0 1f 00 0b 	mcall	80005da4 <sd_mmc_spi_ram_2_mem+0x60>
80005d7e:	c0 61       	brne	80005d8a <sd_mmc_spi_ram_2_mem+0x46>
     {
       sd_mmc_spi_write_close();
80005d80:	f0 1f 00 0a 	mcall	80005da8 <sd_mmc_spi_ram_2_mem+0x64>
80005d84:	30 2c       	mov	r12,2
       Sd_mmc_spi_access_signal_off();
       return CTRL_NO_PRESENT;
80005d86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     }
     sd_mmc_spi_write_close();
80005d8a:	f0 1f 00 08 	mcall	80005da8 <sd_mmc_spi_ram_2_mem+0x64>
80005d8e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80005d92:	00 00       	add	r0,r0
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	22 f4       	sub	r4,47
80005d98:	00 00       	add	r0,r0
80005d9a:	05 80       	ld.ub	r0,r2[0x0]
80005d9c:	80 00       	ld.sh	r0,r0[0x0]
80005d9e:	5d 38       	musfr	r8
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	21 b0       	sub	r0,27
80005da4:	80 00       	ld.sh	r0,r0[0x0]
80005da6:	23 70       	sub	r0,55
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	21 20       	sub	r0,18

80005dac <sd_mmc_spi_mem_2_ram>:
//------------ Standard functions for read/write 1 sector to 1 sector ram buffer -----------------

#if ACCESS_MEM_TO_RAM == true

Ctrl_status sd_mmc_spi_mem_2_ram(uint32_t addr, void *ram)
{
80005dac:	eb cd 40 c0 	pushm	r6-r7,lr
80005db0:	18 97       	mov	r7,r12
80005db2:	16 96       	mov	r6,r11
   Sd_mmc_spi_access_signal_on();
   sd_mmc_spi_check_presence();
80005db4:	f0 1f 00 12 	mcall	80005dfc <sd_mmc_spi_mem_2_ram+0x50>

   if (!sd_mmc_spi_init_done)
80005db8:	49 28       	lddpc	r8,80005e00 <sd_mmc_spi_mem_2_ram+0x54>
80005dba:	11 89       	ld.ub	r9,r8[0x0]
80005dbc:	30 08       	mov	r8,0
80005dbe:	f0 09 18 00 	cp.b	r9,r8
80005dc2:	c0 c1       	brne	80005dda <sd_mmc_spi_mem_2_ram+0x2e>
   {
      sd_mmc_spi_mem_init();
80005dc4:	f0 1f 00 10 	mcall	80005e04 <sd_mmc_spi_mem_2_ram+0x58>
   }

   if (!sd_mmc_spi_init_done)
80005dc8:	48 e8       	lddpc	r8,80005e00 <sd_mmc_spi_mem_2_ram+0x54>
80005dca:	11 89       	ld.ub	r9,r8[0x0]
80005dcc:	30 08       	mov	r8,0
80005dce:	f0 09 18 00 	cp.b	r9,r8
80005dd2:	c0 41       	brne	80005dda <sd_mmc_spi_mem_2_ram+0x2e>
80005dd4:	30 2c       	mov	r12,2
80005dd6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
     return CTRL_NO_PRESENT;

   if( !sd_mmc_spi_read_open(addr) )
80005dda:	0e 9c       	mov	r12,r7
80005ddc:	f0 1f 00 0b 	mcall	80005e08 <sd_mmc_spi_mem_2_ram+0x5c>
80005de0:	c0 c0       	breq	80005df8 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_sector_to_ram(ram))
80005de2:	0c 9c       	mov	r12,r6
80005de4:	f0 1f 00 0a 	mcall	80005e0c <sd_mmc_spi_mem_2_ram+0x60>
80005de8:	c0 80       	breq	80005df8 <sd_mmc_spi_mem_2_ram+0x4c>
     goto sd_mmc_spi_mem_2_ram_fail;

   if( !sd_mmc_spi_read_close() )
80005dea:	f0 1f 00 0a 	mcall	80005e10 <sd_mmc_spi_mem_2_ram+0x64>
80005dee:	ec 1c 00 01 	eorl	r12,0x1
80005df2:	5c 5c       	castu.b	r12
80005df4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005df8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	22 f4       	sub	r4,47
80005e00:	00 00       	add	r0,r0
80005e02:	05 80       	ld.ub	r0,r2[0x0]
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	5d 38       	musfr	r8
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	21 d4       	sub	r4,29
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	26 00       	sub	r0,96
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	21 c8       	sub	r8,28

80005e14 <sd_mmc_spi_read_capacity>:
}



Ctrl_status sd_mmc_spi_read_capacity(uint32_t *nb_sector)
{
80005e14:	eb cd 40 80 	pushm	r7,lr
80005e18:	18 97       	mov	r7,r12
//   sd_mmc_spi_check_presence();   // omitted because creates interferences with "sd_mmc_spi_test_unit_ready()" function
   Sd_mmc_spi_access_signal_on();

   if (!sd_mmc_spi_init_done)
80005e1a:	48 c8       	lddpc	r8,80005e48 <sd_mmc_spi_read_capacity+0x34>
80005e1c:	11 89       	ld.ub	r9,r8[0x0]
80005e1e:	30 08       	mov	r8,0
80005e20:	f0 09 18 00 	cp.b	r9,r8
80005e24:	c0 c1       	brne	80005e3c <sd_mmc_spi_read_capacity+0x28>
   {
      sd_mmc_spi_mem_init();
80005e26:	f0 1f 00 0a 	mcall	80005e4c <sd_mmc_spi_read_capacity+0x38>
   }

   if (sd_mmc_spi_init_done)
80005e2a:	48 88       	lddpc	r8,80005e48 <sd_mmc_spi_read_capacity+0x34>
80005e2c:	11 89       	ld.ub	r9,r8[0x0]
80005e2e:	30 08       	mov	r8,0
80005e30:	f0 09 18 00 	cp.b	r9,r8
80005e34:	c0 41       	brne	80005e3c <sd_mmc_spi_read_capacity+0x28>
80005e36:	30 2c       	mov	r12,2
80005e38:	e3 cd 80 80 	ldm	sp++,r7,pc
   {
     *nb_sector = sd_mmc_spi_last_block_address+1;
80005e3c:	48 58       	lddpc	r8,80005e50 <sd_mmc_spi_read_capacity+0x3c>
80005e3e:	70 08       	ld.w	r8,r8[0x0]
80005e40:	2f f8       	sub	r8,-1
80005e42:	8f 08       	st.w	r7[0x0],r8
80005e44:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80005e48:	00 00       	add	r0,r0
80005e4a:	05 80       	ld.ub	r0,r2[0x0]
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	5d 38       	musfr	r8
80005e50:	00 00       	add	r0,r0
80005e52:	09 d4       	ld.ub	r4,r4[0x5]

80005e54 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005e54:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005e58:	49 70       	lddpc	r0,80005eb4 <udata_clear_loop_end+0x2>
80005e5a:	e3 b0 00 01 	mtsr	0x4,r0

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET

  // Call the startup customization function.
  call    _init_startup
80005e5e:	d5 53       	csrf	0x15
80005e60:	e0 a0 7c 4e 	rcall	800156fc <_init_startup>

  // Load initialized external SDRAM data having a global lifetime from the
  // data_sdram LMA.
  lda.w   r0, _data_sdram
  lda.w   r1, _edata_sdram
80005e64:	49 50       	lddpc	r0,80005eb8 <udata_clear_loop_end+0x6>
  cp      r0, r1
80005e66:	49 61       	lddpc	r1,80005ebc <udata_clear_loop_end+0xa>
  brhs    idata_sdram_load_loop_end
80005e68:	02 30       	cp.w	r0,r1
  lda.w   r2, _data_sdram_lma
80005e6a:	c0 62       	brcc	80005e76 <idata_sdram_load_loop_end>
idata_sdram_load_loop:
  ld.d    r4, r2++
80005e6c:	49 52       	lddpc	r2,80005ec0 <udata_clear_loop_end+0xe>

80005e6e <idata_sdram_load_loop>:
  st.d    r0++, r4
80005e6e:	a5 05       	ld.d	r4,r2++
  cp      r0, r1
80005e70:	a1 24       	st.d	r0++,r4
  brlo    idata_sdram_load_loop
80005e72:	02 30       	cp.w	r0,r1
idata_sdram_load_loop_end:

  // Clear uninitialized external SDRAM data having a global lifetime in the
  // blank static storage section.
  lda.w   r0, __bss_sdram_start
80005e74:	cf d3       	brcs	80005e6e <idata_sdram_load_loop>

80005e76 <idata_sdram_load_loop_end>:
  lda.w   r1, _bss_sdram_end
80005e76:	49 40       	lddpc	r0,80005ec4 <udata_clear_loop_end+0x12>
  cp      r0, r1
80005e78:	49 41       	lddpc	r1,80005ec8 <udata_clear_loop_end+0x16>
  brhs    udata_sdram_clear_loop_end
80005e7a:	02 30       	cp.w	r0,r1
  mov     r2, 0
80005e7c:	c0 62       	brcc	80005e88 <udata_sdram_clear_loop_end>
  mov     r3, 0
80005e7e:	30 02       	mov	r2,0
udata_sdram_clear_loop:
  st.d    r0++, r2
80005e80:	30 03       	mov	r3,0

80005e82 <udata_sdram_clear_loop>:
  cp      r0, r1
80005e82:	a1 22       	st.d	r0++,r2
  brlo    udata_sdram_clear_loop
80005e84:	02 30       	cp.w	r0,r1
udata_sdram_clear_loop_end:

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
80005e86:	cf e3       	brcs	80005e82 <udata_sdram_clear_loop>

80005e88 <udata_sdram_clear_loop_end>:
  lda.w   r1, _edata
80005e88:	30 80       	mov	r0,8
  cp      r0, r1
80005e8a:	e0 61 05 68 	mov	r1,1384
  brhs    idata_load_loop_end
  lda.w   r2, _data_lma
80005e8e:	02 30       	cp.w	r0,r1
idata_load_loop:
  ld.d    r4, r2++
80005e90:	c0 62       	brcc	80005e9c <idata_load_loop_end>
  st.d    r0++, r4
80005e92:	48 f2       	lddpc	r2,80005ecc <udata_clear_loop_end+0x1a>

80005e94 <idata_load_loop>:
  cp      r0, r1
80005e94:	a5 05       	ld.d	r4,r2++
  brlo    idata_load_loop
80005e96:	a1 24       	st.d	r0++,r4
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005e98:	02 30       	cp.w	r0,r1
  lda.w   r1, _end
80005e9a:	cf d3       	brcs	80005e94 <idata_load_loop>

80005e9c <idata_load_loop_end>:
  cp      r0, r1
80005e9c:	e0 60 05 68 	mov	r0,1384
  brhs    udata_clear_loop_end
  mov     r2, 0
80005ea0:	e0 61 0e 40 	mov	r1,3648
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80005ea4:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005ea6:	c0 62       	brcc	80005eb2 <udata_clear_loop_end>
  brlo    udata_clear_loop
80005ea8:	30 02       	mov	r2,0
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005eaa:	30 03       	mov	r3,0

80005eac <udata_clear_loop>:
80005eac:	a1 22       	st.d	r0++,r2
80005eae:	02 30       	cp.w	r0,r1
80005eb0:	cf e3       	brcs	80005eac <udata_clear_loop>

80005eb2 <udata_clear_loop_end>:
80005eb2:	48 8f       	lddpc	pc,80005ed0 <udata_clear_loop_end+0x1e>
80005eb4:	80 01       	ld.sh	r1,r0[0x0]
80005eb6:	da 00       	acall	0xa0
80005eb8:	d0 00       	acall	0x0
80005eba:	00 00       	add	r0,r0
80005ebc:	d0 00       	acall	0x0
80005ebe:	00 00       	add	r0,r0
80005ec0:	80 02       	ld.sh	r2,r0[0x0]
80005ec2:	0b c8       	ld.ub	r8,r5[0x4]
80005ec4:	d0 00       	acall	0x0
80005ec6:	00 00       	add	r0,r0
80005ec8:	d0 00       	acall	0x0
80005eca:	00 00       	add	r0,r0
80005ecc:	80 02       	ld.sh	r2,r0[0x0]
80005ece:	06 68       	and	r8,r3
80005ed0:	80 01       	ld.sh	r1,r0[0x0]
80005ed2:	43 e0       	lddsp	r0,sp[0xf8]

80005ed4 <LED_On>:
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80005ed4:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);
80005ed8:	49 18       	lddpc	r8,80005f1c <LED_On+0x48>
80005eda:	70 09       	ld.w	r9,r8[0x0]
80005edc:	f9 e9 10 09 	or	r9,r12,r9
80005ee0:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80005ee2:	58 0c       	cp.w	r12,0
80005ee4:	5e 0c       	reteq	r12
80005ee6:	48 f8       	lddpc	r8,80005f20 <LED_On+0x4c>
80005ee8:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it on.
    led_shift = 1 + ctz(leds);
80005eea:	18 9a       	mov	r10,r12
80005eec:	5c 9a       	brev	r10
80005eee:	f4 0a 12 00 	clz	r10,r10
80005ef2:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80005ef4:	f4 09 15 04 	lsl	r9,r10,0x4
80005ef8:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80005efa:	70 09       	ld.w	r9,r8[0x0]
80005efc:	a9 69       	lsl	r9,0x8
80005efe:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrc  = led_descriptor->GPIO.PIN_MASK;
80005f02:	70 1b       	ld.w	r11,r8[0x4]
80005f04:	f3 4b 00 58 	st.w	r9[88],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80005f08:	70 1b       	ld.w	r11,r8[0x4]
80005f0a:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80005f0e:	70 1b       	ld.w	r11,r8[0x4]
80005f10:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80005f12:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Set_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80005f16:	ce a1       	brne	80005eea <LED_On+0x16>
80005f18:	5e fc       	retal	r12
80005f1a:	00 00       	add	r0,r0
80005f1c:	00 00       	add	r0,r0
80005f1e:	00 0c       	add	r12,r0
80005f20:	80 01       	ld.sh	r1,r0[0x0]
80005f22:	dc 50       	acall	0xc5

80005f24 <LED_Off>:
  tLED_DESCRIPTOR *led_descriptor = &LED_DESCRIPTOR[0] - 1;
  volatile avr32_gpio_port_t *led_gpio_port;
  uint8_t led_shift;

  // Make sure only existing LEDs are specified.
  leds &= (1 << LED_COUNT) - 1;
80005f24:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);
80005f28:	49 28       	lddpc	r8,80005f70 <LED_Off+0x4c>
80005f2a:	70 09       	ld.w	r9,r8[0x0]
80005f2c:	f8 0a 11 ff 	rsub	r10,r12,-1
80005f30:	f5 e9 00 09 	and	r9,r10,r9
80005f34:	91 09       	st.w	r8[0x0],r9

  // While there are specified LEDs left to manage...
  while (leds)
80005f36:	58 0c       	cp.w	r12,0
80005f38:	5e 0c       	reteq	r12
80005f3a:	48 f8       	lddpc	r8,80005f74 <LED_Off+0x50>
80005f3c:	21 08       	sub	r8,16
  {
    // Select the next specified LED and turn it off.
    led_shift = 1 + ctz(leds);
80005f3e:	18 9a       	mov	r10,r12
80005f40:	5c 9a       	brev	r10
80005f42:	f4 0a 12 00 	clz	r10,r10
80005f46:	2f fa       	sub	r10,-1
    led_descriptor += led_shift;
80005f48:	f4 09 15 04 	lsl	r9,r10,0x4
80005f4c:	12 08       	add	r8,r9
    led_gpio_port = &AVR32_GPIO.port[led_descriptor->GPIO.PORT];
80005f4e:	70 09       	ld.w	r9,r8[0x0]
80005f50:	a9 69       	lsl	r9,0x8
80005f52:	e0 29 f0 00 	sub	r9,61440
    led_gpio_port->ovrs  = led_descriptor->GPIO.PIN_MASK;
80005f56:	70 1b       	ld.w	r11,r8[0x4]
80005f58:	f3 4b 00 54 	st.w	r9[84],r11
    led_gpio_port->oders = led_descriptor->GPIO.PIN_MASK;
80005f5c:	70 1b       	ld.w	r11,r8[0x4]
80005f5e:	f3 4b 00 44 	st.w	r9[68],r11
    led_gpio_port->gpers = led_descriptor->GPIO.PIN_MASK;
80005f62:	70 1b       	ld.w	r11,r8[0x4]
80005f64:	93 1b       	st.w	r9[0x4],r11
    leds >>= led_shift;
80005f66:	f8 0a 0a 4c 	lsr	r12,r12,r10

  // Update the saved state of all LEDs with the requested changes.
  Clr_bits(LED_State, leds);

  // While there are specified LEDs left to manage...
  while (leds)
80005f6a:	ce a1       	brne	80005f3e <LED_Off+0x1a>
80005f6c:	5e fc       	retal	r12
80005f6e:	00 00       	add	r0,r0
80005f70:	00 00       	add	r0,r0
80005f72:	00 0c       	add	r12,r0
80005f74:	80 01       	ld.sh	r1,r0[0x0]
80005f76:	dc 50       	acall	0xc5

80005f78 <et024006_SetLimits>:
/*! \brief Sets the display limits according to the corner coordinates.
 *  Writing to the display will result in writing to the area specified through
 *  this function.
 */
void et024006_SetLimits( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2 )
{
80005f78:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005f7c:	fc 1e c0 00 	movh	lr,0xc000
80005f80:	30 28       	mov	r8,2
80005f82:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005f84:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
80005f88:	fc 18 c0 20 	movh	r8,0xc020
80005f8c:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005f8e:	30 37       	mov	r7,3
80005f90:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005f92:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005f94:	30 4c       	mov	r12,4
80005f96:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005f98:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
80005f9c:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005f9e:	30 5c       	mov	r12,5
80005fa0:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fa2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fa4:	30 6a       	mov	r10,6
80005fa6:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fa8:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80005fac:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fae:	30 7a       	mov	r10,7
80005fb0:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fb2:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fb4:	30 8a       	mov	r10,8
80005fb6:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fb8:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
80005fbc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fbe:	30 9a       	mov	r10,9
80005fc0:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fc2:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80005fc4:	e3 cd 80 80 	ldm	sp++,r7,pc

80005fc8 <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fc8:	fc 19 c0 00 	movh	r9,0xc000
80005fcc:	30 28       	mov	r8,2
80005fce:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fd0:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
80005fd4:	fc 18 c0 20 	movh	r8,0xc020
80005fd8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fda:	30 3a       	mov	r10,3
80005fdc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fde:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fe0:	30 6a       	mov	r10,6
80005fe2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fe4:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
80005fe8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80005fea:	30 7a       	mov	r10,7
80005fec:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80005fee:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
80005ff0:	5e fc       	retal	r12
80005ff2:	d7 03       	nop

80005ff4 <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80005ff4:	eb cd 40 80 	pushm	r7,lr
80005ff8:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
80005ffa:	5c 7b       	castu.h	r11
80005ffc:	5c 7c       	castu.h	r12
80005ffe:	f0 1f 00 06 	mcall	80006014 <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006002:	32 29       	mov	r9,34
80006004:	fc 18 c0 00 	movh	r8,0xc000
80006008:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
8000600a:	fc 18 c0 20 	movh	r8,0xc020
8000600e:	b0 07       	st.h	r8[0x0],r7
#endif

}
80006010:	e3 cd 80 80 	ldm	sp++,r7,pc
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	5f c8       	srvs	r8

80006018 <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
80006018:	d4 31       	pushm	r0-r7,lr
8000601a:	20 dd       	sub	sp,52
8000601c:	18 97       	mov	r7,r12
8000601e:	50 6b       	stdsp	sp[0x18],r11
80006020:	50 8a       	stdsp	sp[0x20],r10
80006022:	50 29       	stdsp	sp[0x8],r9
80006024:	10 94       	mov	r4,r8
80006026:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
80006028:	19 89       	ld.ub	r9,r12[0x0]
8000602a:	30 08       	mov	r8,0
8000602c:	f0 09 18 00 	cp.b	r9,r8
80006030:	e0 80 01 0c 	breq	80006248 <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
80006034:	16 98       	mov	r8,r11
80006036:	11 3a       	ld.ub	r10,r8++
80006038:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
8000603a:	11 89       	ld.ub	r9,r8[0x0]
8000603c:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
8000603e:	11 98       	ld.ub	r8,r8[0x1]
80006040:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
80006042:	5b f3       	cp.w	r3,-1
80006044:	e0 81 00 8d 	brne	8000615e <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
80006048:	e0 69 00 ef 	mov	r9,239
8000604c:	e0 6a 01 3f 	mov	r10,319
80006050:	30 0b       	mov	r11,0
80006052:	16 9c       	mov	r12,r11
80006054:	f0 1f 00 7e 	mcall	8000624c <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
80006058:	40 58       	lddsp	r8,sp[0x14]
8000605a:	50 c8       	stdsp	sp[0x30],r8
8000605c:	f0 08 00 18 	add	r8,r8,r8<<0x1
80006060:	a5 78       	lsl	r8,0x5
80006062:	40 69       	lddsp	r9,sp[0x18]
80006064:	10 09       	add	r9,r8
80006066:	50 b9       	stdsp	sp[0x2c],r9
80006068:	ee c8 ff ff 	sub	r8,r7,-1
8000606c:	50 98       	stdsp	sp[0x24],r8
8000606e:	40 8a       	lddsp	r10,sp[0x20]
80006070:	5c 8a       	casts.h	r10
80006072:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80006074:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
80006076:	08 90       	mov	r0,r4
80006078:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
8000607a:	40 99       	lddsp	r9,sp[0x24]
8000607c:	f3 38 ff ff 	ld.ub	r8,r9[-1]
80006080:	30 aa       	mov	r10,10
80006082:	f4 08 18 00 	cp.b	r8,r10
80006086:	c0 b1       	brne	8000609c <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
80006088:	40 28       	lddsp	r8,sp[0x8]
8000608a:	40 39       	lddsp	r9,sp[0xc]
8000608c:	12 08       	add	r8,r9
8000608e:	5c 88       	casts.h	r8
80006090:	50 28       	stdsp	sp[0x8],r8
80006092:	40 98       	lddsp	r8,sp[0x24]
80006094:	40 8a       	lddsp	r10,sp[0x20]
80006096:	5c 8a       	casts.h	r10
80006098:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
8000609a:	c5 a8       	rjmp	8000614e <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
8000609c:	30 99       	mov	r9,9
8000609e:	f2 08 18 00 	cp.b	r8,r9
800060a2:	c0 81       	brne	800060b2 <et024006_PrintString+0x9a>
        x += xfont;
800060a4:	40 a8       	lddsp	r8,sp[0x28]
800060a6:	40 49       	lddsp	r9,sp[0x10]
800060a8:	12 08       	add	r8,r9
800060aa:	5c 88       	casts.h	r8
800060ac:	50 a8       	stdsp	sp[0x28],r8
800060ae:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
800060b0:	c4 f8       	rjmp	8000614e <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
800060b2:	f0 ca 00 20 	sub	r10,r8,32
800060b6:	35 f9       	mov	r9,95
800060b8:	f2 0a 18 00 	cp.b	r10,r9
800060bc:	e0 88 00 04 	brls	800060c4 <et024006_PrintString+0xac>
800060c0:	40 b5       	lddsp	r5,sp[0x2c]
800060c2:	c0 a8       	rjmp	800060d6 <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
800060c4:	22 08       	sub	r8,32
800060c6:	40 ca       	lddsp	r10,sp[0x30]
800060c8:	f0 0a 02 45 	mul	r5,r8,r10
800060cc:	40 59       	lddsp	r9,sp[0x14]
800060ce:	12 05       	add	r5,r9
800060d0:	40 68       	lddsp	r8,sp[0x18]
800060d2:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800060d6:	40 22       	lddsp	r2,sp[0x8]
800060d8:	5c 72       	castu.h	r2
800060da:	40 3a       	lddsp	r10,sp[0xc]
800060dc:	e4 0a 00 0a 	add	r10,r2,r10
800060e0:	50 1a       	stdsp	sp[0x4],r10
800060e2:	04 3a       	cp.w	r10,r2
800060e4:	e0 8a 00 2f 	brle	80006142 <et024006_PrintString+0x12a>
800060e8:	40 21       	lddsp	r1,sp[0x8]
800060ea:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800060ec:	40 a9       	lddsp	r9,sp[0x28]
800060ee:	5c 79       	castu.h	r9
800060f0:	50 09       	stdsp	sp[0x0],r9
800060f2:	12 94       	mov	r4,r9
800060f4:	40 48       	lddsp	r8,sp[0x10]
800060f6:	10 04       	add	r4,r8
800060f8:	40 aa       	lddsp	r10,sp[0x28]
800060fa:	5c 8a       	casts.h	r10
800060fc:	50 7a       	stdsp	sp[0x1c],r10
800060fe:	c1 b8       	rjmp	80006134 <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
80006100:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
80006102:	0b 88       	ld.ub	r8,r5[0x0]
80006104:	ed e8 00 08 	and	r8,r6,r8
80006108:	e6 08 18 00 	cp.b	r8,r3
8000610c:	c0 50       	breq	80006116 <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
8000610e:	00 9a       	mov	r10,r0
80006110:	04 9b       	mov	r11,r2
80006112:	f0 1f 00 50 	mcall	80006250 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80006116:	2f f7       	sub	r7,-1
80006118:	5c 87       	casts.h	r7
8000611a:	0e 9c       	mov	r12,r7
8000611c:	5c 7c       	castu.h	r12
8000611e:	08 3c       	cp.w	r12,r4
80006120:	cf 05       	brlt	80006100 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
80006122:	2f f1       	sub	r1,-1
80006124:	5c 81       	casts.h	r1
80006126:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
8000612a:	40 19       	lddsp	r9,sp[0x4]
8000612c:	04 39       	cp.w	r9,r2
8000612e:	e0 8a 00 0a 	brle	80006142 <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
80006132:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
80006134:	40 0c       	lddsp	r12,sp[0x0]
80006136:	08 3c       	cp.w	r12,r4
80006138:	cf 54       	brge	80006122 <et024006_PrintString+0x10a>
8000613a:	40 77       	lddsp	r7,sp[0x1c]
8000613c:	e0 66 00 80 	mov	r6,128
80006140:	ce 1b       	rjmp	80006102 <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
80006142:	40 a8       	lddsp	r8,sp[0x28]
80006144:	40 4a       	lddsp	r10,sp[0x10]
80006146:	14 08       	add	r8,r10
80006148:	5c 88       	casts.h	r8
8000614a:	50 a8       	stdsp	sp[0x28],r8
8000614c:	40 98       	lddsp	r8,sp[0x24]
8000614e:	40 99       	lddsp	r9,sp[0x24]
80006150:	2f f9       	sub	r9,-1
80006152:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
80006154:	11 88       	ld.ub	r8,r8[0x0]
80006156:	e6 08 18 00 	cp.b	r8,r3
8000615a:	c9 01       	brne	8000607a <et024006_PrintString+0x62>
8000615c:	c7 68       	rjmp	80006248 <et024006_PrintString+0x230>
8000615e:	f8 c8 ff ff 	sub	r8,r12,-1
80006162:	50 08       	stdsp	sp[0x0],r8
80006164:	40 8c       	lddsp	r12,sp[0x20]
80006166:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80006168:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
8000616a:	5c 83       	casts.h	r3
8000616c:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
80006170:	40 0a       	lddsp	r10,sp[0x0]
80006172:	f5 31 ff ff 	ld.ub	r1,r10[-1]
80006176:	30 a8       	mov	r8,10
80006178:	f0 01 18 00 	cp.b	r1,r8
8000617c:	c0 b1       	brne	80006192 <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
8000617e:	40 28       	lddsp	r8,sp[0x8]
80006180:	40 39       	lddsp	r9,sp[0xc]
80006182:	12 08       	add	r8,r9
80006184:	5c 88       	casts.h	r8
80006186:	50 28       	stdsp	sp[0x8],r8
80006188:	14 98       	mov	r8,r10
8000618a:	40 8a       	lddsp	r10,sp[0x20]
8000618c:	5c 8a       	casts.h	r10
8000618e:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80006190:	c5 28       	rjmp	80006234 <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
80006192:	30 98       	mov	r8,9
80006194:	f0 01 18 00 	cp.b	r1,r8
80006198:	c0 71       	brne	800061a6 <et024006_PrintString+0x18e>
        x += xfont;
8000619a:	40 49       	lddsp	r9,sp[0x10]
8000619c:	12 0c       	add	r12,r9
8000619e:	5c 8c       	casts.h	r12
800061a0:	50 1c       	stdsp	sp[0x4],r12
800061a2:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
800061a4:	c4 88       	rjmp	80006234 <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
800061a6:	40 32       	lddsp	r2,sp[0xc]
800061a8:	40 47       	lddsp	r7,sp[0x10]
800061aa:	f8 07 00 08 	add	r8,r12,r7
800061ae:	5c 88       	casts.h	r8
800061b0:	50 18       	stdsp	sp[0x4],r8
800061b2:	04 99       	mov	r9,r2
800061b4:	20 19       	sub	r9,1
800061b6:	40 28       	lddsp	r8,sp[0x8]
800061b8:	10 09       	add	r9,r8
800061ba:	40 1a       	lddsp	r10,sp[0x4]
800061bc:	20 1a       	sub	r10,1
800061be:	5c 79       	castu.h	r9
800061c0:	5c 7a       	castu.h	r10
800061c2:	10 9b       	mov	r11,r8
800061c4:	5c 7b       	castu.h	r11
800061c6:	5c 7c       	castu.h	r12
800061c8:	f0 1f 00 21 	mcall	8000624c <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800061cc:	32 29       	mov	r9,34
800061ce:	fc 18 c0 00 	movh	r8,0xc000
800061d2:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800061d4:	40 3a       	lddsp	r10,sp[0xc]
800061d6:	58 0a       	cp.w	r10,0
800061d8:	c2 d0       	breq	80006232 <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
800061da:	e2 ce 00 20 	sub	lr,r1,32
800061de:	40 59       	lddsp	r9,sp[0x14]
800061e0:	f2 0e 02 4e 	mul	lr,r9,lr
800061e4:	12 0e       	add	lr,r9
800061e6:	40 68       	lddsp	r8,sp[0x18]
800061e8:	f0 0e 00 0e 	add	lr,r8,lr
800061ec:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800061ee:	e0 60 00 80 	mov	r0,128
800061f2:	18 91       	mov	r1,r12
800061f4:	c1 98       	rjmp	80006226 <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
800061f6:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800061f8:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
800061fc:	ec 0a 18 00 	cp.b	r10,r6
80006200:	e8 0a 17 10 	movne	r10,r4
80006204:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80006208:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
8000620c:	2f f8       	sub	r8,-1
8000620e:	5c 88       	casts.h	r8
80006210:	f0 07 19 00 	cp.h	r7,r8
80006214:	fe 9b ff f1 	brhi	800061f6 <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
80006218:	2f fc       	sub	r12,-1
8000621a:	5c 8c       	casts.h	r12
8000621c:	f8 02 19 00 	cp.h	r2,r12
80006220:	e0 88 00 09 	brls	80006232 <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
80006224:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
80006226:	58 07       	cp.w	r7,0
80006228:	cf 80       	breq	80006218 <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
8000622a:	1d 8b       	ld.ub	r11,lr[0x0]
8000622c:	00 99       	mov	r9,r0
8000622e:	02 98       	mov	r8,r1
80006230:	ce 4b       	rjmp	800061f8 <et024006_PrintString+0x1e0>
80006232:	40 08       	lddsp	r8,sp[0x0]
80006234:	40 09       	lddsp	r9,sp[0x0]
80006236:	2f f9       	sub	r9,-1
80006238:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
8000623a:	11 88       	ld.ub	r8,r8[0x0]
8000623c:	ec 08 18 00 	cp.b	r8,r6
80006240:	c0 40       	breq	80006248 <et024006_PrintString+0x230>
80006242:	40 1c       	lddsp	r12,sp[0x4]
80006244:	5c 8c       	casts.h	r12
80006246:	c9 5b       	rjmp	80006170 <et024006_PrintString+0x158>
  }
}
80006248:	2f 3d       	sub	sp,-52
8000624a:	d8 32       	popm	r0-r7,pc
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	5f 78       	srpl	r8
80006250:	80 00       	ld.sh	r0,r0[0x0]
80006252:	5f f4       	sral	r4

80006254 <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006254:	32 29       	mov	r9,34
80006256:	fc 18 c0 00 	movh	r8,0xc000
8000625a:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000625c:	58 7b       	cp.w	r11,7
8000625e:	e0 88 00 13 	brls	80006284 <et024006_DuplicatePixel+0x30>
80006262:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
80006264:	fc 18 c0 20 	movh	r8,0xc020
80006268:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000626a:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000626c:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000626e:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80006270:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80006272:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80006274:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80006276:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
80006278:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000627a:	58 79       	cp.w	r9,7
8000627c:	fe 9b ff f6 	brhi	80006268 <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
80006280:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80006284:	58 0b       	cp.w	r11,0
80006286:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
80006288:	fc 18 c0 20 	movh	r8,0xc020
8000628c:	b0 0c       	st.h	r8[0x0],r12
    --count;
8000628e:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80006290:	cf e1       	brne	8000628c <et024006_DuplicatePixel+0x38>
80006292:	5e fc       	retal	r12

80006294 <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
80006294:	eb cd 40 e0 	pushm	r5-r7,lr
80006298:	14 97       	mov	r7,r10
8000629a:	12 96       	mov	r6,r9
8000629c:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
8000629e:	f6 c9 00 01 	sub	r9,r11,1
800062a2:	0c 09       	add	r9,r6
800062a4:	f8 ca 00 01 	sub	r10,r12,1
800062a8:	0e 0a       	add	r10,r7
800062aa:	5c 79       	castu.h	r9
800062ac:	5c 7a       	castu.h	r10
800062ae:	5c 7b       	castu.h	r11
800062b0:	5c 7c       	castu.h	r12
800062b2:	f0 1f 00 07 	mcall	800062cc <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
800062b6:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
800062ba:	5c 77       	castu.h	r7
800062bc:	af 3b       	mul	r11,r7
800062be:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
800062c2:	f0 1f 00 04 	mcall	800062d0 <et024006_DrawFilledRect+0x3c>
}
800062c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800062ca:	00 00       	add	r0,r0
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	5f 78       	srpl	r8
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	62 54       	ld.w	r4,r1[0x14]

800062d4 <et024006_CopyPixelsToScreen>:
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
{
800062d4:	eb cd 40 80 	pushm	r7,lr
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800062d8:	32 29       	mov	r9,34
800062da:	fc 18 c0 00 	movh	r8,0xc000
800062de:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
800062e0:	58 7b       	cp.w	r11,7
800062e2:	e0 88 00 23 	brls	80006328 <et024006_CopyPixelsToScreen+0x54>
800062e6:	16 9a       	mov	r10,r11
800062e8:	18 98       	mov	r8,r12
  {
    *ET024006_PARAM_ADDR = *pixels++;
800062ea:	fc 19 c0 20 	movh	r9,0xc020
800062ee:	90 0e       	ld.sh	lr,r8[0x0]
800062f0:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800062f2:	90 1e       	ld.sh	lr,r8[0x2]
800062f4:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800062f6:	90 2e       	ld.sh	lr,r8[0x4]
800062f8:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800062fa:	90 3e       	ld.sh	lr,r8[0x6]
800062fc:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
800062fe:	90 4e       	ld.sh	lr,r8[0x8]
80006300:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80006302:	90 5e       	ld.sh	lr,r8[0xa]
80006304:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
80006306:	90 6e       	ld.sh	lr,r8[0xc]
80006308:	b2 0e       	st.h	r9[0x0],lr
    *ET024006_PARAM_ADDR = *pixels++;
8000630a:	90 7e       	ld.sh	lr,r8[0xe]
8000630c:	b2 0e       	st.h	r9[0x0],lr
    }
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
8000630e:	2f 08       	sub	r8,-16
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
80006310:	20 8a       	sub	r10,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  while (count >= 8)
80006312:	58 7a       	cp.w	r10,7
80006314:	fe 9b ff ed 	brhi	800062ee <et024006_CopyPixelsToScreen+0x1a>
    }
  }
}


void et024006_CopyPixelsToScreen( et024006_color_t const * pixels, uint32_t count )
80006318:	20 8b       	sub	r11,8
8000631a:	f6 08 16 03 	lsr	r8,r11,0x3
8000631e:	2f f8       	sub	r8,-1
80006320:	a5 68       	lsl	r8,0x4
80006322:	10 0c       	add	r12,r8
80006324:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80006328:	58 0b       	cp.w	r11,0
8000632a:	c0 70       	breq	80006338 <et024006_CopyPixelsToScreen+0x64>
  {
    *ET024006_PARAM_ADDR = *pixels;
8000632c:	fc 18 c0 20 	movh	r8,0xc020
80006330:	19 19       	ld.sh	r9,r12++
80006332:	b0 09       	st.h	r8[0x0],r9
    pixels++;
    count--;
80006334:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    *ET024006_PARAM_ADDR = *pixels++;
    count-=8;
  }
  while( count )
80006336:	cf d1       	brne	80006330 <et024006_CopyPixelsToScreen+0x5c>
80006338:	e3 cd 80 80 	ldm	sp++,r7,pc

8000633c <et024006_PutPixmap>:
  uint16_t map_y,
  uint16_t x,
  uint16_t y,
  uint16_t width,
  uint16_t height )
{
8000633c:	eb cd 40 fe 	pushm	r1-r7,lr
80006340:	fa c4 ff e0 	sub	r4,sp,-32
80006344:	18 97       	mov	r7,r12
80006346:	16 95       	mov	r5,r11
80006348:	14 92       	mov	r2,r10
8000634a:	12 91       	mov	r1,r9
8000634c:	68 0b       	ld.w	r11,r4[0x0]
8000634e:	68 13       	ld.w	r3,r4[0x4]
80006350:	68 26       	ld.w	r6,r4[0x8]
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area.
  et024006_SetLimits( x, y, x2, y2 );
80006352:	f6 c9 00 01 	sub	r9,r11,1
80006356:	0c 09       	add	r9,r6
80006358:	f0 ca 00 01 	sub	r10,r8,1
8000635c:	06 0a       	add	r10,r3
8000635e:	5c 79       	castu.h	r9
80006360:	5c 7a       	castu.h	r10
80006362:	5c 7b       	castu.h	r11
80006364:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
80006368:	f0 1f 00 1d 	mcall	800063dc <et024006_PutPixmap+0xa0>

  // Offset into pixmap.
  pixmap += map_x;
8000636c:	f1 d2 c0 10 	bfextu	r8,r2,0x0,0x10
80006370:	ee 08 00 17 	add	r7,r7,r8<<0x1
  if (map_y > 0) {
80006374:	58 01       	cp.w	r1,0
80006376:	c0 70       	breq	80006384 <et024006_PutPixmap+0x48>
    pixmap += (uint32_t) map_y * map_width;
80006378:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000637c:	a1 78       	lsl	r8,0x1
8000637e:	5c 71       	castu.h	r1
80006380:	f0 01 03 47 	mac	r7,r8,r1
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006384:	32 29       	mov	r9,34
80006386:	fc 18 c0 00 	movh	r8,0xc000
8000638a:	b0 09       	st.h	r8[0x0],r9
  }
  // we need access to the display SRAM now
  et024006_SelectRegister( HIMAX_SRAMWRITE );

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
8000638c:	e6 05 19 00 	cp.h	r5,r3
80006390:	5f 0a       	sreq	r10
80006392:	30 08       	mov	r8,0
80006394:	f0 02 19 00 	cp.h	r2,r8
80006398:	5f 09       	sreq	r9
8000639a:	f5 e9 00 09 	and	r9,r10,r9
8000639e:	f0 09 18 00 	cp.b	r9,r8
800063a2:	c0 51       	brne	800063ac <et024006_PutPixmap+0x70>
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
800063a4:	58 06       	cp.w	r6,0
800063a6:	c0 c1       	brne	800063be <et024006_PutPixmap+0x82>
800063a8:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

  // In case of no horizontal pixmap clipping, easier handling is possible.
  if ((map_width == width) && (map_x == 0)) {
    // Compute pixel count and copy pixels to screen.
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
800063ac:	5c 76       	castu.h	r6
800063ae:	5c 73       	castu.h	r3
800063b0:	ec 03 02 4b 	mul	r11,r6,r3
800063b4:	0e 9c       	mov	r12,r7
800063b6:	f0 1f 00 0b 	mcall	800063e0 <et024006_PutPixmap+0xa4>
800063ba:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
      pixmap += map_width;
800063be:	5c 75       	castu.h	r5
800063c0:	a1 75       	lsl	r5,0x1
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
      et024006_CopyPixelsToScreen( pixmap, width );
800063c2:	e9 d3 c0 10 	bfextu	r4,r3,0x0,0x10
800063c6:	08 9b       	mov	r11,r4
800063c8:	0e 9c       	mov	r12,r7
800063ca:	f0 1f 00 06 	mcall	800063e0 <et024006_PutPixmap+0xa4>
      pixmap += map_width;
800063ce:	0a 07       	add	r7,r5
      --lines_left;
800063d0:	20 16       	sub	r6,1
800063d2:	5c 86       	casts.h	r6
    uint32_t count = (uint32_t) width * height;
    et024006_CopyPixelsToScreen( pixmap, count );
  } else {
    // Copy line by line to screen.
    uint16_t lines_left = height;
    while (lines_left > 0) {
800063d4:	cf 91       	brne	800063c6 <et024006_PutPixmap+0x8a>
800063d6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800063da:	00 00       	add	r0,r0
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	5f 78       	srpl	r8
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	62 d4       	ld.w	r4,r1[0x34]

800063e4 <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800063e4:	fc 19 c0 00 	movh	r9,0xc000
800063e8:	34 6a       	mov	r10,70
800063ea:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800063ec:	fc 18 c0 20 	movh	r8,0xc020
800063f0:	e0 6b 00 94 	mov	r11,148
800063f4:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800063f6:	34 7b       	mov	r11,71
800063f8:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800063fa:	34 1b       	mov	r11,65
800063fc:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800063fe:	34 8b       	mov	r11,72
80006400:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006402:	30 0b       	mov	r11,0
80006404:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006406:	34 9b       	mov	r11,73
80006408:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000640a:	33 3b       	mov	r11,51
8000640c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000640e:	34 ab       	mov	r11,74
80006410:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006412:	32 5b       	mov	r11,37
80006414:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006416:	34 bb       	mov	r11,75
80006418:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000641a:	34 5b       	mov	r11,69
8000641c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000641e:	34 cb       	mov	r11,76
80006420:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006422:	34 4b       	mov	r11,68
80006424:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006426:	34 db       	mov	r11,77
80006428:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000642a:	37 7b       	mov	r11,119
8000642c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000642e:	34 eb       	mov	r11,78
80006430:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006432:	31 2b       	mov	r11,18
80006434:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006436:	34 fb       	mov	r11,79
80006438:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000643a:	e0 6b 00 cc 	mov	r11,204
8000643e:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006440:	35 0b       	mov	r11,80
80006442:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006444:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006446:	35 1a       	mov	r10,81
80006448:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000644a:	e0 69 00 82 	mov	r9,130
8000644e:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
80006450:	5e fc       	retal	r12
80006452:	d7 03       	nop

80006454 <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
80006454:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
80006458:	fe f7 04 80 	ld.w	r7,pc[1152]
8000645c:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
8000645e:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
80006460:	16 9c       	mov	r12,r11
80006462:	f0 1f 01 1f 	mcall	800068dc <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
80006466:	35 5c       	mov	r12,85
80006468:	f0 1f 01 1e 	mcall	800068e0 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
8000646c:	30 2b       	mov	r11,2
8000646e:	33 2c       	mov	r12,50
80006470:	f0 1f 01 1d 	mcall	800068e4 <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80006474:	35 2c       	mov	r12,82
80006476:	f0 1f 01 1d 	mcall	800068e8 <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
8000647a:	35 2c       	mov	r12,82
8000647c:	f0 1f 01 1c 	mcall	800068ec <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80006480:	6e 07       	ld.w	r7,r7[0x0]
80006482:	33 28       	mov	r8,50
80006484:	ee 08 06 46 	mulu.d	r6,r7,r8
80006488:	ee 78 42 40 	mov	r8,1000000
8000648c:	30 09       	mov	r9,0
8000648e:	ee 7a 42 3f 	mov	r10,999999
80006492:	30 0b       	mov	r11,0
80006494:	ec 0a 00 0a 	add	r10,r6,r10
80006498:	ee 0b 00 4b 	adc	r11,r7,r11
8000649c:	f0 1f 01 15 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800064a0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800064a4:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800064a8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800064ac:	14 38       	cp.w	r8,r10
800064ae:	e0 88 00 09 	brls	800064c0 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800064b2:	12 38       	cp.w	r8,r9
800064b4:	fe 98 ff fa 	brls	800064a8 <et024006_Init+0x54>
800064b8:	12 3a       	cp.w	r10,r9
800064ba:	e0 83 00 a2 	brlo	800065fe <et024006_Init+0x1aa>
800064be:	cf 5b       	rjmp	800064a8 <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800064c0:	12 38       	cp.w	r8,r9
800064c2:	e0 8b 00 9e 	brhi	800065fe <et024006_Init+0x1aa>
800064c6:	12 3a       	cp.w	r10,r9
800064c8:	e0 83 00 9b 	brlo	800065fe <et024006_Init+0x1aa>
800064cc:	ce eb       	rjmp	800064a8 <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800064ce:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800064d2:	14 38       	cp.w	r8,r10
800064d4:	e0 88 00 09 	brls	800064e6 <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800064d8:	12 38       	cp.w	r8,r9
800064da:	fe 98 ff fa 	brls	800064ce <et024006_Init+0x7a>
800064de:	12 3a       	cp.w	r10,r9
800064e0:	e0 83 00 a9 	brlo	80006632 <et024006_Init+0x1de>
800064e4:	cf 5b       	rjmp	800064ce <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800064e6:	12 38       	cp.w	r8,r9
800064e8:	e0 8b 00 a5 	brhi	80006632 <et024006_Init+0x1de>
800064ec:	12 3a       	cp.w	r10,r9
800064ee:	e0 83 00 a2 	brlo	80006632 <et024006_Init+0x1de>
800064f2:	ce eb       	rjmp	800064ce <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800064f4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800064f8:	14 38       	cp.w	r8,r10
800064fa:	e0 88 00 09 	brls	8000650c <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800064fe:	12 38       	cp.w	r8,r9
80006500:	fe 98 ff fa 	brls	800064f4 <et024006_Init+0xa0>
80006504:	12 3a       	cp.w	r10,r9
80006506:	e0 83 01 1e 	brlo	80006742 <et024006_Init+0x2ee>
8000650a:	cf 5b       	rjmp	800064f4 <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000650c:	12 38       	cp.w	r8,r9
8000650e:	e0 8b 01 1a 	brhi	80006742 <et024006_Init+0x2ee>
80006512:	12 3a       	cp.w	r10,r9
80006514:	e0 83 01 17 	brlo	80006742 <et024006_Init+0x2ee>
80006518:	ce eb       	rjmp	800064f4 <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000651a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000651e:	14 38       	cp.w	r8,r10
80006520:	e0 88 00 09 	brls	80006532 <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006524:	12 38       	cp.w	r8,r9
80006526:	fe 98 ff fa 	brls	8000651a <et024006_Init+0xc6>
8000652a:	12 3a       	cp.w	r10,r9
8000652c:	e0 83 01 29 	brlo	8000677e <et024006_Init+0x32a>
80006530:	cf 5b       	rjmp	8000651a <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006532:	12 38       	cp.w	r8,r9
80006534:	e0 8b 01 25 	brhi	8000677e <et024006_Init+0x32a>
80006538:	12 3a       	cp.w	r10,r9
8000653a:	e0 83 01 22 	brlo	8000677e <et024006_Init+0x32a>
8000653e:	ce eb       	rjmp	8000651a <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006540:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006544:	14 38       	cp.w	r8,r10
80006546:	e0 88 00 09 	brls	80006558 <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000654a:	12 38       	cp.w	r8,r9
8000654c:	fe 98 ff fa 	brls	80006540 <et024006_Init+0xec>
80006550:	12 3a       	cp.w	r10,r9
80006552:	e0 83 01 35 	brlo	800067bc <et024006_Init+0x368>
80006556:	cf 5b       	rjmp	80006540 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006558:	12 38       	cp.w	r8,r9
8000655a:	e0 8b 01 31 	brhi	800067bc <et024006_Init+0x368>
8000655e:	12 3a       	cp.w	r10,r9
80006560:	e0 83 01 2e 	brlo	800067bc <et024006_Init+0x368>
80006564:	ce eb       	rjmp	80006540 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006566:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000656a:	14 38       	cp.w	r8,r10
8000656c:	e0 88 00 09 	brls	8000657e <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006570:	12 38       	cp.w	r8,r9
80006572:	fe 98 ff fa 	brls	80006566 <et024006_Init+0x112>
80006576:	12 3a       	cp.w	r10,r9
80006578:	e0 83 01 40 	brlo	800067f8 <et024006_Init+0x3a4>
8000657c:	cf 5b       	rjmp	80006566 <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000657e:	12 38       	cp.w	r8,r9
80006580:	e0 8b 01 3c 	brhi	800067f8 <et024006_Init+0x3a4>
80006584:	12 3a       	cp.w	r10,r9
80006586:	e0 83 01 39 	brlo	800067f8 <et024006_Init+0x3a4>
8000658a:	ce eb       	rjmp	80006566 <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000658c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006590:	14 38       	cp.w	r8,r10
80006592:	e0 88 00 09 	brls	800065a4 <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006596:	12 38       	cp.w	r8,r9
80006598:	fe 98 ff fa 	brls	8000658c <et024006_Init+0x138>
8000659c:	12 3a       	cp.w	r10,r9
8000659e:	e0 83 01 4b 	brlo	80006834 <et024006_Init+0x3e0>
800065a2:	cf 5b       	rjmp	8000658c <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800065a4:	12 38       	cp.w	r8,r9
800065a6:	e0 8b 01 47 	brhi	80006834 <et024006_Init+0x3e0>
800065aa:	12 3a       	cp.w	r10,r9
800065ac:	e0 83 01 44 	brlo	80006834 <et024006_Init+0x3e0>
800065b0:	ce eb       	rjmp	8000658c <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800065b2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800065b6:	14 38       	cp.w	r8,r10
800065b8:	e0 88 00 09 	brls	800065ca <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800065bc:	12 38       	cp.w	r8,r9
800065be:	fe 98 ff fa 	brls	800065b2 <et024006_Init+0x15e>
800065c2:	12 3a       	cp.w	r10,r9
800065c4:	e0 83 01 56 	brlo	80006870 <et024006_Init+0x41c>
800065c8:	cf 5b       	rjmp	800065b2 <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800065ca:	12 38       	cp.w	r8,r9
800065cc:	e0 8b 01 52 	brhi	80006870 <et024006_Init+0x41c>
800065d0:	12 3a       	cp.w	r10,r9
800065d2:	e0 83 01 4f 	brlo	80006870 <et024006_Init+0x41c>
800065d6:	ce eb       	rjmp	800065b2 <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800065d8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800065dc:	14 38       	cp.w	r8,r10
800065de:	e0 88 00 09 	brls	800065f0 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800065e2:	12 38       	cp.w	r8,r9
800065e4:	fe 98 ff fa 	brls	800065d8 <et024006_Init+0x184>
800065e8:	12 3a       	cp.w	r10,r9
800065ea:	e0 83 01 64 	brlo	800068b2 <et024006_Init+0x45e>
800065ee:	cf 5b       	rjmp	800065d8 <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800065f0:	12 38       	cp.w	r8,r9
800065f2:	e0 8b 01 60 	brhi	800068b2 <et024006_Init+0x45e>
800065f6:	12 3a       	cp.w	r10,r9
800065f8:	e0 83 01 5d 	brlo	800068b2 <et024006_Init+0x45e>
800065fc:	ce eb       	rjmp	800065d8 <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
800065fe:	35 2c       	mov	r12,82
80006600:	f0 1f 00 ba 	mcall	800068e8 <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006604:	fe f8 02 d4 	ld.w	r8,pc[724]
80006608:	70 07       	ld.w	r7,r8[0x0]
8000660a:	30 58       	mov	r8,5
8000660c:	ee 08 06 46 	mulu.d	r6,r7,r8
80006610:	e0 68 03 e8 	mov	r8,1000
80006614:	30 09       	mov	r9,0
80006616:	e0 6a 03 e7 	mov	r10,999
8000661a:	30 0b       	mov	r11,0
8000661c:	ec 0a 00 0a 	add	r10,r6,r10
80006620:	ee 0b 00 4b 	adc	r11,r7,r11
80006624:	f0 1f 00 b3 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006628:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000662c:	f0 0a 00 0a 	add	r10,r8,r10
80006630:	c4 fb       	rjmp	800064ce <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
80006632:	f0 1f 00 b1 	mcall	800068f4 <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006636:	fc 19 c0 00 	movh	r9,0xc000
8000663a:	30 1a       	mov	r10,1
8000663c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000663e:	fc 18 c0 20 	movh	r8,0xc020
80006642:	30 6b       	mov	r11,6
80006644:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006646:	33 ab       	mov	r11,58
80006648:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000664a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000664c:	33 bb       	mov	r11,59
8000664e:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006650:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006652:	33 ca       	mov	r10,60
80006654:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006656:	e0 6a 00 f0 	mov	r10,240
8000665a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000665c:	33 db       	mov	r11,61
8000665e:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006660:	30 07       	mov	r7,0
80006662:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006664:	33 eb       	mov	r11,62
80006666:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006668:	33 8b       	mov	r11,56
8000666a:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000666c:	34 0c       	mov	r12,64
8000666e:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006670:	30 fe       	mov	lr,15
80006672:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006674:	34 1e       	mov	lr,65
80006676:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006678:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000667a:	32 7a       	mov	r10,39
8000667c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000667e:	30 2a       	mov	r10,2
80006680:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006682:	32 8e       	mov	lr,40
80006684:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006686:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006688:	32 9e       	mov	lr,41
8000668a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000668c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000668e:	32 ae       	mov	lr,42
80006690:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006692:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006694:	32 ce       	mov	lr,44
80006696:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006698:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000669a:	32 de       	mov	lr,45
8000669c:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000669e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066a0:	31 9a       	mov	r10,25
800066a2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066a4:	34 9a       	mov	r10,73
800066a6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066a8:	e0 6a 00 93 	mov	r10,147
800066ac:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066ae:	30 8a       	mov	r10,8
800066b0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066b2:	31 6a       	mov	r10,22
800066b4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066b6:	36 8a       	mov	r10,104
800066b8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066ba:	32 3a       	mov	r10,35
800066bc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066be:	e0 6a 00 95 	mov	r10,149
800066c2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066c4:	32 4e       	mov	lr,36
800066c6:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066c8:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066ca:	32 5a       	mov	r10,37
800066cc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066ce:	e0 6a 00 ff 	mov	r10,255
800066d2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066d4:	e0 6a 00 90 	mov	r10,144
800066d8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066da:	37 fa       	mov	r10,127
800066dc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066de:	33 5a       	mov	r10,53
800066e0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066e2:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066e4:	33 6a       	mov	r10,54
800066e6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066e8:	37 8a       	mov	r10,120
800066ea:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066ec:	31 da       	mov	r10,29
800066ee:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066f0:	30 7a       	mov	r10,7
800066f2:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066f4:	31 ea       	mov	r10,30
800066f6:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066f8:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800066fa:	31 fa       	mov	r10,31
800066fc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800066fe:	30 4a       	mov	r10,4
80006700:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006702:	32 0a       	mov	r10,32
80006704:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006706:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006708:	34 4a       	mov	r10,68
8000670a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000670c:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000670e:	34 5a       	mov	r10,69
80006710:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006712:	31 29       	mov	r9,18
80006714:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006716:	4f 18       	lddpc	r8,800068d8 <et024006_Init+0x484>
80006718:	70 07       	ld.w	r7,r8[0x0]
8000671a:	30 a8       	mov	r8,10
8000671c:	ee 08 06 46 	mulu.d	r6,r7,r8
80006720:	e0 68 03 e8 	mov	r8,1000
80006724:	30 09       	mov	r9,0
80006726:	e0 6a 03 e7 	mov	r10,999
8000672a:	30 0b       	mov	r11,0
8000672c:	ec 0a 00 0a 	add	r10,r6,r10
80006730:	ee 0b 00 4b 	adc	r11,r7,r11
80006734:	f0 1f 00 6f 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006738:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000673c:	f0 0a 00 0a 	add	r10,r8,r10
80006740:	cd aa       	rjmp	800064f4 <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006742:	31 c9       	mov	r9,28
80006744:	fc 18 c0 00 	movh	r8,0xc000
80006748:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000674a:	30 49       	mov	r9,4
8000674c:	fc 18 c0 20 	movh	r8,0xc020
80006750:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006752:	4e 28       	lddpc	r8,800068d8 <et024006_Init+0x484>
80006754:	70 07       	ld.w	r7,r8[0x0]
80006756:	31 48       	mov	r8,20
80006758:	ee 08 06 46 	mulu.d	r6,r7,r8
8000675c:	e0 68 03 e8 	mov	r8,1000
80006760:	30 09       	mov	r9,0
80006762:	e0 6a 03 e7 	mov	r10,999
80006766:	30 0b       	mov	r11,0
80006768:	ec 0a 00 0a 	add	r10,r6,r10
8000676c:	ee 0b 00 4b 	adc	r11,r7,r11
80006770:	f0 1f 00 60 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006774:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006778:	f0 0a 00 0a 	add	r10,r8,r10
8000677c:	cc fa       	rjmp	8000651a <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000677e:	34 39       	mov	r9,67
80006780:	fc 18 c0 00 	movh	r8,0xc000
80006784:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006786:	e0 69 00 80 	mov	r9,128
8000678a:	fc 18 c0 20 	movh	r8,0xc020
8000678e:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006790:	4d 28       	lddpc	r8,800068d8 <et024006_Init+0x484>
80006792:	70 07       	ld.w	r7,r8[0x0]
80006794:	30 58       	mov	r8,5
80006796:	ee 08 06 46 	mulu.d	r6,r7,r8
8000679a:	e0 68 03 e8 	mov	r8,1000
8000679e:	30 09       	mov	r9,0
800067a0:	e0 6a 03 e7 	mov	r10,999
800067a4:	30 0b       	mov	r11,0
800067a6:	ec 0a 00 0a 	add	r10,r6,r10
800067aa:	ee 0b 00 4b 	adc	r11,r7,r11
800067ae:	f0 1f 00 51 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800067b2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800067b6:	f0 0a 00 0a 	add	r10,r8,r10
800067ba:	cc 3a       	rjmp	80006540 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800067bc:	31 b9       	mov	r9,27
800067be:	fc 18 c0 00 	movh	r8,0xc000
800067c2:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800067c4:	30 89       	mov	r9,8
800067c6:	fc 18 c0 20 	movh	r8,0xc020
800067ca:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800067cc:	4c 38       	lddpc	r8,800068d8 <et024006_Init+0x484>
800067ce:	70 07       	ld.w	r7,r8[0x0]
800067d0:	32 88       	mov	r8,40
800067d2:	ee 08 06 46 	mulu.d	r6,r7,r8
800067d6:	e0 68 03 e8 	mov	r8,1000
800067da:	30 09       	mov	r9,0
800067dc:	e0 6a 03 e7 	mov	r10,999
800067e0:	30 0b       	mov	r11,0
800067e2:	ec 0a 00 0a 	add	r10,r6,r10
800067e6:	ee 0b 00 4b 	adc	r11,r7,r11
800067ea:	f0 1f 00 42 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800067ee:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800067f2:	f0 0a 00 0a 	add	r10,r8,r10
800067f6:	cb 8a       	rjmp	80006566 <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800067f8:	31 b9       	mov	r9,27
800067fa:	fc 18 c0 00 	movh	r8,0xc000
800067fe:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006800:	31 09       	mov	r9,16
80006802:	fc 18 c0 20 	movh	r8,0xc020
80006806:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006808:	4b 48       	lddpc	r8,800068d8 <et024006_Init+0x484>
8000680a:	70 07       	ld.w	r7,r8[0x0]
8000680c:	32 88       	mov	r8,40
8000680e:	ee 08 06 46 	mulu.d	r6,r7,r8
80006812:	e0 68 03 e8 	mov	r8,1000
80006816:	30 09       	mov	r9,0
80006818:	e0 6a 03 e7 	mov	r10,999
8000681c:	30 0b       	mov	r11,0
8000681e:	ec 0a 00 0a 	add	r10,r6,r10
80006822:	ee 0b 00 4b 	adc	r11,r7,r11
80006826:	f0 1f 00 33 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000682a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000682e:	f0 0a 00 0a 	add	r10,r8,r10
80006832:	ca da       	rjmp	8000658c <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006834:	32 69       	mov	r9,38
80006836:	fc 18 c0 00 	movh	r8,0xc000
8000683a:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000683c:	30 49       	mov	r9,4
8000683e:	fc 18 c0 20 	movh	r8,0xc020
80006842:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006844:	4a 58       	lddpc	r8,800068d8 <et024006_Init+0x484>
80006846:	70 07       	ld.w	r7,r8[0x0]
80006848:	32 88       	mov	r8,40
8000684a:	ee 08 06 46 	mulu.d	r6,r7,r8
8000684e:	e0 68 03 e8 	mov	r8,1000
80006852:	30 09       	mov	r9,0
80006854:	e0 6a 03 e7 	mov	r10,999
80006858:	30 0b       	mov	r11,0
8000685a:	ec 0a 00 0a 	add	r10,r6,r10
8000685e:	ee 0b 00 4b 	adc	r11,r7,r11
80006862:	f0 1f 00 24 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006866:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000686a:	f0 0a 00 0a 	add	r10,r8,r10
8000686e:	ca 2a       	rjmp	800065b2 <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006870:	fc 19 c0 00 	movh	r9,0xc000
80006874:	32 6a       	mov	r10,38
80006876:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006878:	fc 18 c0 20 	movh	r8,0xc020
8000687c:	32 4b       	mov	r11,36
8000687e:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80006880:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80006882:	32 c9       	mov	r9,44
80006884:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006886:	49 58       	lddpc	r8,800068d8 <et024006_Init+0x484>
80006888:	70 07       	ld.w	r7,r8[0x0]
8000688a:	32 88       	mov	r8,40
8000688c:	ee 08 06 46 	mulu.d	r6,r7,r8
80006890:	e0 68 03 e8 	mov	r8,1000
80006894:	30 09       	mov	r9,0
80006896:	e0 6a 03 e7 	mov	r10,999
8000689a:	30 0b       	mov	r11,0
8000689c:	ec 0a 00 0a 	add	r10,r6,r10
800068a0:	ee 0b 00 4b 	adc	r11,r7,r11
800068a4:	f0 1f 00 13 	mcall	800068f0 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800068a8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800068ac:	f0 0a 00 0a 	add	r10,r8,r10
800068b0:	c9 4a       	rjmp	800065d8 <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800068b2:	fc 19 c0 00 	movh	r9,0xc000
800068b6:	32 68       	mov	r8,38
800068b8:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
800068ba:	fc 18 c0 20 	movh	r8,0xc020
800068be:	33 ca       	mov	r10,60
800068c0:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800068c2:	37 0a       	mov	r10,112
800068c4:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
800068c6:	90 0b       	ld.sh	r11,r8[0x0]
800068c8:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800068ca:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800068cc:	16 99       	mov	r9,r11
800068ce:	a3 b9       	sbr	r9,0x3
800068d0:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
800068d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068d6:	00 00       	add	r0,r0
800068d8:	00 00       	add	r0,r0
800068da:	05 84       	ld.ub	r4,r2[0x0]
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	6a 88       	ld.w	r8,r5[0x20]
800068e0:	80 00       	ld.sh	r0,r0[0x0]
800068e2:	6c 34       	ld.w	r4,r6[0xc]
800068e4:	80 00       	ld.sh	r0,r0[0x0]
800068e6:	6b b2       	ld.w	r2,r5[0x6c]
800068e8:	80 00       	ld.sh	r0,r0[0x0]
800068ea:	6c 62       	ld.w	r2,r6[0x18]
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	6c 7e       	ld.w	lr,r6[0x1c]
800068f0:	80 01       	ld.sh	r1,r0[0x0]
800068f2:	4d 42       	lddpc	r2,80006a40 <sdramc_init+0x124>
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	63 e4       	ld.w	r4,r1[0x78]

800068f8 <sdramc_ck_delay>:
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
800068f8:	e1 b8 00 42 	mfsr	r8,0x108
  unsigned long delay_end_cycle = delay_start_cycle + ck;
800068fc:	f0 0c 00 0c 	add	r12,r8,r12

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
80006900:	18 38       	cp.w	r8,r12
80006902:	e0 88 00 06 	brls	8000690e <sdramc_ck_delay+0x16>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80006906:	e1 b8 00 42 	mfsr	r8,0x108
8000690a:	10 3c       	cp.w	r12,r8
8000690c:	cf d3       	brcs	80006906 <sdramc_ck_delay+0xe>
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
8000690e:	e1 b8 00 42 	mfsr	r8,0x108
80006912:	10 3c       	cp.w	r12,r8
80006914:	fe 9b ff fd 	brhi	8000690e <sdramc_ck_delay+0x16>
}
80006918:	5e fc       	retal	r12
8000691a:	d7 03       	nop

8000691c <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
8000691c:	d4 31       	pushm	r0-r7,lr
8000691e:	20 2d       	sub	sp,8
80006920:	18 91       	mov	r1,r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80006922:	ee 7b 42 3f 	mov	r11,999999
80006926:	f8 0b 00 09 	add	r9,r12,r11
8000692a:	e0 60 de 83 	mov	r0,56963
8000692e:	ea 10 43 1b 	orh	r0,0x431b
80006932:	f2 00 06 48 	mulu.d	r8,r9,r0
80006936:	f2 06 16 12 	lsr	r6,r9,0x12
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
8000693a:	32 7b       	mov	r11,39
8000693c:	4d 0c       	lddpc	r12,80006a7c <sdramc_init+0x160>
8000693e:	f0 1f 00 51 	mcall	80006a80 <sdramc_init+0x164>
  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
80006942:	fe 68 10 00 	mov	r8,-126976
80006946:	f0 f9 01 24 	ld.w	r9,r8[292]
8000694a:	a1 b9       	sbr	r9,0x1
8000694c:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80006950:	f0 f8 01 24 	ld.w	r8,r8[292]
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80006954:	ec 09 15 04 	lsl	r9,r6,0x4
80006958:	0c 19       	sub	r9,r6
8000695a:	f2 c3 fc 19 	sub	r3,r9,-999
8000695e:	e0 65 4d d3 	mov	r5,19923
80006962:	ea 15 10 62 	orh	r5,0x1062
80006966:	e6 05 06 42 	mulu.d	r2,r3,r5
8000696a:	a7 83       	lsr	r3,0x6
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
8000696c:	ec 02 15 05 	lsl	r2,r6,0x5
80006970:	0c 02       	add	r2,r6
80006972:	a1 72       	lsl	r2,0x1
80006974:	e4 06 00 0b 	add	r11,r2,r6
80006978:	f6 cb fc 19 	sub	r11,r11,-999
8000697c:	f6 05 06 4a 	mulu.d	r10,r11,r5
80006980:	a7 8b       	lsr	r11,0x6
80006982:	bd 6b       	lsl	r11,0x1c
80006984:	16 9c       	mov	r12,r11
80006986:	e8 1c 00 d9 	orl	r12,0xd9
8000698a:	ec 08 15 03 	lsl	r8,r6,0x3
8000698e:	f0 06 01 0a 	sub	r10,r8,r6
80006992:	a1 7a       	lsl	r10,0x1
80006994:	f4 c7 fc 19 	sub	r7,r10,-999
80006998:	ee 05 06 4a 	mulu.d	r10,r7,r5
8000699c:	fa eb 00 00 	st.d	sp[0],r10
800069a0:	40 0a       	lddsp	r10,sp[0x0]
800069a2:	a3 6a       	lsl	r10,0x2
800069a4:	e2 1a 0f 00 	andl	r10,0xf00,COH
800069a8:	14 4c       	or	r12,r10
800069aa:	a3 69       	lsl	r9,0x2
800069ac:	f2 c9 fc 19 	sub	r9,r9,-999
800069b0:	f2 05 06 4a 	mulu.d	r10,r9,r5
800069b4:	fa eb 00 00 	st.d	sp[0],r10
800069b8:	40 09       	lddsp	r9,sp[0x0]
800069ba:	a7 69       	lsl	r9,0x6
800069bc:	e2 19 f0 00 	andl	r9,0xf000,COH
800069c0:	f9 e9 10 0a 	or	r10,r12,r9
800069c4:	e6 09 15 10 	lsl	r9,r3,0x10
800069c8:	e6 19 00 0f 	andh	r9,0xf,COH
800069cc:	12 4a       	or	r10,r9
800069ce:	e6 09 15 14 	lsl	r9,r3,0x14
800069d2:	e6 19 00 f0 	andh	r9,0xf0,COH
800069d6:	12 4a       	or	r10,r9
800069d8:	f0 06 00 09 	add	r9,r8,r6
800069dc:	ec 09 00 29 	add	r9,r6,r9<<0x2
800069e0:	f2 c9 fc 19 	sub	r9,r9,-999
800069e4:	f2 05 06 48 	mulu.d	r8,r9,r5
800069e8:	b3 69       	lsl	r9,0x12
800069ea:	e6 19 0f 00 	andh	r9,0xf00,COH
800069ee:	f5 e9 10 08 	or	r8,r10,r9
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
800069f2:	fe 67 20 00 	mov	r7,-122880
800069f6:	8f 28       	st.w	r7[0x8],r8
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
800069f8:	6e 28       	ld.w	r8,r7[0x8]

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
800069fa:	30 18       	mov	r8,1
800069fc:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
800069fe:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80006a00:	fc 14 d0 00 	movh	r4,0xd000
80006a04:	88 08       	ld.sh	r8,r4[0x0]

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
80006a06:	ec 0c 10 64 	mul	r12,r6,100
80006a0a:	f0 1f 00 1f 	mcall	80006a84 <sdramc_init+0x168>

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
80006a0e:	30 28       	mov	r8,2
80006a10:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80006a12:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80006a14:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
80006a16:	06 9c       	mov	r12,r3
80006a18:	f0 1f 00 1b 	mcall	80006a84 <sdramc_init+0x168>

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
80006a1c:	30 48       	mov	r8,4
80006a1e:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80006a20:	6e 08       	ld.w	r8,r7[0x0]
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80006a22:	e4 c3 fc 19 	sub	r3,r2,-999
80006a26:	e6 05 06 42 	mulu.d	r2,r3,r5
80006a2a:	a7 83       	lsr	r3,0x6
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80006a2c:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80006a2e:	06 9c       	mov	r12,r3
80006a30:	f0 1f 00 15 	mcall	80006a84 <sdramc_init+0x168>
  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
  {
    sdram[0];
80006a34:	88 08       	ld.sh	r8,r4[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80006a36:	06 9c       	mov	r12,r3
80006a38:	f0 1f 00 13 	mcall	80006a84 <sdramc_init+0x168>
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
80006a3c:	30 38       	mov	r8,3
80006a3e:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80006a40:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80006a42:	88 08       	ld.sh	r8,r4[0x0]
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
80006a44:	ec 09 15 01 	lsl	r9,r6,0x1
80006a48:	f2 c9 fc 19 	sub	r9,r9,-999
80006a4c:	f2 05 06 48 	mulu.d	r8,r9,r5
80006a50:	f2 0c 16 06 	lsr	r12,r9,0x6
80006a54:	f0 1f 00 0c 	mcall	80006a84 <sdramc_init+0x168>

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
80006a58:	30 08       	mov	r8,0
80006a5a:	8f 08       	st.w	r7[0x0],r8
  AVR32_SDRAMC.mr;
80006a5c:	6e 08       	ld.w	r8,r7[0x0]
  sdram[0];
80006a5e:	88 08       	ld.sh	r8,r4[0x0]

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
80006a60:	e2 00 06 40 	mulu.d	r0,r1,r0
80006a64:	b3 81       	lsr	r1,0x12
80006a66:	e0 68 1e 84 	mov	r8,7812
80006a6a:	b1 31       	mul	r1,r8
80006a6c:	e2 05 06 44 	mulu.d	r4,r1,r5
80006a70:	a7 85       	lsr	r5,0x6
80006a72:	8f 15       	st.w	r7[0x4],r5
  AVR32_SDRAMC.tr;
80006a74:	6e 18       	ld.w	r8,r7[0x4]
}
80006a76:	2f ed       	sub	sp,-8
80006a78:	d8 32       	popm	r0-r7,pc
80006a7a:	00 00       	add	r0,r0
80006a7c:	80 01       	ld.sh	r1,r0[0x0]
80006a7e:	e2 a0 80 00 	rcall	80056a7e <_data_sdram_lma+0x35eb6>
80006a82:	6c 04       	ld.w	r4,r6[0x0]
80006a84:	80 00       	ld.sh	r0,r0[0x0]
80006a86:	68 f8       	ld.w	r8,r4[0x3c]

80006a88 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80006a88:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80006a8c:	ee 78 42 3f 	mov	r8,999999
80006a90:	f8 08 00 09 	add	r9,r12,r8
80006a94:	e0 68 de 83 	mov	r8,56963
80006a98:	ea 18 43 1b 	orh	r8,0x431b
80006a9c:	f2 08 06 48 	mulu.d	r8,r9,r8
80006aa0:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80006aa4:	f0 08 00 25 	add	r5,r8,r8<<0x2
80006aa8:	a3 65       	lsl	r5,0x2
80006aaa:	ea c5 fc 19 	sub	r5,r5,-999
80006aae:	e0 69 4d d3 	mov	r9,19923
80006ab2:	ea 19 10 62 	orh	r9,0x1062
80006ab6:	ea 09 06 44 	mulu.d	r4,r5,r9
80006aba:	a7 85       	lsr	r5,0x6
80006abc:	f0 0a 15 04 	lsl	r10,r8,0x4
80006ac0:	f4 08 01 07 	sub	r7,r10,r8
80006ac4:	a1 77       	lsl	r7,0x1
80006ac6:	ee c7 fc 19 	sub	r7,r7,-999
80006aca:	ee 09 06 46 	mulu.d	r6,r7,r9
80006ace:	0e 94       	mov	r4,r7
80006ad0:	a7 84       	lsr	r4,0x6
80006ad2:	f4 08 01 07 	sub	r7,r10,r8
80006ad6:	a3 67       	lsl	r7,0x2
80006ad8:	ee c7 fc 19 	sub	r7,r7,-999
80006adc:	ee 09 06 46 	mulu.d	r6,r7,r9
80006ae0:	a7 87       	lsr	r7,0x6
80006ae2:	f0 03 10 5a 	mul	r3,r8,90
80006ae6:	e6 c3 fc 19 	sub	r3,r3,-999
80006aea:	e6 09 06 42 	mulu.d	r2,r3,r9
80006aee:	e6 0c 16 06 	lsr	r12,r3,0x6
80006af2:	e0 63 00 d2 	mov	r3,210
80006af6:	f0 03 02 43 	mul	r3,r8,r3
80006afa:	e6 c3 fc 19 	sub	r3,r3,-999
80006afe:	e6 09 06 42 	mulu.d	r2,r3,r9
80006b02:	e6 06 16 06 	lsr	r6,r3,0x6
80006b06:	f4 08 01 0b 	sub	r11,r10,r8
80006b0a:	a5 6b       	lsl	r11,0x4
80006b0c:	f6 cb fc 19 	sub	r11,r11,-999
80006b10:	f6 09 06 4a 	mulu.d	r10,r11,r9
80006b14:	f6 0e 16 06 	lsr	lr,r11,0x6
80006b18:	f0 03 10 64 	mul	r3,r8,100
80006b1c:	e6 c3 fc 19 	sub	r3,r3,-999
80006b20:	e6 09 06 42 	mulu.d	r2,r3,r9
80006b24:	a7 83       	lsr	r3,0x6
80006b26:	e0 6a 01 0e 	mov	r10,270
80006b2a:	b5 38       	mul	r8,r10
80006b2c:	f0 c8 fc 19 	sub	r8,r8,-999
80006b30:	f0 09 06 48 	mulu.d	r8,r8,r9
80006b34:	a7 89       	lsr	r9,0x6
80006b36:	ec 04 00 0a 	add	r10,r6,r4
80006b3a:	1c 3a       	cp.w	r10,lr
80006b3c:	f4 0e 17 20 	movhs	lr,r10
80006b40:	ee 05 00 0b 	add	r11,r7,r5
80006b44:	18 3b       	cp.w	r11,r12
80006b46:	f6 0c 17 20 	movhs	r12,r11
80006b4a:	06 3b       	cp.w	r11,r3
80006b4c:	e6 0b 17 30 	movlo	r11,r3
80006b50:	12 3a       	cp.w	r10,r9
80006b52:	f4 09 17 20 	movhs	r9,r10
80006b56:	eb e4 11 05 	or	r5,r5,r4<<0x10
80006b5a:	fe 6a 1c 00 	mov	r10,-123904
80006b5e:	95 05       	st.w	r10[0x0],r5
80006b60:	ef e6 11 07 	or	r7,r7,r6<<0x10
80006b64:	ef ec 10 87 	or	r7,r7,r12<<0x8
80006b68:	ef ee 11 87 	or	r7,r7,lr<<0x18
80006b6c:	95 17       	st.w	r10[0x4],r7
80006b6e:	1c 39       	cp.w	r9,lr
80006b70:	f2 0e 17 20 	movhs	lr,r9
80006b74:	18 3b       	cp.w	r11,r12
80006b76:	f8 0b 17 30 	movlo	r11,r12
80006b7a:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
80006b7e:	95 2b       	st.w	r10[0x8],r11
80006b80:	e0 68 10 03 	mov	r8,4099
80006b84:	95 38       	st.w	r10[0xc],r8
80006b86:	30 19       	mov	r9,1
80006b88:	48 48       	lddpc	r8,80006b98 <smc_init+0x110>
80006b8a:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80006b8c:	31 4b       	mov	r11,20
80006b8e:	48 4c       	lddpc	r12,80006b9c <smc_init+0x114>
80006b90:	f0 1f 00 04 	mcall	80006ba0 <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80006b94:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006b98:	00 00       	add	r0,r0
80006b9a:	05 8c       	ld.ub	r12,r2[0x0]
80006b9c:	80 01       	ld.sh	r1,r0[0x0]
80006b9e:	e3 d8 80 00 	ldswp.w	r8,r1[0]
80006ba2:	6c 04       	ld.w	r4,r6[0x0]

80006ba4 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80006ba4:	fe 68 14 00 	mov	r8,-125952
80006ba8:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80006baa:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80006bae:	91 09       	st.w	r8[0x0],r9
}
80006bb0:	5e fc       	retal	r12

80006bb2 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006bb2:	f8 08 16 05 	lsr	r8,r12,0x5
80006bb6:	a9 68       	lsl	r8,0x8
80006bb8:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006bbc:	58 1b       	cp.w	r11,1
80006bbe:	c0 d0       	breq	80006bd8 <gpio_enable_module_pin+0x26>
80006bc0:	c0 63       	brcs	80006bcc <gpio_enable_module_pin+0x1a>
80006bc2:	58 2b       	cp.w	r11,2
80006bc4:	c1 00       	breq	80006be4 <gpio_enable_module_pin+0x32>
80006bc6:	58 3b       	cp.w	r11,3
80006bc8:	c1 40       	breq	80006bf0 <gpio_enable_module_pin+0x3e>
80006bca:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006bcc:	30 19       	mov	r9,1
80006bce:	f2 0c 09 49 	lsl	r9,r9,r12
80006bd2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006bd4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006bd6:	c1 28       	rjmp	80006bfa <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006bd8:	30 19       	mov	r9,1
80006bda:	f2 0c 09 49 	lsl	r9,r9,r12
80006bde:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006be0:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006be2:	c0 c8       	rjmp	80006bfa <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006be4:	30 19       	mov	r9,1
80006be6:	f2 0c 09 49 	lsl	r9,r9,r12
80006bea:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006bec:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006bee:	c0 68       	rjmp	80006bfa <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006bf0:	30 19       	mov	r9,1
80006bf2:	f2 0c 09 49 	lsl	r9,r9,r12
80006bf6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006bf8:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006bfa:	30 19       	mov	r9,1
80006bfc:	f2 0c 09 4c 	lsl	r12,r9,r12
80006c00:	91 2c       	st.w	r8[0x8],r12
80006c02:	5e fd       	retal	0

80006c04 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006c04:	d4 21       	pushm	r4-r7,lr
80006c06:	18 97       	mov	r7,r12
80006c08:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006c0a:	58 0b       	cp.w	r11,0
80006c0c:	c0 31       	brne	80006c12 <gpio_enable_module+0xe>
80006c0e:	30 05       	mov	r5,0
80006c10:	c0 d8       	rjmp	80006c2a <gpio_enable_module+0x26>
80006c12:	30 06       	mov	r6,0
80006c14:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006c16:	6e 1b       	ld.w	r11,r7[0x4]
80006c18:	6e 0c       	ld.w	r12,r7[0x0]
80006c1a:	f0 1f 00 06 	mcall	80006c30 <gpio_enable_module+0x2c>
80006c1e:	18 45       	or	r5,r12
		gpiomap++;
80006c20:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006c22:	2f f6       	sub	r6,-1
80006c24:	0c 34       	cp.w	r4,r6
80006c26:	fe 9b ff f8 	brhi	80006c16 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006c2a:	0a 9c       	mov	r12,r5
80006c2c:	d8 22       	popm	r4-r7,pc
80006c2e:	00 00       	add	r0,r0
80006c30:	80 00       	ld.sh	r0,r0[0x0]
80006c32:	6b b2       	ld.w	r2,r5[0x6c]

80006c34 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006c34:	f8 08 16 05 	lsr	r8,r12,0x5
80006c38:	a9 68       	lsl	r8,0x8
80006c3a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80006c3e:	30 19       	mov	r9,1
80006c40:	f2 0c 09 4c 	lsl	r12,r9,r12
80006c44:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80006c48:	91 1c       	st.w	r8[0x4],r12
}
80006c4a:	5e fc       	retal	r12

80006c4c <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006c4c:	f8 08 16 05 	lsr	r8,r12,0x5
80006c50:	a9 68       	lsl	r8,0x8
80006c52:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
80006c56:	71 88       	ld.w	r8,r8[0x60]
80006c58:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80006c5c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006c60:	5e fc       	retal	r12

80006c62 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006c62:	f8 08 16 05 	lsr	r8,r12,0x5
80006c66:	a9 68       	lsl	r8,0x8
80006c68:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80006c6c:	30 19       	mov	r9,1
80006c6e:	f2 0c 09 4c 	lsl	r12,r9,r12
80006c72:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80006c76:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006c7a:	91 1c       	st.w	r8[0x4],r12
}
80006c7c:	5e fc       	retal	r12

80006c7e <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006c7e:	f8 08 16 05 	lsr	r8,r12,0x5
80006c82:	a9 68       	lsl	r8,0x8
80006c84:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80006c88:	30 19       	mov	r9,1
80006c8a:	f2 0c 09 4c 	lsl	r12,r9,r12
80006c8e:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80006c92:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006c96:	91 1c       	st.w	r8[0x4],r12
}
80006c98:	5e fc       	retal	r12

80006c9a <gpio_tgl_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_tgl_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006c9a:	f8 08 16 05 	lsr	r8,r12,0x5
80006c9e:	a9 68       	lsl	r8,0x8
80006ca0:	e0 28 f0 00 	sub	r8,61440
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
80006ca4:	30 19       	mov	r9,1
80006ca6:	f2 0c 09 4c 	lsl	r12,r9,r12
80006caa:	f1 4c 00 5c 	st.w	r8[92],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80006cae:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006cb2:	91 1c       	st.w	r8[0x4],r12
}
80006cb4:	5e fc       	retal	r12

80006cb6 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006cb6:	f8 08 16 05 	lsr	r8,r12,0x5
80006cba:	a9 68       	lsl	r8,0x8
80006cbc:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80006cc0:	30 19       	mov	r9,1
80006cc2:	f2 0c 09 4c 	lsl	r12,r9,r12
80006cc6:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80006cca:	12 3b       	cp.w	r11,r9
80006ccc:	c0 a0       	breq	80006ce0 <gpio_enable_pin_interrupt+0x2a>
80006cce:	c0 43       	brcs	80006cd6 <gpio_enable_pin_interrupt+0x20>
80006cd0:	58 2b       	cp.w	r11,2
80006cd2:	c1 11       	brne	80006cf4 <gpio_enable_pin_interrupt+0x3e>
80006cd4:	c0 b8       	rjmp	80006cea <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80006cd6:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80006cda:	f1 4c 00 b8 	st.w	r8[184],r12
80006cde:	c0 c8       	rjmp	80006cf6 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80006ce0:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
80006ce4:	f1 4c 00 b8 	st.w	r8[184],r12
80006ce8:	c0 78       	rjmp	80006cf6 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80006cea:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
80006cee:	f1 4c 00 b4 	st.w	r8[180],r12
80006cf2:	c0 28       	rjmp	80006cf6 <gpio_enable_pin_interrupt+0x40>
80006cf4:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80006cf6:	f1 4c 00 94 	st.w	r8[148],r12
80006cfa:	5e fd       	retal	0

80006cfc <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006cfc:	f8 08 16 05 	lsr	r8,r12,0x5
80006d00:	a9 68       	lsl	r8,0x8
80006d02:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80006d06:	f0 f8 00 d0 	ld.w	r8,r8[208]
80006d0a:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80006d0e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006d12:	5e fc       	retal	r12

80006d14 <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006d14:	f8 08 16 05 	lsr	r8,r12,0x5
80006d18:	a9 68       	lsl	r8,0x8
80006d1a:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
80006d1e:	30 19       	mov	r9,1
80006d20:	f2 0c 09 4c 	lsl	r12,r9,r12
80006d24:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
80006d28:	5e fc       	retal	r12

80006d2a <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80006d2a:	c0 08       	rjmp	80006d2a <_unhandled_interrupt>

80006d2c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80006d2c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80006d30:	49 99       	lddpc	r9,80006d94 <INTC_register_interrupt+0x68>
80006d32:	f2 08 00 39 	add	r9,r9,r8<<0x3
80006d36:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80006d3a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80006d3c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006d40:	58 0a       	cp.w	r10,0
80006d42:	c0 91       	brne	80006d54 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006d44:	49 59       	lddpc	r9,80006d98 <INTC_register_interrupt+0x6c>
80006d46:	49 6a       	lddpc	r10,80006d9c <INTC_register_interrupt+0x70>
80006d48:	12 1a       	sub	r10,r9
80006d4a:	fe 79 08 00 	mov	r9,-63488
80006d4e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006d52:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80006d54:	58 1a       	cp.w	r10,1
80006d56:	c0 a1       	brne	80006d6a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80006d58:	49 09       	lddpc	r9,80006d98 <INTC_register_interrupt+0x6c>
80006d5a:	49 2a       	lddpc	r10,80006da0 <INTC_register_interrupt+0x74>
80006d5c:	12 1a       	sub	r10,r9
80006d5e:	bf aa       	sbr	r10,0x1e
80006d60:	fe 79 08 00 	mov	r9,-63488
80006d64:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006d68:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80006d6a:	58 2a       	cp.w	r10,2
80006d6c:	c0 a1       	brne	80006d80 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80006d6e:	48 b9       	lddpc	r9,80006d98 <INTC_register_interrupt+0x6c>
80006d70:	48 da       	lddpc	r10,80006da4 <INTC_register_interrupt+0x78>
80006d72:	12 1a       	sub	r10,r9
80006d74:	bf ba       	sbr	r10,0x1f
80006d76:	fe 79 08 00 	mov	r9,-63488
80006d7a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006d7e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006d80:	48 69       	lddpc	r9,80006d98 <INTC_register_interrupt+0x6c>
80006d82:	48 aa       	lddpc	r10,80006da8 <INTC_register_interrupt+0x7c>
80006d84:	12 1a       	sub	r10,r9
80006d86:	ea 1a c0 00 	orh	r10,0xc000
80006d8a:	fe 79 08 00 	mov	r9,-63488
80006d8e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006d92:	5e fc       	retal	r12
80006d94:	80 01       	ld.sh	r1,r0[0x0]
80006d96:	e4 78 80 01 	mov	r8,360449
80006d9a:	da 00       	acall	0xa0
80006d9c:	80 01       	ld.sh	r1,r0[0x0]
80006d9e:	db 04       	*unknown*
80006da0:	80 01       	ld.sh	r1,r0[0x0]
80006da2:	db 12       	popm	r0-r3,r11-r12,pc
80006da4:	80 01       	ld.sh	r1,r0[0x0]
80006da6:	db 20       	acall	0xb2
80006da8:	80 01       	ld.sh	r1,r0[0x0]
80006daa:	db 2e       	*unknown*

80006dac <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80006dac:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006dae:	49 18       	lddpc	r8,80006df0 <INTC_init_interrupts+0x44>
80006db0:	e3 b8 00 01 	mtsr	0x4,r8
80006db4:	49 0e       	lddpc	lr,80006df4 <INTC_init_interrupts+0x48>
80006db6:	30 07       	mov	r7,0
80006db8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006dba:	49 0c       	lddpc	r12,80006df8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006dbc:	49 05       	lddpc	r5,80006dfc <INTC_init_interrupts+0x50>
80006dbe:	10 15       	sub	r5,r8
80006dc0:	fe 76 08 00 	mov	r6,-63488
80006dc4:	c1 08       	rjmp	80006de4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006dc6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80006dc8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006dca:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006dcc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006dd0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006dd2:	10 3a       	cp.w	r10,r8
80006dd4:	fe 9b ff fc 	brhi	80006dcc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006dd8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006ddc:	2f f7       	sub	r7,-1
80006dde:	2f 8e       	sub	lr,-8
80006de0:	59 47       	cp.w	r7,20
80006de2:	c0 50       	breq	80006dec <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006de4:	7c 08       	ld.w	r8,lr[0x0]
80006de6:	58 08       	cp.w	r8,0
80006de8:	ce f1       	brne	80006dc6 <INTC_init_interrupts+0x1a>
80006dea:	cf 7b       	rjmp	80006dd8 <INTC_init_interrupts+0x2c>
80006dec:	d8 22       	popm	r4-r7,pc
80006dee:	00 00       	add	r0,r0
80006df0:	80 01       	ld.sh	r1,r0[0x0]
80006df2:	da 00       	acall	0xa0
80006df4:	80 01       	ld.sh	r1,r0[0x0]
80006df6:	e4 78 80 00 	mov	r8,360448
80006dfa:	6d 2a       	ld.w	r10,r6[0x48]
80006dfc:	80 01       	ld.sh	r1,r0[0x0]
80006dfe:	db 04       	*unknown*

80006e00 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006e00:	fe 78 08 00 	mov	r8,-63488
80006e04:	e0 69 00 83 	mov	r9,131
80006e08:	f2 0c 01 0c 	sub	r12,r9,r12
80006e0c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006e10:	f2 ca ff c0 	sub	r10,r9,-64
80006e14:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006e18:	58 08       	cp.w	r8,0
80006e1a:	c0 21       	brne	80006e1e <_get_interrupt_handler+0x1e>
80006e1c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80006e1e:	f0 08 12 00 	clz	r8,r8
80006e22:	48 5a       	lddpc	r10,80006e34 <_get_interrupt_handler+0x34>
80006e24:	f4 09 00 39 	add	r9,r10,r9<<0x3
80006e28:	f0 08 11 1f 	rsub	r8,r8,31
80006e2c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006e2e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80006e32:	5e fc       	retal	r12
80006e34:	80 01       	ld.sh	r1,r0[0x0]
80006e36:	e4 78 78 a8 	mov	r8,358568

80006e38 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006e38:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80006e3a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006e3e:	99 a8       	st.w	r12[0x28],r8
}
80006e40:	5e fc       	retal	r12
80006e42:	d7 03       	nop

80006e44 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80006e44:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80006e46:	ec 5b bb 9f 	cp.w	r11,899999
80006e4a:	e0 8b 00 04 	brhi	80006e52 <pm_enable_osc0_crystal+0xe>
80006e4e:	30 4b       	mov	r11,4
80006e50:	c1 38       	rjmp	80006e76 <pm_enable_osc0_crystal+0x32>
80006e52:	e0 68 c6 bf 	mov	r8,50879
80006e56:	ea 18 00 2d 	orh	r8,0x2d
80006e5a:	10 3b       	cp.w	r11,r8
80006e5c:	e0 8b 00 04 	brhi	80006e64 <pm_enable_osc0_crystal+0x20>
80006e60:	30 5b       	mov	r11,5
80006e62:	c0 a8       	rjmp	80006e76 <pm_enable_osc0_crystal+0x32>
80006e64:	e0 68 12 00 	mov	r8,4608
80006e68:	ea 18 00 7a 	orh	r8,0x7a
80006e6c:	10 3b       	cp.w	r11,r8
80006e6e:	f9 bb 03 06 	movlo	r11,6
80006e72:	f9 bb 02 07 	movhs	r11,7
80006e76:	f0 1f 00 02 	mcall	80006e7c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80006e7a:	d8 02       	popm	pc
80006e7c:	80 00       	ld.sh	r0,r0[0x0]
80006e7e:	6e 38       	ld.w	r8,r7[0xc]

80006e80 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006e80:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80006e82:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006e86:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80006e88:	78 08       	ld.w	r8,r12[0x0]
80006e8a:	a3 a8       	sbr	r8,0x2
80006e8c:	99 08       	st.w	r12[0x0],r8
}
80006e8e:	5e fc       	retal	r12

80006e90 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80006e90:	79 58       	ld.w	r8,r12[0x54]
80006e92:	e2 18 00 80 	andl	r8,0x80,COH
80006e96:	cf d0       	breq	80006e90 <pm_wait_for_clk0_ready>
}
80006e98:	5e fc       	retal	r12
80006e9a:	d7 03       	nop

80006e9c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80006e9c:	eb cd 40 80 	pushm	r7,lr
80006ea0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80006ea2:	f0 1f 00 04 	mcall	80006eb0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80006ea6:	0e 9c       	mov	r12,r7
80006ea8:	f0 1f 00 03 	mcall	80006eb4 <pm_enable_clk0+0x18>
}
80006eac:	e3 cd 80 80 	ldm	sp++,r7,pc
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	6e 80       	ld.w	r0,r7[0x20]
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	6e 90       	ld.w	r0,r7[0x24]

80006eb8 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80006eb8:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80006ebc:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80006ec0:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80006ec2:	09 f7       	ld.ub	r7,r4[0x7]
80006ec4:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80006ec8:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80006ecc:	09 b4       	ld.ub	r4,r4[0x3]
80006ece:	08 96       	mov	r6,r4
80006ed0:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80006ed4:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80006ed8:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80006edc:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80006ee0:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80006ee4:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80006ee8:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80006eec:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80006ef0:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80006ef2:	79 58       	ld.w	r8,r12[0x54]
80006ef4:	e2 18 00 20 	andl	r8,0x20,COH
80006ef8:	cf d0       	breq	80006ef2 <pm_cksel+0x3a>
}
80006efa:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80006efe <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80006efe:	eb cd 40 80 	pushm	r7,lr
80006f02:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80006f04:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80006f06:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80006f0a:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80006f0e:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80006f12:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80006f16:	2f 8b       	sub	r11,-8
80006f18:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006f1c:	e3 cd 80 80 	ldm	sp++,r7,pc

80006f20 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80006f20:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80006f22:	2f 8b       	sub	r11,-8
80006f24:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80006f28:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80006f2c:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80006f30:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80006f34:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006f38:	d8 02       	popm	pc

80006f3a <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80006f3a:	2f 8b       	sub	r11,-8
80006f3c:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80006f40:	a1 a8       	sbr	r8,0x0
80006f42:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80006f46:	5e fc       	retal	r12

80006f48 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80006f48:	79 58       	ld.w	r8,r12[0x54]
80006f4a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f4e:	cf d0       	breq	80006f48 <pm_wait_for_pll0_locked>
}
80006f50:	5e fc       	retal	r12

80006f52 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80006f52:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80006f54:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80006f58:	99 08       	st.w	r12[0x0],r8
}
80006f5a:	5e fc       	retal	r12

80006f5c <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80006f5c:	eb cd 40 c0 	pushm	r6-r7,lr
80006f60:	18 97       	mov	r7,r12
80006f62:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80006f64:	f0 1f 00 06 	mcall	80006f7c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80006f68:	0c 9b       	mov	r11,r6
80006f6a:	0e 9c       	mov	r12,r7
80006f6c:	f0 1f 00 05 	mcall	80006f80 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80006f70:	30 1b       	mov	r11,1
80006f72:	0e 9c       	mov	r12,r7
80006f74:	f0 1f 00 04 	mcall	80006f84 <pm_switch_to_osc0+0x28>
}
80006f78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	6e 44       	ld.w	r4,r7[0x10]
80006f80:	80 00       	ld.sh	r0,r0[0x0]
80006f82:	6e 9c       	ld.w	r12,r7[0x24]
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	6f 52       	ld.w	r2,r7[0x54]

80006f88 <pm_configure_clocks>:

#define PM_MAX_MUL                ((1 << AVR32_PM_PLL0_PLLMUL_SIZE) - 1)


int pm_configure_clocks(pm_freq_param_t *param)
{
80006f88:	eb cd 40 fc 	pushm	r2-r7,lr
80006f8c:	18 97       	mov	r7,r12
  //  12    8   1  108     1     54    27
  //  12    9   1  120     1     60    15
  //  12    9   1  120     1     60    30
  //  12   10   1  132     1     66    16.5
  //
  unsigned long in_cpu_f  = param->cpu_f;
80006f8e:	78 05       	ld.w	r5,r12[0x0]
  unsigned long in_osc0_f = param->osc0_f;
80006f90:	78 26       	ld.w	r6,r12[0x8]
  unsigned long mul, div, div2_en = 0, div2_cpu = 0, div2_pba = 0;
  unsigned long pll_freq, rest;
  bool b_div2_pba, b_div2_cpu;

  // Switch to external Oscillator 0
  pm_switch_to_osc0(&AVR32_PM, in_osc0_f, param->osc0_startup);
80006f92:	78 3a       	ld.w	r10,r12[0xc]
80006f94:	0c 9b       	mov	r11,r6
80006f96:	fe 7c 0c 00 	mov	r12,-62464
80006f9a:	f0 1f 00 69 	mcall	8000713c <pm_configure_clocks+0x1b4>

  // Start with CPU freq config
  if (in_cpu_f == in_osc0_f)
80006f9e:	0c 35       	cp.w	r5,r6
80006fa0:	c0 51       	brne	80006faa <pm_configure_clocks+0x22>
  {
    param->cpu_f = in_osc0_f;
80006fa2:	8f 05       	st.w	r7[0x0],r5
    param->pba_f = in_osc0_f;
80006fa4:	8f 15       	st.w	r7[0x4],r5
80006fa6:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
  else if (in_cpu_f < in_osc0_f)
  {
    // TBD
  }

  rest = in_cpu_f % in_osc0_f;
80006faa:	ea 06 0d 08 	divu	r8,r5,r6
80006fae:	12 9c       	mov	r12,r9

  for (div = 1; div < 32; div++)
  {
    if ((div * rest) % in_osc0_f == 0)
80006fb0:	f8 06 0d 08 	divu	r8,r12,r6
80006fb4:	58 09       	cp.w	r9,0
80006fb6:	c0 31       	brne	80006fbc <pm_configure_clocks+0x34>
80006fb8:	30 19       	mov	r9,1
80006fba:	c1 28       	rjmp	80006fde <pm_configure_clocks+0x56>
80006fbc:	f8 08 15 01 	lsl	r8,r12,0x1
80006fc0:	30 29       	mov	r9,2
80006fc2:	f0 06 0d 0a 	divu	r10,r8,r6
80006fc6:	58 0b       	cp.w	r11,0
80006fc8:	c0 70       	breq	80006fd6 <pm_configure_clocks+0x4e>
    // TBD
  }

  rest = in_cpu_f % in_osc0_f;

  for (div = 1; div < 32; div++)
80006fca:	2f f9       	sub	r9,-1
80006fcc:	18 08       	add	r8,r12
80006fce:	e0 49 00 20 	cp.w	r9,32
80006fd2:	cf 81       	brne	80006fc2 <pm_configure_clocks+0x3a>
80006fd4:	cb 18       	rjmp	80007136 <pm_configure_clocks+0x1ae>
  {
    if ((div * rest) % in_osc0_f == 0)
      break;
  }
  if (div == 32)
80006fd6:	e0 49 00 20 	cp.w	r9,32
80006fda:	e0 80 00 ae 	breq	80007136 <pm_configure_clocks+0x1ae>
    return PM_FREQ_STATUS_FAIL;

  mul = (in_cpu_f * div) / in_osc0_f;
80006fde:	f2 05 02 4b 	mul	r11,r9,r5
80006fe2:	f6 06 0d 0a 	divu	r10,r11,r6

  if (mul > PM_MAX_MUL)
80006fe6:	58 fa       	cp.w	r10,15
80006fe8:	e0 8b 00 a7 	brhi	80007136 <pm_configure_clocks+0x1ae>
    return PM_FREQ_STATUS_FAIL;

  // export 2power from PLL div to div2_cpu
  while (!(div % 2))
80006fec:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80006ff0:	c0 30       	breq	80006ff6 <pm_configure_clocks+0x6e>
80006ff2:	30 05       	mov	r5,0
80006ff4:	c0 78       	rjmp	80007002 <pm_configure_clocks+0x7a>
80006ff6:	30 05       	mov	r5,0
  {
    div /= 2;
80006ff8:	a1 99       	lsr	r9,0x1
    div2_cpu++;
80006ffa:	2f f5       	sub	r5,-1

  if (mul > PM_MAX_MUL)
    return PM_FREQ_STATUS_FAIL;

  // export 2power from PLL div to div2_cpu
  while (!(div % 2))
80006ffc:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80007000:	cf c0       	breq	80006ff8 <pm_configure_clocks+0x70>

  // Here we know the mul and div parameter of the PLL config.
  // . Check out if the PLL has a valid in_cpu_f.
  // . Try to have for the PLL frequency (VCO output) the highest possible value
  //   to reduce jitter.
  while (in_osc0_f * 2 * mul / div < AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
80007002:	f4 06 02 4b 	mul	r11,r10,r6
80007006:	f6 03 15 01 	lsl	r3,r11,0x1
8000700a:	e6 09 0d 02 	divu	r2,r3,r9
8000700e:	e0 6c 1b ff 	mov	r12,7167
80007012:	ea 1c 0e 4e 	orh	r12,0xe4e
80007016:	18 32       	cp.w	r2,r12
80007018:	e0 8b 00 1d 	brhi	80007052 <pm_configure_clocks+0xca>
  {
    if (2 * mul > PM_MAX_MUL)
8000701c:	f4 08 15 01 	lsl	r8,r10,0x1
80007020:	58 f8       	cp.w	r8,15
80007022:	e0 88 00 09 	brls	80007034 <pm_configure_clocks+0xac>
80007026:	c1 68       	rjmp	80007052 <pm_configure_clocks+0xca>
80007028:	f0 0a 15 01 	lsl	r10,r8,0x1
8000702c:	58 fa       	cp.w	r10,15
8000702e:	e0 8b 00 11 	brhi	80007050 <pm_configure_clocks+0xc8>
80007032:	14 98       	mov	r8,r10
      break;
    mul *= 2;
    div2_cpu++;
80007034:	2f f5       	sub	r5,-1

  // Here we know the mul and div parameter of the PLL config.
  // . Check out if the PLL has a valid in_cpu_f.
  // . Try to have for the PLL frequency (VCO output) the highest possible value
  //   to reduce jitter.
  while (in_osc0_f * 2 * mul / div < AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
80007036:	f0 06 02 4b 	mul	r11,r8,r6
8000703a:	f6 03 15 01 	lsl	r3,r11,0x1
8000703e:	e6 09 0d 02 	divu	r2,r3,r9
80007042:	e0 6c 1b ff 	mov	r12,7167
80007046:	ea 1c 0e 4e 	orh	r12,0xe4e
8000704a:	18 32       	cp.w	r2,r12
8000704c:	fe 98 ff ee 	brls	80007028 <pm_configure_clocks+0xa0>
80007050:	10 9a       	mov	r10,r8
      break;
    mul *= 2;
    div2_cpu++;
  }

  if (div2_cpu != 0)
80007052:	58 05       	cp.w	r5,0
80007054:	f9 b6 00 00 	moveq	r6,0
  {
    div2_cpu--;
80007058:	f7 b5 01 01 	subne	r5,1
8000705c:	f9 b6 01 01 	movne	r6,1
    div2_en = 1;
  }

  pll_freq = in_osc0_f * mul / (div * (1 << div2_en));
80007060:	f2 06 09 43 	lsl	r3,r9,r6
80007064:	f6 03 0d 02 	divu	r2,r11,r3
80007068:	04 94       	mov	r4,r2

  // Update real CPU Frequency
  param->cpu_f = pll_freq / (1 << div2_cpu);
8000706a:	e4 05 0a 48 	lsr	r8,r2,r5
8000706e:	8f 08       	st.w	r7[0x0],r8
  mul--;

  pm_pll_setup(&AVR32_PM
80007070:	31 08       	mov	r8,16
80007072:	1a d8       	st.w	--sp,r8
80007074:	30 08       	mov	r8,0
80007076:	20 1a       	sub	r10,1
80007078:	10 9b       	mov	r11,r8
8000707a:	fe 7c 0c 00 	mov	r12,-62464
8000707e:	f0 1f 00 31 	mcall	80007140 <pm_configure_clocks+0x1b8>
  , div // div
  , 0   // osc
  , 16  // lockcount
  );

  pm_pll_set_option(&AVR32_PM
80007082:	e0 69 67 ff 	mov	r9,26623
80007086:	ea 19 09 89 	orh	r9,0x989
8000708a:	12 32       	cp.w	r2,r9
8000708c:	5f 8a       	srls	r10
8000708e:	30 08       	mov	r8,0
80007090:	0c 99       	mov	r9,r6
80007092:	10 9b       	mov	r11,r8
80007094:	fe 7c 0c 00 	mov	r12,-62464
80007098:	f0 1f 00 2b 	mcall	80007144 <pm_configure_clocks+0x1bc>
8000709c:	04 98       	mov	r8,r2
8000709e:	30 06       	mov	r6,0
  , div2_en // pll_div2
  , 0 // pll_wbwdisable
  );

  rest = pll_freq;
  while (rest > AVR32_PM_PBA_MAX_FREQ ||
800070a0:	2f fd       	sub	sp,-4
800070a2:	c0 78       	rjmp	800070b0 <pm_configure_clocks+0x128>
         rest != param->pba_f)
  {
    div2_pba++;
800070a4:	2f f6       	sub	r6,-1
    rest = pll_freq / (1 << div2_pba);
800070a6:	e8 06 0a 48 	lsr	r8,r4,r6
    if (rest < param->pba_f)
800070aa:	6e 19       	ld.w	r9,r7[0x4]
800070ac:	12 38       	cp.w	r8,r9
800070ae:	c0 b3       	brcs	800070c4 <pm_configure_clocks+0x13c>
  , div2_en // pll_div2
  , 0 // pll_wbwdisable
  );

  rest = pll_freq;
  while (rest > AVR32_PM_PBA_MAX_FREQ ||
800070b0:	e0 6c 14 80 	mov	r12,5248
800070b4:	ea 1c 03 ef 	orh	r12,0x3ef
800070b8:	18 38       	cp.w	r8,r12
800070ba:	fe 9b ff f5 	brhi	800070a4 <pm_configure_clocks+0x11c>
         rest != param->pba_f)
800070be:	6e 19       	ld.w	r9,r7[0x4]
800070c0:	10 39       	cp.w	r9,r8
800070c2:	cf 11       	brne	800070a4 <pm_configure_clocks+0x11c>
    if (rest < param->pba_f)
      break;
  }

  // Update real PBA Frequency
  param->pba_f = pll_freq / (1 << div2_pba);
800070c4:	e8 06 0a 44 	lsr	r4,r4,r6
800070c8:	8f 14       	st.w	r7[0x4],r4

  // Enable PLL0
  pm_pll_enable(&AVR32_PM, 0);
800070ca:	30 0b       	mov	r11,0
800070cc:	fe 7c 0c 00 	mov	r12,-62464
800070d0:	f0 1f 00 1e 	mcall	80007148 <pm_configure_clocks+0x1c0>

  // Wait for PLL0 locked
  pm_wait_for_pll0_locked(&AVR32_PM);
800070d4:	fe 7c 0c 00 	mov	r12,-62464
800070d8:	f0 1f 00 1d 	mcall	8000714c <pm_configure_clocks+0x1c4>

  if (div2_cpu)
800070dc:	58 05       	cp.w	r5,0
800070de:	f9 b9 00 00 	moveq	r9,0
  {
    b_div2_cpu = true;
    div2_cpu--;
800070e2:	f7 b5 01 01 	subne	r5,1
800070e6:	f9 b9 01 01 	movne	r9,1
  }
  else
    b_div2_cpu = false;

  if (div2_pba)
800070ea:	58 06       	cp.w	r6,0
800070ec:	f9 bb 00 00 	moveq	r11,0
  {
    b_div2_pba = true;
    div2_pba--;
800070f0:	f7 b6 01 01 	subne	r6,1
800070f4:	f9 bb 01 01 	movne	r11,1
  }
  else
    b_div2_pba = false;

  pm_cksel(&AVR32_PM
800070f8:	1a d5       	st.w	--sp,r5
800070fa:	1a d9       	st.w	--sp,r9
800070fc:	0a 98       	mov	r8,r5
800070fe:	0c 9a       	mov	r10,r6
80007100:	fe 7c 0c 00 	mov	r12,-62464
80007104:	f0 1f 00 13 	mcall	80007150 <pm_configure_clocks+0x1c8>
  , b_div2_pba, div2_pba // PBA
  , b_div2_cpu, div2_cpu // PBB
  , b_div2_cpu, div2_cpu // HSB
  );

  if (param->cpu_f > AVR32_FLASHC_FWS_0_MAX_FREQ)
80007108:	2f ed       	sub	sp,-8
8000710a:	6e 08       	ld.w	r8,r7[0x0]
8000710c:	e0 69 8a 40 	mov	r9,35392
80007110:	ea 19 01 f7 	orh	r9,0x1f7
80007114:	12 38       	cp.w	r8,r9
80007116:	e0 88 00 06 	brls	80007122 <pm_configure_clocks+0x19a>
  {
    flashc_set_wait_state(1);
8000711a:	30 1c       	mov	r12,1
8000711c:	f0 1f 00 0e 	mcall	80007154 <pm_configure_clocks+0x1cc>
80007120:	c0 48       	rjmp	80007128 <pm_configure_clocks+0x1a0>
      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
#endif
  }
  else
  {
    flashc_set_wait_state(0);
80007122:	30 0c       	mov	r12,0
80007124:	f0 1f 00 0c 	mcall	80007154 <pm_configure_clocks+0x1cc>
    else
      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
#endif
  }

  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
80007128:	30 2b       	mov	r11,2
8000712a:	fe 7c 0c 00 	mov	r12,-62464
8000712e:	f0 1f 00 0b 	mcall	80007158 <pm_configure_clocks+0x1d0>
80007132:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

  return PM_FREQ_STATUS_OK;
80007136:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
8000713a:	00 00       	add	r0,r0
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	6f 5c       	ld.w	r12,r7[0x54]
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	6e fe       	ld.w	lr,r7[0x3c]
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	6f 20       	ld.w	r0,r7[0x48]
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	6f 3a       	ld.w	r10,r7[0x4c]
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	6f 48       	ld.w	r8,r7[0x50]
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	6e b8       	ld.w	r8,r7[0x2c]
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	6b a4       	ld.w	r4,r5[0x68]
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	6f 52       	ld.w	r2,r7[0x54]

8000715c <pcl_configure_clocks>:
#if UC3D
static long int pcl_configure_clocks_uc3d(pcl_freq_param_t *param); // FORWARD declaration
#endif

long int pcl_configure_clocks(pcl_freq_param_t *param)
{
8000715c:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
  // Implementation for UC3A, UC3A3, UC3B parts.
  return(pm_configure_clocks(param));
8000715e:	f0 1f 00 02 	mcall	80007164 <pcl_configure_clocks+0x8>
  #else
    // Implementation for UC3L parts.
    return(pcl_configure_clocks_uc3l(param));
  #endif
#endif
}
80007162:	d8 02       	popm	pc
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	6f 88       	ld.w	r8,r7[0x60]

80007168 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80007168:	58 0b       	cp.w	r11,0
8000716a:	c1 90       	breq	8000719c <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
8000716c:	58 6c       	cp.w	r12,6
8000716e:	e0 8b 00 17 	brhi	8000719c <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80007172:	76 0a       	ld.w	r10,r11[0x0]
80007174:	fe 78 30 00 	mov	r8,-53248
80007178:	f8 c9 ff f0 	sub	r9,r12,-16
8000717c:	a5 79       	lsl	r9,0x5
8000717e:	f0 09 00 09 	add	r9,r8,r9
80007182:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80007184:	76 19       	ld.w	r9,r11[0x4]
80007186:	a5 7c       	lsl	r12,0x5
80007188:	f0 0c 00 0c 	add	r12,r8,r12
8000718c:	f8 c8 fd fc 	sub	r8,r12,-516
80007190:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80007192:	76 28       	ld.w	r8,r11[0x8]
80007194:	f8 cc fd f8 	sub	r12,r12,-520
80007198:	99 08       	st.w	r12[0x0],r8
8000719a:	5e fd       	retal	0

  return PWM_SUCCESS;
8000719c:	5e ff       	retal	1

8000719e <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
8000719e:	18 98       	mov	r8,r12
800071a0:	e0 18 ff 80 	andl	r8,0xff80
800071a4:	c0 20       	breq	800071a8 <pwm_start_channels+0xa>
800071a6:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
800071a8:	fe 78 30 00 	mov	r8,-53248
800071ac:	91 1c       	st.w	r8[0x4],r12
800071ae:	5e fd       	retal	0

800071b0 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
800071b0:	58 6c       	cp.w	r12,6
800071b2:	e0 88 00 03 	brls	800071b8 <pwm_async_update_channel+0x8>
800071b6:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
800071b8:	76 0a       	ld.w	r10,r11[0x0]
800071ba:	fe 78 30 00 	mov	r8,-53248
800071be:	f8 c9 ff f0 	sub	r9,r12,-16
800071c2:	a5 79       	lsl	r9,0x5
800071c4:	f0 09 00 09 	add	r9,r8,r9
800071c8:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
800071ca:	76 49       	ld.w	r9,r11[0x10]
800071cc:	a5 7c       	lsl	r12,0x5
800071ce:	18 08       	add	r8,r12
800071d0:	f0 c8 fd f0 	sub	r8,r8,-528
800071d4:	91 09       	st.w	r8[0x0],r9
800071d6:	5e fd       	retal	0

800071d8 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800071d8:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
800071dc:	58 0c       	cp.w	r12,0
800071de:	c0 21       	brne	800071e2 <pwm_init+0xa>
800071e0:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
800071e2:	e6 18 00 01 	andh	r8,0x1,COH
800071e6:	c0 91       	brne	800071f8 <pwm_init+0x20>
800071e8:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800071ea:	fe 78 30 00 	mov	r8,-53248
800071ee:	37 f9       	mov	r9,127
800071f0:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
800071f2:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
800071f4:	d5 03       	csrf	0x10
800071f6:	c0 68       	rjmp	80007202 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
800071f8:	fe 78 30 00 	mov	r8,-53248
800071fc:	37 f9       	mov	r9,127
800071fe:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80007200:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80007202:	78 08       	ld.w	r8,r12[0x0]
80007204:	78 39       	ld.w	r9,r12[0xc]
80007206:	a9 69       	lsl	r9,0x8
80007208:	f3 e8 11 09 	or	r9,r9,r8<<0x10
8000720c:	78 18       	ld.w	r8,r12[0x4]
8000720e:	10 49       	or	r9,r8
80007210:	78 28       	ld.w	r8,r12[0x8]
80007212:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80007216:	fe 78 30 00 	mov	r8,-53248
8000721a:	91 09       	st.w	r8[0x0],r9
8000721c:	5e fd       	retal	0

8000721e <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000721e:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80007220:	f6 08 15 04 	lsl	r8,r11,0x4
80007224:	14 38       	cp.w	r8,r10
80007226:	f9 b8 08 10 	movls	r8,16
8000722a:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000722e:	f0 0b 02 4b 	mul	r11,r8,r11
80007232:	f6 09 16 01 	lsr	r9,r11,0x1
80007236:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000723a:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000723e:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80007242:	f2 cb 00 01 	sub	r11,r9,1
80007246:	e0 4b ff fe 	cp.w	r11,65534
8000724a:	e0 88 00 03 	brls	80007250 <usart_set_async_baudrate+0x32>
8000724e:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80007250:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80007252:	e8 6e 00 00 	mov	lr,524288
80007256:	59 08       	cp.w	r8,16
80007258:	fc 08 17 10 	movne	r8,lr
8000725c:	f9 b8 00 00 	moveq	r8,0
80007260:	e4 1b ff f7 	andh	r11,0xfff7
80007264:	e0 1b fe cf 	andl	r11,0xfecf
80007268:	16 48       	or	r8,r11
8000726a:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000726c:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80007270:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80007274:	99 89       	st.w	r12[0x20],r9
80007276:	d8 0a       	popm	pc,r12=0

80007278 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80007278:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000727a:	e2 18 00 02 	andl	r8,0x2,COH
8000727e:	c0 31       	brne	80007284 <usart_write_char+0xc>
80007280:	30 2c       	mov	r12,2
80007282:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80007284:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80007288:	99 7b       	st.w	r12[0x1c],r11
8000728a:	5e fd       	retal	0

8000728c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
8000728c:	eb cd 40 e0 	pushm	r5-r7,lr
80007290:	18 96       	mov	r6,r12
80007292:	16 95       	mov	r5,r11
80007294:	e0 67 27 0f 	mov	r7,9999
80007298:	c0 68       	rjmp	800072a4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000729a:	58 07       	cp.w	r7,0
8000729c:	c0 31       	brne	800072a2 <usart_putchar+0x16>
8000729e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800072a2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800072a4:	0a 9b       	mov	r11,r5
800072a6:	0c 9c       	mov	r12,r6
800072a8:	f0 1f 00 03 	mcall	800072b4 <usart_putchar+0x28>
800072ac:	cf 71       	brne	8000729a <usart_putchar+0xe>

  return USART_SUCCESS;
}
800072ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800072b2:	00 00       	add	r0,r0
800072b4:	80 00       	ld.sh	r0,r0[0x0]
800072b6:	72 78       	ld.w	r8,r9[0x1c]

800072b8 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800072b8:	eb cd 40 c0 	pushm	r6-r7,lr
800072bc:	18 96       	mov	r6,r12
800072be:	16 97       	mov	r7,r11
  while (*string != '\0')
800072c0:	17 8b       	ld.ub	r11,r11[0x0]
800072c2:	58 0b       	cp.w	r11,0
800072c4:	c0 80       	breq	800072d4 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800072c6:	2f f7       	sub	r7,-1
800072c8:	0c 9c       	mov	r12,r6
800072ca:	f0 1f 00 04 	mcall	800072d8 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800072ce:	0f 8b       	ld.ub	r11,r7[0x0]
800072d0:	58 0b       	cp.w	r11,0
800072d2:	cf a1       	brne	800072c6 <usart_write_line+0xe>
800072d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	72 8c       	ld.w	r12,r9[0x20]

800072dc <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800072dc:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800072e0:	e6 18 00 01 	andh	r8,0x1,COH
800072e4:	c0 71       	brne	800072f2 <usart_reset+0x16>
800072e6:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800072e8:	3f f8       	mov	r8,-1
800072ea:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800072ec:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800072ee:	d5 03       	csrf	0x10
800072f0:	c0 48       	rjmp	800072f8 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800072f2:	3f f8       	mov	r8,-1
800072f4:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800072f6:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800072f8:	30 08       	mov	r8,0
800072fa:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800072fc:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800072fe:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80007300:	ea 68 61 0c 	mov	r8,680204
80007304:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80007306:	5e fc       	retal	r12

80007308 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80007308:	eb cd 40 e0 	pushm	r5-r7,lr
8000730c:	18 96       	mov	r6,r12
8000730e:	16 97       	mov	r7,r11
80007310:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80007312:	f0 1f 00 2f 	mcall	800073cc <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80007316:	58 07       	cp.w	r7,0
80007318:	c5 80       	breq	800073c8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000731a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000731c:	30 49       	mov	r9,4
8000731e:	f2 08 18 00 	cp.b	r8,r9
80007322:	e0 88 00 53 	brls	800073c8 <usart_init_rs232+0xc0>
80007326:	30 99       	mov	r9,9
80007328:	f2 08 18 00 	cp.b	r8,r9
8000732c:	e0 8b 00 4e 	brhi	800073c8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80007330:	0f d9       	ld.ub	r9,r7[0x5]
80007332:	30 78       	mov	r8,7
80007334:	f0 09 18 00 	cp.b	r9,r8
80007338:	e0 8b 00 48 	brhi	800073c8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
8000733c:	8e 39       	ld.sh	r9,r7[0x6]
8000733e:	e0 68 01 01 	mov	r8,257
80007342:	f0 09 19 00 	cp.h	r9,r8
80007346:	e0 8b 00 41 	brhi	800073c8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
8000734a:	ef 39 00 08 	ld.ub	r9,r7[8]
8000734e:	30 38       	mov	r8,3
80007350:	f0 09 18 00 	cp.b	r9,r8
80007354:	e0 8b 00 3a 	brhi	800073c8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80007358:	0a 9a       	mov	r10,r5
8000735a:	6e 0b       	ld.w	r11,r7[0x0]
8000735c:	0c 9c       	mov	r12,r6
8000735e:	f0 1f 00 1d 	mcall	800073d0 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007362:	58 1c       	cp.w	r12,1
80007364:	c3 20       	breq	800073c8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80007366:	0f c8       	ld.ub	r8,r7[0x4]
80007368:	30 99       	mov	r9,9
8000736a:	f2 08 18 00 	cp.b	r8,r9
8000736e:	c0 51       	brne	80007378 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80007370:	6c 18       	ld.w	r8,r6[0x4]
80007372:	b1 b8       	sbr	r8,0x11
80007374:	8d 18       	st.w	r6[0x4],r8
80007376:	c0 68       	rjmp	80007382 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80007378:	6c 19       	ld.w	r9,r6[0x4]
8000737a:	20 58       	sub	r8,5
8000737c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80007380:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80007382:	6c 19       	ld.w	r9,r6[0x4]
80007384:	ef 3a 00 08 	ld.ub	r10,r7[8]
80007388:	0f d8       	ld.ub	r8,r7[0x5]
8000738a:	a9 78       	lsl	r8,0x9
8000738c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80007390:	12 48       	or	r8,r9
80007392:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80007394:	8e 38       	ld.sh	r8,r7[0x6]
80007396:	30 29       	mov	r9,2
80007398:	f2 08 19 00 	cp.h	r8,r9
8000739c:	e0 88 00 09 	brls	800073ae <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800073a0:	6c 18       	ld.w	r8,r6[0x4]
800073a2:	ad b8       	sbr	r8,0xd
800073a4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800073a6:	8e b8       	ld.uh	r8,r7[0x6]
800073a8:	20 28       	sub	r8,2
800073aa:	8d a8       	st.w	r6[0x28],r8
800073ac:	c0 68       	rjmp	800073b8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800073ae:	6c 19       	ld.w	r9,r6[0x4]
800073b0:	5c 78       	castu.h	r8
800073b2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800073b6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800073b8:	6c 18       	ld.w	r8,r6[0x4]
800073ba:	e0 18 ff f0 	andl	r8,0xfff0
800073be:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800073c0:	35 08       	mov	r8,80
800073c2:	8d 08       	st.w	r6[0x0],r8
800073c4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800073c8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800073cc:	80 00       	ld.sh	r0,r0[0x0]
800073ce:	72 dc       	ld.w	r12,r9[0x34]
800073d0:	80 00       	ld.sh	r0,r0[0x0]
800073d2:	72 1e       	ld.w	lr,r9[0x4]

800073d4 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
800073d4:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
800073d6:	f0 1f 00 02 	mcall	800073dc <print+0x8>
}
800073da:	d8 02       	popm	pc
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	72 b8       	ld.w	r8,r9[0x2c]

800073e0 <print_dbg>:
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
}


void print_dbg(const char *str)
{
800073e0:	d4 01       	pushm	lr
  // Redirection to the debug USART.
  print(DBG_USART, str);
800073e2:	18 9b       	mov	r11,r12
800073e4:	fe 7c 14 00 	mov	r12,-60416
800073e8:	f0 1f 00 02 	mcall	800073f0 <print_dbg+0x10>
}
800073ec:	d8 02       	popm	pc
800073ee:	00 00       	add	r0,r0
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	73 d4       	ld.w	r4,r9[0x74]

800073f4 <init_dbg_rs232_ex>:
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
}


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
800073f4:	eb cd 40 80 	pushm	r7,lr
800073f8:	20 3d       	sub	sp,12
800073fa:	16 97       	mov	r7,r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
800073fc:	50 0c       	stdsp	sp[0x0],r12
800073fe:	30 88       	mov	r8,8
80007400:	ba c8       	st.b	sp[0x4],r8
80007402:	30 48       	mov	r8,4
80007404:	ba d8       	st.b	sp[0x5],r8
80007406:	30 08       	mov	r8,0
80007408:	ba 38       	st.h	sp[0x6],r8
8000740a:	fb 68 00 08 	st.b	sp[8],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
8000740e:	30 2b       	mov	r11,2
80007410:	48 6c       	lddpc	r12,80007428 <init_dbg_rs232_ex+0x34>
80007412:	f0 1f 00 07 	mcall	8000742c <init_dbg_rs232_ex+0x38>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
80007416:	0e 9a       	mov	r10,r7
80007418:	1a 9b       	mov	r11,sp
8000741a:	fe 7c 14 00 	mov	r12,-60416
8000741e:	f0 1f 00 05 	mcall	80007430 <init_dbg_rs232_ex+0x3c>
}
80007422:	2f dd       	sub	sp,-12
80007424:	e3 cd 80 80 	ldm	sp++,r7,pc
80007428:	80 01       	ld.sh	r1,r0[0x0]
8000742a:	e5 18 80 00 	ld.uh	r8,r2[-32768]
8000742e:	6c 04       	ld.w	r4,r6[0x0]
80007430:	80 00       	ld.sh	r0,r0[0x0]
80007432:	73 08       	ld.w	r8,r9[0x40]

80007434 <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
80007434:	d4 01       	pushm	lr
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
80007436:	18 9b       	mov	r11,r12
80007438:	e0 6c e1 00 	mov	r12,57600
8000743c:	f0 1f 00 02 	mcall	80007444 <init_dbg_rs232+0x10>
}
80007440:	d8 02       	popm	pc
80007442:	00 00       	add	r0,r0
80007444:	80 00       	ld.sh	r0,r0[0x0]
80007446:	73 f4       	ld.w	r4,r9[0x7c]

80007448 <jpeg_abort>:
 * responsibility.
 */

GLOBAL(void)
jpeg_abort (j_common_ptr cinfo)
{
80007448:	eb cd 40 80 	pushm	r7,lr
8000744c:	18 97       	mov	r7,r12
  int pool;

  /* Do nothing if called on a not-initialized or destroyed JPEG object. */
  if (cinfo->mem == NULL)
8000744e:	78 18       	ld.w	r8,r12[0x4]
80007450:	58 08       	cp.w	r8,0
80007452:	c0 f1       	brne	80007470 <jpeg_abort+0x28>
80007454:	e3 cd 80 80 	ldm	sp++,r7,pc
    (*cinfo->mem->free_pool) (cinfo, pool);
  }

  /* Reset overall state for possible reuse of object */
  if (cinfo->is_decompressor) {
    cinfo->global_state = DSTATE_START;
80007458:	e0 68 00 c8 	mov	r8,200
8000745c:	8f 58       	st.w	r7[0x14],r8
    /* Try to keep application from accessing now-deleted marker list.
     * A bit kludgy to do it here, but this is the most central place.
     */
    ((j_decompress_ptr) cinfo)->marker_list = NULL;
8000745e:	30 08       	mov	r8,0
80007460:	ef 48 01 30 	st.w	r7[304],r8
80007464:	e3 cd 80 80 	ldm	sp++,r7,pc
  } else {
    cinfo->global_state = CSTATE_START;
80007468:	36 48       	mov	r8,100
8000746a:	8f 58       	st.w	r7[0x14],r8
8000746c:	e3 cd 80 80 	ldm	sp++,r7,pc

  /* Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
    (*cinfo->mem->free_pool) (cinfo, pool);
80007470:	70 98       	ld.w	r8,r8[0x24]
80007472:	30 1b       	mov	r11,1
80007474:	5d 18       	icall	r8
  }

  /* Reset overall state for possible reuse of object */
  if (cinfo->is_decompressor) {
80007476:	6e 48       	ld.w	r8,r7[0x10]
80007478:	58 08       	cp.w	r8,0
8000747a:	cf 70       	breq	80007468 <jpeg_abort+0x20>
8000747c:	ce eb       	rjmp	80007458 <jpeg_abort+0x10>

8000747e <jpeg_destroy>:
 * responsibility.
 */

GLOBAL(void)
jpeg_destroy (j_common_ptr cinfo)
{
8000747e:	eb cd 40 80 	pushm	r7,lr
80007482:	18 97       	mov	r7,r12
  /* We need only tell the memory manager to release everything. */
  /* NB: mem pointer is NULL if memory mgr failed to initialize. */
  if (cinfo->mem != NULL)
80007484:	78 18       	ld.w	r8,r12[0x4]
80007486:	58 08       	cp.w	r8,0
80007488:	c0 30       	breq	8000748e <jpeg_destroy+0x10>
    (*cinfo->mem->self_destruct) (cinfo);
8000748a:	70 a8       	ld.w	r8,r8[0x28]
8000748c:	5d 18       	icall	r8
  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
8000748e:	30 08       	mov	r8,0
80007490:	8f 18       	st.w	r7[0x4],r8
  cinfo->global_state = 0;	/* mark it destroyed */
80007492:	8f 58       	st.w	r7[0x14],r8
}
80007494:	e3 cd 80 80 	ldm	sp++,r7,pc

80007498 <jpeg_alloc_quant_table>:
 * (Would jutils.c be a more reasonable place to put these?)
 */

GLOBAL(JQUANT_TBL *)
jpeg_alloc_quant_table (j_common_ptr cinfo)
{
80007498:	d4 01       	pushm	lr
  JQUANT_TBL *tbl;

  tbl = (JQUANT_TBL *)
8000749a:	78 18       	ld.w	r8,r12[0x4]
8000749c:	70 08       	ld.w	r8,r8[0x0]
8000749e:	e0 6a 00 84 	mov	r10,132
800074a2:	30 0b       	mov	r11,0
800074a4:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
800074a6:	30 09       	mov	r9,0
800074a8:	f9 49 00 80 	st.w	r12[128],r9
  return tbl;
}
800074ac:	d8 02       	popm	pc

800074ae <jpeg_alloc_huff_table>:


GLOBAL(JHUFF_TBL *)
jpeg_alloc_huff_table (j_common_ptr cinfo)
{
800074ae:	d4 01       	pushm	lr
  JHUFF_TBL *tbl;

  tbl = (JHUFF_TBL *)
800074b0:	78 18       	ld.w	r8,r12[0x4]
800074b2:	70 08       	ld.w	r8,r8[0x0]
800074b4:	e0 6a 01 18 	mov	r10,280
800074b8:	30 0b       	mov	r11,0
800074ba:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
800074bc:	30 09       	mov	r9,0
800074be:	f9 49 01 14 	st.w	r12[276],r9
  return tbl;
}
800074c2:	d8 02       	popm	pc

800074c4 <jpeg_consume_input>:
 * method.
 */

GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
800074c4:	eb cd 40 c0 	pushm	r6-r7,lr
800074c8:	18 97       	mov	r7,r12
  int retcode = JPEG_SUSPENDED;

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo->global_state) {
800074ca:	78 58       	ld.w	r8,r12[0x14]
800074cc:	e0 48 00 ca 	cp.w	r8,202
800074d0:	c1 40       	breq	800074f8 <jpeg_consume_input+0x34>
800074d2:	e0 89 00 0a 	brgt	800074e6 <jpeg_consume_input+0x22>
800074d6:	e0 48 00 c8 	cp.w	r8,200
800074da:	c1 10       	breq	800074fc <jpeg_consume_input+0x38>
800074dc:	e0 48 00 c9 	cp.w	r8,201
800074e0:	e0 81 00 e8 	brne	800076b0 <jpeg_consume_input+0x1ec>
800074e4:	c1 78       	rjmp	80007512 <jpeg_consume_input+0x4e>
800074e6:	e0 48 00 d0 	cp.w	r8,208
800074ea:	e0 8a 00 dc 	brle	800076a2 <jpeg_consume_input+0x1de>
800074ee:	e0 48 00 d2 	cp.w	r8,210
800074f2:	e0 81 00 df 	brne	800076b0 <jpeg_consume_input+0x1ec>
800074f6:	cd 68       	rjmp	800076a2 <jpeg_consume_input+0x1de>
800074f8:	30 16       	mov	r6,1
800074fa:	ce 68       	rjmp	800076c6 <jpeg_consume_input+0x202>
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo->inputctl->reset_input_controller) (cinfo);
800074fc:	f8 f8 01 b4 	ld.w	r8,r12[436]
80007500:	70 18       	ld.w	r8,r8[0x4]
80007502:	5d 18       	icall	r8
    /* Initialize application's data source module */
    (*cinfo->src->init_source) (cinfo);
80007504:	6e 68       	ld.w	r8,r7[0x18]
80007506:	70 28       	ld.w	r8,r8[0x8]
80007508:	0e 9c       	mov	r12,r7
8000750a:	5d 18       	icall	r8
    cinfo->global_state = DSTATE_INHEADER;
8000750c:	e0 68 00 c9 	mov	r8,201
80007510:	8f 58       	st.w	r7[0x14],r8
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
80007512:	ee f8 01 b4 	ld.w	r8,r7[436]
80007516:	70 08       	ld.w	r8,r8[0x0]
80007518:	0e 9c       	mov	r12,r7
8000751a:	5d 18       	icall	r8
8000751c:	18 96       	mov	r6,r12
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
8000751e:	58 1c       	cp.w	r12,1
80007520:	e0 81 00 d3 	brne	800076c6 <jpeg_consume_input+0x202>
default_decompress_parms (j_decompress_ptr cinfo)
{
  /* Guess the input colorspace, and set output colorspace accordingly. */
  /* (Wish JPEG committee had provided a real way to specify this...) */
  /* Note application may override our guesses. */
  switch (cinfo->num_components) {
80007524:	6e 98       	ld.w	r8,r7[0x24]
80007526:	58 38       	cp.w	r8,3
80007528:	c0 90       	breq	8000753a <jpeg_consume_input+0x76>
8000752a:	58 48       	cp.w	r8,4
8000752c:	c6 50       	breq	800075f6 <jpeg_consume_input+0x132>
8000752e:	58 18       	cp.w	r8,1
80007530:	e0 81 00 8c 	brne	80007648 <jpeg_consume_input+0x184>
  case 1:
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
80007534:	8f a8       	st.w	r7[0x28],r8
    cinfo->out_color_space = JCS_GRAYSCALE;
80007536:	8f b8       	st.w	r7[0x2c],r8
80007538:	c8 b8       	rjmp	8000764e <jpeg_consume_input+0x18a>
    break;

  case 3:
    if (cinfo->saw_JFIF_marker) {
8000753a:	ee f8 01 18 	ld.w	r8,r7[280]
8000753e:	58 08       	cp.w	r8,0
80007540:	c0 40       	breq	80007548 <jpeg_consume_input+0x84>
      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
80007542:	30 38       	mov	r8,3
80007544:	8f a8       	st.w	r7[0x28],r8
80007546:	c5 58       	rjmp	800075f0 <jpeg_consume_input+0x12c>
    } else if (cinfo->saw_Adobe_marker) {
80007548:	ee f8 01 24 	ld.w	r8,r7[292]
8000754c:	58 08       	cp.w	r8,0
8000754e:	c2 10       	breq	80007590 <jpeg_consume_input+0xcc>
      switch (cinfo->Adobe_transform) {
80007550:	ef 38 01 28 	ld.ub	r8,r7[296]
80007554:	30 09       	mov	r9,0
80007556:	f2 08 18 00 	cp.b	r8,r9
8000755a:	c0 60       	breq	80007566 <jpeg_consume_input+0xa2>
8000755c:	30 19       	mov	r9,1
8000755e:	f2 08 18 00 	cp.b	r8,r9
80007562:	c0 81       	brne	80007572 <jpeg_consume_input+0xae>
80007564:	c0 48       	rjmp	8000756c <jpeg_consume_input+0xa8>
      case 0:
	cinfo->jpeg_color_space = JCS_RGB;
80007566:	30 28       	mov	r8,2
80007568:	8f a8       	st.w	r7[0x28],r8
8000756a:	c4 38       	rjmp	800075f0 <jpeg_consume_input+0x12c>
	break;
      case 1:
	cinfo->jpeg_color_space = JCS_YCbCr;
8000756c:	30 38       	mov	r8,3
8000756e:	8f a8       	st.w	r7[0x28],r8
80007570:	c4 08       	rjmp	800075f0 <jpeg_consume_input+0x12c>
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
80007572:	6e 08       	ld.w	r8,r7[0x0]
80007574:	37 29       	mov	r9,114
80007576:	91 59       	st.w	r8[0x14],r9
80007578:	6e 08       	ld.w	r8,r7[0x0]
8000757a:	ef 39 01 28 	ld.ub	r9,r7[296]
8000757e:	91 69       	st.w	r8[0x18],r9
80007580:	6e 08       	ld.w	r8,r7[0x0]
80007582:	70 18       	ld.w	r8,r8[0x4]
80007584:	3f fb       	mov	r11,-1
80007586:	0e 9c       	mov	r12,r7
80007588:	5d 18       	icall	r8
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
8000758a:	30 38       	mov	r8,3
8000758c:	8f a8       	st.w	r7[0x28],r8
8000758e:	c3 18       	rjmp	800075f0 <jpeg_consume_input+0x12c>
	break;
      }
    } else {
      /* Saw no special markers, try to guess from the component IDs */
      int cid0 = cinfo->comp_info[0].component_id;
80007590:	ee f8 00 d8 	ld.w	r8,r7[216]
80007594:	70 0a       	ld.w	r10,r8[0x0]
      int cid1 = cinfo->comp_info[1].component_id;
80007596:	71 59       	ld.w	r9,r8[0x54]
      int cid2 = cinfo->comp_info[2].component_id;
80007598:	f0 f8 00 a8 	ld.w	r8,r8[168]

      if (cid0 == 1 && cid1 == 2 && cid2 == 3)
8000759c:	58 1a       	cp.w	r10,1
8000759e:	5f 0c       	sreq	r12
800075a0:	58 29       	cp.w	r9,2
800075a2:	5f 0b       	sreq	r11
800075a4:	f9 eb 00 0b 	and	r11,r12,r11
800075a8:	c0 50       	breq	800075b2 <jpeg_consume_input+0xee>
800075aa:	58 38       	cp.w	r8,3
800075ac:	c0 31       	brne	800075b2 <jpeg_consume_input+0xee>
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
800075ae:	8f a8       	st.w	r7[0x28],r8
800075b0:	c2 08       	rjmp	800075f0 <jpeg_consume_input+0x12c>
      else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
800075b2:	e0 4a 00 52 	cp.w	r10,82
800075b6:	5f 0c       	sreq	r12
800075b8:	e0 49 00 47 	cp.w	r9,71
800075bc:	5f 0b       	sreq	r11
800075be:	f9 eb 00 0b 	and	r11,r12,r11
800075c2:	c0 70       	breq	800075d0 <jpeg_consume_input+0x10c>
800075c4:	e0 48 00 42 	cp.w	r8,66
800075c8:	c0 41       	brne	800075d0 <jpeg_consume_input+0x10c>
	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
800075ca:	30 28       	mov	r8,2
800075cc:	8f a8       	st.w	r7[0x28],r8
800075ce:	c1 18       	rjmp	800075f0 <jpeg_consume_input+0x12c>
      else {
	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
800075d0:	6e 0c       	ld.w	r12,r7[0x0]
800075d2:	f8 cb ff e8 	sub	r11,r12,-24
800075d6:	99 6a       	st.w	r12[0x18],r10
800075d8:	97 19       	st.w	r11[0x4],r9
800075da:	97 28       	st.w	r11[0x8],r8
800075dc:	6e 08       	ld.w	r8,r7[0x0]
800075de:	36 f9       	mov	r9,111
800075e0:	91 59       	st.w	r8[0x14],r9
800075e2:	6e 08       	ld.w	r8,r7[0x0]
800075e4:	70 18       	ld.w	r8,r8[0x4]
800075e6:	30 1b       	mov	r11,1
800075e8:	0e 9c       	mov	r12,r7
800075ea:	5d 18       	icall	r8
	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
800075ec:	30 38       	mov	r8,3
800075ee:	8f a8       	st.w	r7[0x28],r8
      }
    }
    /* Always guess RGB is proper output colorspace. */
    cinfo->out_color_space = JCS_RGB;
800075f0:	30 28       	mov	r8,2
800075f2:	8f b8       	st.w	r7[0x2c],r8
800075f4:	c2 d8       	rjmp	8000764e <jpeg_consume_input+0x18a>
    break;

  case 4:
    if (cinfo->saw_Adobe_marker) {
800075f6:	ee f8 01 24 	ld.w	r8,r7[292]
800075fa:	58 08       	cp.w	r8,0
800075fc:	c2 10       	breq	8000763e <jpeg_consume_input+0x17a>
      switch (cinfo->Adobe_transform) {
800075fe:	ef 38 01 28 	ld.ub	r8,r7[296]
80007602:	30 09       	mov	r9,0
80007604:	f2 08 18 00 	cp.b	r8,r9
80007608:	c0 60       	breq	80007614 <jpeg_consume_input+0x150>
8000760a:	30 29       	mov	r9,2
8000760c:	f2 08 18 00 	cp.b	r8,r9
80007610:	c0 81       	brne	80007620 <jpeg_consume_input+0x15c>
80007612:	c0 48       	rjmp	8000761a <jpeg_consume_input+0x156>
      case 0:
	cinfo->jpeg_color_space = JCS_CMYK;
80007614:	30 48       	mov	r8,4
80007616:	8f a8       	st.w	r7[0x28],r8
80007618:	c1 58       	rjmp	80007642 <jpeg_consume_input+0x17e>
	break;
      case 2:
	cinfo->jpeg_color_space = JCS_YCCK;
8000761a:	30 58       	mov	r8,5
8000761c:	8f a8       	st.w	r7[0x28],r8
8000761e:	c1 28       	rjmp	80007642 <jpeg_consume_input+0x17e>
	break;
      default:
	WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
80007620:	6e 08       	ld.w	r8,r7[0x0]
80007622:	37 29       	mov	r9,114
80007624:	91 59       	st.w	r8[0x14],r9
80007626:	6e 08       	ld.w	r8,r7[0x0]
80007628:	ef 39 01 28 	ld.ub	r9,r7[296]
8000762c:	91 69       	st.w	r8[0x18],r9
8000762e:	6e 08       	ld.w	r8,r7[0x0]
80007630:	70 18       	ld.w	r8,r8[0x4]
80007632:	3f fb       	mov	r11,-1
80007634:	0e 9c       	mov	r12,r7
80007636:	5d 18       	icall	r8
	cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
80007638:	30 58       	mov	r8,5
8000763a:	8f a8       	st.w	r7[0x28],r8
8000763c:	c0 38       	rjmp	80007642 <jpeg_consume_input+0x17e>
	break;
      }
    } else {
      /* No special markers, assume straight CMYK. */
      cinfo->jpeg_color_space = JCS_CMYK;
8000763e:	30 48       	mov	r8,4
80007640:	8f a8       	st.w	r7[0x28],r8
    }
    cinfo->out_color_space = JCS_CMYK;
80007642:	30 48       	mov	r8,4
80007644:	8f b8       	st.w	r7[0x2c],r8
80007646:	c0 48       	rjmp	8000764e <jpeg_consume_input+0x18a>
    break;

  default:
    cinfo->jpeg_color_space = JCS_UNKNOWN;
80007648:	30 08       	mov	r8,0
8000764a:	8f a8       	st.w	r7[0x28],r8
    cinfo->out_color_space = JCS_UNKNOWN;
8000764c:	8f b8       	st.w	r7[0x2c],r8
    break;
  }

  /* Set defaults for other decompression parameters. */
  cinfo->scale_num = 1;		/* 1:1 scaling */
8000764e:	30 19       	mov	r9,1
80007650:	8f c9       	st.w	r7[0x30],r9
  cinfo->scale_denom = 1;
80007652:	8f d9       	st.w	r7[0x34],r9
  cinfo->output_gamma = 1.0;
80007654:	30 0a       	mov	r10,0
80007656:	fc 1b 3f f0 	movh	r11,0x3ff0
8000765a:	ee eb 00 38 	st.d	r7[56],r10
  cinfo->buffered_image = FALSE;
8000765e:	30 08       	mov	r8,0
80007660:	ef 48 00 40 	st.w	r7[64],r8
  cinfo->raw_data_out = FALSE;
80007664:	ef 48 00 44 	st.w	r7[68],r8
  cinfo->dct_method = JDCT_DEFAULT;
80007668:	ef 48 00 48 	st.w	r7[72],r8
  cinfo->do_fancy_upsampling = TRUE;
8000766c:	ef 49 00 4c 	st.w	r7[76],r9
  cinfo->do_block_smoothing = TRUE;
80007670:	ef 49 00 50 	st.w	r7[80],r9
  cinfo->quantize_colors = FALSE;
80007674:	ef 48 00 54 	st.w	r7[84],r8
  /* We set these in case application only sets quantize_colors. */
  cinfo->dither_mode = JDITHER_FS;
80007678:	30 2a       	mov	r10,2
8000767a:	ef 4a 00 58 	st.w	r7[88],r10
#ifdef QUANT_2PASS_SUPPORTED
  cinfo->two_pass_quantize = TRUE;
8000767e:	ef 49 00 5c 	st.w	r7[92],r9
#else
  cinfo->two_pass_quantize = FALSE;
#endif
  cinfo->desired_number_of_colors = 256;
80007682:	e0 69 01 00 	mov	r9,256
80007686:	ef 49 00 60 	st.w	r7[96],r9
  cinfo->colormap = NULL;
8000768a:	ef 48 00 88 	st.w	r7[136],r8
  /* Initialize for no mode change in buffered-image mode. */
  cinfo->enable_1pass_quant = FALSE;
8000768e:	ef 48 00 64 	st.w	r7[100],r8
  cinfo->enable_external_quant = FALSE;
80007692:	ef 48 00 68 	st.w	r7[104],r8
  cinfo->enable_2pass_quant = FALSE;
80007696:	ef 48 00 6c 	st.w	r7[108],r8
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
      /* Set global state: ready for start_decompress */
      cinfo->global_state = DSTATE_READY;
8000769a:	e0 68 00 ca 	mov	r8,202
8000769e:	8f 58       	st.w	r7[0x14],r8
800076a0:	c1 38       	rjmp	800076c6 <jpeg_consume_input+0x202>
  case DSTATE_SCANNING:
  case DSTATE_RAW_OK:
  case DSTATE_BUFIMAGE:
  case DSTATE_BUFPOST:
  case DSTATE_STOPPING:
    retcode = (*cinfo->inputctl->consume_input) (cinfo);
800076a2:	ee f8 01 b4 	ld.w	r8,r7[436]
800076a6:	70 08       	ld.w	r8,r8[0x0]
800076a8:	0e 9c       	mov	r12,r7
800076aa:	5d 18       	icall	r8
800076ac:	18 96       	mov	r6,r12
    break;
800076ae:	c0 c8       	rjmp	800076c6 <jpeg_consume_input+0x202>
  default:
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
800076b0:	6e 08       	ld.w	r8,r7[0x0]
800076b2:	31 49       	mov	r9,20
800076b4:	91 59       	st.w	r8[0x14],r9
800076b6:	6e 08       	ld.w	r8,r7[0x0]
800076b8:	6e 59       	ld.w	r9,r7[0x14]
800076ba:	91 69       	st.w	r8[0x18],r9
800076bc:	6e 08       	ld.w	r8,r7[0x0]
800076be:	70 08       	ld.w	r8,r8[0x0]
800076c0:	0e 9c       	mov	r12,r7
800076c2:	5d 18       	icall	r8
800076c4:	30 06       	mov	r6,0
  }
  return retcode;
}
800076c6:	0c 9c       	mov	r12,r6
800076c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800076cc <jpeg_finish_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
800076cc:	eb cd 40 80 	pushm	r7,lr
800076d0:	18 97       	mov	r7,r12
  if ((cinfo->global_state == DSTATE_SCANNING ||
800076d2:	78 58       	ld.w	r8,r12[0x14]
800076d4:	f0 c9 00 cd 	sub	r9,r8,205
800076d8:	58 19       	cp.w	r9,1
800076da:	e0 8b 00 19 	brhi	8000770c <jpeg_finish_decompress+0x40>
       cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
800076de:	79 09       	ld.w	r9,r12[0x40]
800076e0:	58 09       	cp.w	r9,0
800076e2:	c1 51       	brne	8000770c <jpeg_finish_decompress+0x40>
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
800076e4:	f8 f9 00 8c 	ld.w	r9,r12[140]
800076e8:	79 d8       	ld.w	r8,r12[0x74]
800076ea:	10 39       	cp.w	r9,r8
800076ec:	c0 72       	brcc	800076fa <jpeg_finish_decompress+0x2e>
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
800076ee:	78 08       	ld.w	r8,r12[0x0]
800076f0:	34 39       	mov	r9,67
800076f2:	91 59       	st.w	r8[0x14],r9
800076f4:	78 08       	ld.w	r8,r12[0x0]
800076f6:	70 08       	ld.w	r8,r8[0x0]
800076f8:	5d 18       	icall	r8
    (*cinfo->master->finish_output_pass) (cinfo);
800076fa:	ee f8 01 a4 	ld.w	r8,r7[420]
800076fe:	70 18       	ld.w	r8,r8[0x4]
80007700:	0e 9c       	mov	r12,r7
80007702:	5d 18       	icall	r8
    cinfo->global_state = DSTATE_STOPPING;
80007704:	e0 68 00 d2 	mov	r8,210
80007708:	8f 58       	st.w	r7[0x14],r8
 */

GLOBAL(boolean)
jpeg_finish_decompress (j_decompress_ptr cinfo)
{
  if ((cinfo->global_state == DSTATE_SCANNING ||
8000770a:	c1 a8       	rjmp	8000773e <jpeg_finish_decompress+0x72>
    /* Terminate final pass of non-buffered mode */
    if (cinfo->output_scanline < cinfo->output_height)
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
    (*cinfo->master->finish_output_pass) (cinfo);
    cinfo->global_state = DSTATE_STOPPING;
  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
8000770c:	e0 48 00 cf 	cp.w	r8,207
80007710:	c0 51       	brne	8000771a <jpeg_finish_decompress+0x4e>
    /* Finishing after a buffered-image operation */
    cinfo->global_state = DSTATE_STOPPING;
80007712:	e0 68 00 d2 	mov	r8,210
80007716:	8f 58       	st.w	r7[0x14],r8
80007718:	c1 38       	rjmp	8000773e <jpeg_finish_decompress+0x72>
  } else if (cinfo->global_state != DSTATE_STOPPING) {
8000771a:	e0 48 00 d2 	cp.w	r8,210
8000771e:	c1 00       	breq	8000773e <jpeg_finish_decompress+0x72>
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
80007720:	6e 08       	ld.w	r8,r7[0x0]
80007722:	31 49       	mov	r9,20
80007724:	91 59       	st.w	r8[0x14],r9
80007726:	6e 08       	ld.w	r8,r7[0x0]
80007728:	6e 59       	ld.w	r9,r7[0x14]
8000772a:	91 69       	st.w	r8[0x18],r9
8000772c:	6e 08       	ld.w	r8,r7[0x0]
8000772e:	70 08       	ld.w	r8,r8[0x0]
80007730:	0e 9c       	mov	r12,r7
80007732:	5d 18       	icall	r8
80007734:	c0 58       	rjmp	8000773e <jpeg_finish_decompress+0x72>
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
80007736:	70 08       	ld.w	r8,r8[0x0]
80007738:	0e 9c       	mov	r12,r7
8000773a:	5d 18       	icall	r8
8000773c:	c0 e0       	breq	80007758 <jpeg_finish_decompress+0x8c>
  } else if (cinfo->global_state != DSTATE_STOPPING) {
    /* STOPPING = repeat call after a suspension, anything else is error */
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  }
  /* Read until EOI */
  while (! cinfo->inputctl->eoi_reached) {
8000773e:	ee f8 01 b4 	ld.w	r8,r7[436]
80007742:	70 59       	ld.w	r9,r8[0x14]
80007744:	58 09       	cp.w	r9,0
80007746:	cf 80       	breq	80007736 <jpeg_finish_decompress+0x6a>
    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
      return FALSE;		/* Suspend, come back later */
  }
  /* Do final cleanup */
  (*cinfo->src->term_source) (cinfo);
80007748:	6e 68       	ld.w	r8,r7[0x18]
8000774a:	70 68       	ld.w	r8,r8[0x18]
8000774c:	0e 9c       	mov	r12,r7
8000774e:	5d 18       	icall	r8
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
80007750:	0e 9c       	mov	r12,r7
80007752:	f0 1f 00 03 	mcall	8000775c <jpeg_finish_decompress+0x90>
80007756:	30 1c       	mov	r12,1
  return TRUE;
}
80007758:	e3 cd 80 80 	ldm	sp++,r7,pc
8000775c:	80 00       	ld.sh	r0,r0[0x0]
8000775e:	74 48       	ld.w	r8,r10[0x10]

80007760 <jpeg_read_header>:
 * extra error checking.
 */

GLOBAL(int)
jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
{
80007760:	eb cd 40 e0 	pushm	r5-r7,lr
80007764:	18 97       	mov	r7,r12
80007766:	16 95       	mov	r5,r11
  int retcode;

  if (cinfo->global_state != DSTATE_START &&
80007768:	78 58       	ld.w	r8,r12[0x14]
8000776a:	f0 c8 00 c8 	sub	r8,r8,200
8000776e:	58 18       	cp.w	r8,1
80007770:	e0 88 00 0b 	brls	80007786 <jpeg_read_header+0x26>
      cinfo->global_state != DSTATE_INHEADER)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
80007774:	78 08       	ld.w	r8,r12[0x0]
80007776:	31 49       	mov	r9,20
80007778:	91 59       	st.w	r8[0x14],r9
8000777a:	78 08       	ld.w	r8,r12[0x0]
8000777c:	78 59       	ld.w	r9,r12[0x14]
8000777e:	91 69       	st.w	r8[0x18],r9
80007780:	78 08       	ld.w	r8,r12[0x0]
80007782:	70 08       	ld.w	r8,r8[0x0]
80007784:	5d 18       	icall	r8

  retcode = jpeg_consume_input(cinfo);
80007786:	0e 9c       	mov	r12,r7
80007788:	f0 1f 00 0a 	mcall	800077b0 <jpeg_read_header+0x50>
8000778c:	18 96       	mov	r6,r12

  switch (retcode) {
8000778e:	58 2c       	cp.w	r12,2
80007790:	c0 d1       	brne	800077aa <jpeg_read_header+0x4a>
  case JPEG_REACHED_SOS:
    retcode = JPEG_HEADER_OK;
    break;
  case JPEG_REACHED_EOI:
    if (require_image)		/* Complain if application wanted an image */
80007792:	58 05       	cp.w	r5,0
80007794:	c0 80       	breq	800077a4 <jpeg_read_header+0x44>
      ERREXIT(cinfo, JERR_NO_IMAGE);
80007796:	6e 08       	ld.w	r8,r7[0x0]
80007798:	33 39       	mov	r9,51
8000779a:	91 59       	st.w	r8[0x14],r9
8000779c:	6e 08       	ld.w	r8,r7[0x0]
8000779e:	70 08       	ld.w	r8,r8[0x0]
800077a0:	0e 9c       	mov	r12,r7
800077a2:	5d 18       	icall	r8
    /* Reset to start state; it would be safer to require the application to
     * call jpeg_abort, but we can't change it now for compatibility reasons.
     * A side effect is to free any temporary memory (there shouldn't be any).
     */
    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
800077a4:	0e 9c       	mov	r12,r7
800077a6:	f0 1f 00 04 	mcall	800077b4 <jpeg_read_header+0x54>
    /* no work */
    break;
  }

  return retcode;
}
800077aa:	0c 9c       	mov	r12,r6
800077ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800077b0:	80 00       	ld.sh	r0,r0[0x0]
800077b2:	74 c4       	ld.w	r4,r10[0x30]
800077b4:	80 00       	ld.sh	r0,r0[0x0]
800077b6:	74 48       	ld.w	r8,r10[0x10]

800077b8 <jpeg_abort_decompress>:
 * but don't destroy the object itself.
 */

GLOBAL(void)
jpeg_abort_decompress (j_decompress_ptr cinfo)
{
800077b8:	d4 01       	pushm	lr
  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
800077ba:	f0 1f 00 02 	mcall	800077c0 <jpeg_abort_decompress+0x8>
}
800077be:	d8 02       	popm	pc
800077c0:	80 00       	ld.sh	r0,r0[0x0]
800077c2:	74 48       	ld.w	r8,r10[0x10]

800077c4 <jpeg_destroy_decompress>:
 * Destruction of a JPEG decompression object
 */

GLOBAL(void)
jpeg_destroy_decompress (j_decompress_ptr cinfo)
{
800077c4:	d4 01       	pushm	lr
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
800077c6:	f0 1f 00 02 	mcall	800077cc <jpeg_destroy_decompress+0x8>
}
800077ca:	d8 02       	popm	pc
800077cc:	80 00       	ld.sh	r0,r0[0x0]
800077ce:	74 7e       	ld.w	lr,r10[0x1c]

800077d0 <jpeg_CreateDecompress>:
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
{
800077d0:	eb cd 40 e0 	pushm	r5-r7,lr
800077d4:	18 97       	mov	r7,r12
800077d6:	14 96       	mov	r6,r10
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
800077d8:	30 08       	mov	r8,0
800077da:	99 18       	st.w	r12[0x4],r8
  if (version != JPEG_LIB_VERSION)
800077dc:	e0 4b 00 3e 	cp.w	r11,62
800077e0:	c0 c0       	breq	800077f8 <jpeg_CreateDecompress+0x28>
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
800077e2:	78 08       	ld.w	r8,r12[0x0]
800077e4:	30 c9       	mov	r9,12
800077e6:	91 59       	st.w	r8[0x14],r9
800077e8:	78 08       	ld.w	r8,r12[0x0]
800077ea:	33 e9       	mov	r9,62
800077ec:	91 69       	st.w	r8[0x18],r9
800077ee:	78 08       	ld.w	r8,r12[0x0]
800077f0:	91 7b       	st.w	r8[0x1c],r11
800077f2:	78 08       	ld.w	r8,r12[0x0]
800077f4:	70 08       	ld.w	r8,r8[0x0]
800077f6:	5d 18       	icall	r8
  if (structsize != SIZEOF(struct jpeg_decompress_struct))
800077f8:	e0 46 01 d0 	cp.w	r6,464
800077fc:	c0 e0       	breq	80007818 <jpeg_CreateDecompress+0x48>
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,
800077fe:	6e 08       	ld.w	r8,r7[0x0]
80007800:	31 59       	mov	r9,21
80007802:	91 59       	st.w	r8[0x14],r9
80007804:	6e 08       	ld.w	r8,r7[0x0]
80007806:	e0 69 01 d0 	mov	r9,464
8000780a:	91 69       	st.w	r8[0x18],r9
8000780c:	6e 08       	ld.w	r8,r7[0x0]
8000780e:	91 76       	st.w	r8[0x1c],r6
80007810:	6e 08       	ld.w	r8,r7[0x0]
80007812:	70 08       	ld.w	r8,r8[0x0]
80007814:	0e 9c       	mov	r12,r7
80007816:	5d 18       	icall	r8
   * client_data, so we have to save and restore those fields.
   * Note: if application hasn't set client_data, tools like Purify may
   * complain here.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
80007818:	6e 06       	ld.w	r6,r7[0x0]
    void * client_data = cinfo->client_data; /* ignore Purify complaint here */
8000781a:	6e 35       	ld.w	r5,r7[0xc]
    MEMZERO(cinfo, SIZEOF(struct jpeg_decompress_struct));
8000781c:	e0 6a 01 d0 	mov	r10,464
80007820:	30 0b       	mov	r11,0
80007822:	0e 9c       	mov	r12,r7
80007824:	f0 1f 00 16 	mcall	8000787c <jpeg_CreateDecompress+0xac>
    cinfo->err = err;
80007828:	8f 06       	st.w	r7[0x0],r6
    cinfo->client_data = client_data;
8000782a:	8f 35       	st.w	r7[0xc],r5
  }
  cinfo->is_decompressor = TRUE;
8000782c:	30 18       	mov	r8,1
8000782e:	8f 48       	st.w	r7[0x10],r8

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);
80007830:	0e 9c       	mov	r12,r7
80007832:	f0 1f 00 14 	mcall	80007880 <jpeg_CreateDecompress+0xb0>

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
80007836:	30 09       	mov	r9,0
80007838:	8f 29       	st.w	r7[0x8],r9
  cinfo->src = NULL;
8000783a:	8f 69       	st.w	r7[0x18],r9

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;
8000783c:	ef 49 00 a4 	st.w	r7[164],r9
80007840:	ef 49 00 a8 	st.w	r7[168],r9
80007844:	ef 49 00 ac 	st.w	r7[172],r9
80007848:	ef 49 00 b0 	st.w	r7[176],r9
8000784c:	ee c8 ff 4c 	sub	r8,r7,-180

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
80007850:	12 9a       	mov	r10,r9
80007852:	91 0a       	st.w	r8[0x0],r10
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
80007854:	91 4a       	st.w	r8[0x10],r10
  cinfo->src = NULL;

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
80007856:	2f f9       	sub	r9,-1
80007858:	2f c8       	sub	r8,-4
8000785a:	58 49       	cp.w	r9,4
8000785c:	cf b1       	brne	80007852 <jpeg_CreateDecompress+0x82>
  }

  /* Initialize marker processor so application can override methods
   * for COM, APPn markers before calling jpeg_read_header.
   */
  cinfo->marker_list = NULL;
8000785e:	30 08       	mov	r8,0
80007860:	ef 48 01 30 	st.w	r7[304],r8
  jinit_marker_reader(cinfo);
80007864:	0e 9c       	mov	r12,r7
80007866:	f0 1f 00 08 	mcall	80007884 <jpeg_CreateDecompress+0xb4>

  /* And initialize the overall input controller. */
  jinit_input_controller(cinfo);
8000786a:	0e 9c       	mov	r12,r7
8000786c:	f0 1f 00 07 	mcall	80007888 <jpeg_CreateDecompress+0xb8>

  /* OK, I'm ready */
  cinfo->global_state = DSTATE_START;
80007870:	e0 68 00 c8 	mov	r8,200
80007874:	8f 58       	st.w	r7[0x14],r8
}
80007876:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000787a:	00 00       	add	r0,r0
8000787c:	80 01       	ld.sh	r1,r0[0x0]
8000787e:	56 02       	stdsp	sp[0x180],r2
80007880:	80 00       	ld.sh	r0,r0[0x0]
80007882:	dd 7c       	*unknown*
80007884:	80 00       	ld.sh	r0,r0[0x0]
80007886:	a7 4c       	asr	r12,0x6
80007888:	80 00       	ld.sh	r0,r0[0x0]
8000788a:	95 cc       	st.w	r10[0x30],r12

8000788c <output_pass_setup>:
 *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.
 */

LOCAL(boolean)
output_pass_setup (j_decompress_ptr cinfo)
{
8000788c:	d4 21       	pushm	r4-r7,lr
8000788e:	18 97       	mov	r7,r12
  if (cinfo->global_state != DSTATE_PRESCAN) {
80007890:	78 58       	ld.w	r8,r12[0x14]
80007892:	e0 48 00 cc 	cp.w	r8,204
80007896:	c0 b0       	breq	800078ac <output_pass_setup+0x20>
    /* First call: do pass setup */
    (*cinfo->master->prepare_for_output_pass) (cinfo);
80007898:	f8 f8 01 a4 	ld.w	r8,r12[420]
8000789c:	70 08       	ld.w	r8,r8[0x0]
8000789e:	5d 18       	icall	r8
    cinfo->output_scanline = 0;
800078a0:	30 08       	mov	r8,0
800078a2:	ef 48 00 8c 	st.w	r7[140],r8
    cinfo->global_state = DSTATE_PRESCAN;
800078a6:	e0 68 00 cc 	mov	r8,204
800078aa:	8f 58       	st.w	r7[0x14],r8
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
800078ac:	ee f8 01 a4 	ld.w	r8,r7[420]
800078b0:	70 28       	ld.w	r8,r8[0x8]
800078b2:	58 08       	cp.w	r8,0
800078b4:	c1 c1       	brne	800078ec <output_pass_setup+0x60>
800078b6:	c3 48       	rjmp	8000791e <output_pass_setup+0x92>
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
      JDIMENSION last_scanline;
      /* Call progress monitor hook if present */
      if (cinfo->progress != NULL) {
800078b8:	6e 29       	ld.w	r9,r7[0x8]
800078ba:	58 09       	cp.w	r9,0
800078bc:	c0 90       	breq	800078ce <output_pass_setup+0x42>
	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
800078be:	93 18       	st.w	r9[0x4],r8
	cinfo->progress->pass_limit = (long) cinfo->output_height;
800078c0:	6e 28       	ld.w	r8,r7[0x8]
800078c2:	6f d9       	ld.w	r9,r7[0x74]
800078c4:	91 29       	st.w	r8[0x8],r9
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
800078c6:	6e 28       	ld.w	r8,r7[0x8]
800078c8:	70 08       	ld.w	r8,r8[0x0]
800078ca:	0e 9c       	mov	r12,r7
800078cc:	5d 18       	icall	r8
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
800078ce:	ee f6 00 8c 	ld.w	r6,r7[140]
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
800078d2:	ee f8 01 a8 	ld.w	r8,r7[424]
800078d6:	70 18       	ld.w	r8,r8[0x4]
800078d8:	0a 99       	mov	r9,r5
800078da:	08 9a       	mov	r10,r4
800078dc:	0a 9b       	mov	r11,r5
800078de:	0e 9c       	mov	r12,r7
800078e0:	5d 18       	icall	r8
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
800078e2:	ee f8 00 8c 	ld.w	r8,r7[140]
800078e6:	0c 38       	cp.w	r8,r6
800078e8:	c0 51       	brne	800078f2 <output_pass_setup+0x66>
800078ea:	d8 2a       	popm	r4-r7,pc,r12=0
	cinfo->progress->pass_limit = (long) cinfo->output_height;
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
      }
      /* Process some data */
      last_scanline = cinfo->output_scanline;
      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
800078ec:	ee c4 ff 74 	sub	r4,r7,-140
800078f0:	30 05       	mov	r5,0
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
#ifdef QUANT_2PASS_SUPPORTED
    /* Crank through the dummy pass */
    while (cinfo->output_scanline < cinfo->output_height) {
800078f2:	ee f8 00 8c 	ld.w	r8,r7[140]
800078f6:	6f d9       	ld.w	r9,r7[0x74]
800078f8:	12 38       	cp.w	r8,r9
800078fa:	cd f3       	brcs	800078b8 <output_pass_setup+0x2c>
				    &cinfo->output_scanline, (JDIMENSION) 0);
      if (cinfo->output_scanline == last_scanline)
	return FALSE;		/* No progress made, must suspend */
    }
    /* Finish up dummy pass, and set up for another one */
    (*cinfo->master->finish_output_pass) (cinfo);
800078fc:	ee f8 01 a4 	ld.w	r8,r7[420]
80007900:	70 18       	ld.w	r8,r8[0x4]
80007902:	0e 9c       	mov	r12,r7
80007904:	5d 18       	icall	r8
    (*cinfo->master->prepare_for_output_pass) (cinfo);
80007906:	ee f8 01 a4 	ld.w	r8,r7[420]
8000790a:	70 08       	ld.w	r8,r8[0x0]
8000790c:	0e 9c       	mov	r12,r7
8000790e:	5d 18       	icall	r8
    cinfo->output_scanline = 0;
80007910:	ef 45 00 8c 	st.w	r7[140],r5
    (*cinfo->master->prepare_for_output_pass) (cinfo);
    cinfo->output_scanline = 0;
    cinfo->global_state = DSTATE_PRESCAN;
  }
  /* Loop over any required dummy passes */
  while (cinfo->master->is_dummy_pass) {
80007914:	ee f8 01 a4 	ld.w	r8,r7[420]
80007918:	70 28       	ld.w	r8,r8[0x8]
8000791a:	58 08       	cp.w	r8,0
8000791c:	ce b1       	brne	800078f2 <output_pass_setup+0x66>
#endif /* QUANT_2PASS_SUPPORTED */
  }
  /* Ready for application to drive output pass through
   * jpeg_read_scanlines or jpeg_read_raw_data.
   */
  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
8000791e:	6f 18       	ld.w	r8,r7[0x44]
80007920:	e0 69 00 cd 	mov	r9,205
80007924:	e0 6a 00 ce 	mov	r10,206
80007928:	58 08       	cp.w	r8,0
8000792a:	f4 08 17 10 	movne	r8,r10
8000792e:	f2 08 17 00 	moveq	r8,r9
80007932:	8f 58       	st.w	r7[0x14],r8
80007934:	da 2a       	popm	r4-r7,pc,r12=1

80007936 <jpeg_read_scanlines>:
 */

GLOBAL(JDIMENSION)
jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
		     JDIMENSION max_lines)
{
80007936:	eb cd 40 70 	pushm	r4-r6,lr
8000793a:	20 1d       	sub	sp,4
8000793c:	18 96       	mov	r6,r12
8000793e:	16 95       	mov	r5,r11
80007940:	14 94       	mov	r4,r10
  JDIMENSION row_ctr;

  if (cinfo->global_state != DSTATE_SCANNING)
80007942:	78 58       	ld.w	r8,r12[0x14]
80007944:	e0 48 00 cd 	cp.w	r8,205
80007948:	c0 a0       	breq	8000795c <jpeg_read_scanlines+0x26>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
8000794a:	78 08       	ld.w	r8,r12[0x0]
8000794c:	31 49       	mov	r9,20
8000794e:	91 59       	st.w	r8[0x14],r9
80007950:	78 08       	ld.w	r8,r12[0x0]
80007952:	78 59       	ld.w	r9,r12[0x14]
80007954:	91 69       	st.w	r8[0x18],r9
80007956:	78 08       	ld.w	r8,r12[0x0]
80007958:	70 08       	ld.w	r8,r8[0x0]
8000795a:	5d 18       	icall	r8
  if (cinfo->output_scanline >= cinfo->output_height) {
8000795c:	ec f8 00 8c 	ld.w	r8,r6[140]
80007960:	6d d9       	ld.w	r9,r6[0x74]
80007962:	12 38       	cp.w	r8,r9
80007964:	c0 b3       	brcs	8000797a <jpeg_read_scanlines+0x44>
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
80007966:	6c 08       	ld.w	r8,r6[0x0]
80007968:	37 b9       	mov	r9,123
8000796a:	91 59       	st.w	r8[0x14],r9
8000796c:	6c 08       	ld.w	r8,r6[0x0]
8000796e:	70 18       	ld.w	r8,r8[0x4]
80007970:	3f fb       	mov	r11,-1
80007972:	0c 9c       	mov	r12,r6
80007974:	5d 18       	icall	r8
80007976:	30 0c       	mov	r12,0
    return 0;
80007978:	c1 e8       	rjmp	800079b4 <jpeg_read_scanlines+0x7e>
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
8000797a:	6c 29       	ld.w	r9,r6[0x8]
8000797c:	58 09       	cp.w	r9,0
8000797e:	c0 90       	breq	80007990 <jpeg_read_scanlines+0x5a>
    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
80007980:	93 18       	st.w	r9[0x4],r8
    cinfo->progress->pass_limit = (long) cinfo->output_height;
80007982:	6c 28       	ld.w	r8,r6[0x8]
80007984:	6d d9       	ld.w	r9,r6[0x74]
80007986:	91 29       	st.w	r8[0x8],r9
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
80007988:	6c 28       	ld.w	r8,r6[0x8]
8000798a:	70 08       	ld.w	r8,r8[0x0]
8000798c:	0c 9c       	mov	r12,r6
8000798e:	5d 18       	icall	r8
  }

  /* Process some data */
  row_ctr = 0;
80007990:	fa ca ff fc 	sub	r10,sp,-4
80007994:	30 08       	mov	r8,0
80007996:	14 d8       	st.w	--r10,r8
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
80007998:	ec f8 01 a8 	ld.w	r8,r6[424]
8000799c:	70 18       	ld.w	r8,r8[0x4]
8000799e:	08 99       	mov	r9,r4
800079a0:	1a 9a       	mov	r10,sp
800079a2:	0a 9b       	mov	r11,r5
800079a4:	0c 9c       	mov	r12,r6
800079a6:	5d 18       	icall	r8
  cinfo->output_scanline += row_ctr;
800079a8:	ec f8 00 8c 	ld.w	r8,r6[140]
800079ac:	40 0c       	lddsp	r12,sp[0x0]
800079ae:	18 08       	add	r8,r12
800079b0:	ed 48 00 8c 	st.w	r6[140],r8
  return row_ctr;
}
800079b4:	2f fd       	sub	sp,-4
800079b6:	e3 cd 80 70 	ldm	sp++,r4-r6,pc
800079ba:	d7 03       	nop

800079bc <jpeg_start_decompress>:
 * a suspending data source is used.
 */

GLOBAL(boolean)
jpeg_start_decompress (j_decompress_ptr cinfo)
{
800079bc:	eb cd 40 c0 	pushm	r6-r7,lr
800079c0:	18 97       	mov	r7,r12
  if (cinfo->global_state == DSTATE_READY) {
800079c2:	78 58       	ld.w	r8,r12[0x14]
800079c4:	e0 48 00 ca 	cp.w	r8,202
800079c8:	c0 f1       	brne	800079e6 <jpeg_start_decompress+0x2a>
    /* First call: initialize master control, select active modules */
    jinit_master_decompress(cinfo);
800079ca:	f0 1f 00 2b 	mcall	80007a74 <jpeg_start_decompress+0xb8>
    if (cinfo->buffered_image) {
800079ce:	6f 08       	ld.w	r8,r7[0x40]
800079d0:	58 08       	cp.w	r8,0
800079d2:	c0 60       	breq	800079de <jpeg_start_decompress+0x22>
      /* No more work here; expecting jpeg_start_output next */
      cinfo->global_state = DSTATE_BUFIMAGE;
800079d4:	e0 68 00 cf 	mov	r8,207
800079d8:	8f 58       	st.w	r7[0x14],r8
800079da:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
      return TRUE;
    }
    cinfo->global_state = DSTATE_PRELOAD;
800079de:	e0 68 00 cb 	mov	r8,203
800079e2:	8f 58       	st.w	r7[0x14],r8
800079e4:	c0 48       	rjmp	800079ec <jpeg_start_decompress+0x30>
  }
  if (cinfo->global_state == DSTATE_PRELOAD) {
800079e6:	e0 48 00 cb 	cp.w	r8,203
800079ea:	c3 31       	brne	80007a50 <jpeg_start_decompress+0x94>
    /* If file has multiple scans, absorb them all into the coef buffer */
    if (cinfo->inputctl->has_multiple_scans) {
800079ec:	ee f8 01 b4 	ld.w	r8,r7[436]
800079f0:	70 48       	ld.w	r8,r8[0x10]
800079f2:	58 08       	cp.w	r8,0
800079f4:	c2 90       	breq	80007a46 <jpeg_start_decompress+0x8a>
	if (retcode == JPEG_SUSPENDED)
	  return FALSE;
	if (retcode == JPEG_REACHED_EOI)
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
800079f6:	30 06       	mov	r6,0
    if (cinfo->inputctl->has_multiple_scans) {
#ifdef D_MULTISCAN_FILES_SUPPORTED
      for (;;) {
	int retcode;
	/* Call progress monitor hook if present */
	if (cinfo->progress != NULL)
800079f8:	6e 28       	ld.w	r8,r7[0x8]
800079fa:	58 08       	cp.w	r8,0
800079fc:	c0 40       	breq	80007a04 <jpeg_start_decompress+0x48>
	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
800079fe:	70 08       	ld.w	r8,r8[0x0]
80007a00:	0e 9c       	mov	r12,r7
80007a02:	5d 18       	icall	r8
	/* Absorb some more input */
	retcode = (*cinfo->inputctl->consume_input) (cinfo);
80007a04:	ee f8 01 b4 	ld.w	r8,r7[436]
80007a08:	70 08       	ld.w	r8,r8[0x0]
80007a0a:	0e 9c       	mov	r12,r7
80007a0c:	5d 18       	icall	r8
	if (retcode == JPEG_SUSPENDED)
80007a0e:	c3 00       	breq	80007a6e <jpeg_start_decompress+0xb2>
	  return FALSE;
	if (retcode == JPEG_REACHED_EOI)
80007a10:	58 2c       	cp.w	r12,2
80007a12:	c1 a0       	breq	80007a46 <jpeg_start_decompress+0x8a>
	  break;
	/* Advance progress counter if appropriate */
	if (cinfo->progress != NULL &&
80007a14:	6e 28       	ld.w	r8,r7[0x8]
80007a16:	58 08       	cp.w	r8,0
80007a18:	cf 00       	breq	800079f8 <jpeg_start_decompress+0x3c>
80007a1a:	58 3c       	cp.w	r12,3
80007a1c:	5f 0a       	sreq	r10
80007a1e:	58 1c       	cp.w	r12,1
80007a20:	5f 09       	sreq	r9
80007a22:	f5 e9 10 09 	or	r9,r10,r9
80007a26:	ec 09 18 00 	cp.b	r9,r6
80007a2a:	ce 70       	breq	800079f8 <jpeg_start_decompress+0x3c>
	    (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
80007a2c:	70 19       	ld.w	r9,r8[0x4]
80007a2e:	2f f9       	sub	r9,-1
80007a30:	91 19       	st.w	r8[0x4],r9
80007a32:	6e 28       	ld.w	r8,r7[0x8]
80007a34:	70 2a       	ld.w	r10,r8[0x8]
80007a36:	14 39       	cp.w	r9,r10
80007a38:	ce 05       	brlt	800079f8 <jpeg_start_decompress+0x3c>
	    /* jdmaster underestimated number of scans; ratchet up one scan */
	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
80007a3a:	ee f9 01 40 	ld.w	r9,r7[320]
80007a3e:	f2 0a 00 0a 	add	r10,r9,r10
80007a42:	91 2a       	st.w	r8[0x8],r10
80007a44:	cd ab       	rjmp	800079f8 <jpeg_start_decompress+0x3c>
      }
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* D_MULTISCAN_FILES_SUPPORTED */
    }
    cinfo->output_scan_number = cinfo->input_scan_number;
80007a46:	ee f8 00 90 	ld.w	r8,r7[144]
80007a4a:	ef 48 00 98 	st.w	r7[152],r8
80007a4e:	c0 d8       	rjmp	80007a68 <jpeg_start_decompress+0xac>
  } else if (cinfo->global_state != DSTATE_PRESCAN)
80007a50:	e0 48 00 cc 	cp.w	r8,204
80007a54:	c0 a0       	breq	80007a68 <jpeg_start_decompress+0xac>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
80007a56:	78 08       	ld.w	r8,r12[0x0]
80007a58:	31 49       	mov	r9,20
80007a5a:	91 59       	st.w	r8[0x14],r9
80007a5c:	78 08       	ld.w	r8,r12[0x0]
80007a5e:	78 59       	ld.w	r9,r12[0x14]
80007a60:	91 69       	st.w	r8[0x18],r9
80007a62:	78 08       	ld.w	r8,r12[0x0]
80007a64:	70 08       	ld.w	r8,r8[0x0]
80007a66:	5d 18       	icall	r8
  /* Perform any dummy output passes, and set up for the final pass */
  return output_pass_setup(cinfo);
80007a68:	0e 9c       	mov	r12,r7
80007a6a:	f0 1f 00 04 	mcall	80007a78 <jpeg_start_decompress+0xbc>
}
80007a6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a72:	00 00       	add	r0,r0
80007a74:	80 00       	ld.sh	r0,r0[0x0]
80007a76:	b4 d8       	st.b	r10[0x5],r8
80007a78:	80 00       	ld.sh	r0,r0[0x0]
80007a7a:	78 8c       	ld.w	r12,r12[0x20]

80007a7c <start_iMCU_row>:

LOCAL(void)
start_iMCU_row (j_decompress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row (input side) */
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
80007a7c:	f8 f8 01 ac 	ld.w	r8,r12[428]

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
80007a80:	f8 f9 01 48 	ld.w	r9,r12[328]
80007a84:	58 19       	cp.w	r9,1
80007a86:	e0 8a 00 05 	brle	80007a90 <start_iMCU_row+0x14>
    coef->MCU_rows_per_iMCU_row = 1;
80007a8a:	30 19       	mov	r9,1
80007a8c:	91 79       	st.w	r8[0x1c],r9
80007a8e:	c1 38       	rjmp	80007ab4 <start_iMCU_row+0x38>
  } else {
    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
80007a90:	f8 f9 01 40 	ld.w	r9,r12[320]
80007a94:	20 19       	sub	r9,1
80007a96:	f8 fa 00 94 	ld.w	r10,r12[148]
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
80007a9a:	12 3a       	cp.w	r10,r9
80007a9c:	f9 f9 30 53 	ld.wcs	r9,r12[0x14c]
80007aa0:	f3 f9 30 03 	ld.wcs	r9,r9[0xc]
80007aa4:	f1 f9 3a 07 	st.wcs	r8[0x1c],r9
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
80007aa8:	f9 f9 20 53 	ld.wcc	r9,r12[0x14c]
80007aac:	f3 f9 20 12 	ld.wcc	r9,r9[0x48]
80007ab0:	f1 f9 2a 07 	st.wcc	r8[0x1c],r9
  }

  coef->MCU_ctr = 0;
80007ab4:	30 09       	mov	r9,0
80007ab6:	91 59       	st.w	r8[0x14],r9
  coef->MCU_vert_offset = 0;
80007ab8:	91 69       	st.w	r8[0x18],r9
}
80007aba:	5e fc       	retal	r12

80007abc <start_input_pass>:
 * Initialize for an input processing pass.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
80007abc:	d4 01       	pushm	lr
  cinfo->input_iMCU_row = 0;
80007abe:	30 09       	mov	r9,0
80007ac0:	f9 49 00 94 	st.w	r12[148],r9
  start_iMCU_row(cinfo);
80007ac4:	f0 1f 00 02 	mcall	80007acc <start_input_pass+0x10>
}
80007ac8:	d8 02       	popm	pc
80007aca:	00 00       	add	r0,r0
80007acc:	80 00       	ld.sh	r0,r0[0x0]
80007ace:	7a 7c       	ld.w	r12,sp[0x1c]

80007ad0 <dummy_consume_data>:

METHODDEF(int)
dummy_consume_data (j_decompress_ptr cinfo)
{
  return JPEG_SUSPENDED;	/* Always indicate nothing was done */
}
80007ad0:	5e fd       	retal	0
80007ad2:	d7 03       	nop

80007ad4 <consume_data>:
 * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
 */

METHODDEF(int)
consume_data (j_decompress_ptr cinfo)
{
80007ad4:	d4 31       	pushm	r0-r7,lr
80007ad6:	20 dd       	sub	sp,52
80007ad8:	18 95       	mov	r5,r12
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
80007ada:	f8 f7 01 ac 	ld.w	r7,r12[428]
80007ade:	f8 c0 fe b4 	sub	r0,r12,-332
80007ae2:	fa c1 ff dc 	sub	r1,sp,-36
80007ae6:	02 93       	mov	r3,r1
80007ae8:	00 92       	mov	r2,r0
80007aea:	30 04       	mov	r4,0
80007aec:	0e 96       	mov	r6,r7
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
80007aee:	c1 28       	rjmp	80007b12 <consume_data+0x3e>
    compptr = cinfo->cur_comp_info[ci];
80007af0:	05 08       	ld.w	r8,r2++
    buffer[ci] = (*cinfo->mem->access_virt_barray)
80007af2:	70 3a       	ld.w	r10,r8[0xc]
80007af4:	6a 19       	ld.w	r9,r5[0x4]
80007af6:	ea fc 00 94 	ld.w	r12,r5[148]
80007afa:	70 1b       	ld.w	r11,r8[0x4]
80007afc:	2e eb       	sub	r11,-18
80007afe:	72 87       	ld.w	r7,r9[0x20]
80007b00:	30 18       	mov	r8,1
80007b02:	14 99       	mov	r9,r10
80007b04:	b9 3a       	mul	r10,r12
80007b06:	ec 0b 03 2b 	ld.w	r11,r6[r11<<0x2]
80007b0a:	0a 9c       	mov	r12,r5
80007b0c:	5d 17       	icall	r7
80007b0e:	06 ac       	st.w	r3++,r12
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan. */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
80007b10:	2f f4       	sub	r4,-1
80007b12:	ea f8 01 48 	ld.w	r8,r5[328]
80007b16:	10 34       	cp.w	r4,r8
80007b18:	ce c5       	brlt	80007af0 <consume_data+0x1c>
80007b1a:	0c 97       	mov	r7,r6
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
80007b1c:	6c 69       	ld.w	r9,r6[0x18]
80007b1e:	50 49       	stdsp	sp[0x10],r9
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
80007b20:	ec c8 ff e0 	sub	r8,r6,-32
80007b24:	50 58       	stdsp	sp[0x14],r8
80007b26:	a3 69       	lsl	r9,0x2
80007b28:	50 19       	stdsp	sp[0x4],r9
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
80007b2a:	30 09       	mov	r9,0
80007b2c:	50 69       	stdsp	sp[0x18],r9
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
80007b2e:	50 29       	stdsp	sp[0x8],r9
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
80007b30:	50 71       	stdsp	sp[0x1c],r1
80007b32:	50 80       	stdsp	sp[0x20],r0
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
80007b34:	12 96       	mov	r6,r9
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
80007b36:	c6 28       	rjmp	80007bfa <consume_data+0x126>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
80007b38:	6e 58       	ld.w	r8,r7[0x14]
80007b3a:	50 08       	stdsp	sp[0x0],r8
80007b3c:	ea f8 01 5c 	ld.w	r8,r5[348]
80007b40:	40 09       	lddsp	r9,sp[0x0]
80007b42:	10 39       	cp.w	r9,r8
80007b44:	c4 d3       	brcs	80007bde <consume_data+0x10a>
80007b46:	c5 28       	rjmp	80007bea <consume_data+0x116>
80007b48:	40 70       	lddsp	r0,sp[0x1c]
80007b4a:	40 81       	lddsp	r1,sp[0x20]
80007b4c:	40 62       	lddsp	r2,sp[0x18]
80007b4e:	40 2a       	lddsp	r10,sp[0x8]
80007b50:	50 35       	stdsp	sp[0xc],r5
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
80007b52:	62 0e       	ld.w	lr,r1[0x0]
	start_col = MCU_col_num * compptr->MCU_width;
80007b54:	7c d9       	ld.w	r9,lr[0x34]
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
80007b56:	7c e8       	ld.w	r8,lr[0x38]
80007b58:	58 08       	cp.w	r8,0
80007b5a:	e0 8a 00 23 	brle	80007ba0 <consume_data+0xcc>
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
80007b5e:	a7 79       	lsl	r9,0x7
80007b60:	40 08       	lddsp	r8,sp[0x0]
80007b62:	f2 08 02 43 	mul	r3,r9,r8
80007b66:	60 04       	ld.w	r4,r0[0x0]
80007b68:	40 19       	lddsp	r9,sp[0x4]
80007b6a:	12 04       	add	r4,r9
80007b6c:	40 25       	lddsp	r5,sp[0x8]
80007b6e:	68 09       	ld.w	r9,r4[0x0]
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
80007b70:	7c d8       	ld.w	r8,lr[0x34]
80007b72:	58 08       	cp.w	r8,0
80007b74:	e0 8a 00 10 	brle	80007b94 <consume_data+0xc0>
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
80007b78:	06 09       	add	r9,r3
80007b7a:	f4 cb ff f8 	sub	r11,r10,-8
80007b7e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
80007b82:	0c 98       	mov	r8,r6
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
80007b84:	16 a9       	st.w	r11++,r9
80007b86:	2f fa       	sub	r10,-1
80007b88:	28 09       	sub	r9,-128
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
80007b8a:	2f f8       	sub	r8,-1
80007b8c:	7c dc       	ld.w	r12,lr[0x34]
80007b8e:	10 3c       	cp.w	r12,r8
80007b90:	fe 99 ff fa 	brgt	80007b84 <consume_data+0xb0>
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
80007b94:	2f f5       	sub	r5,-1
80007b96:	2f c4       	sub	r4,-4
80007b98:	7c e8       	ld.w	r8,lr[0x38]
80007b9a:	0a 38       	cp.w	r8,r5
80007b9c:	fe 99 ff e9 	brgt	80007b6e <consume_data+0x9a>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
80007ba0:	2f f2       	sub	r2,-1
80007ba2:	2f c1       	sub	r1,-4
80007ba4:	2f c0       	sub	r0,-4
80007ba6:	40 39       	lddsp	r9,sp[0xc]
80007ba8:	f2 f8 01 48 	ld.w	r8,r9[328]
80007bac:	04 38       	cp.w	r8,r2
80007bae:	fe 99 ff d2 	brgt	80007b52 <consume_data+0x7e>
80007bb2:	12 95       	mov	r5,r9
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to fetch the MCU. */
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
80007bb4:	ea f8 01 bc 	ld.w	r8,r5[444]
80007bb8:	70 18       	ld.w	r8,r8[0x4]
80007bba:	40 5b       	lddsp	r11,sp[0x14]
80007bbc:	0a 9c       	mov	r12,r5
80007bbe:	5d 18       	icall	r8
80007bc0:	c0 61       	brne	80007bcc <consume_data+0xf8>
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
80007bc2:	40 48       	lddsp	r8,sp[0x10]
80007bc4:	8f 68       	st.w	r7[0x18],r8
	coef->MCU_ctr = MCU_col_num;
80007bc6:	40 09       	lddsp	r9,sp[0x0]
80007bc8:	8f 59       	st.w	r7[0x14],r9
	return JPEG_SUSPENDED;
80007bca:	c3 08       	rjmp	80007c2a <consume_data+0x156>

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
80007bcc:	40 08       	lddsp	r8,sp[0x0]
80007bce:	2f f8       	sub	r8,-1
80007bd0:	50 08       	stdsp	sp[0x0],r8
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
80007bd2:	ea f8 01 5c 	ld.w	r8,r5[348]
80007bd6:	40 09       	lddsp	r9,sp[0x0]
80007bd8:	12 38       	cp.w	r8,r9
80007bda:	e0 88 00 08 	brls	80007bea <consume_data+0x116>
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
80007bde:	ea f8 01 48 	ld.w	r8,r5[328]
80007be2:	58 08       	cp.w	r8,0
80007be4:	fe 99 ff b2 	brgt	80007b48 <consume_data+0x74>
80007be8:	ce 6b       	rjmp	80007bb4 <consume_data+0xe0>
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
80007bea:	30 08       	mov	r8,0
80007bec:	8f 58       	st.w	r7[0x14],r8
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
80007bee:	40 49       	lddsp	r9,sp[0x10]
80007bf0:	2f f9       	sub	r9,-1
80007bf2:	50 49       	stdsp	sp[0x10],r9
80007bf4:	40 18       	lddsp	r8,sp[0x4]
80007bf6:	2f c8       	sub	r8,-4
80007bf8:	50 18       	stdsp	sp[0x4],r8
     * because we requested a pre-zeroed array.
     */
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
80007bfa:	6e 78       	ld.w	r8,r7[0x1c]
80007bfc:	40 49       	lddsp	r9,sp[0x10]
80007bfe:	10 39       	cp.w	r9,r8
80007c00:	c9 c5       	brlt	80007b38 <consume_data+0x64>
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
80007c02:	ea f8 00 94 	ld.w	r8,r5[148]
80007c06:	2f f8       	sub	r8,-1
80007c08:	eb 48 00 94 	st.w	r5[148],r8
80007c0c:	ea f9 01 40 	ld.w	r9,r5[320]
80007c10:	12 38       	cp.w	r8,r9
80007c12:	c0 62       	brcc	80007c1e <consume_data+0x14a>
    start_iMCU_row(cinfo);
80007c14:	0a 9c       	mov	r12,r5
80007c16:	f0 1f 00 07 	mcall	80007c30 <consume_data+0x15c>
80007c1a:	30 3c       	mov	r12,3
    return JPEG_ROW_COMPLETED;
80007c1c:	c0 78       	rjmp	80007c2a <consume_data+0x156>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
80007c1e:	ea f8 01 b4 	ld.w	r8,r5[436]
80007c22:	70 38       	ld.w	r8,r8[0xc]
80007c24:	0a 9c       	mov	r12,r5
80007c26:	5d 18       	icall	r8
80007c28:	30 4c       	mov	r12,4
  return JPEG_SCAN_COMPLETED;
}
80007c2a:	2f 3d       	sub	sp,-52
80007c2c:	d8 32       	popm	r0-r7,pc
80007c2e:	00 00       	add	r0,r0
80007c30:	80 00       	ld.sh	r0,r0[0x0]
80007c32:	7a 7c       	ld.w	r12,sp[0x1c]

80007c34 <decompress_data>:
 * NB: output_buf contains a plane for each component in image.
 */

METHODDEF(int)
decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
80007c34:	d4 31       	pushm	r0-r7,lr
80007c36:	20 9d       	sub	sp,36
80007c38:	18 93       	mov	r3,r12
80007c3a:	16 97       	mov	r7,r11
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
80007c3c:	f8 f5 01 ac 	ld.w	r5,r12[428]
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
80007c40:	f8 f8 01 40 	ld.w	r8,r12[320]
80007c44:	20 18       	sub	r8,1
80007c46:	50 88       	stdsp	sp[0x20],r8
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
80007c48:	c0 88       	rjmp	80007c58 <decompress_data+0x24>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
80007c4a:	e6 f8 01 b4 	ld.w	r8,r3[436]
80007c4e:	70 08       	ld.w	r8,r8[0x0]
80007c50:	06 9c       	mov	r12,r3
80007c52:	5d 18       	icall	r8
80007c54:	e0 80 00 8f 	breq	80007d72 <decompress_data+0x13e>
  JDIMENSION output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number < cinfo->output_scan_number ||
80007c58:	e6 f9 00 90 	ld.w	r9,r3[144]
80007c5c:	e6 f8 00 98 	ld.w	r8,r3[152]
80007c60:	10 39       	cp.w	r9,r8
80007c62:	cf 45       	brlt	80007c4a <decompress_data+0x16>
80007c64:	c0 81       	brne	80007c74 <decompress_data+0x40>
	 (cinfo->input_scan_number == cinfo->output_scan_number &&
	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
80007c66:	e6 f9 00 94 	ld.w	r9,r3[148]
80007c6a:	e6 f8 00 9c 	ld.w	r8,r3[156]
80007c6e:	10 39       	cp.w	r9,r8
80007c70:	fe 98 ff ed 	brls	80007c4a <decompress_data+0x16>
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80007c74:	e6 f6 00 d8 	ld.w	r6,r3[216]
80007c78:	66 98       	ld.w	r8,r3[0x24]
80007c7a:	58 08       	cp.w	r8,0
80007c7c:	e0 8a 00 6f 	brle	80007d5a <decompress_data+0x126>
80007c80:	50 77       	stdsp	sp[0x1c],r7
80007c82:	2f 46       	sub	r6,-12
80007c84:	2b 85       	sub	r5,-72
80007c86:	50 65       	stdsp	sp[0x18],r5
80007c88:	30 0c       	mov	r12,0
80007c8a:	50 3c       	stdsp	sp[0xc],r12
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      output_col = 0;
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
80007c8c:	50 4c       	stdsp	sp[0x10],r12
80007c8e:	50 5c       	stdsp	sp[0x14],r12
80007c90:	06 92       	mov	r2,r3
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80007c92:	ec c0 00 0c 	sub	r0,r6,12
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
80007c96:	6c 98       	ld.w	r8,r6[0x24]
80007c98:	58 08       	cp.w	r8,0
80007c9a:	c5 00       	breq	80007d3a <decompress_data+0x106>
      continue;
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
80007c9c:	6c 0a       	ld.w	r10,r6[0x0]
80007c9e:	64 18       	ld.w	r8,r2[0x4]
80007ca0:	e4 fb 00 9c 	ld.w	r11,r2[156]
80007ca4:	70 87       	ld.w	r7,r8[0x20]
80007ca6:	30 08       	mov	r8,0
80007ca8:	14 99       	mov	r9,r10
80007caa:	b7 3a       	mul	r10,r11
80007cac:	40 6c       	lddsp	r12,sp[0x18]
80007cae:	78 0b       	ld.w	r11,r12[0x0]
80007cb0:	04 9c       	mov	r12,r2
80007cb2:	5d 17       	icall	r7
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       cinfo->output_iMCU_row * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, FALSE);
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row)
80007cb4:	e4 f8 00 9c 	ld.w	r8,r2[156]
80007cb8:	40 8a       	lddsp	r10,sp[0x20]
80007cba:	10 3a       	cp.w	r10,r8
80007cbc:	e0 88 00 05 	brls	80007cc6 <decompress_data+0x92>
      block_rows = compptr->v_samp_factor;
80007cc0:	6c 09       	ld.w	r9,r6[0x0]
80007cc2:	50 29       	stdsp	sp[0x8],r9
80007cc4:	c0 98       	rjmp	80007cd6 <decompress_data+0xa2>
    else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
80007cc6:	6c 0a       	ld.w	r10,r6[0x0]
80007cc8:	6c 59       	ld.w	r9,r6[0x14]
80007cca:	f2 0a 0d 08 	divu	r8,r9,r10
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
80007cce:	58 09       	cp.w	r9,0
80007cd0:	f2 0a 17 10 	movne	r10,r9
80007cd4:	50 2a       	stdsp	sp[0x8],r10
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
80007cd6:	e4 f8 01 c0 	ld.w	r8,r2[448]
80007cda:	40 39       	lddsp	r9,sp[0xc]
80007cdc:	2f f9       	sub	r9,-1
80007cde:	f0 09 03 21 	ld.w	r1,r8[r9<<0x2]
    output_ptr = output_buf[ci];
80007ce2:	40 78       	lddsp	r8,sp[0x1c]
80007ce4:	70 03       	ld.w	r3,r8[0x0]
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
80007ce6:	40 2a       	lddsp	r10,sp[0x8]
80007ce8:	58 0a       	cp.w	r10,0
80007cea:	e0 8a 00 28 	brle	80007d3a <decompress_data+0x106>
80007cee:	50 0c       	stdsp	sp[0x0],r12
80007cf0:	30 09       	mov	r9,0
80007cf2:	50 19       	stdsp	sp[0x4],r9
      buffer_ptr = buffer[block_row];
80007cf4:	40 08       	lddsp	r8,sp[0x0]
80007cf6:	70 07       	ld.w	r7,r8[0x0]
      output_col = 0;
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
80007cf8:	6c 48       	ld.w	r8,r6[0x10]
80007cfa:	58 08       	cp.w	r8,0
80007cfc:	c1 10       	breq	80007d1e <decompress_data+0xea>
80007cfe:	40 45       	lddsp	r5,sp[0x10]
80007d00:	40 54       	lddsp	r4,sp[0x14]
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
80007d02:	0a 98       	mov	r8,r5
80007d04:	06 99       	mov	r9,r3
80007d06:	0e 9a       	mov	r10,r7
80007d08:	00 9b       	mov	r11,r0
80007d0a:	04 9c       	mov	r12,r2
80007d0c:	5d 11       	icall	r1
			output_ptr, output_col);
	buffer_ptr++;
80007d0e:	28 07       	sub	r7,-128
	output_col += compptr->DCT_scaled_size;
80007d10:	6c 68       	ld.w	r8,r6[0x18]
80007d12:	10 05       	add	r5,r8
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
      output_col = 0;
      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
80007d14:	2f f4       	sub	r4,-1
80007d16:	6c 48       	ld.w	r8,r6[0x10]
80007d18:	08 38       	cp.w	r8,r4
80007d1a:	fe 9b ff f4 	brhi	80007d02 <decompress_data+0xce>
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
			output_ptr, output_col);
	buffer_ptr++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
80007d1e:	6c 68       	ld.w	r8,r6[0x18]
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
    }
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
80007d20:	40 1c       	lddsp	r12,sp[0x4]
80007d22:	2f fc       	sub	r12,-1
80007d24:	50 1c       	stdsp	sp[0x4],r12
80007d26:	40 0a       	lddsp	r10,sp[0x0]
80007d28:	2f ca       	sub	r10,-4
80007d2a:	50 0a       	stdsp	sp[0x0],r10
80007d2c:	40 29       	lddsp	r9,sp[0x8]
80007d2e:	18 39       	cp.w	r9,r12
80007d30:	e0 8a 00 05 	brle	80007d3a <decompress_data+0x106>
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
			output_ptr, output_col);
	buffer_ptr++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
80007d34:	e6 08 00 23 	add	r3,r3,r8<<0x2
80007d38:	cd eb       	rjmp	80007cf4 <decompress_data+0xc0>
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80007d3a:	40 38       	lddsp	r8,sp[0xc]
80007d3c:	2f f8       	sub	r8,-1
80007d3e:	50 38       	stdsp	sp[0xc],r8
80007d40:	40 7c       	lddsp	r12,sp[0x1c]
80007d42:	2f cc       	sub	r12,-4
80007d44:	50 7c       	stdsp	sp[0x1c],r12
80007d46:	2a c6       	sub	r6,-84
80007d48:	40 6a       	lddsp	r10,sp[0x18]
80007d4a:	2f ca       	sub	r10,-4
80007d4c:	50 6a       	stdsp	sp[0x18],r10
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80007d4e:	64 98       	ld.w	r8,r2[0x24]
80007d50:	40 39       	lddsp	r9,sp[0xc]
80007d52:	12 38       	cp.w	r8,r9
80007d54:	fe 99 ff 9f 	brgt	80007c92 <decompress_data+0x5e>
80007d58:	04 93       	mov	r3,r2
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
80007d5a:	e6 f8 00 9c 	ld.w	r8,r3[156]
80007d5e:	2f f8       	sub	r8,-1
80007d60:	e7 48 00 9c 	st.w	r3[156],r8
80007d64:	e6 fc 01 40 	ld.w	r12,r3[320]
80007d68:	18 38       	cp.w	r8,r12
80007d6a:	f9 bc 03 03 	movlo	r12,3
80007d6e:	f9 bc 02 04 	movhs	r12,4
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}
80007d72:	2f 7d       	sub	sp,-36
80007d74:	d8 32       	popm	r0-r7,pc
80007d76:	d7 03       	nop

80007d78 <start_output_pass>:
 * Initialize for an output processing pass.
 */

METHODDEF(void)
start_output_pass (j_decompress_ptr cinfo)
{
80007d78:	eb cd 40 fc 	pushm	r2-r7,lr
80007d7c:	18 97       	mov	r7,r12
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
80007d7e:	f8 f6 01 ac 	ld.w	r6,r12[428]

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
80007d82:	6c 48       	ld.w	r8,r6[0x10]
80007d84:	58 08       	cp.w	r8,0
80007d86:	e0 80 00 8f 	breq	80007ea4 <start_output_pass+0x12c>
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
80007d8a:	79 48       	ld.w	r8,r12[0x50]
80007d8c:	58 08       	cp.w	r8,0
80007d8e:	e0 80 00 89 	breq	80007ea0 <start_output_pass+0x128>
  jpeg_component_info *compptr;
  JQUANT_TBL * qtable;
  int * coef_bits;
  int * coef_bits_latch;

  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
80007d92:	f8 f8 00 dc 	ld.w	r8,r12[220]
80007d96:	58 08       	cp.w	r8,0
80007d98:	e0 80 00 84 	breq	80007ea0 <start_output_pass+0x128>
80007d9c:	f8 f8 00 a0 	ld.w	r8,r12[160]
80007da0:	58 08       	cp.w	r8,0
80007da2:	c7 f0       	breq	80007ea0 <start_output_pass+0x128>
    return FALSE;

  /* Allocate latch area if not already done */
  if (coef->coef_bits_latch == NULL)
80007da4:	6d 68       	ld.w	r8,r6[0x58]
80007da6:	58 08       	cp.w	r8,0
80007da8:	c0 b1       	brne	80007dbe <start_output_pass+0x46>
    coef->coef_bits_latch = (int *)
80007daa:	78 19       	ld.w	r9,r12[0x4]
80007dac:	78 98       	ld.w	r8,r12[0x24]
80007dae:	f0 08 00 1a 	add	r10,r8,r8<<0x1
80007db2:	72 08       	ld.w	r8,r9[0x0]
80007db4:	a3 7a       	lsl	r10,0x3
80007db6:	30 1b       	mov	r11,1
80007db8:	5d 18       	icall	r8
80007dba:	ed 4c 00 58 	st.w	r6[88],r12
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  cinfo->num_components *
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;
80007dbe:	6d 64       	ld.w	r4,r6[0x58]

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80007dc0:	ee f3 00 d8 	ld.w	r3,r7[216]
80007dc4:	6e 98       	ld.w	r8,r7[0x24]
80007dc6:	58 08       	cp.w	r8,0
80007dc8:	e0 8a 00 6c 	brle	80007ea0 <start_output_pass+0x128>
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
80007dcc:	67 38       	ld.w	r8,r3[0x4c]
80007dce:	58 08       	cp.w	r8,0
80007dd0:	c6 80       	breq	80007ea0 <start_output_pass+0x128>
      return FALSE;
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
80007dd2:	90 0a       	ld.sh	r10,r8[0x0]
80007dd4:	30 09       	mov	r9,0
80007dd6:	f2 0a 19 00 	cp.h	r10,r9
80007dda:	c6 30       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q01_POS] == 0 ||
80007ddc:	90 1a       	ld.sh	r10,r8[0x2]
80007dde:	f2 0a 19 00 	cp.h	r10,r9
80007de2:	c5 f0       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q10_POS] == 0 ||
80007de4:	f1 0a 00 10 	ld.sh	r10,r8[16]
80007de8:	f2 0a 19 00 	cp.h	r10,r9
80007dec:	c5 a0       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q20_POS] == 0 ||
80007dee:	f1 0a 00 20 	ld.sh	r10,r8[32]
80007df2:	f2 0a 19 00 	cp.h	r10,r9
80007df6:	c5 50       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q11_POS] == 0 ||
80007df8:	f1 0a 00 12 	ld.sh	r10,r8[18]
80007dfc:	f2 0a 19 00 	cp.h	r10,r9
80007e00:	c5 00       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q02_POS] == 0)
80007e02:	90 29       	ld.sh	r9,r8[0x4]
80007e04:	30 08       	mov	r8,0
80007e06:	f0 09 19 00 	cp.h	r9,r8
80007e0a:	c4 b0       	breq	80007ea0 <start_output_pass+0x128>
      return FALSE;
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
80007e0c:	ee f9 00 a0 	ld.w	r9,r7[160]
    if (coef_bits[0] < 0)
80007e10:	72 08       	ld.w	r8,r9[0x0]
80007e12:	58 08       	cp.w	r8,0
80007e14:	c4 65       	brlt	80007ea0 <start_output_pass+0x128>
80007e16:	e6 c3 ff 60 	sub	r3,r3,-160
80007e1a:	2f c4       	sub	r4,-4
80007e1c:	30 05       	mov	r5,0
80007e1e:	0a 9c       	mov	r12,r5
80007e20:	30 12       	mov	r2,1
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
      return FALSE;
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
80007e22:	30 0e       	mov	lr,0
80007e24:	c2 98       	rjmp	80007e76 <start_output_pass+0xfe>
  coef_bits_latch = coef->coef_bits_latch;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* All components' quantization values must already be latched. */
    if ((qtable = compptr->quant_table) == NULL)
80007e26:	66 08       	ld.w	r8,r3[0x0]
80007e28:	58 08       	cp.w	r8,0
80007e2a:	c3 b0       	breq	80007ea0 <start_output_pass+0x128>
      return FALSE;
    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
    if (qtable->quantval[0] == 0 ||
80007e2c:	90 09       	ld.sh	r9,r8[0x0]
80007e2e:	fc 09 19 00 	cp.h	r9,lr
80007e32:	c3 70       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q01_POS] == 0 ||
80007e34:	90 19       	ld.sh	r9,r8[0x2]
80007e36:	fc 09 19 00 	cp.h	r9,lr
80007e3a:	c3 30       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q10_POS] == 0 ||
80007e3c:	f1 09 00 10 	ld.sh	r9,r8[16]
80007e40:	fc 09 19 00 	cp.h	r9,lr
80007e44:	c2 e0       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q20_POS] == 0 ||
80007e46:	f1 09 00 20 	ld.sh	r9,r8[32]
80007e4a:	fc 09 19 00 	cp.h	r9,lr
80007e4e:	c2 90       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q11_POS] == 0 ||
80007e50:	f1 09 00 12 	ld.sh	r9,r8[18]
80007e54:	fc 09 19 00 	cp.h	r9,lr
80007e58:	c2 40       	breq	80007ea0 <start_output_pass+0x128>
	qtable->quantval[Q02_POS] == 0)
80007e5a:	90 28       	ld.sh	r8,r8[0x4]
80007e5c:	fc 08 19 00 	cp.h	r8,lr
80007e60:	c2 00       	breq	80007ea0 <start_output_pass+0x128>
      return FALSE;
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
80007e62:	ea 08 15 08 	lsl	r8,r5,0x8
80007e66:	ee f9 00 a0 	ld.w	r9,r7[160]
80007e6a:	10 09       	add	r9,r8
80007e6c:	2a c3       	sub	r3,-84
80007e6e:	2e 84       	sub	r4,-24
    if (coef_bits[0] < 0)
80007e70:	72 08       	ld.w	r8,r9[0x0]
80007e72:	58 08       	cp.w	r8,0
80007e74:	c1 65       	brlt	80007ea0 <start_output_pass+0x128>
80007e76:	2f c9       	sub	r9,-4
80007e78:	08 9b       	mov	r11,r4
80007e7a:	04 98       	mov	r8,r2
      return FALSE;
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
      coef_bits_latch[coefi] = coef_bits[coefi];
80007e7c:	72 0a       	ld.w	r10,r9[0x0]
80007e7e:	16 aa       	st.w	r11++,r10
      if (coef_bits[coefi] != 0)
80007e80:	13 0a       	ld.w	r10,r9++
80007e82:	58 0a       	cp.w	r10,0
80007e84:	f9 bc 01 01 	movne	r12,1
    /* DC values must be at least partly known for all components. */
    coef_bits = cinfo->coef_bits[ci];
    if (coef_bits[0] < 0)
      return FALSE;
    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */
    for (coefi = 1; coefi <= 5; coefi++) {
80007e88:	2f f8       	sub	r8,-1
80007e8a:	58 68       	cp.w	r8,6
80007e8c:	cf 81       	brne	80007e7c <start_output_pass+0x104>
				  cinfo->num_components *
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80007e8e:	2f f5       	sub	r5,-1
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  cinfo->num_components *
				  (SAVED_COEFS * SIZEOF(int)));
  coef_bits_latch = coef->coef_bits_latch;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80007e90:	6e 98       	ld.w	r8,r7[0x24]
80007e92:	10 35       	cp.w	r5,r8
80007e94:	cc 95       	brlt	80007e26 <start_output_pass+0xae>
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
80007e96:	58 0c       	cp.w	r12,0
80007e98:	c0 40       	breq	80007ea0 <start_output_pass+0x128>
      coef->pub.decompress_data = decompress_smooth_data;
80007e9a:	48 68       	lddpc	r8,80007eb0 <start_output_pass+0x138>
80007e9c:	8d 38       	st.w	r6[0xc],r8
#ifdef BLOCK_SMOOTHING_SUPPORTED
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* If multipass, check to see whether to use block smoothing on this pass */
  if (coef->pub.coef_arrays != NULL) {
    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
80007e9e:	c0 38       	rjmp	80007ea4 <start_output_pass+0x12c>
      coef->pub.decompress_data = decompress_smooth_data;
    else
      coef->pub.decompress_data = decompress_data;
80007ea0:	48 58       	lddpc	r8,80007eb4 <start_output_pass+0x13c>
80007ea2:	8d 38       	st.w	r6[0xc],r8
  }
#endif
  cinfo->output_iMCU_row = 0;
80007ea4:	30 08       	mov	r8,0
80007ea6:	ef 48 00 9c 	st.w	r7[156],r8
}
80007eaa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007eae:	00 00       	add	r0,r0
80007eb0:	80 00       	ld.sh	r0,r0[0x0]
80007eb2:	81 5c       	st.w	r0[0x14],r12
80007eb4:	80 00       	ld.sh	r0,r0[0x0]
80007eb6:	7c 34       	ld.w	r4,lr[0xc]

80007eb8 <jinit_d_coef_controller>:
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
80007eb8:	d4 31       	pushm	r0-r7,lr
80007eba:	20 1d       	sub	sp,4
80007ebc:	18 96       	mov	r6,r12
80007ebe:	16 97       	mov	r7,r11
  my_coef_ptr coef;

  coef = (my_coef_ptr)
80007ec0:	50 0c       	stdsp	sp[0x0],r12
80007ec2:	78 18       	ld.w	r8,r12[0x4]
80007ec4:	70 08       	ld.w	r8,r8[0x0]
80007ec6:	35 ca       	mov	r10,92
80007ec8:	30 1b       	mov	r11,1
80007eca:	5d 18       	icall	r8
80007ecc:	18 95       	mov	r5,r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
80007ece:	ed 4c 01 ac 	st.w	r6[428],r12
  coef->pub.start_input_pass = start_input_pass;
80007ed2:	4a b8       	lddpc	r8,80007f7c <jinit_d_coef_controller+0xc4>
80007ed4:	99 08       	st.w	r12[0x0],r8
  coef->pub.start_output_pass = start_output_pass;
80007ed6:	4a b8       	lddpc	r8,80007f80 <jinit_d_coef_controller+0xc8>
80007ed8:	99 28       	st.w	r12[0x8],r8
#ifdef BLOCK_SMOOTHING_SUPPORTED
  coef->coef_bits_latch = NULL;
80007eda:	30 08       	mov	r8,0
80007edc:	f9 48 00 58 	st.w	r12[88],r8
#endif

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
80007ee0:	58 07       	cp.w	r7,0
80007ee2:	c3 60       	breq	80007f4e <jinit_d_coef_controller+0x96>
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80007ee4:	ec f7 00 d8 	ld.w	r7,r6[216]
80007ee8:	6c 98       	ld.w	r8,r6[0x24]
80007eea:	58 08       	cp.w	r8,0
80007eec:	e0 8a 00 29 	brle	80007f3e <jinit_d_coef_controller+0x86>
80007ef0:	2f 47       	sub	r7,-12
80007ef2:	f8 c3 ff b8 	sub	r3,r12,-72
80007ef6:	30 04       	mov	r4,0
	 ci++, compptr++) {
      access_rows = compptr->v_samp_factor;
80007ef8:	6e 0b       	ld.w	r11,r7[0x0]
#ifdef BLOCK_SMOOTHING_SUPPORTED
      /* If block smoothing could be used, need a bigger window */
      if (cinfo->progressive_mode)
80007efa:	ec f8 00 dc 	ld.w	r8,r6[220]
80007efe:	58 08       	cp.w	r8,0
80007f00:	c0 31       	brne	80007f06 <jinit_d_coef_controller+0x4e>
80007f02:	16 92       	mov	r2,r11
80007f04:	c0 38       	rjmp	80007f0a <jinit_d_coef_controller+0x52>
	access_rows *= 3;
80007f06:	f6 0b 00 12 	add	r2,r11,r11<<0x1
#endif
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
80007f0a:	6c 18       	ld.w	r8,r6[0x4]
80007f0c:	70 50       	ld.w	r0,r8[0x14]
80007f0e:	6e 5c       	ld.w	r12,r7[0x14]
80007f10:	f0 1f 00 1d 	mcall	80007f84 <jinit_d_coef_controller+0xcc>
80007f14:	18 91       	mov	r1,r12
80007f16:	ee fb ff fc 	ld.w	r11,r7[-4]
80007f1a:	6e 4c       	ld.w	r12,r7[0x10]
80007f1c:	f0 1f 00 1a 	mcall	80007f84 <jinit_d_coef_controller+0xcc>
80007f20:	1a d2       	st.w	--sp,r2
80007f22:	02 98       	mov	r8,r1
80007f24:	18 99       	mov	r9,r12
80007f26:	30 1a       	mov	r10,1
80007f28:	14 9b       	mov	r11,r10
80007f2a:	40 1c       	lddsp	r12,sp[0x4]
80007f2c:	5d 10       	icall	r0
80007f2e:	06 ac       	st.w	r3++,r12
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
80007f30:	2f f4       	sub	r4,-1
80007f32:	2a c7       	sub	r7,-84
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    /* Note we ask for a pre-zeroed array. */
    int ci, access_rows;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80007f34:	2f fd       	sub	sp,-4
80007f36:	6c 98       	ld.w	r8,r6[0x24]
80007f38:	08 38       	cp.w	r8,r4
80007f3a:	fe 99 ff df 	brgt	80007ef8 <jinit_d_coef_controller+0x40>
				(long) compptr->h_samp_factor),
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
				(long) compptr->v_samp_factor),
	 (JDIMENSION) access_rows);
    }
    coef->pub.consume_data = consume_data;
80007f3e:	49 38       	lddpc	r8,80007f88 <jinit_d_coef_controller+0xd0>
80007f40:	8b 18       	st.w	r5[0x4],r8
    coef->pub.decompress_data = decompress_data;
80007f42:	49 38       	lddpc	r8,80007f8c <jinit_d_coef_controller+0xd4>
80007f44:	8b 38       	st.w	r5[0xc],r8
    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
80007f46:	ea c8 ff b8 	sub	r8,r5,-72
80007f4a:	8b 48       	st.w	r5[0x10],r8
80007f4c:	c1 68       	rjmp	80007f78 <jinit_d_coef_controller+0xc0>
  } else {
    /* We only need a single-MCU buffer. */
    JBLOCKROW buffer;
    int i;

    buffer = (JBLOCKROW)
80007f4e:	6c 18       	ld.w	r8,r6[0x4]
80007f50:	70 18       	ld.w	r8,r8[0x4]
80007f52:	e0 6a 05 00 	mov	r10,1280
80007f56:	30 1b       	mov	r11,1
80007f58:	40 0c       	lddsp	r12,sp[0x0]
80007f5a:	5d 18       	icall	r8
80007f5c:	ea c8 ff e0 	sub	r8,r5,-32
/*
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
80007f60:	f8 c9 fb 00 	sub	r9,r12,-1280

    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
      coef->MCU_buffer[i] = buffer + i;
80007f64:	10 ac       	st.w	r8++,r12
80007f66:	28 0c       	sub	r12,-128
    int i;

    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
80007f68:	12 3c       	cp.w	r12,r9
80007f6a:	cf d1       	brne	80007f64 <jinit_d_coef_controller+0xac>
      coef->MCU_buffer[i] = buffer + i;
    }
    coef->pub.consume_data = dummy_consume_data;
80007f6c:	48 98       	lddpc	r8,80007f90 <jinit_d_coef_controller+0xd8>
80007f6e:	8b 18       	st.w	r5[0x4],r8
    coef->pub.decompress_data = decompress_onepass;
80007f70:	48 98       	lddpc	r8,80007f94 <jinit_d_coef_controller+0xdc>
80007f72:	8b 38       	st.w	r5[0xc],r8
    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
80007f74:	30 08       	mov	r8,0
80007f76:	8b 48       	st.w	r5[0x10],r8
  }
}
80007f78:	2f fd       	sub	sp,-4
80007f7a:	d8 32       	popm	r0-r7,pc
80007f7c:	80 00       	ld.sh	r0,r0[0x0]
80007f7e:	7a bc       	ld.w	r12,sp[0x2c]
80007f80:	80 00       	ld.sh	r0,r0[0x0]
80007f82:	7d 78       	ld.w	r8,lr[0x5c]
80007f84:	80 00       	ld.sh	r0,r0[0x0]
80007f86:	fd 0e 80 00 	ld.sh	lr,lr[-32768]
80007f8a:	7a d4       	ld.w	r4,sp[0x34]
80007f8c:	80 00       	ld.sh	r0,r0[0x0]
80007f8e:	7c 34       	ld.w	r4,lr[0xc]
80007f90:	80 00       	ld.sh	r0,r0[0x0]
80007f92:	7a d0       	ld.w	r0,sp[0x34]
80007f94:	80 00       	ld.sh	r0,r0[0x0]
80007f96:	7f 98       	ld.w	r8,pc[0x64]

80007f98 <decompress_onepass>:
 * which we index according to the component's SOF position.
 */

METHODDEF(int)
decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
80007f98:	d4 31       	pushm	r0-r7,lr
80007f9a:	21 0d       	sub	sp,64
80007f9c:	18 93       	mov	r3,r12
80007f9e:	50 cb       	stdsp	sp[0x30],r11
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
80007fa0:	f8 fa 01 ac 	ld.w	r10,r12[428]
80007fa4:	50 3a       	stdsp	sp[0xc],r10
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
80007fa6:	f8 f8 01 5c 	ld.w	r8,r12[348]
80007faa:	20 18       	sub	r8,1
80007fac:	50 a8       	stdsp	sp[0x28],r8
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
80007fae:	f8 f8 01 40 	ld.w	r8,r12[320]
80007fb2:	20 18       	sub	r8,1
80007fb4:	50 28       	stdsp	sp[0x8],r8
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
80007fb6:	74 69       	ld.w	r9,r10[0x18]
80007fb8:	50 89       	stdsp	sp[0x20],r9
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      jzero_far((void FAR *) coef->MCU_buffer[0],
		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
80007fba:	2e 0a       	sub	r10,-32
80007fbc:	50 da       	stdsp	sp[0x34],r10
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
80007fbe:	30 08       	mov	r8,0
80007fc0:	50 e8       	stdsp	sp[0x38],r8
	output_ptr = output_buf[compptr->component_index] +
	  yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
80007fc2:	50 b8       	stdsp	sp[0x2c],r8
		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->MCU_ctr = MCU_col_num;
	return JPEG_SUSPENDED;
80007fc4:	f8 ca fe b4 	sub	r10,r12,-332
80007fc8:	50 fa       	stdsp	sp[0x3c],r10
	output_ptr = output_buf[compptr->component_index] +
	  yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
80007fca:	50 58       	stdsp	sp[0x14],r8
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
80007fcc:	ca 28       	rjmp	80008110 <decompress_onepass+0x178>
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
80007fce:	40 39       	lddsp	r9,sp[0xc]
80007fd0:	72 59       	ld.w	r9,r9[0x14]
80007fd2:	50 99       	stdsp	sp[0x24],r9
80007fd4:	40 a8       	lddsp	r8,sp[0x28]
80007fd6:	12 38       	cp.w	r8,r9
80007fd8:	e0 83 00 96 	brlo	80008104 <decompress_onepass+0x16c>
	 MCU_col_num++) {
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      jzero_far((void FAR *) coef->MCU_buffer[0],
80007fdc:	e6 fb 01 64 	ld.w	r11,r3[356]
80007fe0:	a7 7b       	lsl	r11,0x7
80007fe2:	40 3a       	lddsp	r10,sp[0xc]
80007fe4:	74 8c       	ld.w	r12,r10[0x20]
80007fe6:	f0 1f 00 5c 	mcall	80008154 <decompress_onepass+0x1bc>
		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
80007fea:	e6 f8 01 bc 	ld.w	r8,r3[444]
80007fee:	70 18       	ld.w	r8,r8[0x4]
80007ff0:	40 db       	lddsp	r11,sp[0x34]
80007ff2:	06 9c       	mov	r12,r3
80007ff4:	5d 18       	icall	r8
80007ff6:	c0 70       	breq	80008004 <decompress_onepass+0x6c>
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
80007ff8:	e6 f8 01 48 	ld.w	r8,r3[328]
80007ffc:	58 08       	cp.w	r8,0
80007ffe:	e0 89 00 0a 	brgt	80008012 <decompress_onepass+0x7a>
80008002:	c7 a8       	rjmp	800080f6 <decompress_onepass+0x15e>
      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
      jzero_far((void FAR *) coef->MCU_buffer[0],
		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
80008004:	40 88       	lddsp	r8,sp[0x20]
80008006:	40 39       	lddsp	r9,sp[0xc]
80008008:	93 68       	st.w	r9[0x18],r8
	coef->MCU_ctr = MCU_col_num;
8000800a:	40 9a       	lddsp	r10,sp[0x24]
8000800c:	93 5a       	st.w	r9[0x14],r10
8000800e:	30 0c       	mov	r12,0
	return JPEG_SUSPENDED;
80008010:	c9 f8       	rjmp	8000814e <decompress_onepass+0x1b6>
80008012:	40 f9       	lddsp	r9,sp[0x3c]
80008014:	50 69       	stdsp	sp[0x18],r9
80008016:	40 e8       	lddsp	r8,sp[0x38]
80008018:	50 78       	stdsp	sp[0x1c],r8
8000801a:	40 ba       	lddsp	r10,sp[0x2c]
8000801c:	50 1a       	stdsp	sp[0x4],r10
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
8000801e:	40 69       	lddsp	r9,sp[0x18]
80008020:	72 06       	ld.w	r6,r9[0x0]
	/* Don't bother to IDCT an uninteresting component. */
	if (! compptr->component_needed) {
80008022:	6c c8       	ld.w	r8,r6[0x30]
80008024:	58 08       	cp.w	r8,0
80008026:	c0 61       	brne	80008032 <decompress_onepass+0x9a>
	  blkn += compptr->MCU_blocks;
80008028:	6c f8       	ld.w	r8,r6[0x3c]
8000802a:	40 1a       	lddsp	r10,sp[0x4]
8000802c:	10 0a       	add	r10,r8
8000802e:	50 1a       	stdsp	sp[0x4],r10
	  continue;
80008030:	c5 88       	rjmp	800080e0 <decompress_onepass+0x148>
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
80008032:	6c 18       	ld.w	r8,r6[0x4]
80008034:	e6 f9 01 c0 	ld.w	r9,r3[448]
80008038:	f0 ca ff ff 	sub	r10,r8,-1
8000803c:	f2 0a 03 20 	ld.w	r0,r9[r10<<0x2]
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
80008040:	40 a9       	lddsp	r9,sp[0x28]
80008042:	40 9a       	lddsp	r10,sp[0x24]
80008044:	14 39       	cp.w	r9,r10
80008046:	ed f1 b0 0d 	ld.whi	r1,r6[0x34]
8000804a:	ed f1 80 11 	ld.wls	r1,r6[0x44]
						    : compptr->last_col_width;
	output_ptr = output_buf[compptr->component_index] +
8000804e:	40 ca       	lddsp	r10,sp[0x30]
80008050:	f4 08 03 29 	ld.w	r9,r10[r8<<0x2]
	  yoffset * compptr->DCT_scaled_size;
80008054:	6c 9a       	ld.w	r10,r6[0x24]
	start_col = MCU_col_num * compptr->MCU_sample_width;
80008056:	6d 0b       	ld.w	r11,r6[0x40]
80008058:	40 98       	lddsp	r8,sp[0x24]
8000805a:	f0 0b 02 4b 	mul	r11,r8,r11
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
8000805e:	6c e8       	ld.w	r8,r6[0x38]
80008060:	58 08       	cp.w	r8,0
80008062:	e0 8a 00 3f 	brle	800080e0 <decompress_onepass+0x148>
	  continue;
	}
	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
	output_ptr = output_buf[compptr->component_index] +
80008066:	40 88       	lddsp	r8,sp[0x20]
80008068:	f0 0a 02 4a 	mul	r10,r8,r10
8000806c:	f2 0a 00 22 	add	r2,r9,r10<<0x2
80008070:	40 ba       	lddsp	r10,sp[0x2c]
80008072:	50 0a       	stdsp	sp[0x0],r10
	  yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
80008074:	50 4b       	stdsp	sp[0x10],r11
						    : compptr->last_col_width;
	output_ptr = output_buf[compptr->component_index] +
	  yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
80008076:	e6 f8 00 94 	ld.w	r8,r3[148]
8000807a:	40 29       	lddsp	r9,sp[0x8]
8000807c:	10 39       	cp.w	r9,r8
8000807e:	e0 88 00 06 	brls	8000808a <decompress_onepass+0xf2>
	      yoffset+yindex < compptr->last_row_height) {
	    output_col = start_col;
	    for (xindex = 0; xindex < useful_width; xindex++) {
80008082:	58 01       	cp.w	r1,0
80008084:	e0 89 00 0b 	brgt	8000809a <decompress_onepass+0x102>
80008088:	c1 c8       	rjmp	800080c0 <decompress_onepass+0x128>
	output_ptr = output_buf[compptr->component_index] +
	  yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
8000808a:	40 88       	lddsp	r8,sp[0x20]
8000808c:	40 0a       	lddsp	r10,sp[0x0]
8000808e:	14 08       	add	r8,r10
80008090:	6d 29       	ld.w	r9,r6[0x48]
80008092:	10 39       	cp.w	r9,r8
80008094:	fe 99 ff f7 	brgt	80008082 <decompress_onepass+0xea>
80008098:	c1 48       	rjmp	800080c0 <decompress_onepass+0x128>
8000809a:	40 14       	lddsp	r4,sp[0x4]
8000809c:	2f 84       	sub	r4,-8
8000809e:	40 39       	lddsp	r9,sp[0xc]
800080a0:	f2 04 00 24 	add	r4,r9,r4<<0x2
800080a4:	40 47       	lddsp	r7,sp[0x10]
800080a6:	40 55       	lddsp	r5,sp[0x14]
	    output_col = start_col;
	    for (xindex = 0; xindex < useful_width; xindex++) {
	      (*inverse_DCT) (cinfo, compptr,
800080a8:	0e 98       	mov	r8,r7
800080aa:	04 99       	mov	r9,r2
800080ac:	09 0a       	ld.w	r10,r4++
800080ae:	0c 9b       	mov	r11,r6
800080b0:	06 9c       	mov	r12,r3
800080b2:	5d 10       	icall	r0
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
			      output_ptr, output_col);
	      output_col += compptr->DCT_scaled_size;
800080b4:	6c 98       	ld.w	r8,r6[0x24]
800080b6:	10 07       	add	r7,r8
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (cinfo->input_iMCU_row < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
	    output_col = start_col;
	    for (xindex = 0; xindex < useful_width; xindex++) {
800080b8:	2f f5       	sub	r5,-1
800080ba:	0a 31       	cp.w	r1,r5
800080bc:	fe 99 ff f6 	brgt	800080a8 <decompress_onepass+0x110>
			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
			      output_ptr, output_col);
	      output_col += compptr->DCT_scaled_size;
	    }
	  }
	  blkn += compptr->MCU_width;
800080c0:	6c d8       	ld.w	r8,r6[0x34]
800080c2:	40 1a       	lddsp	r10,sp[0x4]
800080c4:	10 0a       	add	r10,r8
800080c6:	50 1a       	stdsp	sp[0x4],r10
	  output_ptr += compptr->DCT_scaled_size;
800080c8:	6c 99       	ld.w	r9,r6[0x24]
	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						    : compptr->last_col_width;
	output_ptr = output_buf[compptr->component_index] +
	  yoffset * compptr->DCT_scaled_size;
	start_col = MCU_col_num * compptr->MCU_sample_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
800080ca:	40 08       	lddsp	r8,sp[0x0]
800080cc:	2f f8       	sub	r8,-1
800080ce:	50 08       	stdsp	sp[0x0],r8
800080d0:	6c e8       	ld.w	r8,r6[0x38]
800080d2:	40 0a       	lddsp	r10,sp[0x0]
800080d4:	14 38       	cp.w	r8,r10
800080d6:	e0 8a 00 05 	brle	800080e0 <decompress_onepass+0x148>
			      output_ptr, output_col);
	      output_col += compptr->DCT_scaled_size;
	    }
	  }
	  blkn += compptr->MCU_width;
	  output_ptr += compptr->DCT_scaled_size;
800080da:	e4 09 00 22 	add	r2,r2,r9<<0x2
800080de:	cc cb       	rjmp	80008076 <decompress_onepass+0xde>
       * We skip dummy blocks at the right and bottom edges (but blkn gets
       * incremented past them!).  Note the inner loop relies on having
       * allocated the MCU_buffer[] blocks sequentially.
       */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
800080e0:	40 79       	lddsp	r9,sp[0x1c]
800080e2:	2f f9       	sub	r9,-1
800080e4:	50 79       	stdsp	sp[0x1c],r9
800080e6:	40 68       	lddsp	r8,sp[0x18]
800080e8:	2f c8       	sub	r8,-4
800080ea:	50 68       	stdsp	sp[0x18],r8
800080ec:	e6 f8 01 48 	ld.w	r8,r3[328]
800080f0:	12 38       	cp.w	r8,r9
800080f2:	fe 99 ff 96 	brgt	8000801e <decompress_onepass+0x86>

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
	 MCU_col_num++) {
800080f6:	40 9a       	lddsp	r10,sp[0x24]
800080f8:	2f fa       	sub	r10,-1
800080fa:	50 9a       	stdsp	sp[0x24],r10
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
800080fc:	40 a9       	lddsp	r9,sp[0x28]
800080fe:	14 39       	cp.w	r9,r10
80008100:	fe 92 ff 6e 	brhs	80007fdc <decompress_onepass+0x44>
	  output_ptr += compptr->DCT_scaled_size;
	}
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
80008104:	30 0a       	mov	r10,0
80008106:	40 38       	lddsp	r8,sp[0xc]
80008108:	91 5a       	st.w	r8[0x14],r10
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
8000810a:	40 89       	lddsp	r9,sp[0x20]
8000810c:	2f f9       	sub	r9,-1
8000810e:	50 89       	stdsp	sp[0x20],r9
  JDIMENSION start_col, output_col;
  jpeg_component_info *compptr;
  inverse_DCT_method_ptr inverse_DCT;

  /* Loop to process as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
80008110:	40 3a       	lddsp	r10,sp[0xc]
80008112:	74 78       	ld.w	r8,r10[0x1c]
80008114:	40 89       	lddsp	r9,sp[0x20]
80008116:	10 39       	cp.w	r9,r8
80008118:	fe 95 ff 5b 	brlt	80007fce <decompress_onepass+0x36>
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->MCU_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  cinfo->output_iMCU_row++;
8000811c:	e6 f8 00 9c 	ld.w	r8,r3[156]
80008120:	2f f8       	sub	r8,-1
80008122:	e7 48 00 9c 	st.w	r3[156],r8
  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
80008126:	e6 f8 00 94 	ld.w	r8,r3[148]
8000812a:	2f f8       	sub	r8,-1
8000812c:	e7 48 00 94 	st.w	r3[148],r8
80008130:	e6 f9 01 40 	ld.w	r9,r3[320]
80008134:	12 38       	cp.w	r8,r9
80008136:	c0 62       	brcc	80008142 <decompress_onepass+0x1aa>
    start_iMCU_row(cinfo);
80008138:	06 9c       	mov	r12,r3
8000813a:	f0 1f 00 08 	mcall	80008158 <decompress_onepass+0x1c0>
8000813e:	30 3c       	mov	r12,3
    return JPEG_ROW_COMPLETED;
80008140:	c0 78       	rjmp	8000814e <decompress_onepass+0x1b6>
  }
  /* Completed the scan */
  (*cinfo->inputctl->finish_input_pass) (cinfo);
80008142:	e6 f8 01 b4 	ld.w	r8,r3[436]
80008146:	70 38       	ld.w	r8,r8[0xc]
80008148:	06 9c       	mov	r12,r3
8000814a:	5d 18       	icall	r8
8000814c:	30 4c       	mov	r12,4
  return JPEG_SCAN_COMPLETED;
}
8000814e:	2f 0d       	sub	sp,-64
80008150:	d8 32       	popm	r0-r7,pc
80008152:	00 00       	add	r0,r0
80008154:	80 00       	ld.sh	r0,r0[0x0]
80008156:	fd 20 80 00 	ld.sb	r0,lr[-32768]
8000815a:	7a 7c       	ld.w	r12,sp[0x1c]

8000815c <decompress_smooth_data>:
 * Variant of decompress_data for use when doing block smoothing.
 */

METHODDEF(int)
decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
{
8000815c:	d4 31       	pushm	r0-r7,lr
8000815e:	fa cd 01 28 	sub	sp,sp,296
80008162:	50 cc       	stdsp	sp[0x30],r12
80008164:	16 97       	mov	r7,r11
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
80008166:	f8 fe 01 ac 	ld.w	lr,r12[428]
8000816a:	52 8e       	stdsp	sp[0xa0],lr
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
8000816c:	f8 f8 01 40 	ld.w	r8,r12[320]
80008170:	20 18       	sub	r8,1
80008172:	52 98       	stdsp	sp[0xa4],r8
80008174:	18 96       	mov	r6,r12
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
80008176:	c1 58       	rjmp	800081a0 <decompress_smooth_data+0x44>
	 ! cinfo->inputctl->eoi_reached) {
    if (cinfo->input_scan_number == cinfo->output_scan_number) {
80008178:	10 39       	cp.w	r9,r8
8000817a:	c0 e1       	brne	80008196 <decompress_smooth_data+0x3a>
      /* If input is working on current scan, we ordinarily want it to
       * have completed the current row.  But if input scan is DC,
       * we want it to keep one row ahead so that next block row's DC
       * values are up to date.
       */
      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
8000817c:	ec f8 01 90 	ld.w	r8,r6[400]
80008180:	58 08       	cp.w	r8,0
80008182:	5f 09       	sreq	r9
      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
80008184:	ec f8 00 9c 	ld.w	r8,r6[156]
80008188:	f2 08 00 08 	add	r8,r9,r8
8000818c:	ec f9 00 94 	ld.w	r9,r6[148]
80008190:	10 39       	cp.w	r9,r8
80008192:	e0 8b 00 13 	brhi	800081b8 <decompress_smooth_data+0x5c>
	break;
    }
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
80008196:	74 08       	ld.w	r8,r10[0x0]
80008198:	0c 9c       	mov	r12,r6
8000819a:	5d 18       	icall	r8
8000819c:	e0 80 02 5c 	breq	80008654 <decompress_smooth_data+0x4f8>
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
800081a0:	ec f9 00 90 	ld.w	r9,r6[144]
800081a4:	ec f8 00 98 	ld.w	r8,r6[152]
800081a8:	10 39       	cp.w	r9,r8
800081aa:	e0 89 00 07 	brgt	800081b8 <decompress_smooth_data+0x5c>
	 ! cinfo->inputctl->eoi_reached) {
800081ae:	ec fa 01 b4 	ld.w	r10,r6[436]
  INT32 Q00,Q01,Q02,Q10,Q11,Q20, num;
  int DC1,DC2,DC3,DC4,DC5,DC6,DC7,DC8,DC9;
  int Al, pred;

  /* Force some input to be done if we are getting ahead of the input. */
  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
800081b2:	74 5b       	ld.w	r11,r10[0x14]
800081b4:	58 0b       	cp.w	r11,0
800081b6:	ce 10       	breq	80008178 <decompress_smooth_data+0x1c>
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
800081b8:	40 cc       	lddsp	r12,sp[0x30]
800081ba:	f8 fc 00 d8 	ld.w	r12,r12[216]
800081be:	50 3c       	stdsp	sp[0xc],r12
800081c0:	40 ca       	lddsp	r10,sp[0x30]
800081c2:	74 98       	ld.w	r8,r10[0x24]
800081c4:	58 08       	cp.w	r8,0
800081c6:	e0 8a 02 3a 	brle	8000863a <decompress_smooth_data+0x4de>
800081ca:	52 77       	stdsp	sp[0x9c],r7
800081cc:	2f 4c       	sub	r12,-12
800081ce:	52 3c       	stdsp	sp[0x8c],r12
800081d0:	42 89       	lddsp	r9,sp[0xa0]
800081d2:	2b 89       	sub	r9,-72
800081d4:	52 69       	stdsp	sp[0x98],r9
800081d6:	30 08       	mov	r8,0
800081d8:	52 58       	stdsp	sp[0x94],r8
800081da:	52 28       	stdsp	sp[0x88],r8
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
      output_col = 0;
      last_block_column = compptr->width_in_blocks - 1;
800081dc:	52 08       	stdsp	sp[0x80],r8
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
800081de:	30 04       	mov	r4,0
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
      output_col = 0;
      last_block_column = compptr->width_in_blocks - 1;
800081e0:	52 18       	stdsp	sp[0x84],r8

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Don't bother to IDCT an uninteresting component. */
    if (! compptr->component_needed)
800081e2:	40 3e       	lddsp	lr,sp[0xc]
800081e4:	7c c8       	ld.w	r8,lr[0x30]
800081e6:	58 08       	cp.w	r8,0
800081e8:	e0 80 02 10 	breq	80008608 <decompress_smooth_data+0x4ac>
      continue;
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (cinfo->output_iMCU_row < last_iMCU_row) {
800081ec:	40 cc       	lddsp	r12,sp[0x30]
800081ee:	f8 fb 00 9c 	ld.w	r11,r12[156]
800081f2:	42 9a       	lddsp	r10,sp[0xa4]
800081f4:	16 3a       	cp.w	r10,r11
800081f6:	e0 88 00 09 	brls	80008208 <decompress_smooth_data+0xac>
      block_rows = compptr->v_samp_factor;
800081fa:	42 39       	lddsp	r9,sp[0x8c]
800081fc:	72 09       	ld.w	r9,r9[0x0]
800081fe:	51 d9       	stdsp	sp[0x74],r9
      access_rows = block_rows * 2; /* this and next iMCU row */
80008200:	a1 79       	lsl	r9,0x1
80008202:	30 08       	mov	r8,0
80008204:	51 e8       	stdsp	sp[0x78],r8
80008206:	c1 68       	rjmp	80008232 <decompress_smooth_data+0xd6>
      last_row = FALSE;
    } else {
      /* NB: can't use last_row_height here; it is input-side-dependent! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
80008208:	42 30       	lddsp	r0,sp[0x8c]
8000820a:	60 09       	ld.w	r9,r0[0x0]
8000820c:	40 3e       	lddsp	lr,sp[0xc]
8000820e:	7c 87       	ld.w	r7,lr[0x20]
80008210:	ee 09 0d 06 	divu	r6,r7,r9
80008214:	0e 9c       	mov	r12,r7
80008216:	51 dc       	stdsp	sp[0x74],r12
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
80008218:	58 0c       	cp.w	r12,0
8000821a:	fb f9 0a 1d 	st.weq	sp[0x74],r9
8000821e:	f9 ba 00 01 	moveq	r10,1
80008222:	fb fa 0a 1e 	st.weq	sp[0x78],r10
80008226:	fb f9 10 1d 	ld.wne	r9,sp[0x74]
8000822a:	f9 b8 01 01 	movne	r8,1
8000822e:	fb f8 1a 1e 	st.wne	sp[0x78],r8
      access_rows = block_rows; /* this iMCU row only */
      last_row = TRUE;
    }
    /* Align the virtual buffer for this component. */
    if (cinfo->output_iMCU_row > 0) {
80008232:	58 0b       	cp.w	r11,0
80008234:	c1 40       	breq	8000825c <decompress_smooth_data+0x100>
      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
80008236:	42 30       	lddsp	r0,sp[0x8c]
80008238:	60 0a       	ld.w	r10,r0[0x0]
      buffer = (*cinfo->mem->access_virt_barray)
8000823a:	40 ce       	lddsp	lr,sp[0x30]
8000823c:	7c 18       	ld.w	r8,lr[0x4]
8000823e:	20 1b       	sub	r11,1
80008240:	70 87       	ld.w	r7,r8[0x20]
80008242:	30 08       	mov	r8,0
80008244:	14 09       	add	r9,r10
80008246:	b7 3a       	mul	r10,r11
80008248:	42 6c       	lddsp	r12,sp[0x98]
8000824a:	78 0b       	ld.w	r11,r12[0x0]
8000824c:	1c 9c       	mov	r12,lr
8000824e:	5d 17       	icall	r7
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
	 (JDIMENSION) access_rows, FALSE);
      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
80008250:	60 02       	ld.w	r2,r0[0x0]
80008252:	f8 02 00 22 	add	r2,r12,r2<<0x2
80008256:	30 0a       	mov	r10,0
80008258:	51 fa       	stdsp	sp[0x7c],r10
8000825a:	c0 d8       	rjmp	80008274 <decompress_smooth_data+0x118>
      first_row = FALSE;
    } else {
      buffer = (*cinfo->mem->access_virt_barray)
8000825c:	40 c0       	lddsp	r0,sp[0x30]
8000825e:	60 18       	ld.w	r8,r0[0x4]
80008260:	70 87       	ld.w	r7,r8[0x20]
80008262:	30 08       	mov	r8,0
80008264:	10 9a       	mov	r10,r8
80008266:	42 6e       	lddsp	lr,sp[0x98]
80008268:	7c 0b       	ld.w	r11,lr[0x0]
8000826a:	00 9c       	mov	r12,r0
8000826c:	5d 17       	icall	r7
8000826e:	18 92       	mov	r2,r12
80008270:	30 1c       	mov	r12,1
80008272:	51 fc       	stdsp	sp[0x7c],r12
	((j_common_ptr) cinfo, coef->whole_image[ci],
	 (JDIMENSION) 0, (JDIMENSION) access_rows, FALSE);
      first_row = TRUE;
    }
    /* Fetch component-dependent info */
    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
80008274:	42 8a       	lddsp	r10,sp[0xa0]
80008276:	75 67       	ld.w	r7,r10[0x58]
80008278:	42 59       	lddsp	r9,sp[0x94]
8000827a:	12 07       	add	r7,r9
    quanttbl = compptr->quant_table;
8000827c:	40 38       	lddsp	r8,sp[0xc]
8000827e:	71 3a       	ld.w	r10,r8[0x4c]
    Q00 = quanttbl->quantval[0];
80008280:	94 88       	ld.uh	r8,r10[0x0]
    Q01 = quanttbl->quantval[Q01_POS];
80008282:	94 9c       	ld.uh	r12,r10[0x2]
    Q10 = quanttbl->quantval[Q10_POS];
80008284:	f5 1b 00 10 	ld.uh	r11,r10[16]
    Q20 = quanttbl->quantval[Q20_POS];
80008288:	f5 19 00 20 	ld.uh	r9,r10[32]
    Q11 = quanttbl->quantval[Q11_POS];
8000828c:	f5 15 00 12 	ld.uh	r5,r10[18]
    Q02 = quanttbl->quantval[Q02_POS];
80008290:	94 a3       	ld.uh	r3,r10[0x4]
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
80008292:	40 c0       	lddsp	r0,sp[0x30]
80008294:	e0 f6 01 c0 	ld.w	r6,r0[448]
80008298:	42 2a       	lddsp	r10,sp[0x88]
8000829a:	2f fa       	sub	r10,-1
8000829c:	ec 0a 03 2a 	ld.w	r10,r6[r10<<0x2]
800082a0:	50 da       	stdsp	sp[0x34],r10
    output_ptr = output_buf[ci];
800082a2:	42 7e       	lddsp	lr,sp[0x9c]
800082a4:	7c 0e       	ld.w	lr,lr[0x0]
800082a6:	50 be       	stdsp	sp[0x2c],lr
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
800082a8:	41 da       	lddsp	r10,sp[0x74]
800082aa:	58 0a       	cp.w	r10,0
800082ac:	e0 8a 01 ae 	brle	80008608 <decompress_smooth_data+0x4ac>
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
	  num = 36 * Q00 * (DC4 - DC6);
800082b0:	f0 0a 15 03 	lsl	r10,r8,0x3
800082b4:	f4 08 00 06 	add	r6,r10,r8
800082b8:	a3 66       	lsl	r6,0x2
800082ba:	50 f6       	stdsp	sp[0x3c],r6
	  if (num >= 0) {
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
800082bc:	f8 00 15 07 	lsl	r0,r12,0x7
800082c0:	51 c0       	stdsp	sp[0x70],r0
800082c2:	a9 6c       	lsl	r12,0x8
800082c4:	51 bc       	stdsp	sp[0x6c],r12
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
	  num = 36 * Q00 * (DC2 - DC8);
	  if (num >= 0) {
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
800082c6:	f6 0e 15 07 	lsl	lr,r11,0x7
800082ca:	51 ae       	stdsp	sp[0x68],lr
800082cc:	a9 6b       	lsl	r11,0x8
800082ce:	51 9b       	stdsp	sp[0x64],r11
	  }
	  workspace[8] = (JCOEF) pred;
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
800082d0:	10 0a       	add	r10,r8
800082d2:	50 ea       	stdsp	sp[0x38],r10
	  if (num >= 0) {
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
800082d4:	f2 0c 15 07 	lsl	r12,r9,0x7
800082d8:	51 8c       	stdsp	sp[0x60],r12
800082da:	a9 69       	lsl	r9,0x8
800082dc:	51 79       	stdsp	sp[0x5c],r9
	  }
	  workspace[16] = (JCOEF) pred;
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
800082de:	f0 08 00 28 	add	r8,r8,r8<<0x2
800082e2:	51 68       	stdsp	sp[0x58],r8
	  if (num >= 0) {
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
800082e4:	ea 0a 15 07 	lsl	r10,r5,0x7
800082e8:	51 5a       	stdsp	sp[0x54],r10
800082ea:	a9 65       	lsl	r5,0x8
800082ec:	51 45       	stdsp	sp[0x50],r5
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
	  if (num >= 0) {
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
800082ee:	e6 09 15 07 	lsl	r9,r3,0x7
800082f2:	51 39       	stdsp	sp[0x4c],r9
800082f4:	a9 63       	lsl	r3,0x8
800082f6:	51 23       	stdsp	sp[0x48],r3
800082f8:	51 12       	stdsp	sp[0x44],r2
800082fa:	30 08       	mov	r8,0
800082fc:	51 08       	stdsp	sp[0x40],r8
      buffer_ptr = buffer[block_row];
      if (first_row && block_row == 0)
	prev_block_row = buffer_ptr;
      else
	prev_block_row = buffer[block_row-1];
      if (last_row && block_row == block_rows-1)
800082fe:	41 d0       	lddsp	r0,sp[0x74]
80008300:	20 10       	sub	r0,1
80008302:	52 40       	stdsp	sp[0x90],r0
    Q02 = quanttbl->quantval[Q02_POS];
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
      buffer_ptr = buffer[block_row];
80008304:	41 1e       	lddsp	lr,sp[0x44]
80008306:	7c 05       	ld.w	r5,lr[0x0]
      if (first_row && block_row == 0)
80008308:	41 0c       	lddsp	r12,sp[0x40]
8000830a:	58 0c       	cp.w	r12,0
8000830c:	5f 08       	sreq	r8
8000830e:	41 fa       	lddsp	r10,sp[0x7c]
80008310:	f5 e8 00 08 	and	r8,r10,r8
80008314:	30 09       	mov	r9,0
80008316:	f2 08 18 00 	cp.b	r8,r9
8000831a:	c0 30       	breq	80008320 <decompress_smooth_data+0x1c4>
8000831c:	0a 92       	mov	r2,r5
8000831e:	c0 48       	rjmp	80008326 <decompress_smooth_data+0x1ca>
	prev_block_row = buffer_ptr;
      else
	prev_block_row = buffer[block_row-1];
80008320:	41 18       	lddsp	r8,sp[0x44]
80008322:	f0 f2 ff fc 	ld.w	r2,r8[-4]
      if (last_row && block_row == block_rows-1)
80008326:	41 e0       	lddsp	r0,sp[0x78]
80008328:	58 00       	cp.w	r0,0
8000832a:	c0 70       	breq	80008338 <decompress_smooth_data+0x1dc>
8000832c:	42 4e       	lddsp	lr,sp[0x90]
8000832e:	41 0c       	lddsp	r12,sp[0x40]
80008330:	18 3e       	cp.w	lr,r12
80008332:	c0 31       	brne	80008338 <decompress_smooth_data+0x1dc>
80008334:	0a 91       	mov	r1,r5
80008336:	c0 38       	rjmp	8000833c <decompress_smooth_data+0x1e0>
	next_block_row = buffer_ptr;
      else
	next_block_row = buffer[block_row+1];
80008338:	41 1a       	lddsp	r10,sp[0x44]
8000833a:	74 11       	ld.w	r1,r10[0x4]
      /* We fetch the surrounding DC values using a sliding-register approach.
       * Initialize all nine here so as to do the right thing on narrow pics.
       */
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
8000833c:	84 09       	ld.sh	r9,r2[0x0]
8000833e:	50 79       	stdsp	sp[0x1c],r9
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
80008340:	8a 08       	ld.sh	r8,r5[0x0]
80008342:	50 48       	stdsp	sp[0x10],r8
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
80008344:	82 00       	ld.sh	r0,r1[0x0]
80008346:	50 60       	stdsp	sp[0x18],r0
      output_col = 0;
      last_block_column = compptr->width_in_blocks - 1;
80008348:	40 3e       	lddsp	lr,sp[0xc]
8000834a:	7c 78       	ld.w	r8,lr[0x1c]
8000834c:	20 18       	sub	r8,1
8000834e:	50 58       	stdsp	sp[0x14],r8
80008350:	28 02       	sub	r2,-128
80008352:	28 01       	sub	r1,-128
80008354:	50 90       	stdsp	sp[0x24],r0
80008356:	40 4c       	lddsp	r12,sp[0x10]
80008358:	50 1c       	stdsp	sp[0x4],r12
8000835a:	50 8c       	stdsp	sp[0x20],r12
8000835c:	50 29       	stdsp	sp[0x8],r9
8000835e:	50 a9       	stdsp	sp[0x28],r9
80008360:	42 03       	lddsp	r3,sp[0x80]
80008362:	42 16       	lddsp	r6,sp[0x84]
80008364:	50 00       	stdsp	sp[0x0],r0
      for (block_num = 0; block_num <= last_block_column; block_num++) {
	/* Fetch current DCT block into workspace so we can modify it. */
	jcopy_block_row(buffer_ptr, (JBLOCKROW) workspace, (JDIMENSION) 1);
80008366:	30 1a       	mov	r10,1
80008368:	fa cb ff 58 	sub	r11,sp,-168
8000836c:	0a 9c       	mov	r12,r5
8000836e:	f0 1f 00 bb 	mcall	80008658 <decompress_smooth_data+0x4fc>
	/* Update DC values */
	if (block_num < last_block_column) {
80008372:	40 5a       	lddsp	r10,sp[0x14]
80008374:	0c 3a       	cp.w	r10,r6
80008376:	e0 88 00 09 	brls	80008388 <decompress_smooth_data+0x22c>
	  DC3 = (int) prev_block_row[1][0];
8000837a:	84 09       	ld.sh	r9,r2[0x0]
8000837c:	50 79       	stdsp	sp[0x1c],r9
	  DC6 = (int) buffer_ptr[1][0];
8000837e:	eb 08 00 80 	ld.sh	r8,r5[128]
80008382:	50 48       	stdsp	sp[0x10],r8
	  DC9 = (int) next_block_row[1][0];
80008384:	82 00       	ld.sh	r0,r1[0x0]
80008386:	50 60       	stdsp	sp[0x18],r0
	/* Compute coefficient estimates per K.8.
	 * An estimate is applied only if coefficient is still zero,
	 * and is not known to be fully accurate.
	 */
	/* AC01 */
	if ((Al=coef_bits[1]) != 0 && workspace[1] == 0) {
80008388:	6e 18       	ld.w	r8,r7[0x4]
8000838a:	58 08       	cp.w	r8,0
8000838c:	c3 20       	breq	800083f0 <decompress_smooth_data+0x294>
8000838e:	fb 09 00 aa 	ld.sh	r9,sp[170]
80008392:	e8 09 19 00 	cp.h	r9,r4
80008396:	c2 d1       	brne	800083f0 <decompress_smooth_data+0x294>
	  num = 36 * Q00 * (DC4 - DC6);
80008398:	40 8b       	lddsp	r11,sp[0x20]
8000839a:	40 4e       	lddsp	lr,sp[0x10]
8000839c:	1c 1b       	sub	r11,lr
8000839e:	40 fc       	lddsp	r12,sp[0x3c]
800083a0:	b9 3b       	mul	r11,r12
	  if (num >= 0) {
800083a2:	58 0b       	cp.w	r11,0
800083a4:	c1 25       	brlt	800083c8 <decompress_smooth_data+0x26c>
	    pred = (int) (((Q01<<7) + num) / (Q01<<8));
800083a6:	41 ca       	lddsp	r10,sp[0x70]
800083a8:	14 0b       	add	r11,r10
800083aa:	41 b9       	lddsp	r9,sp[0x6c]
800083ac:	f6 09 0c 0a 	divs	r10,r11,r9
800083b0:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
800083b2:	58 08       	cp.w	r8,0
800083b4:	e0 8a 00 1c 	brle	800083ec <decompress_smooth_data+0x290>
800083b8:	30 10       	mov	r0,1
800083ba:	e0 08 09 48 	lsl	r8,r0,r8
800083be:	10 3a       	cp.w	r10,r8
800083c0:	c1 65       	brlt	800083ec <decompress_smooth_data+0x290>
	      pred = (1<<Al)-1;
800083c2:	f0 c9 00 01 	sub	r9,r8,1
800083c6:	c1 38       	rjmp	800083ec <decompress_smooth_data+0x290>
	  } else {
	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
800083c8:	41 ce       	lddsp	lr,sp[0x70]
800083ca:	fc 0b 01 0b 	sub	r11,lr,r11
800083ce:	41 bc       	lddsp	r12,sp[0x6c]
800083d0:	f6 0c 0c 0a 	divs	r10,r11,r12
800083d4:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
800083d6:	58 08       	cp.w	r8,0
800083d8:	e0 8a 00 09 	brle	800083ea <decompress_smooth_data+0x28e>
800083dc:	30 1a       	mov	r10,1
800083de:	f4 08 09 48 	lsl	r8,r10,r8
800083e2:	10 39       	cp.w	r9,r8
800083e4:	c0 35       	brlt	800083ea <decompress_smooth_data+0x28e>
	      pred = (1<<Al)-1;
800083e6:	f0 c9 00 01 	sub	r9,r8,1
	    pred = -pred;
800083ea:	5c 39       	neg	r9
	  }
	  workspace[1] = (JCOEF) pred;
800083ec:	fb 59 00 aa 	st.h	sp[170],r9
	}
	/* AC10 */
	if ((Al=coef_bits[2]) != 0 && workspace[8] == 0) {
800083f0:	6e 28       	ld.w	r8,r7[0x8]
800083f2:	58 08       	cp.w	r8,0
800083f4:	c3 30       	breq	8000845a <decompress_smooth_data+0x2fe>
800083f6:	fb 09 00 b8 	ld.sh	r9,sp[184]
800083fa:	e8 09 19 00 	cp.h	r9,r4
800083fe:	c2 e1       	brne	8000845a <decompress_smooth_data+0x2fe>
	  num = 36 * Q00 * (DC2 - DC8);
80008400:	40 2b       	lddsp	r11,sp[0x8]
80008402:	40 09       	lddsp	r9,sp[0x0]
80008404:	12 1b       	sub	r11,r9
80008406:	40 f0       	lddsp	r0,sp[0x3c]
80008408:	e0 0b 02 4b 	mul	r11,r0,r11
	  if (num >= 0) {
8000840c:	58 0b       	cp.w	r11,0
8000840e:	c1 25       	brlt	80008432 <decompress_smooth_data+0x2d6>
	    pred = (int) (((Q10<<7) + num) / (Q10<<8));
80008410:	41 ae       	lddsp	lr,sp[0x68]
80008412:	1c 0b       	add	r11,lr
80008414:	41 9c       	lddsp	r12,sp[0x64]
80008416:	f6 0c 0c 0a 	divs	r10,r11,r12
8000841a:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
8000841c:	58 08       	cp.w	r8,0
8000841e:	e0 8a 00 1c 	brle	80008456 <decompress_smooth_data+0x2fa>
80008422:	30 1a       	mov	r10,1
80008424:	f4 08 09 48 	lsl	r8,r10,r8
80008428:	10 39       	cp.w	r9,r8
8000842a:	c1 65       	brlt	80008456 <decompress_smooth_data+0x2fa>
	      pred = (1<<Al)-1;
8000842c:	f0 c9 00 01 	sub	r9,r8,1
80008430:	c1 38       	rjmp	80008456 <decompress_smooth_data+0x2fa>
	  } else {
	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
80008432:	41 a9       	lddsp	r9,sp[0x68]
80008434:	f2 0b 01 0b 	sub	r11,r9,r11
80008438:	41 90       	lddsp	r0,sp[0x64]
8000843a:	f6 00 0c 0a 	divs	r10,r11,r0
8000843e:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
80008440:	58 08       	cp.w	r8,0
80008442:	e0 8a 00 09 	brle	80008454 <decompress_smooth_data+0x2f8>
80008446:	30 1e       	mov	lr,1
80008448:	fc 08 09 48 	lsl	r8,lr,r8
8000844c:	10 3a       	cp.w	r10,r8
8000844e:	c0 35       	brlt	80008454 <decompress_smooth_data+0x2f8>
	      pred = (1<<Al)-1;
80008450:	f0 c9 00 01 	sub	r9,r8,1
	    pred = -pred;
80008454:	5c 39       	neg	r9
	  }
	  workspace[8] = (JCOEF) pred;
80008456:	fb 59 00 b8 	st.h	sp[184],r9
	}
	/* AC20 */
	if ((Al=coef_bits[3]) != 0 && workspace[16] == 0) {
8000845a:	6e 38       	ld.w	r8,r7[0xc]
8000845c:	58 08       	cp.w	r8,0
8000845e:	c3 50       	breq	800084c8 <decompress_smooth_data+0x36c>
80008460:	fb 09 00 c8 	ld.sh	r9,sp[200]
80008464:	e8 09 19 00 	cp.h	r9,r4
80008468:	c3 01       	brne	800084c8 <decompress_smooth_data+0x36c>
	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
8000846a:	40 0b       	lddsp	r11,sp[0x0]
8000846c:	40 2c       	lddsp	r12,sp[0x8]
8000846e:	18 0b       	add	r11,r12
80008470:	40 1a       	lddsp	r10,sp[0x4]
80008472:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
80008476:	40 e9       	lddsp	r9,sp[0x38]
80008478:	b3 3b       	mul	r11,r9
	  if (num >= 0) {
8000847a:	58 0b       	cp.w	r11,0
8000847c:	c1 25       	brlt	800084a0 <decompress_smooth_data+0x344>
	    pred = (int) (((Q20<<7) + num) / (Q20<<8));
8000847e:	41 80       	lddsp	r0,sp[0x60]
80008480:	00 0b       	add	r11,r0
80008482:	41 7e       	lddsp	lr,sp[0x5c]
80008484:	f6 0e 0c 0a 	divs	r10,r11,lr
80008488:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
8000848a:	58 08       	cp.w	r8,0
8000848c:	e0 8a 00 1c 	brle	800084c4 <decompress_smooth_data+0x368>
80008490:	30 1c       	mov	r12,1
80008492:	f8 08 09 48 	lsl	r8,r12,r8
80008496:	10 3a       	cp.w	r10,r8
80008498:	c1 65       	brlt	800084c4 <decompress_smooth_data+0x368>
	      pred = (1<<Al)-1;
8000849a:	f0 c9 00 01 	sub	r9,r8,1
8000849e:	c1 38       	rjmp	800084c4 <decompress_smooth_data+0x368>
	  } else {
	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
800084a0:	41 8a       	lddsp	r10,sp[0x60]
800084a2:	f4 0b 01 0b 	sub	r11,r10,r11
800084a6:	41 79       	lddsp	r9,sp[0x5c]
800084a8:	f6 09 0c 0a 	divs	r10,r11,r9
800084ac:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
800084ae:	58 08       	cp.w	r8,0
800084b0:	e0 8a 00 09 	brle	800084c2 <decompress_smooth_data+0x366>
800084b4:	30 10       	mov	r0,1
800084b6:	e0 08 09 48 	lsl	r8,r0,r8
800084ba:	10 3a       	cp.w	r10,r8
800084bc:	c0 35       	brlt	800084c2 <decompress_smooth_data+0x366>
	      pred = (1<<Al)-1;
800084be:	f0 c9 00 01 	sub	r9,r8,1
	    pred = -pred;
800084c2:	5c 39       	neg	r9
	  }
	  workspace[16] = (JCOEF) pred;
800084c4:	fb 59 00 c8 	st.h	sp[200],r9
	}
	/* AC11 */
	if ((Al=coef_bits[4]) != 0 && workspace[9] == 0) {
800084c8:	6e 48       	ld.w	r8,r7[0x10]
800084ca:	58 08       	cp.w	r8,0
800084cc:	c3 60       	breq	80008538 <decompress_smooth_data+0x3dc>
800084ce:	fb 09 00 ba 	ld.sh	r9,sp[186]
800084d2:	e8 09 19 00 	cp.h	r9,r4
800084d6:	c3 11       	brne	80008538 <decompress_smooth_data+0x3dc>
	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
800084d8:	40 ab       	lddsp	r11,sp[0x28]
800084da:	40 9e       	lddsp	lr,sp[0x24]
800084dc:	1c 1b       	sub	r11,lr
800084de:	40 6c       	lddsp	r12,sp[0x18]
800084e0:	18 0b       	add	r11,r12
800084e2:	40 7a       	lddsp	r10,sp[0x1c]
800084e4:	14 1b       	sub	r11,r10
800084e6:	41 69       	lddsp	r9,sp[0x58]
800084e8:	b3 3b       	mul	r11,r9
	  if (num >= 0) {
800084ea:	58 0b       	cp.w	r11,0
800084ec:	c1 25       	brlt	80008510 <decompress_smooth_data+0x3b4>
	    pred = (int) (((Q11<<7) + num) / (Q11<<8));
800084ee:	41 50       	lddsp	r0,sp[0x54]
800084f0:	00 0b       	add	r11,r0
800084f2:	41 4e       	lddsp	lr,sp[0x50]
800084f4:	f6 0e 0c 0a 	divs	r10,r11,lr
800084f8:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
800084fa:	58 08       	cp.w	r8,0
800084fc:	e0 8a 00 1c 	brle	80008534 <decompress_smooth_data+0x3d8>
80008500:	30 1c       	mov	r12,1
80008502:	f8 08 09 48 	lsl	r8,r12,r8
80008506:	10 3a       	cp.w	r10,r8
80008508:	c1 65       	brlt	80008534 <decompress_smooth_data+0x3d8>
	      pred = (1<<Al)-1;
8000850a:	f0 c9 00 01 	sub	r9,r8,1
8000850e:	c1 38       	rjmp	80008534 <decompress_smooth_data+0x3d8>
	  } else {
	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
80008510:	41 5a       	lddsp	r10,sp[0x54]
80008512:	f4 0b 01 0b 	sub	r11,r10,r11
80008516:	41 49       	lddsp	r9,sp[0x50]
80008518:	f6 09 0c 0a 	divs	r10,r11,r9
8000851c:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
8000851e:	58 08       	cp.w	r8,0
80008520:	e0 8a 00 09 	brle	80008532 <decompress_smooth_data+0x3d6>
80008524:	30 10       	mov	r0,1
80008526:	e0 08 09 48 	lsl	r8,r0,r8
8000852a:	10 3a       	cp.w	r10,r8
8000852c:	c0 35       	brlt	80008532 <decompress_smooth_data+0x3d6>
	      pred = (1<<Al)-1;
8000852e:	f0 c9 00 01 	sub	r9,r8,1
	    pred = -pred;
80008532:	5c 39       	neg	r9
	  }
	  workspace[9] = (JCOEF) pred;
80008534:	fb 59 00 ba 	st.h	sp[186],r9
	}
	/* AC02 */
	if ((Al=coef_bits[5]) != 0 && workspace[2] == 0) {
80008538:	6e 58       	ld.w	r8,r7[0x14]
8000853a:	58 08       	cp.w	r8,0
8000853c:	c3 60       	breq	800085a8 <decompress_smooth_data+0x44c>
8000853e:	fb 09 00 ac 	ld.sh	r9,sp[172]
80008542:	e8 09 19 00 	cp.h	r9,r4
80008546:	c3 11       	brne	800085a8 <decompress_smooth_data+0x44c>
	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
80008548:	40 8e       	lddsp	lr,sp[0x20]
8000854a:	40 1c       	lddsp	r12,sp[0x4]
8000854c:	fc 0c 01 1b 	sub	r11,lr,r12<<0x1
80008550:	40 4a       	lddsp	r10,sp[0x10]
80008552:	14 0b       	add	r11,r10
80008554:	40 e9       	lddsp	r9,sp[0x38]
80008556:	f2 0b 02 4b 	mul	r11,r9,r11
	  if (num >= 0) {
8000855a:	58 0b       	cp.w	r11,0
8000855c:	c1 25       	brlt	80008580 <decompress_smooth_data+0x424>
	    pred = (int) (((Q02<<7) + num) / (Q02<<8));
8000855e:	41 30       	lddsp	r0,sp[0x4c]
80008560:	00 0b       	add	r11,r0
80008562:	41 2e       	lddsp	lr,sp[0x48]
80008564:	f6 0e 0c 0a 	divs	r10,r11,lr
80008568:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
8000856a:	58 08       	cp.w	r8,0
8000856c:	e0 8a 00 1c 	brle	800085a4 <decompress_smooth_data+0x448>
80008570:	30 1c       	mov	r12,1
80008572:	f8 08 09 48 	lsl	r8,r12,r8
80008576:	10 3a       	cp.w	r10,r8
80008578:	c1 65       	brlt	800085a4 <decompress_smooth_data+0x448>
	      pred = (1<<Al)-1;
8000857a:	f0 c9 00 01 	sub	r9,r8,1
8000857e:	c1 38       	rjmp	800085a4 <decompress_smooth_data+0x448>
	  } else {
	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
80008580:	41 3a       	lddsp	r10,sp[0x4c]
80008582:	f4 0b 01 0b 	sub	r11,r10,r11
80008586:	41 29       	lddsp	r9,sp[0x48]
80008588:	f6 09 0c 0a 	divs	r10,r11,r9
8000858c:	14 99       	mov	r9,r10
	    if (Al > 0 && pred >= (1<<Al))
8000858e:	58 08       	cp.w	r8,0
80008590:	e0 8a 00 09 	brle	800085a2 <decompress_smooth_data+0x446>
80008594:	30 10       	mov	r0,1
80008596:	e0 08 09 48 	lsl	r8,r0,r8
8000859a:	10 3a       	cp.w	r10,r8
8000859c:	c0 35       	brlt	800085a2 <decompress_smooth_data+0x446>
	      pred = (1<<Al)-1;
8000859e:	f0 c9 00 01 	sub	r9,r8,1
	    pred = -pred;
800085a2:	5c 39       	neg	r9
	  }
	  workspace[2] = (JCOEF) pred;
800085a4:	fb 59 00 ac 	st.h	sp[172],r9
	}
	/* OK, do the IDCT */
	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) workspace,
800085a8:	06 98       	mov	r8,r3
800085aa:	40 b9       	lddsp	r9,sp[0x2c]
800085ac:	fa ca ff 58 	sub	r10,sp,-168
800085b0:	40 3b       	lddsp	r11,sp[0xc]
800085b2:	40 cc       	lddsp	r12,sp[0x30]
800085b4:	40 d0       	lddsp	r0,sp[0x34]
800085b6:	5d 10       	icall	r0
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
	DC4 = DC5; DC5 = DC6;
	DC7 = DC8; DC8 = DC9;
	buffer_ptr++, prev_block_row++, next_block_row++;
	output_col += compptr->DCT_scaled_size;
800085b8:	40 3e       	lddsp	lr,sp[0xc]
800085ba:	7c 98       	ld.w	r8,lr[0x24]
      DC1 = DC2 = DC3 = (int) prev_block_row[0][0];
      DC4 = DC5 = DC6 = (int) buffer_ptr[0][0];
      DC7 = DC8 = DC9 = (int) next_block_row[0][0];
      output_col = 0;
      last_block_column = compptr->width_in_blocks - 1;
      for (block_num = 0; block_num <= last_block_column; block_num++) {
800085bc:	2f f6       	sub	r6,-1
800085be:	28 02       	sub	r2,-128
800085c0:	28 01       	sub	r1,-128
800085c2:	40 5c       	lddsp	r12,sp[0x14]
800085c4:	0c 3c       	cp.w	r12,r6
800085c6:	c1 03       	brcs	800085e6 <decompress_smooth_data+0x48a>
			output_ptr, output_col);
	/* Advance for next column */
	DC1 = DC2; DC2 = DC3;
	DC4 = DC5; DC5 = DC6;
	DC7 = DC8; DC8 = DC9;
	buffer_ptr++, prev_block_row++, next_block_row++;
800085c8:	28 05       	sub	r5,-128
	output_col += compptr->DCT_scaled_size;
800085ca:	10 03       	add	r3,r8
800085cc:	40 2a       	lddsp	r10,sp[0x8]
800085ce:	50 aa       	stdsp	sp[0x28],r10
800085d0:	40 79       	lddsp	r9,sp[0x1c]
800085d2:	50 29       	stdsp	sp[0x8],r9
800085d4:	40 18       	lddsp	r8,sp[0x4]
800085d6:	50 88       	stdsp	sp[0x20],r8
800085d8:	40 40       	lddsp	r0,sp[0x10]
800085da:	50 10       	stdsp	sp[0x4],r0
800085dc:	40 0e       	lddsp	lr,sp[0x0]
800085de:	50 9e       	stdsp	sp[0x24],lr
800085e0:	40 6c       	lddsp	r12,sp[0x18]
800085e2:	50 0c       	stdsp	sp[0x0],r12
800085e4:	cc 1a       	rjmp	80008366 <decompress_smooth_data+0x20a>
      }
      output_ptr += compptr->DCT_scaled_size;
800085e6:	40 3a       	lddsp	r10,sp[0xc]
800085e8:	74 98       	ld.w	r8,r10[0x24]
    Q11 = quanttbl->quantval[Q11_POS];
    Q02 = quanttbl->quantval[Q02_POS];
    inverse_DCT = cinfo->idct->inverse_DCT[ci];
    output_ptr = output_buf[ci];
    /* Loop over all DCT blocks to be processed. */
    for (block_row = 0; block_row < block_rows; block_row++) {
800085ea:	41 09       	lddsp	r9,sp[0x40]
800085ec:	2f f9       	sub	r9,-1
800085ee:	51 09       	stdsp	sp[0x40],r9
800085f0:	41 10       	lddsp	r0,sp[0x44]
800085f2:	2f c0       	sub	r0,-4
800085f4:	51 10       	stdsp	sp[0x44],r0
800085f6:	41 de       	lddsp	lr,sp[0x74]
800085f8:	12 3e       	cp.w	lr,r9
800085fa:	e0 8a 00 07 	brle	80008608 <decompress_smooth_data+0x4ac>
	DC4 = DC5; DC5 = DC6;
	DC7 = DC8; DC8 = DC9;
	buffer_ptr++, prev_block_row++, next_block_row++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
800085fe:	40 bc       	lddsp	r12,sp[0x2c]
80008600:	f8 08 00 2c 	add	r12,r12,r8<<0x2
80008604:	50 bc       	stdsp	sp[0x2c],r12
80008606:	c7 fa       	rjmp	80008304 <decompress_smooth_data+0x1a8>
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80008608:	42 2a       	lddsp	r10,sp[0x88]
8000860a:	2f fa       	sub	r10,-1
8000860c:	52 2a       	stdsp	sp[0x88],r10
8000860e:	42 59       	lddsp	r9,sp[0x94]
80008610:	2e 89       	sub	r9,-24
80008612:	52 59       	stdsp	sp[0x94],r9
80008614:	42 78       	lddsp	r8,sp[0x9c]
80008616:	2f c8       	sub	r8,-4
80008618:	52 78       	stdsp	sp[0x9c],r8
8000861a:	42 30       	lddsp	r0,sp[0x8c]
8000861c:	2a c0       	sub	r0,-84
8000861e:	52 30       	stdsp	sp[0x8c],r0
80008620:	42 6e       	lddsp	lr,sp[0x98]
80008622:	2f ce       	sub	lr,-4
80008624:	52 6e       	stdsp	sp[0x98],lr
    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
      return JPEG_SUSPENDED;
  }

  /* OK, output from the virtual arrays. */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80008626:	40 cc       	lddsp	r12,sp[0x30]
80008628:	78 98       	ld.w	r8,r12[0x24]
8000862a:	14 38       	cp.w	r8,r10
8000862c:	e0 8a 00 07 	brle	8000863a <decompress_smooth_data+0x4de>
       ci++, compptr++) {
80008630:	40 3a       	lddsp	r10,sp[0xc]
80008632:	2a ca       	sub	r10,-84
80008634:	50 3a       	stdsp	sp[0xc],r10
80008636:	fe 9f fd d6 	bral	800081e2 <decompress_smooth_data+0x86>
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }

  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
8000863a:	40 c9       	lddsp	r9,sp[0x30]
8000863c:	f2 f8 00 9c 	ld.w	r8,r9[156]
80008640:	2f f8       	sub	r8,-1
80008642:	f3 48 00 9c 	st.w	r9[156],r8
80008646:	f2 fc 01 40 	ld.w	r12,r9[320]
8000864a:	18 38       	cp.w	r8,r12
8000864c:	f9 bc 03 03 	movlo	r12,3
80008650:	f9 bc 02 04 	movhs	r12,4
    return JPEG_ROW_COMPLETED;
  return JPEG_SCAN_COMPLETED;
}
80008654:	2b 6d       	sub	sp,-296
80008656:	d8 32       	popm	r0-r7,pc
80008658:	80 00       	ld.sh	r0,r0[0x0]
8000865a:	fd 30 eb cd 	ld.ub	r0,lr[-5171]

8000865c <build_ycc_rgb_table>:
 * Initialize tables for YCC->RGB colorspace conversion.
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
8000865c:	eb cd 40 c0 	pushm	r6-r7,lr
80008660:	18 96       	mov	r6,r12
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
80008662:	f8 f7 01 c8 	ld.w	r7,r12[456]
  int i;
  INT32 x;
  SHIFT_TEMPS

  cconvert->Cr_r_tab = (int *)
80008666:	78 18       	ld.w	r8,r12[0x4]
80008668:	70 08       	ld.w	r8,r8[0x0]
8000866a:	e0 6a 04 00 	mov	r10,1024
8000866e:	30 1b       	mov	r11,1
80008670:	5d 18       	icall	r8
80008672:	8f 2c       	st.w	r7[0x8],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cb_b_tab = (int *)
80008674:	6c 18       	ld.w	r8,r6[0x4]
80008676:	70 08       	ld.w	r8,r8[0x0]
80008678:	e0 6a 04 00 	mov	r10,1024
8000867c:	30 1b       	mov	r11,1
8000867e:	0c 9c       	mov	r12,r6
80008680:	5d 18       	icall	r8
80008682:	8f 3c       	st.w	r7[0xc],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  cconvert->Cr_g_tab = (INT32 *)
80008684:	6c 18       	ld.w	r8,r6[0x4]
80008686:	70 08       	ld.w	r8,r8[0x0]
80008688:	e0 6a 04 00 	mov	r10,1024
8000868c:	30 1b       	mov	r11,1
8000868e:	0c 9c       	mov	r12,r6
80008690:	5d 18       	icall	r8
80008692:	8f 4c       	st.w	r7[0x10],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
80008694:	6c 18       	ld.w	r8,r6[0x4]
80008696:	70 08       	ld.w	r8,r8[0x0]
80008698:	e0 6a 04 00 	mov	r10,1024
8000869c:	30 1b       	mov	r11,1
8000869e:	0c 9c       	mov	r12,r6
800086a0:	5d 18       	icall	r8
800086a2:	8f 5c       	st.w	r7[0x14],r12
800086a4:	e0 6c 8d 00 	mov	r12,36096
800086a8:	ea 1c 00 2c 	orh	r12,0x2c
800086ac:	e0 6b 69 00 	mov	r11,26880
800086b0:	ea 1b 00 5b 	orh	r11,0x5b
800086b4:	e0 6a af 00 	mov	r10,44800
800086b8:	ea 1a ff 1d 	orh	r10,0xff1d
800086bc:	e0 69 0b 80 	mov	r9,2944
800086c0:	ea 19 ff 4d 	orh	r9,0xff4d
800086c4:	30 08       	mov	r8,0

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    cconvert->Cr_r_tab[i] = (int)
800086c6:	6e 2e       	ld.w	lr,r7[0x8]
800086c8:	f2 06 14 10 	asr	r6,r9,0x10
800086cc:	fc 08 09 06 	st.w	lr[r8],r6
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    cconvert->Cb_b_tab[i] = (int)
800086d0:	6e 36       	ld.w	r6,r7[0xc]
800086d2:	f4 0e 14 10 	asr	lr,r10,0x10
800086d6:	ec 08 09 0e 	st.w	r6[r8],lr
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
800086da:	6e 46       	ld.w	r6,r7[0x10]
800086dc:	ec 08 09 0b 	st.w	r6[r8],r11
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
800086e0:	6e 56       	ld.w	r6,r7[0x14]
800086e2:	ec 08 09 0c 	st.w	r6[r8],r12
800086e6:	2f c8       	sub	r8,-4
800086e8:	fe 29 99 17 	sub	r9,-91881
800086ec:	fe 2a 3a 5e 	sub	r10,-116130
800086f0:	e0 2b b6 d2 	sub	r11,46802
800086f4:	f8 cc 58 1a 	sub	r12,r12,22554
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  cconvert->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
800086f8:	e0 48 04 00 	cp.w	r8,1024
800086fc:	ce 51       	brne	800086c6 <build_ycc_rgb_table+0x6a>
    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
  }
}
800086fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80008702 <ycc_rgb_convert>:

METHODDEF(void)
ycc_rgb_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
80008702:	d4 31       	pushm	r0-r7,lr
80008704:	20 6d       	sub	sp,24
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
80008706:	f8 f7 01 c8 	ld.w	r7,r12[456]
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
8000870a:	79 ce       	ld.w	lr,r12[0x70]
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
8000870c:	f8 fc 01 44 	ld.w	r12,r12[324]
  register int * Crrtab = cconvert->Cr_r_tab;
80008710:	6e 26       	ld.w	r6,r7[0x8]
80008712:	50 56       	stdsp	sp[0x14],r6
  register int * Cbbtab = cconvert->Cb_b_tab;
80008714:	6e 31       	ld.w	r1,r7[0xc]
80008716:	50 41       	stdsp	sp[0x10],r1
  register INT32 * Crgtab = cconvert->Cr_g_tab;
80008718:	6e 46       	ld.w	r6,r7[0x10]
8000871a:	50 36       	stdsp	sp[0xc],r6
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
8000871c:	6e 51       	ld.w	r1,r7[0x14]
8000871e:	50 21       	stdsp	sp[0x8],r1
80008720:	a3 6a       	lsl	r10,0x2
  SHIFT_TEMPS

  while (--num_rows >= 0) {
80008722:	c4 38       	rjmp	800087a8 <ycc_rgb_convert+0xa6>
    inptr0 = input_buf[0][input_row];
80008724:	76 07       	ld.w	r7,r11[0x0]
80008726:	ee 0a 03 04 	ld.w	r4,r7[r10]
    inptr1 = input_buf[1][input_row];
8000872a:	76 17       	ld.w	r7,r11[0x4]
8000872c:	ee 0a 03 05 	ld.w	r5,r7[r10]
    inptr2 = input_buf[2][input_row];
80008730:	76 27       	ld.w	r7,r11[0x8]
80008732:	ee 0a 03 06 	ld.w	r6,r7[r10]
    input_row++;
    outptr = *output_buf++;
80008736:	72 07       	ld.w	r7,r9[0x0]
    for (col = 0; col < num_cols; col++) {
80008738:	58 0e       	cp.w	lr,0
8000873a:	c3 50       	breq	800087a4 <ycc_rgb_convert+0xa2>
8000873c:	30 03       	mov	r3,0
8000873e:	50 08       	stdsp	sp[0x0],r8
      y  = GETJSAMPLE(inptr0[col]);
80008740:	e8 03 07 02 	ld.ub	r2,r4[r3]
      cb = GETJSAMPLE(inptr1[col]);
80008744:	ea 03 07 08 	ld.ub	r8,r5[r3]
80008748:	50 18       	stdsp	sp[0x4],r8
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
8000874a:	ec 03 07 00 	ld.ub	r0,r6[r3]
8000874e:	a3 60       	lsl	r0,0x2
80008750:	40 51       	lddsp	r1,sp[0x14]
80008752:	e2 00 03 08 	ld.w	r8,r1[r0]
80008756:	f8 08 00 01 	add	r1,r12,r8
8000875a:	e2 02 07 01 	ld.ub	r1,r1[r2]
8000875e:	ae a1       	st.b	r7[0x2],r1
      outptr[RGB_GREEN] = range_limit[y +
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
80008760:	40 11       	lddsp	r1,sp[0x4]
80008762:	a3 61       	lsl	r1,0x2
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];
      outptr[RGB_GREEN] = range_limit[y +
80008764:	40 38       	lddsp	r8,sp[0xc]
80008766:	f0 00 03 00 	ld.w	r0,r8[r0]
8000876a:	50 10       	stdsp	sp[0x4],r0
8000876c:	40 28       	lddsp	r8,sp[0x8]
8000876e:	f0 01 03 00 	ld.w	r0,r8[r1]
80008772:	40 18       	lddsp	r8,sp[0x4]
80008774:	f0 00 00 00 	add	r0,r8,r0
80008778:	b1 40       	asr	r0,0x10
8000877a:	50 10       	stdsp	sp[0x4],r0
8000877c:	f8 02 00 00 	add	r0,r12,r2
80008780:	40 18       	lddsp	r8,sp[0x4]
80008782:	e0 08 07 00 	ld.ub	r0,r0[r8]
80008786:	ae 90       	st.b	r7[0x1],r0
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
80008788:	40 48       	lddsp	r8,sp[0x10]
8000878a:	f0 01 03 01 	ld.w	r1,r8[r1]
8000878e:	f8 01 00 01 	add	r1,r12,r1
80008792:	e2 02 07 02 	ld.ub	r2,r1[r2]
80008796:	ae 82       	st.b	r7[0x0],r2
      outptr += RGB_PIXELSIZE;
80008798:	2f d7       	sub	r7,-3
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
8000879a:	2f f3       	sub	r3,-1
8000879c:	06 3e       	cp.w	lr,r3
8000879e:	fe 9b ff d1 	brhi	80008740 <ycc_rgb_convert+0x3e>
800087a2:	40 08       	lddsp	r8,sp[0x0]
  while (--num_rows >= 0) {
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;
    outptr = *output_buf++;
800087a4:	2f c9       	sub	r9,-4
800087a6:	2f ca       	sub	r10,-4
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
800087a8:	20 18       	sub	r8,1
800087aa:	cb d7       	brpl	80008724 <ycc_rgb_convert+0x22>
						 SCALEBITS))];
      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];
      outptr += RGB_PIXELSIZE;
    }
  }
}
800087ac:	2f ad       	sub	sp,-24
800087ae:	d8 32       	popm	r0-r7,pc

800087b0 <ycc_rgb565_convert>:

METHODDEF(void)
ycc_rgb565_convert (j_decompress_ptr cinfo,
		 JSAMPIMAGE input_buf, JDIMENSION input_row,
		 JSAMPARRAY output_buf, int num_rows)
{
800087b0:	d4 31       	pushm	r0-r7,lr
800087b2:	20 7d       	sub	sp,28
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
800087b4:	f8 fe 01 c8 	ld.w	lr,r12[456]
  register int y, cb, cr;
  //register unsigned short *outptr;
  register JSAMPROW inptr0, inptr1, inptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
800087b8:	79 c9       	ld.w	r9,r12[0x70]
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
800087ba:	f8 fc 01 44 	ld.w	r12,r12[324]
  register int * Crrtab = cconvert->Cr_r_tab;
800087be:	7c 27       	ld.w	r7,lr[0x8]
800087c0:	50 67       	stdsp	sp[0x18],r7
  register int * Cbbtab = cconvert->Cb_b_tab;
800087c2:	7c 30       	ld.w	r0,lr[0xc]
800087c4:	50 50       	stdsp	sp[0x14],r0
  register INT32 * Crgtab = cconvert->Cr_g_tab;
800087c6:	7c 47       	ld.w	r7,lr[0x10]
800087c8:	50 47       	stdsp	sp[0x10],r7
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
800087ca:	7c 5e       	ld.w	lr,lr[0x14]
800087cc:	50 3e       	stdsp	sp[0xc],lr
800087ce:	a3 6a       	lsl	r10,0x2
      cr = GETJSAMPLE(inptr2[col]);

      red = range_limit[y + Crrtab[cr]];
      green = range_limit[y + ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS))];
      blue = range_limit[y + Cbbtab[cb]];
	*jpeg_out_buffer_pos = ((red >> 3) & 0x1F) << 11
800087d0:	4a 63       	lddpc	r3,80008868 <ycc_rgb565_convert+0xb8>
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS
  JSAMPLE red, green, blue;

  while (--num_rows >= 0) {
800087d2:	c4 78       	rjmp	80008860 <ycc_rgb565_convert+0xb0>
    inptr0 = input_buf[0][input_row];
800087d4:	76 0e       	ld.w	lr,r11[0x0]
800087d6:	fc 0a 03 06 	ld.w	r6,lr[r10]
    inptr1 = input_buf[1][input_row];
800087da:	76 1e       	ld.w	lr,r11[0x4]
800087dc:	fc 0a 03 07 	ld.w	r7,lr[r10]
    inptr2 = input_buf[2][input_row];
800087e0:	76 2e       	ld.w	lr,r11[0x8]
800087e2:	fc 0a 03 0e 	ld.w	lr,lr[r10]
    input_row++;

    for (col = 0; col < num_cols; col++) {
800087e6:	58 09       	cp.w	r9,0
800087e8:	c3 b0       	breq	8000885e <ycc_rgb565_convert+0xae>
800087ea:	30 05       	mov	r5,0
800087ec:	50 08       	stdsp	sp[0x0],r8
      y  = GETJSAMPLE(inptr0[col]);
800087ee:	ec 05 07 04 	ld.ub	r4,r6[r5]
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);

      red = range_limit[y + Crrtab[cr]];
800087f2:	fc 05 07 01 	ld.ub	r1,lr[r5]
800087f6:	a3 61       	lsl	r1,0x2
      green = range_limit[y + ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS))];
800087f8:	ee 05 07 02 	ld.ub	r2,r7[r5]
800087fc:	a3 62       	lsl	r2,0x2
      blue = range_limit[y + Cbbtab[cb]];
	*jpeg_out_buffer_pos = ((red >> 3) & 0x1F) << 11
800087fe:	40 60       	lddsp	r0,sp[0x18]
80008800:	e0 01 03 08 	ld.w	r8,r0[r1]
80008804:	f8 08 00 00 	add	r0,r12,r8
80008808:	e0 04 07 00 	ld.ub	r0,r0[r4]
8000880c:	a3 90       	lsr	r0,0x3
8000880e:	50 10       	stdsp	sp[0x4],r0
80008810:	40 50       	lddsp	r0,sp[0x14]
80008812:	e0 02 03 08 	ld.w	r8,r0[r2]
80008816:	f8 08 00 00 	add	r0,r12,r8
8000881a:	e0 04 07 00 	ld.ub	r0,r0[r4]
8000881e:	50 20       	stdsp	sp[0x8],r0
80008820:	40 10       	lddsp	r0,sp[0x4]
80008822:	ab 70       	lsl	r0,0xb
80008824:	40 48       	lddsp	r8,sp[0x10]
80008826:	f0 01 03 01 	ld.w	r1,r8[r1]
8000882a:	40 38       	lddsp	r8,sp[0xc]
8000882c:	f0 02 03 02 	ld.w	r2,r8[r2]
80008830:	e2 02 00 02 	add	r2,r1,r2
80008834:	b1 42       	asr	r2,0x10
80008836:	f8 04 00 04 	add	r4,r12,r4
8000883a:	e8 02 07 04 	ld.ub	r4,r4[r2]
8000883e:	a3 84       	lsr	r4,0x2
80008840:	40 28       	lddsp	r8,sp[0x8]
80008842:	e1 e8 12 30 	or	r0,r0,r8>>0x3
80008846:	e1 e4 10 50 	or	r0,r0,r4<<0x5
8000884a:	66 08       	ld.w	r8,r3[0x0]
8000884c:	b0 00       	st.h	r8[0x0],r0
      /*
      *jpeg_out_buffer_pos =   ((((range_limit[y + Crrtab[cr]]) >> 3) & 0x1F) << 11)
      	| ((((range_limit[y + ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS))]) >> 2) & 0x3F) << 5)
      	| (((range_limit[y + Cbbtab[cb]]) >> 3) & 0x1F);
	*/
      jpeg_out_buffer_pos++;
8000884e:	66 04       	ld.w	r4,r3[0x0]
80008850:	2f e4       	sub	r4,-2
80008852:	87 04       	st.w	r3[0x0],r4
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    input_row++;

    for (col = 0; col < num_cols; col++) {
80008854:	2f f5       	sub	r5,-1
80008856:	0a 39       	cp.w	r9,r5
80008858:	fe 9b ff cb 	brhi	800087ee <ycc_rgb565_convert+0x3e>
8000885c:	40 08       	lddsp	r8,sp[0x0]
8000885e:	2f ca       	sub	r10,-4
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS
  JSAMPLE red, green, blue;

  while (--num_rows >= 0) {
80008860:	20 18       	sub	r8,1
80008862:	cb 97       	brpl	800087d4 <ycc_rgb565_convert+0x24>
      	| (((range_limit[y + Cbbtab[cb]]) >> 3) & 0x1F);
	*/
      jpeg_out_buffer_pos++;
    }
  }
}
80008864:	2f 9d       	sub	sp,-28
80008866:	d8 32       	popm	r0-r7,pc
80008868:	00 00       	add	r0,r0
8000886a:	0d 34       	ld.ub	r4,r6++

8000886c <null_convert>:

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION input_row,
	      JSAMPARRAY output_buf, int num_rows)
{
8000886c:	d4 31       	pushm	r0-r7,lr
8000886e:	12 9e       	mov	lr,r9
  register JSAMPROW inptr, outptr;
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
80008870:	78 99       	ld.w	r9,r12[0x24]
  JDIMENSION num_cols = cinfo->output_width;
80008872:	79 cc       	ld.w	r12,r12[0x70]
  int ci;

  while (--num_rows >= 0) {
80008874:	f0 c2 00 01 	sub	r2,r8,1
80008878:	c2 66       	brmi	800088c4 <null_convert+0x58>
8000887a:	f4 04 15 02 	lsl	r4,r10,0x2
    for (ci = 0; ci < num_components; ci++) {
8000887e:	16 90       	mov	r0,r11
80008880:	30 01       	mov	r1,0
      inptr = input_buf[ci][input_row];
      outptr = output_buf[0] + ci;
80008882:	02 93       	mov	r3,r1
80008884:	c1 a8       	rjmp	800088b8 <null_convert+0x4c>
  JDIMENSION num_cols = cinfo->output_width;
  int ci;

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
      inptr = input_buf[ci][input_row];
80008886:	6a 08       	ld.w	r8,r5[0x0]
80008888:	f0 04 03 07 	ld.w	r7,r8[r4]
      outptr = output_buf[0] + ci;
8000888c:	7c 08       	ld.w	r8,lr[0x0]
      for (count = num_cols; count > 0; count--) {
8000888e:	58 0c       	cp.w	r12,0
80008890:	c0 b0       	breq	800088a6 <null_convert+0x3a>
  int ci;

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
      inptr = input_buf[ci][input_row];
      outptr = output_buf[0] + ci;
80008892:	f0 06 00 0a 	add	r10,r8,r6
80008896:	06 98       	mov	r8,r3
      for (count = num_cols; count > 0; count--) {
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
80008898:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8000889c:	b4 8b       	st.b	r10[0x0],r11
 * Color conversion for no colorspace change: just copy the data,
 * converting from separate-planes to interleaved representation.
 */

METHODDEF(void)
null_convert (j_decompress_ptr cinfo,
8000889e:	12 0a       	add	r10,r9
800088a0:	2f f8       	sub	r8,-1

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
      inptr = input_buf[ci][input_row];
      outptr = output_buf[0] + ci;
      for (count = num_cols; count > 0; count--) {
800088a2:	18 38       	cp.w	r8,r12
800088a4:	cf a1       	brne	80008898 <null_convert+0x2c>
  register int num_components = cinfo->num_components;
  JDIMENSION num_cols = cinfo->output_width;
  int ci;

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
800088a6:	2f f6       	sub	r6,-1
800088a8:	2f c5       	sub	r5,-4
800088aa:	12 36       	cp.w	r6,r9
800088ac:	ce d1       	brne	80008886 <null_convert+0x1a>
  register JDIMENSION count;
  register int num_components = cinfo->num_components;
  JDIMENSION num_cols = cinfo->output_width;
  int ci;

  while (--num_rows >= 0) {
800088ae:	20 12       	sub	r2,1
800088b0:	2f c4       	sub	r4,-4
800088b2:	5b f2       	cp.w	r2,-1
800088b4:	c0 80       	breq	800088c4 <null_convert+0x58>
	*outptr = *inptr++;	/* needn't bother with GETJSAMPLE() here */
	outptr += num_components;
      }
    }
    input_row++;
    output_buf++;
800088b6:	2f ce       	sub	lr,-4
  register int num_components = cinfo->num_components;
  JDIMENSION num_cols = cinfo->output_width;
  int ci;

  while (--num_rows >= 0) {
    for (ci = 0; ci < num_components; ci++) {
800088b8:	58 09       	cp.w	r9,0
800088ba:	fe 9a ff fa 	brle	800088ae <null_convert+0x42>
800088be:	00 95       	mov	r5,r0
800088c0:	02 96       	mov	r6,r1
800088c2:	ce 2b       	rjmp	80008886 <null_convert+0x1a>
800088c4:	d8 32       	popm	r0-r7,pc

800088c6 <gray_rgb_convert>:

METHODDEF(void)
gray_rgb_convert (j_decompress_ptr cinfo,
		  JSAMPIMAGE input_buf, JDIMENSION input_row,
		  JSAMPARRAY output_buf, int num_rows)
{
800088c6:	d4 21       	pushm	r4-r7,lr
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
800088c8:	79 cc       	ld.w	r12,r12[0x70]
800088ca:	a3 6a       	lsl	r10,0x2

  while (--num_rows >= 0) {
    inptr = input_buf[0][input_row++];
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
800088cc:	30 04       	mov	r4,0
{
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
800088ce:	c1 48       	rjmp	800088f6 <gray_rgb_convert+0x30>
    inptr = input_buf[0][input_row++];
800088d0:	76 0e       	ld.w	lr,r11[0x0]
800088d2:	fc 0a 03 07 	ld.w	r7,lr[r10]
    outptr = *output_buf++;
800088d6:	72 0e       	ld.w	lr,r9[0x0]
    for (col = 0; col < num_cols; col++) {
800088d8:	58 0c       	cp.w	r12,0
800088da:	c0 c0       	breq	800088f2 <gray_rgb_convert+0x2c>
800088dc:	08 96       	mov	r6,r4
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
800088de:	ee 06 07 05 	ld.ub	r5,r7[r6]
800088e2:	bc 85       	st.b	lr[0x0],r5
800088e4:	bc 95       	st.b	lr[0x1],r5
800088e6:	bc a5       	st.b	lr[0x2],r5
      outptr += RGB_PIXELSIZE;
800088e8:	2f de       	sub	lr,-3
  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
    inptr = input_buf[0][input_row++];
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
800088ea:	2f f6       	sub	r6,-1
800088ec:	0c 3c       	cp.w	r12,r6
800088ee:	fe 9b ff f8 	brhi	800088de <gray_rgb_convert+0x18>
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
    inptr = input_buf[0][input_row++];
    outptr = *output_buf++;
800088f2:	2f c9       	sub	r9,-4
800088f4:	2f ca       	sub	r10,-4
{
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;

  while (--num_rows >= 0) {
800088f6:	20 18       	sub	r8,1
800088f8:	ce c7       	brpl	800088d0 <gray_rgb_convert+0xa>
      /* We can dispense with GETJSAMPLE() here */
      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
      outptr += RGB_PIXELSIZE;
    }
  }
}
800088fa:	d8 22       	popm	r4-r7,pc

800088fc <ycck_cmyk_convert>:

METHODDEF(void)
ycck_cmyk_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
800088fc:	d4 31       	pushm	r0-r7,lr
800088fe:	20 7d       	sub	sp,28
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
80008900:	f8 f7 01 c8 	ld.w	r7,r12[456]
  register int y, cb, cr;
  register JSAMPROW outptr;
  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->output_width;
80008904:	79 ce       	ld.w	lr,r12[0x70]
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
80008906:	f8 fc 01 44 	ld.w	r12,r12[324]
8000890a:	50 2c       	stdsp	sp[0x8],r12
  register int * Crrtab = cconvert->Cr_r_tab;
8000890c:	6e 2c       	ld.w	r12,r7[0x8]
8000890e:	50 6c       	stdsp	sp[0x18],r12
  register int * Cbbtab = cconvert->Cb_b_tab;
80008910:	6e 32       	ld.w	r2,r7[0xc]
80008912:	50 52       	stdsp	sp[0x14],r2
  register INT32 * Crgtab = cconvert->Cr_g_tab;
80008914:	6e 41       	ld.w	r1,r7[0x10]
80008916:	50 41       	stdsp	sp[0x10],r1
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
80008918:	6e 5c       	ld.w	r12,r7[0x14]
8000891a:	50 3c       	stdsp	sp[0xc],r12
8000891c:	a3 6a       	lsl	r10,0x2
  SHIFT_TEMPS

  while (--num_rows >= 0) {
8000891e:	c4 d8       	rjmp	800089b8 <ycck_cmyk_convert+0xbc>
    inptr0 = input_buf[0][input_row];
80008920:	76 0c       	ld.w	r12,r11[0x0]
80008922:	f8 0a 03 03 	ld.w	r3,r12[r10]
    inptr1 = input_buf[1][input_row];
80008926:	76 1c       	ld.w	r12,r11[0x4]
80008928:	f8 0a 03 04 	ld.w	r4,r12[r10]
    inptr2 = input_buf[2][input_row];
8000892c:	76 2c       	ld.w	r12,r11[0x8]
8000892e:	f8 0a 03 05 	ld.w	r5,r12[r10]
    inptr3 = input_buf[3][input_row];
80008932:	76 3c       	ld.w	r12,r11[0xc]
80008934:	f8 0a 03 06 	ld.w	r6,r12[r10]
    input_row++;
    outptr = *output_buf++;
80008938:	72 0c       	ld.w	r12,r9[0x0]
    for (col = 0; col < num_cols; col++) {
8000893a:	58 0e       	cp.w	lr,0
8000893c:	c3 c0       	breq	800089b4 <ycck_cmyk_convert+0xb8>
8000893e:	30 07       	mov	r7,0
80008940:	50 08       	stdsp	sp[0x0],r8
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
80008942:	e8 07 07 08 	ld.ub	r8,r4[r7]
80008946:	50 18       	stdsp	sp[0x4],r8
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
80008948:	ea 07 07 00 	ld.ub	r0,r5[r7]
8000894c:	a3 60       	lsl	r0,0x2
8000894e:	e6 07 07 02 	ld.ub	r2,r3[r7]
80008952:	e0 61 00 ff 	mov	r1,255
80008956:	e2 02 01 02 	sub	r2,r1,r2
8000895a:	40 61       	lddsp	r1,sp[0x18]
8000895c:	e2 00 03 08 	ld.w	r8,r1[r0]
80008960:	e4 08 01 01 	sub	r1,r2,r8
80008964:	40 28       	lddsp	r8,sp[0x8]
80008966:	f0 01 07 01 	ld.ub	r1,r8[r1]
8000896a:	b8 81       	st.b	r12[0x0],r1
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
8000896c:	40 11       	lddsp	r1,sp[0x4]
8000896e:	a3 61       	lsl	r1,0x2
      y  = GETJSAMPLE(inptr0[col]);
      cb = GETJSAMPLE(inptr1[col]);
      cr = GETJSAMPLE(inptr2[col]);
      /* Range-limiting is essential due to noise introduced by DCT losses. */
      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
80008970:	40 48       	lddsp	r8,sp[0x10]
80008972:	f0 00 03 00 	ld.w	r0,r8[r0]
80008976:	50 10       	stdsp	sp[0x4],r0
80008978:	40 38       	lddsp	r8,sp[0xc]
8000897a:	f0 01 03 00 	ld.w	r0,r8[r1]
8000897e:	40 18       	lddsp	r8,sp[0x4]
80008980:	f0 00 00 00 	add	r0,r8,r0
80008984:	b1 40       	asr	r0,0x10
80008986:	e4 00 01 00 	sub	r0,r2,r0
8000898a:	40 28       	lddsp	r8,sp[0x8]
8000898c:	f0 00 07 00 	ld.ub	r0,r8[r0]
80008990:	b8 90       	st.b	r12[0x1],r0
			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
						 SCALEBITS)))];
      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
80008992:	40 58       	lddsp	r8,sp[0x14]
80008994:	f0 01 03 01 	ld.w	r1,r8[r1]
80008998:	02 12       	sub	r2,r1
8000899a:	40 21       	lddsp	r1,sp[0x8]
8000899c:	e2 02 07 02 	ld.ub	r2,r1[r2]
800089a0:	b8 a2       	st.b	r12[0x2],r2
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
800089a2:	ec 07 07 02 	ld.ub	r2,r6[r7]
800089a6:	b8 b2       	st.b	r12[0x3],r2
      outptr += 4;
800089a8:	2f cc       	sub	r12,-4
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    inptr3 = input_buf[3][input_row];
    input_row++;
    outptr = *output_buf++;
    for (col = 0; col < num_cols; col++) {
800089aa:	2f f7       	sub	r7,-1
800089ac:	0e 3e       	cp.w	lr,r7
800089ae:	fe 9b ff ca 	brhi	80008942 <ycck_cmyk_convert+0x46>
800089b2:	40 08       	lddsp	r8,sp[0x0]
    inptr0 = input_buf[0][input_row];
    inptr1 = input_buf[1][input_row];
    inptr2 = input_buf[2][input_row];
    inptr3 = input_buf[3][input_row];
    input_row++;
    outptr = *output_buf++;
800089b4:	2f c9       	sub	r9,-4
800089b6:	2f ca       	sub	r10,-4
  register int * Cbbtab = cconvert->Cb_b_tab;
  register INT32 * Crgtab = cconvert->Cr_g_tab;
  register INT32 * Cbgtab = cconvert->Cb_g_tab;
  SHIFT_TEMPS

  while (--num_rows >= 0) {
800089b8:	20 18       	sub	r8,1
800089ba:	cb 37       	brpl	80008920 <ycck_cmyk_convert+0x24>
      /* K passes through unchanged */
      outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
      outptr += 4;
    }
  }
}
800089bc:	2f 9d       	sub	sp,-28
800089be:	d8 32       	popm	r0-r7,pc

800089c0 <start_pass_dcolor>:

METHODDEF(void)
start_pass_dcolor (j_decompress_ptr cinfo)
{
  /* no work needed */
}
800089c0:	5e fc       	retal	r12
800089c2:	d7 03       	nop

800089c4 <jinit_color_deconverter>:
 * Module initialization routine for output colorspace conversion.
 */

GLOBAL(void)
jinit_color_deconverter (j_decompress_ptr cinfo)
{
800089c4:	eb cd 40 e0 	pushm	r5-r7,lr
800089c8:	18 97       	mov	r7,r12
  my_cconvert_ptr cconvert;
  int ci;

  cconvert = (my_cconvert_ptr)
800089ca:	18 95       	mov	r5,r12
800089cc:	78 18       	ld.w	r8,r12[0x4]
800089ce:	70 08       	ld.w	r8,r8[0x0]
800089d0:	31 8a       	mov	r10,24
800089d2:	30 1b       	mov	r11,1
800089d4:	5d 18       	icall	r8
800089d6:	18 96       	mov	r6,r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_color_deconverter));
  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
800089d8:	ef 4c 01 c8 	st.w	r7[456],r12
  cconvert->pub.start_pass = start_pass_dcolor;
800089dc:	4e e8       	lddpc	r8,80008b94 <jinit_color_deconverter+0x1d0>
800089de:	99 08       	st.w	r12[0x0],r8

  /* Make sure num_components agrees with jpeg_color_space */
  switch (cinfo->jpeg_color_space) {
800089e0:	6e a8       	ld.w	r8,r7[0x28]
800089e2:	58 68       	cp.w	r8,6
800089e4:	e0 8b 00 31 	brhi	80008a46 <jinit_color_deconverter+0x82>
800089e8:	30 19       	mov	r9,1
800089ea:	f2 08 09 48 	lsl	r8,r9,r8
800089ee:	10 99       	mov	r9,r8
800089f0:	e2 19 00 4c 	andl	r9,0x4c,COH
800089f4:	c1 31       	brne	80008a1a <jinit_color_deconverter+0x56>
800089f6:	10 99       	mov	r9,r8
800089f8:	e2 19 00 30 	andl	r9,0x30,COH
800089fc:	c1 a1       	brne	80008a30 <jinit_color_deconverter+0x6c>
800089fe:	e2 18 00 02 	andl	r8,0x2,COH
80008a02:	c2 20       	breq	80008a46 <jinit_color_deconverter+0x82>
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
80008a04:	6e 98       	ld.w	r8,r7[0x24]
80008a06:	58 18       	cp.w	r8,1
80008a08:	c2 a0       	breq	80008a5c <jinit_color_deconverter+0x98>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
80008a0a:	6e 08       	ld.w	r8,r7[0x0]
80008a0c:	30 a9       	mov	r9,10
80008a0e:	91 59       	st.w	r8[0x14],r9
80008a10:	6e 08       	ld.w	r8,r7[0x0]
80008a12:	70 08       	ld.w	r8,r8[0x0]
80008a14:	0e 9c       	mov	r12,r7
80008a16:	5d 18       	icall	r8
80008a18:	c2 28       	rjmp	80008a5c <jinit_color_deconverter+0x98>
    break;

  case JCS_RGB:
  case JCS_RGB565:
  case JCS_YCbCr:
    if (cinfo->num_components != 3)
80008a1a:	6e 98       	ld.w	r8,r7[0x24]
80008a1c:	58 38       	cp.w	r8,3
80008a1e:	c1 f0       	breq	80008a5c <jinit_color_deconverter+0x98>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
80008a20:	6e 08       	ld.w	r8,r7[0x0]
80008a22:	30 a9       	mov	r9,10
80008a24:	91 59       	st.w	r8[0x14],r9
80008a26:	6e 08       	ld.w	r8,r7[0x0]
80008a28:	70 08       	ld.w	r8,r8[0x0]
80008a2a:	0e 9c       	mov	r12,r7
80008a2c:	5d 18       	icall	r8
80008a2e:	c1 78       	rjmp	80008a5c <jinit_color_deconverter+0x98>
    break;

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->num_components != 4)
80008a30:	6e 98       	ld.w	r8,r7[0x24]
80008a32:	58 48       	cp.w	r8,4
80008a34:	c1 40       	breq	80008a5c <jinit_color_deconverter+0x98>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
80008a36:	6e 08       	ld.w	r8,r7[0x0]
80008a38:	30 a9       	mov	r9,10
80008a3a:	91 59       	st.w	r8[0x14],r9
80008a3c:	6e 08       	ld.w	r8,r7[0x0]
80008a3e:	70 08       	ld.w	r8,r8[0x0]
80008a40:	0e 9c       	mov	r12,r7
80008a42:	5d 18       	icall	r8
80008a44:	c0 c8       	rjmp	80008a5c <jinit_color_deconverter+0x98>
    break;

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->num_components < 1)
80008a46:	6e 98       	ld.w	r8,r7[0x24]
80008a48:	58 08       	cp.w	r8,0
80008a4a:	e0 89 00 09 	brgt	80008a5c <jinit_color_deconverter+0x98>
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
80008a4e:	6e 08       	ld.w	r8,r7[0x0]
80008a50:	30 a9       	mov	r9,10
80008a52:	91 59       	st.w	r8[0x14],r9
80008a54:	6e 08       	ld.w	r8,r7[0x0]
80008a56:	70 08       	ld.w	r8,r8[0x0]
80008a58:	0a 9c       	mov	r12,r5
80008a5a:	5d 18       	icall	r8
  /* Set out_color_components and conversion method based on requested space.
   * Also clear the component_needed flags for any unused components,
   * so that earlier pipeline stages can avoid useless computation.
   */

  switch (cinfo->out_color_space) {
80008a5c:	6e b8       	ld.w	r8,r7[0x2c]
80008a5e:	58 28       	cp.w	r8,2
80008a60:	c3 30       	breq	80008ac6 <jinit_color_deconverter+0x102>
80008a62:	e0 8b 00 05 	brhi	80008a6c <jinit_color_deconverter+0xa8>
80008a66:	58 18       	cp.w	r8,1
80008a68:	c7 a1       	brne	80008b5c <jinit_color_deconverter+0x198>
80008a6a:	c0 68       	rjmp	80008a76 <jinit_color_deconverter+0xb2>
80008a6c:	58 48       	cp.w	r8,4
80008a6e:	c5 e0       	breq	80008b2a <jinit_color_deconverter+0x166>
80008a70:	58 68       	cp.w	r8,6
80008a72:	c7 51       	brne	80008b5c <jinit_color_deconverter+0x198>
80008a74:	c4 78       	rjmp	80008b02 <jinit_color_deconverter+0x13e>
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
80008a76:	30 18       	mov	r8,1
80008a78:	ef 48 00 78 	st.w	r7[120],r8
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
80008a7c:	6e a8       	ld.w	r8,r7[0x28]
80008a7e:	58 18       	cp.w	r8,1
80008a80:	5f 09       	sreq	r9
80008a82:	58 38       	cp.w	r8,3
80008a84:	5f 08       	sreq	r8
80008a86:	f3 e8 10 08 	or	r8,r9,r8
80008a8a:	c1 60       	breq	80008ab6 <jinit_color_deconverter+0xf2>
	cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = grayscale_convert;
80008a8c:	4c 38       	lddpc	r8,80008b98 <jinit_color_deconverter+0x1d4>
80008a8e:	8d 18       	st.w	r6[0x4],r8
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
80008a90:	6e 98       	ld.w	r8,r7[0x24]
80008a92:	58 18       	cp.w	r8,1
80008a94:	e0 8a 00 74 	brle	80008b7c <jinit_color_deconverter+0x1b8>
80008a98:	30 18       	mov	r8,1
	cinfo->comp_info[ci].component_needed = FALSE;
80008a9a:	30 0b       	mov	r11,0
80008a9c:	ee fa 00 d8 	ld.w	r10,r7[216]
80008aa0:	f0 09 10 54 	mul	r9,r8,84
80008aa4:	f4 09 00 09 	add	r9,r10,r9
80008aa8:	93 cb       	st.w	r9[0x30],r11
    cinfo->out_color_components = 1;
    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
	cinfo->jpeg_color_space == JCS_YCbCr) {
      cconvert->pub.color_convert = grayscale_convert;
      /* For color->grayscale conversion, only the Y (0) component is needed */
      for (ci = 1; ci < cinfo->num_components; ci++)
80008aaa:	2f f8       	sub	r8,-1
80008aac:	6e 99       	ld.w	r9,r7[0x24]
80008aae:	10 39       	cp.w	r9,r8
80008ab0:	fe 99 ff f6 	brgt	80008a9c <jinit_color_deconverter+0xd8>
80008ab4:	c6 48       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
	cinfo->comp_info[ci].component_needed = FALSE;
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
80008ab6:	6e 08       	ld.w	r8,r7[0x0]
80008ab8:	31 b9       	mov	r9,27
80008aba:	91 59       	st.w	r8[0x14],r9
80008abc:	6e 08       	ld.w	r8,r7[0x0]
80008abe:	70 08       	ld.w	r8,r8[0x0]
80008ac0:	0a 9c       	mov	r12,r5
80008ac2:	5d 18       	icall	r8
80008ac4:	c5 c8       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    break;

  case JCS_RGB:
    cinfo->out_color_components = RGB_PIXELSIZE;
80008ac6:	30 38       	mov	r8,3
80008ac8:	ef 48 00 78 	st.w	r7[120],r8
    if (cinfo->jpeg_color_space == JCS_YCbCr) {
80008acc:	6e a8       	ld.w	r8,r7[0x28]
80008ace:	58 38       	cp.w	r8,3
80008ad0:	c0 71       	brne	80008ade <jinit_color_deconverter+0x11a>
      cconvert->pub.color_convert = ycc_rgb_convert;
80008ad2:	4b 38       	lddpc	r8,80008b9c <jinit_color_deconverter+0x1d8>
80008ad4:	8d 18       	st.w	r6[0x4],r8
      build_ycc_rgb_table(cinfo);
80008ad6:	0e 9c       	mov	r12,r7
80008ad8:	f0 1f 00 32 	mcall	80008ba0 <jinit_color_deconverter+0x1dc>
80008adc:	c5 08       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
80008ade:	58 18       	cp.w	r8,1
80008ae0:	c0 41       	brne	80008ae8 <jinit_color_deconverter+0x124>
      cconvert->pub.color_convert = gray_rgb_convert;
80008ae2:	4b 18       	lddpc	r8,80008ba4 <jinit_color_deconverter+0x1e0>
80008ae4:	8d 18       	st.w	r6[0x4],r8
80008ae6:	c4 b8       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {
80008ae8:	58 28       	cp.w	r8,2
80008aea:	c0 41       	brne	80008af2 <jinit_color_deconverter+0x12e>
      cconvert->pub.color_convert = null_convert;
80008aec:	4a f8       	lddpc	r8,80008ba8 <jinit_color_deconverter+0x1e4>
80008aee:	8d 18       	st.w	r6[0x4],r8
80008af0:	c4 68       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
80008af2:	6e 08       	ld.w	r8,r7[0x0]
80008af4:	31 b9       	mov	r9,27
80008af6:	91 59       	st.w	r8[0x14],r9
80008af8:	6e 08       	ld.w	r8,r7[0x0]
80008afa:	70 08       	ld.w	r8,r8[0x0]
80008afc:	0a 9c       	mov	r12,r5
80008afe:	5d 18       	icall	r8
80008b00:	c3 e8       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    break;

  case JCS_RGB565:
	  cinfo->out_color_components = RGB_PIXELSIZE;
80008b02:	30 38       	mov	r8,3
80008b04:	ef 48 00 78 	st.w	r7[120],r8
	  if(cinfo->jpeg_color_space == JCS_YCbCr)
80008b08:	6e a8       	ld.w	r8,r7[0x28]
80008b0a:	58 38       	cp.w	r8,3
80008b0c:	c0 71       	brne	80008b1a <jinit_color_deconverter+0x156>
	  {
		  cconvert->pub.color_convert = ycc_rgb565_convert;
80008b0e:	4a 88       	lddpc	r8,80008bac <jinit_color_deconverter+0x1e8>
80008b10:	8d 18       	st.w	r6[0x4],r8
		  build_ycc_rgb_table(cinfo);
80008b12:	0e 9c       	mov	r12,r7
80008b14:	f0 1f 00 23 	mcall	80008ba0 <jinit_color_deconverter+0x1dc>
80008b18:	c3 28       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
	  }
	  else
		  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
80008b1a:	6e 08       	ld.w	r8,r7[0x0]
80008b1c:	31 b9       	mov	r9,27
80008b1e:	91 59       	st.w	r8[0x14],r9
80008b20:	6e 08       	ld.w	r8,r7[0x0]
80008b22:	70 08       	ld.w	r8,r8[0x0]
80008b24:	0a 9c       	mov	r12,r5
80008b26:	5d 18       	icall	r8
80008b28:	c2 a8       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
	  break;

  case JCS_CMYK:
    cinfo->out_color_components = 4;
80008b2a:	30 48       	mov	r8,4
80008b2c:	ef 48 00 78 	st.w	r7[120],r8
    if (cinfo->jpeg_color_space == JCS_YCCK) {
80008b30:	6e a8       	ld.w	r8,r7[0x28]
80008b32:	58 58       	cp.w	r8,5
80008b34:	c0 71       	brne	80008b42 <jinit_color_deconverter+0x17e>
      cconvert->pub.color_convert = ycck_cmyk_convert;
80008b36:	49 f8       	lddpc	r8,80008bb0 <jinit_color_deconverter+0x1ec>
80008b38:	8d 18       	st.w	r6[0x4],r8
      build_ycc_rgb_table(cinfo);
80008b3a:	0e 9c       	mov	r12,r7
80008b3c:	f0 1f 00 19 	mcall	80008ba0 <jinit_color_deconverter+0x1dc>
80008b40:	c1 e8       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
80008b42:	58 48       	cp.w	r8,4
80008b44:	c0 41       	brne	80008b4c <jinit_color_deconverter+0x188>
      cconvert->pub.color_convert = null_convert;
80008b46:	49 98       	lddpc	r8,80008ba8 <jinit_color_deconverter+0x1e4>
80008b48:	8d 18       	st.w	r6[0x4],r8
80008b4a:	c1 98       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    } else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
80008b4c:	6e 08       	ld.w	r8,r7[0x0]
80008b4e:	31 b9       	mov	r9,27
80008b50:	91 59       	st.w	r8[0x14],r9
80008b52:	6e 08       	ld.w	r8,r7[0x0]
80008b54:	70 08       	ld.w	r8,r8[0x0]
80008b56:	0a 9c       	mov	r12,r5
80008b58:	5d 18       	icall	r8
80008b5a:	c1 18       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    break;

  default:
    /* Permit null conversion to same output space */
    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
80008b5c:	6e a9       	ld.w	r9,r7[0x28]
80008b5e:	12 38       	cp.w	r8,r9
80008b60:	c0 71       	brne	80008b6e <jinit_color_deconverter+0x1aa>
      cinfo->out_color_components = cinfo->num_components;
80008b62:	6e 98       	ld.w	r8,r7[0x24]
80008b64:	ef 48 00 78 	st.w	r7[120],r8
      cconvert->pub.color_convert = null_convert;
80008b68:	49 08       	lddpc	r8,80008ba8 <jinit_color_deconverter+0x1e4>
80008b6a:	8d 18       	st.w	r6[0x4],r8
80008b6c:	c0 88       	rjmp	80008b7c <jinit_color_deconverter+0x1b8>
    } else			/* unsupported non-null conversion */
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
80008b6e:	6e 08       	ld.w	r8,r7[0x0]
80008b70:	31 b9       	mov	r9,27
80008b72:	91 59       	st.w	r8[0x14],r9
80008b74:	6e 08       	ld.w	r8,r7[0x0]
80008b76:	70 08       	ld.w	r8,r8[0x0]
80008b78:	0a 9c       	mov	r12,r5
80008b7a:	5d 18       	icall	r8
    break;
  }

  if (cinfo->quantize_colors)
80008b7c:	6f 58       	ld.w	r8,r7[0x54]
    cinfo->output_components = 1; /* single colormapped output component */
80008b7e:	58 08       	cp.w	r8,0
80008b80:	f9 b8 01 01 	movne	r8,1
80008b84:	ef f8 1a 1f 	st.wne	r7[0x7c],r8
  else
    cinfo->output_components = cinfo->out_color_components;
80008b88:	ef f8 00 1e 	ld.weq	r8,r7[0x78]
80008b8c:	ef f8 0a 1f 	st.weq	r7[0x7c],r8
80008b90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80008b94:	80 00       	ld.sh	r0,r0[0x0]
80008b96:	89 c0       	st.w	r4[0x30],r0
80008b98:	80 00       	ld.sh	r0,r0[0x0]
80008b9a:	8b b4       	st.w	r5[0x2c],r4
80008b9c:	80 00       	ld.sh	r0,r0[0x0]
80008b9e:	87 02       	st.w	r3[0x0],r2
80008ba0:	80 00       	ld.sh	r0,r0[0x0]
80008ba2:	86 5c       	ld.sh	r12,r3[0xa]
80008ba4:	80 00       	ld.sh	r0,r0[0x0]
80008ba6:	88 c6       	ld.uh	r6,r4[0x8]
80008ba8:	80 00       	ld.sh	r0,r0[0x0]
80008baa:	88 6c       	ld.sh	r12,r4[0xc]
80008bac:	80 00       	ld.sh	r0,r0[0x0]
80008bae:	87 b0       	st.w	r3[0x2c],r0
80008bb0:	80 00       	ld.sh	r0,r0[0x0]
80008bb2:	88 fc       	ld.uh	r12,r4[0xe]

80008bb4 <grayscale_convert>:

METHODDEF(void)
grayscale_convert (j_decompress_ptr cinfo,
		   JSAMPIMAGE input_buf, JDIMENSION input_row,
		   JSAMPARRAY output_buf, int num_rows)
{
80008bb4:	eb cd 40 80 	pushm	r7,lr
80008bb8:	14 97       	mov	r7,r10
80008bba:	12 9a       	mov	r10,r9
  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
80008bbc:	76 0e       	ld.w	lr,r11[0x0]
80008bbe:	79 c9       	ld.w	r9,r12[0x70]
80008bc0:	1a d9       	st.w	--sp,r9
80008bc2:	30 09       	mov	r9,0
80008bc4:	0e 9b       	mov	r11,r7
80008bc6:	1c 9c       	mov	r12,lr
80008bc8:	f0 1f 00 03 	mcall	80008bd4 <grayscale_convert+0x20>
80008bcc:	2f fd       	sub	sp,-4
		    num_rows, cinfo->output_width);
}
80008bce:	e3 cd 80 80 	ldm	sp++,r7,pc
80008bd2:	00 00       	add	r0,r0
80008bd4:	80 00       	ld.sh	r0,r0[0x0]
80008bd6:	fd 44 d4 31 	st.w	lr[-11215],r4

80008bd8 <start_pass>:
 * a matching multiplier table.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
{
80008bd8:	d4 31       	pushm	r0-r7,lr
80008bda:	18 95       	mov	r5,r12
  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
80008bdc:	f8 f4 01 c0 	ld.w	r4,r12[448]
  jpeg_component_info *compptr;
  int method = 0;
  inverse_DCT_method_ptr method_ptr = NULL;
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80008be0:	f8 f6 00 d8 	ld.w	r6,r12[216]
80008be4:	78 98       	ld.w	r8,r12[0x24]
80008be6:	58 08       	cp.w	r8,0
80008be8:	e0 8a 00 74 	brle	80008cd0 <start_pass+0xf8>
80008bec:	2d c6       	sub	r6,-36
80008bee:	2e c4       	sub	r4,-20
80008bf0:	30 02       	mov	r2,0
80008bf2:	04 91       	mov	r1,r2
80008bf4:	04 93       	mov	r3,r2
       ci++, compptr++) {
    /* Select the proper IDCT routine for this component's scaling */
    switch (compptr->DCT_scaled_size) {
80008bf6:	04 90       	mov	r0,r2
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
	  ifmtbl[i] = (IFAST_MULT_TYPE)
80008bf8:	4b 77       	lddpc	r7,80008cd4 <start_pass+0xfc>
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Select the proper IDCT routine for this component's scaling */
    switch (compptr->DCT_scaled_size) {
80008bfa:	6c 08       	ld.w	r8,r6[0x0]
80008bfc:	58 28       	cp.w	r8,2
80008bfe:	c0 b0       	breq	80008c14 <start_pass+0x3c>
80008c00:	e0 89 00 05 	brgt	80008c0a <start_pass+0x32>
80008c04:	58 18       	cp.w	r8,1
80008c06:	c2 31       	brne	80008c4c <start_pass+0x74>
80008c08:	c0 98       	rjmp	80008c1a <start_pass+0x42>
80008c0a:	58 48       	cp.w	r8,4
80008c0c:	c0 a0       	breq	80008c20 <start_pass+0x48>
80008c0e:	58 88       	cp.w	r8,8
80008c10:	c1 e1       	brne	80008c4c <start_pass+0x74>
80008c12:	c0 a8       	rjmp	80008c26 <start_pass+0x4e>
80008c14:	4b 12       	lddpc	r2,80008cd8 <start_pass+0x100>
80008c16:	00 91       	mov	r1,r0
80008c18:	c2 48       	rjmp	80008c60 <start_pass+0x88>
80008c1a:	4b 12       	lddpc	r2,80008cdc <start_pass+0x104>
80008c1c:	00 91       	mov	r1,r0
80008c1e:	c2 18       	rjmp	80008c60 <start_pass+0x88>
80008c20:	4b 02       	lddpc	r2,80008ce0 <start_pass+0x108>
80008c22:	00 91       	mov	r1,r0
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
    case 4:
      method_ptr = jpeg_idct_4x4;
      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
      break;
80008c24:	c1 e8       	rjmp	80008c60 <start_pass+0x88>
#endif
    case DCTSIZE:
      switch (cinfo->dct_method) {
80008c26:	6b 28       	ld.w	r8,r5[0x48]
80008c28:	58 08       	cp.w	r8,0
80008c2a:	c0 60       	breq	80008c36 <start_pass+0x5e>
80008c2c:	58 18       	cp.w	r8,1
80008c2e:	c0 71       	brne	80008c3c <start_pass+0x64>
80008c30:	4a d2       	lddpc	r2,80008ce4 <start_pass+0x10c>
80008c32:	30 11       	mov	r1,1
80008c34:	c1 68       	rjmp	80008c60 <start_pass+0x88>
80008c36:	4a d2       	lddpc	r2,80008ce8 <start_pass+0x110>
80008c38:	00 91       	mov	r1,r0
80008c3a:	c1 38       	rjmp	80008c60 <start_pass+0x88>
	method_ptr = jpeg_idct_float;
	method = JDCT_FLOAT;
	break;
#endif
      default:
	ERREXIT(cinfo, JERR_NOT_COMPILED);
80008c3c:	6a 08       	ld.w	r8,r5[0x0]
80008c3e:	33 09       	mov	r9,48
80008c40:	91 59       	st.w	r8[0x14],r9
80008c42:	6a 08       	ld.w	r8,r5[0x0]
80008c44:	70 08       	ld.w	r8,r8[0x0]
80008c46:	0a 9c       	mov	r12,r5
80008c48:	5d 18       	icall	r8
80008c4a:	c0 b8       	rjmp	80008c60 <start_pass+0x88>
	break;
      }
      break;
    default:
      ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
80008c4c:	6a 08       	ld.w	r8,r5[0x0]
80008c4e:	30 79       	mov	r9,7
80008c50:	91 59       	st.w	r8[0x14],r9
80008c52:	6a 08       	ld.w	r8,r5[0x0]
80008c54:	6c 09       	ld.w	r9,r6[0x0]
80008c56:	91 69       	st.w	r8[0x18],r9
80008c58:	6a 08       	ld.w	r8,r5[0x0]
80008c5a:	70 08       	ld.w	r8,r8[0x0]
80008c5c:	0a 9c       	mov	r12,r5
80008c5e:	5d 18       	icall	r8
      break;
    }
    idct->pub.inverse_DCT[ci] = method_ptr;
80008c60:	e9 42 ff f0 	st.w	r4[-16],r2
     * or if we already built the table.  Also, if no quant table
     * has yet been saved for the component, we leave the
     * multiplier table all-zero; we'll be reading zeroes from the
     * coefficient controller's buffer anyway.
     */
    if (! compptr->component_needed || idct->cur_method[ci] == method)
80008c64:	6c 38       	ld.w	r8,r6[0xc]
80008c66:	58 08       	cp.w	r8,0
80008c68:	c2 d0       	breq	80008cc2 <start_pass+0xea>
80008c6a:	68 08       	ld.w	r8,r4[0x0]
80008c6c:	02 38       	cp.w	r8,r1
80008c6e:	c2 a0       	breq	80008cc2 <start_pass+0xea>
      continue;
    qtbl = compptr->quant_table;
80008c70:	6c ab       	ld.w	r11,r6[0x28]
    if (qtbl == NULL)		/* happens if no data yet for component */
80008c72:	58 0b       	cp.w	r11,0
80008c74:	c2 70       	breq	80008cc2 <start_pass+0xea>
      continue;
    idct->cur_method[ci] = method;
80008c76:	89 01       	st.w	r4[0x0],r1
    switch (method) {
80008c78:	58 01       	cp.w	r1,0
80008c7a:	c0 40       	breq	80008c82 <start_pass+0xaa>
80008c7c:	58 11       	cp.w	r1,1
80008c7e:	c1 b1       	brne	80008cb4 <start_pass+0xdc>
80008c80:	c0 a8       	rjmp	80008c94 <start_pass+0xbc>
80008c82:	16 99       	mov	r9,r11
80008c84:	6c b8       	ld.w	r8,r6[0x2c]
 * Here we select the proper IDCT routine for each component and build
 * a matching multiplier table.
 */

METHODDEF(void)
start_pass (j_decompress_ptr cinfo)
80008c86:	f0 cb ff 00 	sub	r11,r8,-256
	/* For LL&M IDCT method, multipliers are equal to raw quantization
	 * coefficients, but are stored as ints to ensure access efficiency.
	 */
	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
	for (i = 0; i < DCTSIZE2; i++) {
	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
80008c8a:	13 2a       	ld.uh	r10,r9++
80008c8c:	10 aa       	st.w	r8++,r10
      {
	/* For LL&M IDCT method, multipliers are equal to raw quantization
	 * coefficients, but are stored as ints to ensure access efficiency.
	 */
	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
	for (i = 0; i < DCTSIZE2; i++) {
80008c8e:	16 38       	cp.w	r8,r11
80008c90:	cf d1       	brne	80008c8a <start_pass+0xb2>
80008c92:	c1 88       	rjmp	80008cc2 <start_pass+0xea>
80008c94:	6c b9       	ld.w	r9,r6[0x2c]
80008c96:	00 98       	mov	r8,r0
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
	  ifmtbl[i] = (IFAST_MULT_TYPE)
80008c98:	ee 08 04 0c 	ld.sh	r12,r7[r8]
80008c9c:	f6 08 05 0a 	ld.uh	r10,r11[r8]
80008ca0:	f8 0a 02 4a 	mul	r10,r12,r10
80008ca4:	f3 ba 03 ec 	satrnds	r10>>0xc,0x1f
80008ca8:	12 aa       	st.w	r9++,r10
80008caa:	2f e8       	sub	r8,-2
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	for (i = 0; i < DCTSIZE2; i++) {
80008cac:	e0 48 00 80 	cp.w	r8,128
80008cb0:	cf 41       	brne	80008c98 <start_pass+0xc0>
80008cb2:	c0 88       	rjmp	80008cc2 <start_pass+0xea>
	}
      }
      break;
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
80008cb4:	6a 08       	ld.w	r8,r5[0x0]
80008cb6:	33 09       	mov	r9,48
80008cb8:	91 59       	st.w	r8[0x14],r9
80008cba:	6a 08       	ld.w	r8,r5[0x0]
80008cbc:	70 08       	ld.w	r8,r8[0x0]
80008cbe:	0a 9c       	mov	r12,r5
80008cc0:	5d 18       	icall	r8
  int method = 0;
  inverse_DCT_method_ptr method_ptr = NULL;
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80008cc2:	2f f3       	sub	r3,-1
80008cc4:	2a c6       	sub	r6,-84
80008cc6:	2f c4       	sub	r4,-4
  jpeg_component_info *compptr;
  int method = 0;
  inverse_DCT_method_ptr method_ptr = NULL;
  JQUANT_TBL * qtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80008cc8:	6a 98       	ld.w	r8,r5[0x24]
80008cca:	06 38       	cp.w	r8,r3
80008ccc:	fe 99 ff 97 	brgt	80008bfa <start_pass+0x22>
80008cd0:	d8 32       	popm	r0-r7,pc
80008cd2:	00 00       	add	r0,r0
80008cd4:	80 01       	ld.sh	r1,r0[0x0]
80008cd6:	e5 28 80 00 	ld.sb	r8,r2[-32768]
80008cda:	d8 b8       	*unknown*
80008cdc:	80 00       	ld.sh	r0,r0[0x0]
80008cde:	da 52       	popm	r0-r3,r8-r9,r12,pc
80008ce0:	80 00       	ld.sh	r0,r0[0x0]
80008ce2:	d6 18       	*unknown*
80008ce4:	80 00       	ld.sh	r0,r0[0x0]
80008ce6:	ce 90       	breq	80008cb8 <start_pass+0xe0>
80008ce8:	80 00       	ld.sh	r0,r0[0x0]
80008cea:	d1 ec       	*unknown*

80008cec <jinit_inverse_dct>:
 * Initialize IDCT manager.
 */

GLOBAL(void)
jinit_inverse_dct (j_decompress_ptr cinfo)
{
80008cec:	d4 31       	pushm	r0-r7,lr
80008cee:	18 97       	mov	r7,r12
  my_idct_ptr idct;
  int ci;
  jpeg_component_info *compptr;

  idct = (my_idct_ptr)
80008cf0:	18 92       	mov	r2,r12
80008cf2:	78 18       	ld.w	r8,r12[0x4]
80008cf4:	70 08       	ld.w	r8,r8[0x0]
80008cf6:	32 4a       	mov	r10,36
80008cf8:	30 1b       	mov	r11,1
80008cfa:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
80008cfc:	ef 4c 01 c0 	st.w	r7[448],r12
  idct->pub.start_pass = start_pass;
80008d00:	49 28       	lddpc	r8,80008d48 <jinit_inverse_dct+0x5c>
80008d02:	99 08       	st.w	r12[0x0],r8

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80008d04:	ee f6 00 d8 	ld.w	r6,r7[216]
80008d08:	6e 98       	ld.w	r8,r7[0x24]
80008d0a:	58 08       	cp.w	r8,0
80008d0c:	e0 8a 00 1d 	brle	80008d46 <jinit_inverse_dct+0x5a>
80008d10:	2b 06       	sub	r6,-80
80008d12:	f8 c4 ff ec 	sub	r4,r12,-20
80008d16:	30 05       	mov	r5,0
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
80008d18:	e0 63 01 00 	mov	r3,256
80008d1c:	30 11       	mov	r1,1
				  SIZEOF(multiplier_table));
    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
80008d1e:	0a 90       	mov	r0,r5

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
80008d20:	6e 18       	ld.w	r8,r7[0x4]
80008d22:	70 08       	ld.w	r8,r8[0x0]
80008d24:	06 9a       	mov	r10,r3
80008d26:	02 9b       	mov	r11,r1
80008d28:	04 9c       	mov	r12,r2
80008d2a:	5d 18       	icall	r8
  idct->pub.start_pass = start_pass;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Allocate and pre-zero a multiplier table for each component */
    compptr->dct_table =
80008d2c:	8d 0c       	st.w	r6[0x0],r12
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(multiplier_table));
    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
80008d2e:	06 9a       	mov	r10,r3
80008d30:	00 9b       	mov	r11,r0
80008d32:	f0 1f 00 07 	mcall	80008d4c <jinit_inverse_dct+0x60>
    /* Mark multiplier table not yet set up for any method */
    idct->cur_method[ci] = -1;
80008d36:	3f f8       	mov	r8,-1
80008d38:	08 a8       	st.w	r4++,r8
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
  idct->pub.start_pass = start_pass;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80008d3a:	2f f5       	sub	r5,-1
80008d3c:	2a c6       	sub	r6,-84
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_idct_controller));
  cinfo->idct = (struct jpeg_inverse_dct *) idct;
  idct->pub.start_pass = start_pass;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80008d3e:	6e 98       	ld.w	r8,r7[0x24]
80008d40:	0a 38       	cp.w	r8,r5
80008d42:	fe 99 ff ef 	brgt	80008d20 <jinit_inverse_dct+0x34>
80008d46:	d8 32       	popm	r0-r7,pc
80008d48:	80 00       	ld.sh	r0,r0[0x0]
80008d4a:	8b d8       	st.w	r5[0x34],r8
80008d4c:	80 01       	ld.sh	r1,r0[0x0]
80008d4e:	56 02       	stdsp	sp[0x180],r2

80008d50 <jpeg_fill_bit_buffer>:
GLOBAL(boolean)
jpeg_fill_bit_buffer (bitread_working_state * state,
		      register bit_buf_type get_buffer, register int bits_left,
		      int nbits)
/* Load up the bit buffer to a depth of at least nbits */
{
80008d50:	d4 31       	pushm	r0-r7,lr
80008d52:	18 91       	mov	r1,r12
80008d54:	16 92       	mov	r2,r11
80008d56:	14 94       	mov	r4,r10
80008d58:	12 90       	mov	r0,r9
  /* Copy heavily used state fields into locals (hopefully registers) */
  register const JOCTET * next_input_byte = state->next_input_byte;
80008d5a:	78 06       	ld.w	r6,r12[0x0]
  register size_t bytes_in_buffer = state->bytes_in_buffer;
80008d5c:	78 17       	ld.w	r7,r12[0x4]
  j_decompress_ptr cinfo = state->cinfo;
80008d5e:	78 45       	ld.w	r5,r12[0x10]

  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */
  /* We fail to do so only if we hit a marker or are forced to suspend. */

  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
80008d60:	ea f8 01 a0 	ld.w	r8,r5[416]
80008d64:	58 08       	cp.w	r8,0
80008d66:	c2 e1       	brne	80008dc2 <jpeg_fill_bit_buffer+0x72>
    while (bits_left < MIN_GET_BITS) {
80008d68:	59 8a       	cp.w	r10,24
80008d6a:	e0 89 00 44 	brgt	80008df2 <jpeg_fill_bit_buffer+0xa2>
      register int c;

      /* Attempt to read a byte */
      if (bytes_in_buffer == 0) {
80008d6e:	58 07       	cp.w	r7,0
80008d70:	c0 91       	brne	80008d82 <jpeg_fill_bit_buffer+0x32>
	if (! (*cinfo->src->fill_input_buffer) (cinfo))
80008d72:	6a 68       	ld.w	r8,r5[0x18]
80008d74:	70 38       	ld.w	r8,r8[0xc]
80008d76:	0a 9c       	mov	r12,r5
80008d78:	5d 18       	icall	r8
80008d7a:	c4 10       	breq	80008dfc <jpeg_fill_bit_buffer+0xac>
	  return FALSE;
	next_input_byte = cinfo->src->next_input_byte;
80008d7c:	6a 68       	ld.w	r8,r5[0x18]
80008d7e:	70 06       	ld.w	r6,r8[0x0]
	bytes_in_buffer = cinfo->src->bytes_in_buffer;
80008d80:	70 17       	ld.w	r7,r8[0x4]
      }
      bytes_in_buffer--;
80008d82:	20 17       	sub	r7,1
      c = GETJOCTET(*next_input_byte++);
80008d84:	0d 33       	ld.ub	r3,r6++

      /* If it's 0xFF, check and discard stuffed zero byte */
      if (c == 0xFF) {
80008d86:	e0 43 00 ff 	cp.w	r3,255
80008d8a:	c1 51       	brne	80008db4 <jpeg_fill_bit_buffer+0x64>
	 * so that we can save a valid unread_marker value.  NOTE: we will
	 * accept multiple FF's followed by a 0 as meaning a single FF data
	 * byte.  This data pattern is not valid according to the standard.
	 */
	do {
	  if (bytes_in_buffer == 0) {
80008d8c:	58 07       	cp.w	r7,0
80008d8e:	c0 91       	brne	80008da0 <jpeg_fill_bit_buffer+0x50>
	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
80008d90:	6a 68       	ld.w	r8,r5[0x18]
80008d92:	70 38       	ld.w	r8,r8[0xc]
80008d94:	0a 9c       	mov	r12,r5
80008d96:	5d 18       	icall	r8
80008d98:	c3 20       	breq	80008dfc <jpeg_fill_bit_buffer+0xac>
	      return FALSE;
	    next_input_byte = cinfo->src->next_input_byte;
80008d9a:	6a 68       	ld.w	r8,r5[0x18]
80008d9c:	70 06       	ld.w	r6,r8[0x0]
	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
80008d9e:	70 17       	ld.w	r7,r8[0x4]
	  }
	  bytes_in_buffer--;
80008da0:	20 17       	sub	r7,1
	  c = GETJOCTET(*next_input_byte++);
80008da2:	0d 38       	ld.ub	r8,r6++
	} while (c == 0xFF);
80008da4:	e0 48 00 ff 	cp.w	r8,255
80008da8:	cf 20       	breq	80008d8c <jpeg_fill_bit_buffer+0x3c>

	if (c == 0) {
80008daa:	58 08       	cp.w	r8,0
80008dac:	c0 40       	breq	80008db4 <jpeg_fill_bit_buffer+0x64>
	   * bitread working state, not straight into permanent state.  But
	   * once we have hit a marker, we cannot need to suspend within the
	   * current MCU, because we will read no more bytes from the data
	   * source.  So it is OK to update permanent state right away.
	   */
	  cinfo->unread_marker = c;
80008dae:	eb 48 01 a0 	st.w	r5[416],r8
	  /* See if we need to insert some fake zero bits. */
	  goto no_more_bytes;
80008db2:	c0 88       	rjmp	80008dc2 <jpeg_fill_bit_buffer+0x72>
	}
      }

      /* OK, load c into get_buffer */
      get_buffer = (get_buffer << 8) | c;
80008db4:	e7 e2 10 82 	or	r2,r3,r2<<0x8
      bits_left += 8;
80008db8:	2f 84       	sub	r4,-8
  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
  /* (It is assumed that no request will be for more than that many bits.) */
  /* We fail to do so only if we hit a marker or are forced to suspend. */

  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
    while (bits_left < MIN_GET_BITS) {
80008dba:	59 84       	cp.w	r4,24
80008dbc:	fe 9a ff d9 	brle	80008d6e <jpeg_fill_bit_buffer+0x1e>
80008dc0:	c1 98       	rjmp	80008df2 <jpeg_fill_bit_buffer+0xa2>
  no_more_bytes:
    /* We get here if we've read the marker that terminates the compressed
     * data segment.  There should be enough bits in the buffer register
     * to satisfy the request; if so, no problem.
     */
    if (nbits > bits_left) {
80008dc2:	00 34       	cp.w	r4,r0
80008dc4:	c1 74       	brge	80008df2 <jpeg_fill_bit_buffer+0xa2>
      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
       * the data stream, so that we can produce some kind of image.
       * We use a nonvolatile flag to ensure that only one warning message
       * appears per data segment.
       */
      if (! cinfo->entropy->insufficient_data) {
80008dc6:	ea f8 01 bc 	ld.w	r8,r5[444]
80008dca:	70 28       	ld.w	r8,r8[0x8]
80008dcc:	58 08       	cp.w	r8,0
80008dce:	c0 d1       	brne	80008de8 <jpeg_fill_bit_buffer+0x98>
	WARNMS(cinfo, JWRN_HIT_MARKER);
80008dd0:	6a 08       	ld.w	r8,r5[0x0]
80008dd2:	37 59       	mov	r9,117
80008dd4:	91 59       	st.w	r8[0x14],r9
80008dd6:	6a 08       	ld.w	r8,r5[0x0]
80008dd8:	70 18       	ld.w	r8,r8[0x4]
80008dda:	3f fb       	mov	r11,-1
80008ddc:	0a 9c       	mov	r12,r5
80008dde:	5d 18       	icall	r8
	cinfo->entropy->insufficient_data = TRUE;
80008de0:	ea f8 01 bc 	ld.w	r8,r5[444]
80008de4:	30 19       	mov	r9,1
80008de6:	91 29       	st.w	r8[0x8],r9
      }
      /* Fill the buffer with zero bits */
      get_buffer <<= MIN_GET_BITS - bits_left;
80008de8:	e8 04 11 19 	rsub	r4,r4,25
80008dec:	e4 04 09 42 	lsl	r2,r2,r4
80008df0:	31 94       	mov	r4,25
      bits_left = MIN_GET_BITS;
    }
  }

  /* Unload the local registers */
  state->next_input_byte = next_input_byte;
80008df2:	83 06       	st.w	r1[0x0],r6
  state->bytes_in_buffer = bytes_in_buffer;
80008df4:	83 17       	st.w	r1[0x4],r7
  state->get_buffer = get_buffer;
80008df6:	83 22       	st.w	r1[0x8],r2
  state->bits_left = bits_left;
80008df8:	83 34       	st.w	r1[0xc],r4
80008dfa:	da 3a       	popm	r0-r7,pc,r12=1

  return TRUE;
80008dfc:	d8 3a       	popm	r0-r7,pc,r12=0
80008dfe:	d7 03       	nop

80008e00 <jpeg_huff_decode>:

GLOBAL(int)
jpeg_huff_decode (bitread_working_state * state,
		  register bit_buf_type get_buffer, register int bits_left,
		  d_derived_tbl * htbl, int min_bits)
{
80008e00:	eb cd 40 fc 	pushm	r2-r7,lr
80008e04:	18 93       	mov	r3,r12
80008e06:	12 94       	mov	r4,r9
80008e08:	10 96       	mov	r6,r8
  register INT32 code;

  /* HUFF_DECODE has determined that the code is at least min_bits */
  /* bits long, so fetch that many bits in one swoop. */

  CHECK_BIT_BUFFER(*state, l, return -1);
80008e0a:	14 38       	cp.w	r8,r10
80008e0c:	e0 8a 00 08 	brle	80008e1c <jpeg_huff_decode+0x1c>
80008e10:	10 99       	mov	r9,r8
80008e12:	f0 1f 00 26 	mcall	80008ea8 <jpeg_huff_decode+0xa8>
80008e16:	c4 60       	breq	80008ea2 <jpeg_huff_decode+0xa2>
80008e18:	66 2b       	ld.w	r11,r3[0x8]
80008e1a:	66 3a       	ld.w	r10,r3[0xc]
  code = GET_BITS(l);
80008e1c:	0c 1a       	sub	r10,r6
80008e1e:	f6 0a 08 47 	asr	r7,r11,r10
80008e22:	30 18       	mov	r8,1
80008e24:	f0 06 09 48 	lsl	r8,r8,r6
80008e28:	20 18       	sub	r8,1
80008e2a:	10 67       	and	r7,r8

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
80008e2c:	e8 06 03 28 	ld.w	r8,r4[r6<<0x2]
80008e30:	10 37       	cp.w	r7,r8
80008e32:	e0 8a 00 1c 	brle	80008e6a <jpeg_huff_decode+0x6a>
80008e36:	ec c5 ff ff 	sub	r5,r6,-1
80008e3a:	e8 05 00 25 	add	r5,r4,r5<<0x2
    code <<= 1;
    CHECK_BIT_BUFFER(*state, 1, return -1);
80008e3e:	30 12       	mov	r2,1
80008e40:	58 0a       	cp.w	r10,0
80008e42:	e0 89 00 09 	brgt	80008e54 <jpeg_huff_decode+0x54>
80008e46:	04 99       	mov	r9,r2
80008e48:	06 9c       	mov	r12,r3
80008e4a:	f0 1f 00 18 	mcall	80008ea8 <jpeg_huff_decode+0xa8>
80008e4e:	c2 a0       	breq	80008ea2 <jpeg_huff_decode+0xa2>
80008e50:	66 2b       	ld.w	r11,r3[0x8]
80008e52:	66 3a       	ld.w	r10,r3[0xc]
    code |= GET_BITS(1);
80008e54:	20 1a       	sub	r10,1
80008e56:	f6 0a 08 48 	asr	r8,r11,r10
80008e5a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008e5e:	f1 e7 10 17 	or	r7,r8,r7<<0x1
    l++;
80008e62:	2f f6       	sub	r6,-1
  code = GET_BITS(l);

  /* Collect the rest of the Huffman code one bit at a time. */
  /* This is per Figure F.16 in the JPEG spec. */

  while (code > htbl->maxcode[l]) {
80008e64:	0b 08       	ld.w	r8,r5++
80008e66:	0e 38       	cp.w	r8,r7
80008e68:	ce c5       	brlt	80008e40 <jpeg_huff_decode+0x40>
    code |= GET_BITS(1);
    l++;
  }

  /* Unload the local registers */
  state->get_buffer = get_buffer;
80008e6a:	87 2b       	st.w	r3[0x8],r11
  state->bits_left = bits_left;
80008e6c:	87 3a       	st.w	r3[0xc],r10

  /* With garbage input we may reach the sentinel value l = 17. */

  if (l > 16) {
80008e6e:	59 06       	cp.w	r6,16
80008e70:	e0 8a 00 0d 	brle	80008e8a <jpeg_huff_decode+0x8a>
    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
80008e74:	66 48       	ld.w	r8,r3[0x10]
80008e76:	70 08       	ld.w	r8,r8[0x0]
80008e78:	37 69       	mov	r9,118
80008e7a:	91 59       	st.w	r8[0x14],r9
80008e7c:	66 4c       	ld.w	r12,r3[0x10]
80008e7e:	78 08       	ld.w	r8,r12[0x0]
80008e80:	70 18       	ld.w	r8,r8[0x4]
80008e82:	3f fb       	mov	r11,-1
80008e84:	5d 18       	icall	r8
80008e86:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
    return 0;			/* fake a zero as the safest result */
  }

  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
80008e8a:	e8 f9 00 8c 	ld.w	r9,r4[140]
80008e8e:	2e e6       	sub	r6,-18
80008e90:	e8 06 03 28 	ld.w	r8,r4[r6<<0x2]
80008e94:	f2 07 00 07 	add	r7,r9,r7
80008e98:	10 07       	add	r7,r8
80008e9a:	ef 3c 00 11 	ld.ub	r12,r7[17]
80008e9e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80008ea2:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
80008ea6:	00 00       	add	r0,r0
80008ea8:	80 00       	ld.sh	r0,r0[0x0]
80008eaa:	8d 50       	st.w	r6[0x14],r0

80008eac <decode_mcu>:
 * this module, since we'll just re-assign them on the next call.)
 */

METHODDEF(boolean)
decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
80008eac:	d4 31       	pushm	r0-r7,lr
80008eae:	21 1d       	sub	sp,68
80008eb0:	18 90       	mov	r0,r12
80008eb2:	16 97       	mov	r7,r11
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
80008eb4:	f8 fc 01 bc 	ld.w	r12,r12[444]
80008eb8:	50 2c       	stdsp	sp[0x8],r12
  int blkn;
  BITREAD_STATE_VARS;
  savable_state state;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
80008eba:	e0 f8 01 14 	ld.w	r8,r0[276]
80008ebe:	58 08       	cp.w	r8,0
80008ec0:	c3 00       	breq	80008f20 <decode_mcu+0x74>
    if (entropy->restarts_to_go == 0)
80008ec2:	78 98       	ld.w	r8,r12[0x24]
80008ec4:	58 08       	cp.w	r8,0
80008ec6:	c2 d1       	brne	80008f20 <decode_mcu+0x74>
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
80008ec8:	e0 f9 01 b8 	ld.w	r9,r0[440]
80008ecc:	78 48       	ld.w	r8,r12[0x10]
80008ece:	58 08       	cp.w	r8,0
80008ed0:	f7 b8 05 f9 	sublt	r8,-7
80008ed4:	a3 58       	asr	r8,0x3
80008ed6:	72 6a       	ld.w	r10,r9[0x18]
80008ed8:	f4 08 00 08 	add	r8,r10,r8
80008edc:	93 68       	st.w	r9[0x18],r8
  entropy->bitstate.bits_left = 0;
80008ede:	30 08       	mov	r8,0
80008ee0:	99 48       	st.w	r12[0x10],r8

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
80008ee2:	e0 f8 01 b8 	ld.w	r8,r0[440]
80008ee6:	70 28       	ld.w	r8,r8[0x8]
80008ee8:	00 9c       	mov	r12,r0
80008eea:	5d 18       	icall	r8
80008eec:	e0 80 01 87 	breq	800091fa <decode_mcu+0x34e>
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
80008ef0:	e0 f8 01 48 	ld.w	r8,r0[328]
80008ef4:	58 08       	cp.w	r8,0
80008ef6:	e0 8a 00 0c 	brle	80008f0e <decode_mcu+0x62>
80008efa:	40 29       	lddsp	r9,sp[0x8]
80008efc:	2e c9       	sub	r9,-20
80008efe:	30 08       	mov	r8,0
    entropy->saved.last_dc_val[ci] = 0;
80008f00:	10 9b       	mov	r11,r8
80008f02:	12 ab       	st.w	r9++,r11
  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
80008f04:	2f f8       	sub	r8,-1
80008f06:	e0 fa 01 48 	ld.w	r10,r0[328]
80008f0a:	14 38       	cp.w	r8,r10
80008f0c:	cf b5       	brlt	80008f02 <decode_mcu+0x56>
    entropy->saved.last_dc_val[ci] = 0;

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
80008f0e:	e0 f8 01 14 	ld.w	r8,r0[276]
80008f12:	40 2a       	lddsp	r10,sp[0x8]
80008f14:	95 98       	st.w	r10[0x24],r8
  /* Reset out-of-data flag, unless read_restart_marker left us smack up
   * against a marker.  In that case we will end up treating the next data
   * segment as empty, and we can avoid producing bogus output pixels by
   * leaving the flag set.
   */
  if (cinfo->unread_marker == 0)
80008f16:	e0 f8 01 a0 	ld.w	r8,r0[416]
    entropy->pub.insufficient_data = FALSE;
80008f1a:	58 08       	cp.w	r8,0
80008f1c:	f5 f8 0a 02 	st.weq	r10[0x8],r8
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->pub.insufficient_data) {
80008f20:	40 29       	lddsp	r9,sp[0x8]
80008f22:	72 28       	ld.w	r8,r9[0x8]
80008f24:	58 08       	cp.w	r8,0
80008f26:	e0 81 01 64 	brne	800091ee <decode_mcu+0x342>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
80008f2a:	51 00       	stdsp	sp[0x40],r0
80008f2c:	60 68       	ld.w	r8,r0[0x18]
80008f2e:	70 09       	ld.w	r9,r8[0x0]
80008f30:	50 c9       	stdsp	sp[0x30],r9
80008f32:	70 18       	ld.w	r8,r8[0x4]
80008f34:	50 d8       	stdsp	sp[0x34],r8
80008f36:	40 28       	lddsp	r8,sp[0x8]
80008f38:	70 3b       	ld.w	r11,r8[0xc]
80008f3a:	70 4a       	ld.w	r10,r8[0x10]
    ASSIGN_STATE(state, entropy->saved);
80008f3c:	fa c8 ff e0 	sub	r8,sp,-32
80008f40:	40 29       	lddsp	r9,sp[0x8]
80008f42:	2e c9       	sub	r9,-20
80008f44:	f2 e4 00 00 	ld.d	r4,r9[0]
80008f48:	f0 e5 00 00 	st.d	r8[0],r4
80008f4c:	f2 e4 00 08 	ld.d	r4,r9[8]
80008f50:	f0 e5 00 08 	st.d	r8[8],r4

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
80008f54:	e0 f8 01 64 	ld.w	r8,r0[356]
80008f58:	58 08       	cp.w	r8,0
80008f5a:	e0 8a 01 35 	brle	800091c4 <decode_mcu+0x318>
80008f5e:	50 47       	stdsp	sp[0x10],r7
80008f60:	40 2c       	lddsp	r12,sp[0x8]
80008f62:	2b 8c       	sub	r12,-72
80008f64:	50 1c       	stdsp	sp[0x4],r12
80008f66:	e0 c9 fe 98 	sub	r9,r0,-360
80008f6a:	50 69       	stdsp	sp[0x18],r9
80008f6c:	30 08       	mov	r8,0
80008f6e:	50 58       	stdsp	sp[0x14],r8
      register int s, k, r;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
80008f70:	fa c3 ff d0 	sub	r3,sp,-48
      if (s) {
	CHECK_BIT_BUFFER(br_state, s, return FALSE);
	r = GET_BITS(s);
	s = HUFF_EXTEND(r, s);
80008f74:	fe f2 02 8c 	ld.w	r2,pc[652]
      } else {

	/* Section F.2.2.2: decode the AC coefficients */
	/* In this path we just discard the values */
	for (k = 1; k < DCTSIZE2; k++) {
	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
80008f78:	30 96       	mov	r6,9
80008f7a:	30 1c       	mov	r12,1
80008f7c:	50 3c       	stdsp	sp[0xc],r12
	    s = HUFF_EXTEND(r, s);
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in jpeg_natural_order[] will save us
	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
	     */
	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
80008f7e:	fe f1 02 86 	ld.w	r1,pc[646]
80008f82:	50 70       	stdsp	sp[0x1c],r0
80008f84:	0c 90       	mov	r0,r6
    ASSIGN_STATE(state, entropy->saved);

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
      JBLOCKROW block = MCU_data[blkn];
80008f86:	40 49       	lddsp	r9,sp[0x10]
80008f88:	72 09       	ld.w	r9,r9[0x0]
80008f8a:	50 09       	stdsp	sp[0x0],r9
      d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
80008f8c:	40 18       	lddsp	r8,sp[0x4]
80008f8e:	70 07       	ld.w	r7,r8[0x0]
      d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
80008f90:	70 a6       	ld.w	r6,r8[0x28]
      register int s, k, r;

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
80008f92:	58 7a       	cp.w	r10,7
80008f94:	e0 89 00 0d 	brgt	80008fae <decode_mcu+0x102>
80008f98:	30 09       	mov	r9,0
80008f9a:	06 9c       	mov	r12,r3
80008f9c:	f0 1f 00 9b 	mcall	80009208 <decode_mcu+0x35c>
80008fa0:	e0 80 01 2d 	breq	800091fa <decode_mcu+0x34e>
80008fa4:	40 eb       	lddsp	r11,sp[0x38]
80008fa6:	40 fa       	lddsp	r10,sp[0x3c]
80008fa8:	58 7a       	cp.w	r10,7
80008faa:	e0 8a 00 16 	brle	80008fd6 <decode_mcu+0x12a>
80008fae:	f4 c8 00 08 	sub	r8,r10,8
80008fb2:	f6 08 08 48 	asr	r8,r11,r8
80008fb6:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80008fba:	f0 c9 ff dc 	sub	r9,r8,-36
80008fbe:	ee 09 03 29 	ld.w	r9,r7[r9<<0x2]
80008fc2:	58 09       	cp.w	r9,0
80008fc4:	c0 31       	brne	80008fca <decode_mcu+0x11e>
80008fc6:	30 98       	mov	r8,9
80008fc8:	c0 88       	rjmp	80008fd8 <decode_mcu+0x12c>
80008fca:	12 1a       	sub	r10,r9
80008fcc:	ee 08 00 08 	add	r8,r7,r8
80008fd0:	f1 37 04 90 	ld.ub	r7,r8[1168]
80008fd4:	c0 b8       	rjmp	80008fea <decode_mcu+0x13e>
80008fd6:	30 18       	mov	r8,1
80008fd8:	0e 99       	mov	r9,r7
80008fda:	06 9c       	mov	r12,r3
80008fdc:	f0 1f 00 8c 	mcall	8000920c <decode_mcu+0x360>
80008fe0:	18 97       	mov	r7,r12
80008fe2:	e0 85 01 0c 	brlt	800091fa <decode_mcu+0x34e>
80008fe6:	40 eb       	lddsp	r11,sp[0x38]
80008fe8:	40 fa       	lddsp	r10,sp[0x3c]
      if (s) {
80008fea:	58 07       	cp.w	r7,0
80008fec:	c1 f0       	breq	8000902a <decode_mcu+0x17e>
	CHECK_BIT_BUFFER(br_state, s, return FALSE);
80008fee:	0e 3a       	cp.w	r10,r7
80008ff0:	c0 94       	brge	80009002 <decode_mcu+0x156>
80008ff2:	0e 99       	mov	r9,r7
80008ff4:	06 9c       	mov	r12,r3
80008ff6:	f0 1f 00 85 	mcall	80009208 <decode_mcu+0x35c>
80008ffa:	e0 80 01 00 	breq	800091fa <decode_mcu+0x34e>
80008ffe:	40 eb       	lddsp	r11,sp[0x38]
80009000:	40 fa       	lddsp	r10,sp[0x3c]
	r = GET_BITS(s);
80009002:	0e 1a       	sub	r10,r7
80009004:	f6 0a 08 49 	asr	r9,r11,r10
80009008:	30 1c       	mov	r12,1
8000900a:	f8 07 09 48 	lsl	r8,r12,r7
8000900e:	20 18       	sub	r8,1
80009010:	f3 e8 00 08 	and	r8,r9,r8
	s = HUFF_EXTEND(r, s);
80009014:	e4 07 03 29 	ld.w	r9,r2[r7<<0x2]
80009018:	12 38       	cp.w	r8,r9
8000901a:	c0 35       	brlt	80009020 <decode_mcu+0x174>
8000901c:	10 97       	mov	r7,r8
8000901e:	c0 68       	rjmp	8000902a <decode_mcu+0x17e>
80009020:	4f c9       	lddpc	r9,80009210 <decode_mcu+0x364>
80009022:	f2 07 03 27 	ld.w	r7,r9[r7<<0x2]
80009026:	f0 07 00 07 	add	r7,r8,r7
      }

      if (entropy->dc_needed[blkn]) {
8000902a:	40 19       	lddsp	r9,sp[0x4]
8000902c:	73 48       	ld.w	r8,r9[0x50]
8000902e:	58 08       	cp.w	r8,0
80009030:	c0 f0       	breq	8000904e <decode_mcu+0x1a2>
	/* Convert DC difference to actual value, update last_dc_val */
	int ci = cinfo->MCU_membership[blkn];
80009032:	40 6c       	lddsp	r12,sp[0x18]
80009034:	78 08       	ld.w	r8,r12[0x0]
	s += state.last_dc_val[ci];
80009036:	fa c9 ff bc 	sub	r9,sp,-68
8000903a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000903e:	f0 f9 ff dc 	ld.w	r9,r8[-36]
80009042:	ee 09 00 09 	add	r9,r7,r9
	state.last_dc_val[ci] = s;
80009046:	f1 49 ff dc 	st.w	r8[-36],r9
	/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
	(*block)[0] = (JCOEF) s;
8000904a:	40 08       	lddsp	r8,sp[0x0]
8000904c:	b0 09       	st.h	r8[0x0],r9
      }

      if (entropy->ac_needed[blkn]) {
8000904e:	40 1c       	lddsp	r12,sp[0x4]
80009050:	79 e8       	ld.w	r8,r12[0x78]
80009052:	58 08       	cp.w	r8,0
80009054:	c5 f0       	breq	80009112 <decode_mcu+0x266>
80009056:	30 15       	mov	r5,1

	  if (s) {
	    k += r;
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
	    r = GET_BITS(s);
	    s = HUFF_EXTEND(r, s);
80009058:	0c 94       	mov	r4,r6
      if (entropy->ac_needed[blkn]) {

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (k = 1; k < DCTSIZE2; k++) {
	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
8000905a:	58 7a       	cp.w	r10,7
8000905c:	e0 89 00 0d 	brgt	80009076 <decode_mcu+0x1ca>
80009060:	30 09       	mov	r9,0
80009062:	06 9c       	mov	r12,r3
80009064:	f0 1f 00 69 	mcall	80009208 <decode_mcu+0x35c>
80009068:	e0 80 00 c9 	breq	800091fa <decode_mcu+0x34e>
8000906c:	40 eb       	lddsp	r11,sp[0x38]
8000906e:	40 fa       	lddsp	r10,sp[0x3c]
80009070:	58 7a       	cp.w	r10,7
80009072:	e0 8a 00 16 	brle	8000909e <decode_mcu+0x1f2>
80009076:	f4 c8 00 08 	sub	r8,r10,8
8000907a:	f6 08 08 48 	asr	r8,r11,r8
8000907e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80009082:	f0 c9 ff dc 	sub	r9,r8,-36
80009086:	e8 09 03 29 	ld.w	r9,r4[r9<<0x2]
8000908a:	58 09       	cp.w	r9,0
8000908c:	c0 31       	brne	80009092 <decode_mcu+0x1e6>
8000908e:	00 98       	mov	r8,r0
80009090:	c0 88       	rjmp	800090a0 <decode_mcu+0x1f4>
80009092:	12 1a       	sub	r10,r9
80009094:	e8 08 00 08 	add	r8,r4,r8
80009098:	f1 3c 04 90 	ld.ub	r12,r8[1168]
8000909c:	c0 a8       	rjmp	800090b0 <decode_mcu+0x204>
8000909e:	40 38       	lddsp	r8,sp[0xc]
800090a0:	08 99       	mov	r9,r4
800090a2:	06 9c       	mov	r12,r3
800090a4:	f0 1f 00 5a 	mcall	8000920c <decode_mcu+0x360>
800090a8:	e0 85 00 a9 	brlt	800091fa <decode_mcu+0x34e>
800090ac:	40 eb       	lddsp	r11,sp[0x38]
800090ae:	40 fa       	lddsp	r10,sp[0x3c]

	  r = s >> 4;
800090b0:	f8 06 14 04 	asr	r6,r12,0x4
	  s &= 15;
800090b4:	ef dc c0 04 	bfextu	r7,r12,0x0,0x4

	  if (s) {
800090b8:	c2 40       	breq	80009100 <decode_mcu+0x254>
	    k += r;
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
800090ba:	0e 3a       	cp.w	r10,r7
800090bc:	c0 94       	brge	800090ce <decode_mcu+0x222>
800090be:	0e 99       	mov	r9,r7
800090c0:	06 9c       	mov	r12,r3
800090c2:	f0 1f 00 52 	mcall	80009208 <decode_mcu+0x35c>
800090c6:	e0 80 00 9a 	breq	800091fa <decode_mcu+0x34e>
800090ca:	40 eb       	lddsp	r11,sp[0x38]
800090cc:	40 fa       	lddsp	r10,sp[0x3c]
	    r = GET_BITS(s);
800090ce:	0e 1a       	sub	r10,r7
800090d0:	f6 0a 08 49 	asr	r9,r11,r10
800090d4:	30 1c       	mov	r12,1
800090d6:	f8 07 09 48 	lsl	r8,r12,r7
800090da:	20 18       	sub	r8,1
800090dc:	f3 e8 00 08 	and	r8,r9,r8
	    s = HUFF_EXTEND(r, s);
800090e0:	e4 07 03 29 	ld.w	r9,r2[r7<<0x2]
800090e4:	12 38       	cp.w	r8,r9
800090e6:	c0 54       	brge	800090f0 <decode_mcu+0x244>
800090e8:	4c ac       	lddpc	r12,80009210 <decode_mcu+0x364>
800090ea:	f8 07 03 29 	ld.w	r9,r12[r7<<0x2]
800090ee:	12 08       	add	r8,r9

	  r = s >> 4;
	  s &= 15;

	  if (s) {
	    k += r;
800090f0:	ec 05 00 05 	add	r5,r6,r5
	    s = HUFF_EXTEND(r, s);
	    /* Output coefficient in natural (dezigzagged) order.
	     * Note: the extra entries in jpeg_natural_order[] will save us
	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
	     */
	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
800090f4:	e2 05 03 29 	ld.w	r9,r1[r5<<0x2]
800090f8:	40 0c       	lddsp	r12,sp[0x0]
800090fa:	f8 09 0a 18 	st.h	r12[r9<<0x1],r8
800090fe:	c0 48       	rjmp	80009106 <decode_mcu+0x25a>
	  } else {
	    if (r != 15)
80009100:	58 f6       	cp.w	r6,15
80009102:	c4 d1       	brne	8000919c <decode_mcu+0x2f0>
	      break;
	    k += 15;
80009104:	2f 15       	sub	r5,-15

      if (entropy->ac_needed[blkn]) {

	/* Section F.2.2.2: decode the AC coefficients */
	/* Since zeroes are skipped, output area must be cleared beforehand */
	for (k = 1; k < DCTSIZE2; k++) {
80009106:	2f f5       	sub	r5,-1
80009108:	e0 45 00 3f 	cp.w	r5,63
8000910c:	fe 9a ff a7 	brle	8000905a <decode_mcu+0x1ae>
80009110:	c4 68       	rjmp	8000919c <decode_mcu+0x2f0>
80009112:	30 15       	mov	r5,1
      } else {

	/* Section F.2.2.2: decode the AC coefficients */
	/* In this path we just discard the values */
	for (k = 1; k < DCTSIZE2; k++) {
	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
80009114:	0c 94       	mov	r4,r6
80009116:	58 7a       	cp.w	r10,7
80009118:	e0 89 00 0c 	brgt	80009130 <decode_mcu+0x284>
8000911c:	30 09       	mov	r9,0
8000911e:	06 9c       	mov	r12,r3
80009120:	f0 1f 00 3a 	mcall	80009208 <decode_mcu+0x35c>
80009124:	c6 b0       	breq	800091fa <decode_mcu+0x34e>
80009126:	40 eb       	lddsp	r11,sp[0x38]
80009128:	40 fa       	lddsp	r10,sp[0x3c]
8000912a:	58 7a       	cp.w	r10,7
8000912c:	e0 8a 00 16 	brle	80009158 <decode_mcu+0x2ac>
80009130:	f4 c8 00 08 	sub	r8,r10,8
80009134:	f6 08 08 48 	asr	r8,r11,r8
80009138:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000913c:	f0 c9 ff dc 	sub	r9,r8,-36
80009140:	e8 09 03 29 	ld.w	r9,r4[r9<<0x2]
80009144:	58 09       	cp.w	r9,0
80009146:	c0 31       	brne	8000914c <decode_mcu+0x2a0>
80009148:	00 98       	mov	r8,r0
8000914a:	c0 88       	rjmp	8000915a <decode_mcu+0x2ae>
8000914c:	12 1a       	sub	r10,r9
8000914e:	e8 08 00 08 	add	r8,r4,r8
80009152:	f1 3c 04 90 	ld.ub	r12,r8[1168]
80009156:	c0 98       	rjmp	80009168 <decode_mcu+0x2bc>
80009158:	40 38       	lddsp	r8,sp[0xc]
8000915a:	08 99       	mov	r9,r4
8000915c:	06 9c       	mov	r12,r3
8000915e:	f0 1f 00 2c 	mcall	8000920c <decode_mcu+0x360>
80009162:	c4 c5       	brlt	800091fa <decode_mcu+0x34e>
80009164:	40 eb       	lddsp	r11,sp[0x38]
80009166:	40 fa       	lddsp	r10,sp[0x3c]

	  r = s >> 4;
80009168:	f8 06 14 04 	asr	r6,r12,0x4
	  s &= 15;
8000916c:	ef dc c0 04 	bfextu	r7,r12,0x0,0x4

	  if (s) {
80009170:	c0 e0       	breq	8000918c <decode_mcu+0x2e0>
	    k += r;
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
80009172:	0e 3a       	cp.w	r10,r7
80009174:	c0 84       	brge	80009184 <decode_mcu+0x2d8>
80009176:	0e 99       	mov	r9,r7
80009178:	06 9c       	mov	r12,r3
8000917a:	f0 1f 00 24 	mcall	80009208 <decode_mcu+0x35c>
8000917e:	c3 e0       	breq	800091fa <decode_mcu+0x34e>
80009180:	40 eb       	lddsp	r11,sp[0x38]
80009182:	40 fa       	lddsp	r10,sp[0x3c]

	  r = s >> 4;
	  s &= 15;

	  if (s) {
	    k += r;
80009184:	ec 05 00 05 	add	r5,r6,r5
	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
	    DROP_BITS(s);
80009188:	0e 1a       	sub	r10,r7
8000918a:	c0 48       	rjmp	80009192 <decode_mcu+0x2e6>
	  } else {
	    if (r != 15)
8000918c:	58 f6       	cp.w	r6,15
8000918e:	c0 71       	brne	8000919c <decode_mcu+0x2f0>
	      break;
	    k += 15;
80009190:	2f 15       	sub	r5,-15

      } else {

	/* Section F.2.2.2: decode the AC coefficients */
	/* In this path we just discard the values */
	for (k = 1; k < DCTSIZE2; k++) {
80009192:	2f f5       	sub	r5,-1
80009194:	e0 45 00 3f 	cp.w	r5,63
80009198:	fe 9a ff bf 	brle	80009116 <decode_mcu+0x26a>
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(state, entropy->saved);

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
8000919c:	40 59       	lddsp	r9,sp[0x14]
8000919e:	2f f9       	sub	r9,-1
800091a0:	50 59       	stdsp	sp[0x14],r9
800091a2:	40 48       	lddsp	r8,sp[0x10]
800091a4:	2f c8       	sub	r8,-4
800091a6:	50 48       	stdsp	sp[0x10],r8
800091a8:	40 1c       	lddsp	r12,sp[0x4]
800091aa:	2f cc       	sub	r12,-4
800091ac:	50 1c       	stdsp	sp[0x4],r12
800091ae:	40 69       	lddsp	r9,sp[0x18]
800091b0:	2f c9       	sub	r9,-4
800091b2:	50 69       	stdsp	sp[0x18],r9
800091b4:	40 7c       	lddsp	r12,sp[0x1c]
800091b6:	f8 f8 01 64 	ld.w	r8,r12[356]
800091ba:	40 59       	lddsp	r9,sp[0x14]
800091bc:	12 38       	cp.w	r8,r9
800091be:	fe 99 fe e4 	brgt	80008f86 <decode_mcu+0xda>
800091c2:	18 90       	mov	r0,r12

      }
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
800091c4:	60 68       	ld.w	r8,r0[0x18]
800091c6:	40 c9       	lddsp	r9,sp[0x30]
800091c8:	91 09       	st.w	r8[0x0],r9
800091ca:	60 68       	ld.w	r8,r0[0x18]
800091cc:	40 d9       	lddsp	r9,sp[0x34]
800091ce:	91 19       	st.w	r8[0x4],r9
800091d0:	40 28       	lddsp	r8,sp[0x8]
800091d2:	91 3b       	st.w	r8[0xc],r11
800091d4:	91 4a       	st.w	r8[0x10],r10
    ASSIGN_STATE(entropy->saved, state);
800091d6:	40 28       	lddsp	r8,sp[0x8]
800091d8:	2e c8       	sub	r8,-20
800091da:	fa c9 ff e0 	sub	r9,sp,-32
800091de:	f2 ea 00 00 	ld.d	r10,r9[0]
800091e2:	f0 eb 00 00 	st.d	r8[0],r10
800091e6:	f2 ea 00 08 	ld.d	r10,r9[8]
800091ea:	f0 eb 00 08 	st.d	r8[8],r10
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
800091ee:	40 2c       	lddsp	r12,sp[0x8]
800091f0:	78 98       	ld.w	r8,r12[0x24]
800091f2:	20 18       	sub	r8,1
800091f4:	99 98       	st.w	r12[0x24],r8
800091f6:	30 1c       	mov	r12,1

  return TRUE;
800091f8:	c0 28       	rjmp	800091fc <decode_mcu+0x350>
800091fa:	30 0c       	mov	r12,0
}
800091fc:	2e fd       	sub	sp,-68
800091fe:	d8 32       	popm	r0-r7,pc
80009200:	80 01       	ld.sh	r1,r0[0x0]
80009202:	e5 a8 80 01 	cop	cp4,cr0,cr0,cr1,0x50
80009206:	fc 54 80 00 	cp.w	r4,-163840
8000920a:	8d 50       	st.w	r6[0x14],r0
8000920c:	80 00       	ld.sh	r0,r0[0x0]
8000920e:	8e 00       	ld.sh	r0,r7[0x0]
80009210:	80 01       	ld.sh	r1,r0[0x0]
80009212:	e5 e8 eb cd 	sthh.w	sp[0x2f0],r2:t,r8:b

80009214 <jinit_huff_decoder>:
 * Module initialization routine for Huffman entropy decoding.
 */

GLOBAL(void)
jinit_huff_decoder (j_decompress_ptr cinfo)
{
80009214:	eb cd 40 80 	pushm	r7,lr
80009218:	18 97       	mov	r7,r12
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
8000921a:	78 18       	ld.w	r8,r12[0x4]
8000921c:	70 08       	ld.w	r8,r8[0x0]
8000921e:	e0 6a 00 e8 	mov	r10,232
80009222:	30 1b       	mov	r11,1
80009224:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(huff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
80009226:	ef 4c 01 bc 	st.w	r7[444],r12
  entropy->pub.start_pass = start_pass_huff_decoder;
8000922a:	48 98       	lddpc	r8,8000924c <jinit_huff_decoder+0x38>
8000922c:	99 08       	st.w	r12[0x0],r8
  entropy->pub.decode_mcu = decode_mcu;
8000922e:	48 98       	lddpc	r8,80009250 <jinit_huff_decoder+0x3c>
80009230:	99 18       	st.w	r12[0x4],r8
80009232:	2c 8c       	sub	r12,-56
80009234:	30 09       	mov	r9,0

  /* Mark tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
80009236:	12 98       	mov	r8,r9
80009238:	99 08       	st.w	r12[0x0],r8
8000923a:	f9 48 ff f0 	st.w	r12[-16],r8
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
  entropy->pub.start_pass = start_pass_huff_decoder;
  entropy->pub.decode_mcu = decode_mcu;

  /* Mark tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
8000923e:	2f f9       	sub	r9,-1
80009240:	2f cc       	sub	r12,-4
80009242:	58 49       	cp.w	r9,4
80009244:	cf a1       	brne	80009238 <jinit_huff_decoder+0x24>
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
  }
}
80009246:	e3 cd 80 80 	ldm	sp++,r7,pc
8000924a:	00 00       	add	r0,r0
8000924c:	80 00       	ld.sh	r0,r0[0x0]
8000924e:	94 8c       	ld.uh	r12,r10[0x0]
80009250:	80 00       	ld.sh	r0,r0[0x0]
80009252:	8e ac       	ld.uh	r12,r7[0x4]

80009254 <jpeg_make_d_derived_tbl>:
 */

GLOBAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
			 d_derived_tbl ** pdtbl)
{
80009254:	d4 31       	pushm	r0-r7,lr
80009256:	fa cd 05 1c 	sub	sp,sp,1308
8000925a:	18 96       	mov	r6,r12
8000925c:	50 2b       	stdsp	sp[0x8],r11
8000925e:	14 97       	mov	r7,r10
80009260:	12 95       	mov	r5,r9
  /* Note that huffsize[] and huffcode[] are filled in code-length order,
   * paralleling the order of the symbols themselves in htbl->huffval[].
   */

  /* Find the input Huffman table */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
80009262:	58 3a       	cp.w	r10,3
80009264:	e0 88 00 0a 	brls	80009278 <jpeg_make_d_derived_tbl+0x24>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
80009268:	78 08       	ld.w	r8,r12[0x0]
8000926a:	33 29       	mov	r9,50
8000926c:	91 59       	st.w	r8[0x14],r9
8000926e:	78 08       	ld.w	r8,r12[0x0]
80009270:	91 6a       	st.w	r8[0x18],r10
80009272:	78 08       	ld.w	r8,r12[0x0]
80009274:	70 08       	ld.w	r8,r8[0x0]
80009276:	5d 18       	icall	r8
  htbl =
80009278:	40 2a       	lddsp	r10,sp[0x8]
8000927a:	58 0a       	cp.w	r10,0
8000927c:	c0 60       	breq	80009288 <jpeg_make_d_derived_tbl+0x34>
8000927e:	ee c8 ff d3 	sub	r8,r7,-45
80009282:	ec 08 03 23 	ld.w	r3,r6[r8<<0x2]
80009286:	c0 58       	rjmp	80009290 <jpeg_make_d_derived_tbl+0x3c>
80009288:	ee c8 ff cf 	sub	r8,r7,-49
8000928c:	ec 08 03 23 	ld.w	r3,r6[r8<<0x2]
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
  if (htbl == NULL)
80009290:	58 03       	cp.w	r3,0
80009292:	c0 a1       	brne	800092a6 <jpeg_make_d_derived_tbl+0x52>
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
80009294:	6c 08       	ld.w	r8,r6[0x0]
80009296:	33 29       	mov	r9,50
80009298:	91 59       	st.w	r8[0x14],r9
8000929a:	6c 08       	ld.w	r8,r6[0x0]
8000929c:	91 67       	st.w	r8[0x18],r7
8000929e:	6c 08       	ld.w	r8,r6[0x0]
800092a0:	70 08       	ld.w	r8,r8[0x0]
800092a2:	0c 9c       	mov	r12,r6
800092a4:	5d 18       	icall	r8

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
800092a6:	6a 08       	ld.w	r8,r5[0x0]
800092a8:	58 08       	cp.w	r8,0
800092aa:	c0 91       	brne	800092bc <jpeg_make_d_derived_tbl+0x68>
    *pdtbl = (d_derived_tbl *)
800092ac:	6c 18       	ld.w	r8,r6[0x4]
800092ae:	70 08       	ld.w	r8,r8[0x0]
800092b0:	e0 6a 05 90 	mov	r10,1424
800092b4:	30 1b       	mov	r11,1
800092b6:	0c 9c       	mov	r12,r6
800092b8:	5d 18       	icall	r8
800092ba:	8b 0c       	st.w	r5[0x0],r12
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(d_derived_tbl));
  dtbl = *pdtbl;
800092bc:	6a 04       	ld.w	r4,r5[0x0]
  dtbl->pub = htbl;		/* fill in back link */
800092be:	e9 43 00 8c 	st.w	r4[140],r3
800092c2:	30 17       	mov	r7,1
800092c4:	30 05       	mov	r5,0

  p = 0;
  for (l = 1; l <= 16; l++) {
    i = (int) htbl->bits[l];
    if (i < 0 || p + i > 256)	/* protect against table overrun */
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
800092c6:	30 81       	mov	r1,8
    while (i--)
800092c8:	fa c0 fb e8 	sub	r0,sp,-1048
800092cc:	08 92       	mov	r2,r4

  /* Figure C.1: make table of Huffman code length for each symbol */

  p = 0;
  for (l = 1; l <= 16; l++) {
    i = (int) htbl->bits[l];
800092ce:	e6 07 07 04 	ld.ub	r4,r3[r7]
    if (i < 0 || p + i > 256)	/* protect against table overrun */
800092d2:	ea 04 00 09 	add	r9,r5,r4
800092d6:	50 19       	stdsp	sp[0x4],r9
800092d8:	e0 49 01 00 	cp.w	r9,256
800092dc:	e0 8a 00 08 	brle	800092ec <jpeg_make_d_derived_tbl+0x98>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
800092e0:	6c 08       	ld.w	r8,r6[0x0]
800092e2:	91 51       	st.w	r8[0x14],r1
800092e4:	6c 08       	ld.w	r8,r6[0x0]
800092e6:	70 08       	ld.w	r8,r8[0x0]
800092e8:	0c 9c       	mov	r12,r6
800092ea:	5d 18       	icall	r8
    while (i--)
800092ec:	58 04       	cp.w	r4,0
800092ee:	c0 31       	brne	800092f4 <jpeg_make_d_derived_tbl+0xa0>
800092f0:	50 15       	stdsp	sp[0x4],r5
800092f2:	c0 88       	rjmp	80009302 <jpeg_make_d_derived_tbl+0xae>
800092f4:	20 14       	sub	r4,1
800092f6:	e0 05 00 05 	add	r5,r0,r5
      huffsize[p++] = (char) l;
800092fa:	0a c7       	st.b	r5++,r7
  p = 0;
  for (l = 1; l <= 16; l++) {
    i = (int) htbl->bits[l];
    if (i < 0 || p + i > 256)	/* protect against table overrun */
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    while (i--)
800092fc:	20 14       	sub	r4,1
800092fe:	5b f4       	cp.w	r4,-1
80009300:	cf d1       	brne	800092fa <jpeg_make_d_derived_tbl+0xa6>
  dtbl->pub = htbl;		/* fill in back link */

  /* Figure C.1: make table of Huffman code length for each symbol */

  p = 0;
  for (l = 1; l <= 16; l++) {
80009302:	2f f7       	sub	r7,-1
80009304:	59 17       	cp.w	r7,17
80009306:	c0 30       	breq	8000930c <jpeg_make_d_derived_tbl+0xb8>
80009308:	40 15       	lddsp	r5,sp[0x4]
8000930a:	ce 2b       	rjmp	800092ce <jpeg_make_d_derived_tbl+0x7a>
8000930c:	04 94       	mov	r4,r2
    if (i < 0 || p + i > 256)	/* protect against table overrun */
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    while (i--)
      huffsize[p++] = (char) l;
  }
  huffsize[p] = 0;
8000930e:	fa c8 fa e4 	sub	r8,sp,-1308
80009312:	40 15       	lddsp	r5,sp[0x4]
80009314:	0a 08       	add	r8,r5
80009316:	30 09       	mov	r9,0
80009318:	f1 69 fe fc 	st.b	r8[-260],r9

  /* Figure C.2: generate the codes themselves */
  /* We also validate that the counts represent a legal Huffman code tree. */

  code = 0;
  si = huffsize[0];
8000931c:	fb 31 04 18 	ld.ub	r1,sp[1048]
80009320:	30 02       	mov	r2,0
80009322:	04 97       	mov	r7,r2
80009324:	04 95       	mov	r5,r2
  p = 0;
  while (huffsize[p]) {
    while (((int) huffsize[p]) == si) {
80009326:	fa c0 ff ec 	sub	r0,sp,-20
  /* We also validate that the counts represent a legal Huffman code tree. */

  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
8000932a:	c1 58       	rjmp	80009354 <jpeg_make_d_derived_tbl+0x100>
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
8000932c:	12 a7       	st.w	r9++,r7
8000932e:	2f f5       	sub	r5,-1
      code++;
80009330:	2f f7       	sub	r7,-1

  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
    while (((int) huffsize[p]) == si) {
80009332:	11 3a       	ld.ub	r10,r8++
80009334:	16 3a       	cp.w	r10,r11
80009336:	cf b0       	breq	8000932c <jpeg_make_d_derived_tbl+0xd8>
      code++;
    }
    /* code is now 1 more than the last code used for codelength si; but
     * it must still fit in si bits, since no code is allowed to be all ones.
     */
    if (((INT32) code) >= (((INT32) 1) << si))
80009338:	30 1a       	mov	r10,1
8000933a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000933e:	18 37       	cp.w	r7,r12
80009340:	c0 85       	brlt	80009350 <jpeg_make_d_derived_tbl+0xfc>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
80009342:	6c 08       	ld.w	r8,r6[0x0]
80009344:	30 89       	mov	r9,8
80009346:	91 59       	st.w	r8[0x14],r9
80009348:	6c 08       	ld.w	r8,r6[0x0]
8000934a:	70 08       	ld.w	r8,r8[0x0]
8000934c:	0c 9c       	mov	r12,r6
8000934e:	5d 18       	icall	r8
    code <<= 1;
80009350:	a1 77       	lsl	r7,0x1
80009352:	2f f2       	sub	r2,-1
80009354:	e4 01 00 0c 	add	r12,r2,r1
  /* We also validate that the counts represent a legal Huffman code tree. */

  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
80009358:	fa c8 fa e4 	sub	r8,sp,-1308
8000935c:	0a 08       	add	r8,r5
8000935e:	f1 3b fe fc 	ld.ub	r11,r8[-260]
80009362:	58 0b       	cp.w	r11,0
80009364:	e0 80 00 86 	breq	80009470 <jpeg_make_d_derived_tbl+0x21c>
    while (((int) huffsize[p]) == si) {
80009368:	18 3b       	cp.w	r11,r12
8000936a:	ce 71       	brne	80009338 <jpeg_make_d_derived_tbl+0xe4>
8000936c:	e0 05 00 29 	add	r9,r0,r5<<0x2
80009370:	ea c8 ff ff 	sub	r8,r5,-1
80009374:	fa ca fb e8 	sub	r10,sp,-1048
80009378:	f4 08 00 08 	add	r8,r10,r8
8000937c:	cd 8b       	rjmp	8000932c <jpeg_make_d_derived_tbl+0xd8>

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
    if (htbl->bits[l]) {
8000937e:	15 87       	ld.ub	r7,r10[0x0]
80009380:	fc 07 18 00 	cp.b	r7,lr
80009384:	c1 30       	breq	800093aa <jpeg_make_d_derived_tbl+0x156>
      /* valoffset[l] = huffval[] index of 1st symbol of code length l,
       * minus the minimum code of length l
       */
      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
80009386:	fa c5 fa e4 	sub	r5,sp,-1308
8000938a:	ea 08 00 27 	add	r7,r5,r8<<0x2
8000938e:	ee f7 fa f8 	ld.w	r7,r7[-1288]
80009392:	f0 07 01 07 	sub	r7,r8,r7
80009396:	f3 47 00 48 	st.w	r9[72],r7
      p += htbl->bits[l];
8000939a:	15 87       	ld.ub	r7,r10[0x0]
8000939c:	0e 08       	add	r8,r7
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
8000939e:	ea 08 00 27 	add	r7,r5,r8<<0x2
800093a2:	ee f7 fa f4 	ld.w	r7,r7[-1292]
800093a6:	93 07       	st.w	r9[0x0],r7
800093a8:	c0 28       	rjmp	800093ac <jpeg_make_d_derived_tbl+0x158>
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
800093aa:	93 0c       	st.w	r9[0x0],r12
  }

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
800093ac:	2f fb       	sub	r11,-1
800093ae:	2f fa       	sub	r10,-1
800093b0:	2f c9       	sub	r9,-4
800093b2:	59 1b       	cp.w	r11,17
800093b4:	ce 51       	brne	8000937e <jpeg_make_d_derived_tbl+0x12a>
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
    }
  }
  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
800093b6:	ee 78 ff ff 	mov	r8,1048575
800093ba:	e9 48 00 44 	st.w	r4[68],r8
   * then we iterate through the Huffman codes that are short enough and
   * fill in all the entries that correspond to bit sequences starting
   * with that code.
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
800093be:	e0 6a 04 00 	mov	r10,1024
800093c2:	30 0b       	mov	r11,0
800093c4:	e8 cc ff 70 	sub	r12,r4,-144
800093c8:	f0 1f 00 30 	mcall	80009488 <jpeg_make_d_derived_tbl+0x234>
800093cc:	30 17       	mov	r7,1
800093ce:	30 02       	mov	r2,0
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
800093d0:	50 37       	stdsp	sp[0xc],r7
800093d2:	50 46       	stdsp	sp[0x10],r6
800093d4:	c2 08       	rjmp	80009414 <jpeg_make_d_derived_tbl+0x1c0>
  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
800093d6:	6c 08       	ld.w	r8,r6[0x0]
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
800093d8:	58 05       	cp.w	r5,0
800093da:	e0 8a 00 12 	brle	800093fe <jpeg_make_d_derived_tbl+0x1aa>
  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
800093de:	f0 00 09 48 	lsl	r8,r8,r0
800093e2:	f0 ca ff dc 	sub	r10,r8,-36
800093e6:	e8 0a 00 2a 	add	r10,r4,r10<<0x2
800093ea:	f0 c8 fb 70 	sub	r8,r8,-1168
800093ee:	e8 08 00 09 	add	r9,r4,r8
800093f2:	40 08       	lddsp	r8,sp[0x0]
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
	dtbl->look_nbits[lookbits] = l;
800093f4:	14 a7       	st.w	r10++,r7
	dtbl->look_sym[lookbits] = htbl->huffval[p];
800093f6:	19 8b       	ld.ub	r11,r12[0x0]
800093f8:	12 cb       	st.b	r9++,r11
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
800093fa:	20 18       	sub	r8,1
800093fc:	cf c1       	brne	800093f4 <jpeg_make_d_derived_tbl+0x1a0>

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
800093fe:	2f fe       	sub	lr,-1
80009400:	2f f2       	sub	r2,-1
80009402:	2f c6       	sub	r6,-4
80009404:	2f fc       	sub	r12,-1
80009406:	e6 01 07 08 	ld.ub	r8,r3[r1]
8000940a:	1c 38       	cp.w	r8,lr
8000940c:	ce 54       	brge	800093d6 <jpeg_make_d_derived_tbl+0x182>
   */

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
8000940e:	2f f7       	sub	r7,-1
80009410:	58 97       	cp.w	r7,9
80009412:	c1 60       	breq	8000943e <jpeg_make_d_derived_tbl+0x1ea>
 *
 * Note this is also used by jdphuff.c.
 */

GLOBAL(void)
jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
80009414:	0e 91       	mov	r1,r7

  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));

  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
80009416:	e6 07 07 08 	ld.ub	r8,r3[r7]
8000941a:	58 08       	cp.w	r8,0
8000941c:	fe 9a ff f9 	brle	8000940e <jpeg_make_d_derived_tbl+0x1ba>
80009420:	ee 00 11 08 	rsub	r0,r7,8
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
80009424:	30 19       	mov	r9,1
80009426:	f2 00 09 45 	lsl	r5,r9,r0
8000942a:	fa c8 ff ec 	sub	r8,sp,-20
8000942e:	f0 02 00 26 	add	r6,r8,r2<<0x2
80009432:	e6 02 00 0c 	add	r12,r3,r2
80009436:	2e fc       	sub	r12,-17
80009438:	40 3e       	lddsp	lr,sp[0xc]
  p = 0;
  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
      /* l = current code's length, p = its index in huffcode[] & huffval[]. */
      /* Generate left-justified code followed by all possible bit sequences */
      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
8000943a:	50 05       	stdsp	sp[0x0],r5
8000943c:	cc db       	rjmp	800093d6 <jpeg_make_d_derived_tbl+0x182>
8000943e:	40 46       	lddsp	r6,sp[0x10]
   * For AC tables, we make no check, but accept all byte values 0..255.
   * For DC tables, we require the symbols to be in range 0..15.
   * (Tighter bounds could be applied depending on the data depth and mode,
   * but this is sufficient to ensure safe decoding.)
   */
  if (isDC) {
80009440:	40 25       	lddsp	r5,sp[0x8]
80009442:	58 05       	cp.w	r5,0
80009444:	c1 f0       	breq	80009482 <jpeg_make_d_derived_tbl+0x22e>
80009446:	2e f3       	sub	r3,-17
80009448:	30 07       	mov	r7,0
    for (i = 0; i < numsymbols; i++) {
      int sym = htbl->huffval[i];
      if (sym < 0 || sym > 15)
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
8000944a:	30 85       	mov	r5,8
8000944c:	c0 d8       	rjmp	80009466 <jpeg_make_d_derived_tbl+0x212>
   * but this is sufficient to ensure safe decoding.)
   */
  if (isDC) {
    for (i = 0; i < numsymbols; i++) {
      int sym = htbl->huffval[i];
      if (sym < 0 || sym > 15)
8000944e:	07 88       	ld.ub	r8,r3[0x0]
80009450:	58 f8       	cp.w	r8,15
80009452:	e0 88 00 08 	brls	80009462 <jpeg_make_d_derived_tbl+0x20e>
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
80009456:	6c 08       	ld.w	r8,r6[0x0]
80009458:	91 55       	st.w	r8[0x14],r5
8000945a:	6c 08       	ld.w	r8,r6[0x0]
8000945c:	70 08       	ld.w	r8,r8[0x0]
8000945e:	0c 9c       	mov	r12,r6
80009460:	5d 18       	icall	r8
   * For DC tables, we require the symbols to be in range 0..15.
   * (Tighter bounds could be applied depending on the data depth and mode,
   * but this is sufficient to ensure safe decoding.)
   */
  if (isDC) {
    for (i = 0; i < numsymbols; i++) {
80009462:	2f f7       	sub	r7,-1
80009464:	2f f3       	sub	r3,-1
80009466:	40 1a       	lddsp	r10,sp[0x4]
80009468:	0e 3a       	cp.w	r10,r7
8000946a:	fe 99 ff f2 	brgt	8000944e <jpeg_make_d_derived_tbl+0x1fa>
8000946e:	c0 a8       	rjmp	80009482 <jpeg_make_d_derived_tbl+0x22e>
      int sym = htbl->huffval[i];
      if (sym < 0 || sym > 15)
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    }
  }
}
80009470:	e6 ca ff ff 	sub	r10,r3,-1
80009474:	e8 c9 ff fc 	sub	r9,r4,-4
80009478:	30 1b       	mov	r11,1
8000947a:	30 08       	mov	r8,0

  /* Figure F.15: generate decoding tables for bit-sequential decoding */

  p = 0;
  for (l = 1; l <= 16; l++) {
    if (htbl->bits[l]) {
8000947c:	30 0e       	mov	lr,0
       */
      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
      p += htbl->bits[l];
      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
    } else {
      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
8000947e:	3f fc       	mov	r12,-1
80009480:	c7 fb       	rjmp	8000937e <jpeg_make_d_derived_tbl+0x12a>
      int sym = htbl->huffval[i];
      if (sym < 0 || sym > 15)
	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    }
  }
}
80009482:	fe 3d fa e4 	sub	sp,-1308
80009486:	d8 32       	popm	r0-r7,pc
80009488:	80 01       	ld.sh	r1,r0[0x0]
8000948a:	56 02       	stdsp	sp[0x180],r2

8000948c <start_pass_huff_decoder>:
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_huff_decoder (j_decompress_ptr cinfo)
{
8000948c:	d4 31       	pushm	r0-r7,lr
8000948e:	18 97       	mov	r7,r12
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
80009490:	f8 f6 01 bc 	ld.w	r6,r12[444]

  /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
   * This ought to be an error condition, but we make it a warning because
   * there are some baseline files out there with all zeroes in these bytes.
   */
  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
80009494:	f8 f8 01 90 	ld.w	r8,r12[400]
80009498:	58 08       	cp.w	r8,0
8000949a:	c0 e1       	brne	800094b6 <start_pass_huff_decoder+0x2a>
8000949c:	f8 f8 01 94 	ld.w	r8,r12[404]
800094a0:	e0 48 00 3f 	cp.w	r8,63
800094a4:	c0 91       	brne	800094b6 <start_pass_huff_decoder+0x2a>
      cinfo->Ah != 0 || cinfo->Al != 0)
800094a6:	f8 f8 01 98 	ld.w	r8,r12[408]
800094aa:	58 08       	cp.w	r8,0
800094ac:	c0 51       	brne	800094b6 <start_pass_huff_decoder+0x2a>
800094ae:	f8 f8 01 9c 	ld.w	r8,r12[412]
800094b2:	58 08       	cp.w	r8,0
800094b4:	c0 90       	breq	800094c6 <start_pass_huff_decoder+0x3a>
    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
800094b6:	6e 08       	ld.w	r8,r7[0x0]
800094b8:	37 a9       	mov	r9,122
800094ba:	91 59       	st.w	r8[0x14],r9
800094bc:	6e 08       	ld.w	r8,r7[0x0]
800094be:	70 18       	ld.w	r8,r8[0x4]
800094c0:	3f fb       	mov	r11,-1
800094c2:	0e 9c       	mov	r12,r7
800094c4:	5d 18       	icall	r8

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
800094c6:	ee f8 01 48 	ld.w	r8,r7[328]
800094ca:	58 08       	cp.w	r8,0
800094cc:	e0 8a 00 24 	brle	80009514 <start_pass_huff_decoder+0x88>
800094d0:	ee c3 fe b4 	sub	r3,r7,-332
800094d4:	ec c2 ff ec 	sub	r2,r6,-20
800094d8:	30 05       	mov	r5,0
    compptr = cinfo->cur_comp_info[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    /* Compute derived values for Huffman tables */
    /* We may do this more than once for a table, but it's not expensive */
    jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
800094da:	30 10       	mov	r0,1
			    & entropy->dc_derived_tbls[dctbl]);
    jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
800094dc:	0a 91       	mov	r1,r5
  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
      cinfo->Ah != 0 || cinfo->Al != 0)
    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
800094de:	07 08       	ld.w	r8,r3++
    dctbl = compptr->dc_tbl_no;
800094e0:	70 5a       	ld.w	r10,r8[0x14]
    actbl = compptr->ac_tbl_no;
800094e2:	70 64       	ld.w	r4,r8[0x18]
    /* Compute derived values for Huffman tables */
    /* We may do this more than once for a table, but it's not expensive */
    jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
800094e4:	f4 c9 ff f6 	sub	r9,r10,-10
800094e8:	ec 09 00 29 	add	r9,r6,r9<<0x2
800094ec:	00 9b       	mov	r11,r0
800094ee:	0e 9c       	mov	r12,r7
800094f0:	f0 1f 00 25 	mcall	80009584 <start_pass_huff_decoder+0xf8>
			    & entropy->dc_derived_tbls[dctbl]);
    jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
800094f4:	e8 c9 ff f2 	sub	r9,r4,-14
800094f8:	ec 09 00 29 	add	r9,r6,r9<<0x2
800094fc:	08 9a       	mov	r10,r4
800094fe:	02 9b       	mov	r11,r1
80009500:	0e 9c       	mov	r12,r7
80009502:	f0 1f 00 21 	mcall	80009584 <start_pass_huff_decoder+0xf8>
			    & entropy->ac_derived_tbls[actbl]);
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
80009506:	04 a1       	st.w	r2++,r1
   */
  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
      cinfo->Ah != 0 || cinfo->Al != 0)
    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
80009508:	2f f5       	sub	r5,-1
8000950a:	ee f8 01 48 	ld.w	r8,r7[328]
8000950e:	0a 38       	cp.w	r8,r5
80009510:	fe 99 ff e7 	brgt	800094de <start_pass_huff_decoder+0x52>
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Precalculate decoding info for each block in an MCU of this scan */
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
80009514:	ee f8 01 64 	ld.w	r8,r7[356]
80009518:	58 08       	cp.w	r8,0
8000951a:	e0 8a 00 2c 	brle	80009572 <start_pass_huff_decoder+0xe6>
8000951e:	ee cb fe 98 	sub	r11,r7,-360
80009522:	ec c8 ff 68 	sub	r8,r6,-152
80009526:	30 0a       	mov	r10,0
    if (compptr->component_needed) {
      entropy->dc_needed[blkn] = TRUE;
      /* we don't need the ACs if producing a 1/8th-size image */
      entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
    } else {
      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
80009528:	14 95       	mov	r5,r10
    /* Precalculate which table to use for each block */
    entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
    entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
    /* Decide whether we really care about the coefficient values */
    if (compptr->component_needed) {
      entropy->dc_needed[blkn] = TRUE;
8000952a:	30 14       	mov	r4,1
  }

  /* Precalculate decoding info for each block in an MCU of this scan */
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
8000952c:	76 09       	ld.w	r9,r11[0x0]
8000952e:	2a d9       	sub	r9,-83
80009530:	ee 09 03 29 	ld.w	r9,r7[r9<<0x2]
    /* Precalculate which table to use for each block */
    entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
80009534:	72 5c       	ld.w	r12,r9[0x14]
80009536:	2f 6c       	sub	r12,-10
80009538:	ec 0c 03 2c 	ld.w	r12,r6[r12<<0x2]
8000953c:	f1 4c ff b0 	st.w	r8[-80],r12
    entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
80009540:	72 6c       	ld.w	r12,r9[0x18]
80009542:	2f 2c       	sub	r12,-14
80009544:	ec 0c 03 2c 	ld.w	r12,r6[r12<<0x2]
80009548:	f1 4c ff d8 	st.w	r8[-40],r12
    /* Decide whether we really care about the coefficient values */
    if (compptr->component_needed) {
8000954c:	72 cc       	ld.w	r12,r9[0x30]
8000954e:	58 0c       	cp.w	r12,0
80009550:	c0 70       	breq	8000955e <start_pass_huff_decoder+0xd2>
      entropy->dc_needed[blkn] = TRUE;
80009552:	91 04       	st.w	r8[0x0],r4
      /* we don't need the ACs if producing a 1/8th-size image */
      entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
80009554:	72 99       	ld.w	r9,r9[0x24]
80009556:	58 19       	cp.w	r9,1
80009558:	5f 99       	srgt	r9
8000955a:	91 a9       	st.w	r8[0x28],r9
8000955c:	c0 38       	rjmp	80009562 <start_pass_huff_decoder+0xd6>
    } else {
      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
8000955e:	91 a5       	st.w	r8[0x28],r5
80009560:	91 05       	st.w	r8[0x0],r5
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Precalculate decoding info for each block in an MCU of this scan */
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
80009562:	2f fa       	sub	r10,-1
80009564:	2f cb       	sub	r11,-4
80009566:	2f c8       	sub	r8,-4
80009568:	ee f9 01 64 	ld.w	r9,r7[356]
8000956c:	14 39       	cp.w	r9,r10
8000956e:	fe 99 ff df 	brgt	8000952c <start_pass_huff_decoder+0xa0>
      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
    }
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
80009572:	30 08       	mov	r8,0
80009574:	8d 48       	st.w	r6[0x10],r8
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
80009576:	8d 38       	st.w	r6[0xc],r8
  entropy->pub.insufficient_data = FALSE;
80009578:	8d 28       	st.w	r6[0x8],r8

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
8000957a:	ee f8 01 14 	ld.w	r8,r7[276]
8000957e:	8d 98       	st.w	r6[0x24],r8
}
80009580:	d8 32       	popm	r0-r7,pc
80009582:	00 00       	add	r0,r0
80009584:	80 00       	ld.sh	r0,r0[0x0]
80009586:	92 54       	ld.sh	r4,r9[0xa]

80009588 <finish_input_pass>:
 */

METHODDEF(void)
finish_input_pass (j_decompress_ptr cinfo)
{
  cinfo->inputctl->consume_input = consume_markers;
80009588:	f8 f8 01 b4 	ld.w	r8,r12[436]
8000958c:	48 29       	lddpc	r9,80009594 <finish_input_pass+0xc>
8000958e:	91 09       	st.w	r8[0x0],r9
}
80009590:	5e fc       	retal	r12
80009592:	00 00       	add	r0,r0
80009594:	80 00       	ld.sh	r0,r0[0x0]
80009596:	97 d4       	st.w	r11[0x34],r4

80009598 <reset_input_controller>:
 * Reset state to begin a fresh datastream.
 */

METHODDEF(void)
reset_input_controller (j_decompress_ptr cinfo)
{
80009598:	eb cd 40 c0 	pushm	r6-r7,lr
8000959c:	18 97       	mov	r7,r12
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
8000959e:	f8 f8 01 b4 	ld.w	r8,r12[436]

  inputctl->pub.consume_input = consume_markers;
800095a2:	48 a9       	lddpc	r9,800095c8 <reset_input_controller+0x30>
800095a4:	91 09       	st.w	r8[0x0],r9
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
800095a6:	30 06       	mov	r6,0
800095a8:	91 46       	st.w	r8[0x10],r6
  inputctl->pub.eoi_reached = FALSE;
800095aa:	91 56       	st.w	r8[0x14],r6
  inputctl->inheaders = TRUE;
800095ac:	30 19       	mov	r9,1
800095ae:	91 69       	st.w	r8[0x18],r9
  /* Reset other modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
800095b0:	78 08       	ld.w	r8,r12[0x0]
800095b2:	70 48       	ld.w	r8,r8[0x10]
800095b4:	5d 18       	icall	r8
  (*cinfo->marker->reset_marker_reader) (cinfo);
800095b6:	ee f8 01 b8 	ld.w	r8,r7[440]
800095ba:	70 08       	ld.w	r8,r8[0x0]
800095bc:	0e 9c       	mov	r12,r7
800095be:	5d 18       	icall	r8
  /* Reset progression state -- would be cleaner if entropy decoder did this */
  cinfo->coef_bits = NULL;
800095c0:	ef 46 00 a0 	st.w	r7[160],r6
}
800095c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800095c8:	80 00       	ld.sh	r0,r0[0x0]
800095ca:	97 d4       	st.w	r11[0x34],r4

800095cc <jinit_input_controller>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_input_controller (j_decompress_ptr cinfo)
{
800095cc:	eb cd 40 80 	pushm	r7,lr
800095d0:	18 97       	mov	r7,r12
  my_inputctl_ptr inputctl;

  /* Create subobject in permanent pool */
  inputctl = (my_inputctl_ptr)
800095d2:	78 18       	ld.w	r8,r12[0x4]
800095d4:	70 08       	ld.w	r8,r8[0x0]
800095d6:	31 ca       	mov	r10,28
800095d8:	30 0b       	mov	r11,0
800095da:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				SIZEOF(my_input_controller));
  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
800095dc:	ef 4c 01 b4 	st.w	r7[436],r12
  /* Initialize method pointers */
  inputctl->pub.consume_input = consume_markers;
800095e0:	48 88       	lddpc	r8,80009600 <jinit_input_controller+0x34>
800095e2:	99 08       	st.w	r12[0x0],r8
  inputctl->pub.reset_input_controller = reset_input_controller;
800095e4:	48 88       	lddpc	r8,80009604 <jinit_input_controller+0x38>
800095e6:	99 18       	st.w	r12[0x4],r8
  inputctl->pub.start_input_pass = start_input_pass;
800095e8:	48 88       	lddpc	r8,80009608 <jinit_input_controller+0x3c>
800095ea:	99 28       	st.w	r12[0x8],r8
  inputctl->pub.finish_input_pass = finish_input_pass;
800095ec:	48 88       	lddpc	r8,8000960c <jinit_input_controller+0x40>
800095ee:	99 38       	st.w	r12[0xc],r8
  /* Initialize state: can't use reset_input_controller since we don't
   * want to try to reset other modules yet.
   */
  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
800095f0:	30 08       	mov	r8,0
800095f2:	99 48       	st.w	r12[0x10],r8
  inputctl->pub.eoi_reached = FALSE;
800095f4:	99 58       	st.w	r12[0x14],r8
  inputctl->inheaders = TRUE;
800095f6:	30 18       	mov	r8,1
800095f8:	99 68       	st.w	r12[0x18],r8
}
800095fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800095fe:	00 00       	add	r0,r0
80009600:	80 00       	ld.sh	r0,r0[0x0]
80009602:	97 d4       	st.w	r11[0x34],r4
80009604:	80 00       	ld.sh	r0,r0[0x0]
80009606:	95 98       	st.w	r10[0x24],r8
80009608:	80 00       	ld.sh	r0,r0[0x0]
8000960a:	96 10       	ld.sh	r0,r11[0x2]
8000960c:	80 00       	ld.sh	r0,r0[0x0]
8000960e:	95 88       	st.w	r10[0x20],r8

80009610 <start_input_pass>:
 * Subsequent calls come from consume_markers, below.
 */

METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
80009610:	d4 31       	pushm	r0-r7,lr
80009612:	18 97       	mov	r7,r12
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
{
  int ci, mcublks, tmp;
  jpeg_component_info *compptr;

  if (cinfo->comps_in_scan == 1) {
80009614:	f8 f8 01 48 	ld.w	r8,r12[328]
80009618:	58 18       	cp.w	r8,1
8000961a:	c2 71       	brne	80009668 <start_input_pass+0x58>

    /* Noninterleaved (single-component) scan */
    compptr = cinfo->cur_comp_info[0];
8000961c:	f8 f8 01 4c 	ld.w	r8,r12[332]

    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = compptr->width_in_blocks;
80009620:	70 79       	ld.w	r9,r8[0x1c]
80009622:	f9 49 01 5c 	st.w	r12[348],r9
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
80009626:	70 89       	ld.w	r9,r8[0x20]
80009628:	f9 49 01 60 	st.w	r12[352],r9

    /* For noninterleaved scan, always one block per MCU */
    compptr->MCU_width = 1;
8000962c:	30 19       	mov	r9,1
8000962e:	91 d9       	st.w	r8[0x34],r9
    compptr->MCU_height = 1;
80009630:	91 e9       	st.w	r8[0x38],r9
    compptr->MCU_blocks = 1;
80009632:	91 f9       	st.w	r8[0x3c],r9
    compptr->MCU_sample_width = compptr->DCT_scaled_size;
80009634:	70 9a       	ld.w	r10,r8[0x24]
80009636:	f1 4a 00 40 	st.w	r8[64],r10
    compptr->last_col_width = 1;
8000963a:	f1 49 00 44 	st.w	r8[68],r9
    /* For noninterleaved scans, it is convenient to define last_row_height
     * as the number of block rows present in the last iMCU row.
     */
    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
8000963e:	70 39       	ld.w	r9,r8[0xc]
80009640:	70 8b       	ld.w	r11,r8[0x20]
80009642:	f6 09 0d 0a 	divu	r10,r11,r9
    if (tmp == 0) tmp = compptr->v_samp_factor;
80009646:	58 0b       	cp.w	r11,0
80009648:	f2 0b 17 00 	moveq	r11,r9
    compptr->last_row_height = tmp;
8000964c:	f1 4b 00 48 	st.w	r8[72],r11

    /* Prepare array describing MCU composition */
    cinfo->blocks_in_MCU = 1;
80009650:	30 18       	mov	r8,1
80009652:	f9 48 01 64 	st.w	r12[356],r8
    cinfo->MCU_membership[0] = 0;
80009656:	30 08       	mov	r8,0
80009658:	f9 48 01 68 	st.w	r12[360],r8
{
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
8000965c:	ee f8 01 48 	ld.w	r8,r7[328]
80009660:	58 08       	cp.w	r8,0
80009662:	e0 89 00 72 	brgt	80009746 <start_input_pass+0x136>
80009666:	ca 28       	rjmp	800097aa <start_input_pass+0x19a>
    cinfo->MCU_membership[0] = 0;

  } else {

    /* Interleaved (multi-component) scan */
    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
80009668:	20 18       	sub	r8,1
8000966a:	58 38       	cp.w	r8,3
8000966c:	e0 88 00 0f 	brls	8000968a <start_input_pass+0x7a>
      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
80009670:	78 08       	ld.w	r8,r12[0x0]
80009672:	31 a9       	mov	r9,26
80009674:	91 59       	st.w	r8[0x14],r9
80009676:	78 08       	ld.w	r8,r12[0x0]
80009678:	f8 f9 01 48 	ld.w	r9,r12[328]
8000967c:	91 69       	st.w	r8[0x18],r9
8000967e:	78 08       	ld.w	r8,r12[0x0]
80009680:	30 49       	mov	r9,4
80009682:	91 79       	st.w	r8[0x1c],r9
80009684:	78 08       	ld.w	r8,r12[0x0]
80009686:	70 08       	ld.w	r8,r8[0x0]
80009688:	5d 18       	icall	r8
	       MAX_COMPS_IN_SCAN);

    /* Overall image size in MCUs */
    cinfo->MCUs_per_row = (JDIMENSION)
8000968a:	ee fb 01 34 	ld.w	r11,r7[308]
8000968e:	a3 7b       	lsl	r11,0x3
80009690:	6e 7c       	ld.w	r12,r7[0x1c]
80009692:	f0 1f 00 4f 	mcall	800097cc <start_input_pass+0x1bc>
80009696:	ef 4c 01 5c 	st.w	r7[348],r12
      jdiv_round_up((long) cinfo->image_width,
		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
    cinfo->MCU_rows_in_scan = (JDIMENSION)
8000969a:	ee fb 01 38 	ld.w	r11,r7[312]
8000969e:	a3 7b       	lsl	r11,0x3
800096a0:	6e 8c       	ld.w	r12,r7[0x20]
800096a2:	f0 1f 00 4b 	mcall	800097cc <start_input_pass+0x1bc>
800096a6:	ef 4c 01 60 	st.w	r7[352],r12
      jdiv_round_up((long) cinfo->image_height,
		    (long) (cinfo->max_v_samp_factor*DCTSIZE));

    cinfo->blocks_in_MCU = 0;
800096aa:	30 08       	mov	r8,0
800096ac:	ef 48 01 64 	st.w	r7[356],r8

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
800096b0:	ee f8 01 48 	ld.w	r8,r7[328]
800096b4:	58 08       	cp.w	r8,0
800096b6:	e0 8a 00 7a 	brle	800097aa <start_input_pass+0x19a>
800096ba:	ee c4 fe b4 	sub	r4,r7,-332
800096be:	30 06       	mov	r6,0
      if (tmp == 0) tmp = compptr->MCU_height;
      compptr->last_row_height = tmp;
      /* Prepare array describing MCU composition */
      mcublks = compptr->MCU_blocks;
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
800096c0:	30 d3       	mov	r3,13
		    (long) (cinfo->max_v_samp_factor*DCTSIZE));

    cinfo->blocks_in_MCU = 0;

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
      compptr = cinfo->cur_comp_info[ci];
800096c2:	68 08       	ld.w	r8,r4[0x0]
      /* Sampling factors give # of blocks of component in each MCU */
      compptr->MCU_width = compptr->h_samp_factor;
800096c4:	70 29       	ld.w	r9,r8[0x8]
800096c6:	91 d9       	st.w	r8[0x34],r9
      compptr->MCU_height = compptr->v_samp_factor;
800096c8:	70 3a       	ld.w	r10,r8[0xc]
800096ca:	91 ea       	st.w	r8[0x38],r10
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
800096cc:	f4 09 02 45 	mul	r5,r10,r9
800096d0:	91 f5       	st.w	r8[0x3c],r5
      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
800096d2:	70 9b       	ld.w	r11,r8[0x24]
800096d4:	b3 3b       	mul	r11,r9
800096d6:	f1 4b 00 40 	st.w	r8[64],r11
      /* Figure number of non-dummy blocks in last MCU column & row */
      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
800096da:	70 71       	ld.w	r1,r8[0x1c]
800096dc:	e2 09 0d 00 	divu	r0,r1,r9
      if (tmp == 0) tmp = compptr->MCU_width;
800096e0:	58 01       	cp.w	r1,0
800096e2:	f2 01 17 00 	moveq	r1,r9
      compptr->last_col_width = tmp;
800096e6:	f1 41 00 44 	st.w	r8[68],r1
      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
800096ea:	70 81       	ld.w	r1,r8[0x20]
800096ec:	e2 0a 0d 00 	divu	r0,r1,r10
      if (tmp == 0) tmp = compptr->MCU_height;
800096f0:	58 01       	cp.w	r1,0
800096f2:	f4 01 17 00 	moveq	r1,r10
      compptr->last_row_height = tmp;
800096f6:	f1 41 00 48 	st.w	r8[72],r1
      /* Prepare array describing MCU composition */
      mcublks = compptr->MCU_blocks;
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
800096fa:	ee f8 01 64 	ld.w	r8,r7[356]
800096fe:	ea 08 00 08 	add	r8,r5,r8
80009702:	58 a8       	cp.w	r8,10
80009704:	e0 8a 00 08 	brle	80009714 <start_input_pass+0x104>
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
80009708:	6e 08       	ld.w	r8,r7[0x0]
8000970a:	91 53       	st.w	r8[0x14],r3
8000970c:	6e 08       	ld.w	r8,r7[0x0]
8000970e:	70 08       	ld.w	r8,r8[0x0]
80009710:	0e 9c       	mov	r12,r7
80009712:	5d 18       	icall	r8
      while (mcublks-- > 0) {
80009714:	58 05       	cp.w	r5,0
80009716:	e0 8a 00 11 	brle	80009738 <start_input_pass+0x128>
8000971a:	ea c8 00 01 	sub	r8,r5,1
8000971e:	ee fa 01 64 	ld.w	r10,r7[356]
80009722:	f4 c9 ff a6 	sub	r9,r10,-90
80009726:	ee 09 00 29 	add	r9,r7,r9<<0x2
	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
8000972a:	12 a6       	st.w	r9++,r6
      compptr->last_row_height = tmp;
      /* Prepare array describing MCU composition */
      mcublks = compptr->MCU_blocks;
      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
      while (mcublks-- > 0) {
8000972c:	20 18       	sub	r8,1
8000972e:	5b f8       	cp.w	r8,-1
80009730:	cf d1       	brne	8000972a <start_input_pass+0x11a>
80009732:	14 05       	add	r5,r10
80009734:	ef 45 01 64 	st.w	r7[356],r5
      jdiv_round_up((long) cinfo->image_height,
		    (long) (cinfo->max_v_samp_factor*DCTSIZE));

    cinfo->blocks_in_MCU = 0;

    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
80009738:	2f f6       	sub	r6,-1
8000973a:	2f c4       	sub	r4,-4
8000973c:	ee f8 01 48 	ld.w	r8,r7[328]
80009740:	10 36       	cp.w	r6,r8
80009742:	cc 05       	brlt	800096c2 <start_input_pass+0xb2>
80009744:	c8 cb       	rjmp	8000965c <start_input_pass+0x4c>
80009746:	ee c5 fe b4 	sub	r5,r7,-332
8000974a:	30 04       	mov	r4,0
    qtblno = compptr->quant_tbl_no;
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
    /* OK, save away the quantization table */
    qtbl = (JQUANT_TBL *)
8000974c:	e0 62 00 84 	mov	r2,132
80009750:	30 11       	mov	r1,1
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
80009752:	6a 06       	ld.w	r6,r5[0x0]
    /* No work if we already saved Q-table for this component */
    if (compptr->quant_table != NULL)
80009754:	6d 38       	ld.w	r8,r6[0x4c]
80009756:	58 08       	cp.w	r8,0
80009758:	c2 31       	brne	8000979e <start_input_pass+0x18e>
      continue;
    /* Make sure specified quantization table is present */
    qtblno = compptr->quant_tbl_no;
8000975a:	6c 43       	ld.w	r3,r6[0x10]
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
8000975c:	58 33       	cp.w	r3,3
8000975e:	e0 8b 00 08 	brhi	8000976e <start_input_pass+0x15e>
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
80009762:	e6 c8 ff d7 	sub	r8,r3,-41
80009766:	ee 08 03 28 	ld.w	r8,r7[r8<<0x2]
8000976a:	58 08       	cp.w	r8,0
8000976c:	c0 a1       	brne	80009780 <start_input_pass+0x170>
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
8000976e:	6e 08       	ld.w	r8,r7[0x0]
80009770:	33 49       	mov	r9,52
80009772:	91 59       	st.w	r8[0x14],r9
80009774:	6e 08       	ld.w	r8,r7[0x0]
80009776:	91 63       	st.w	r8[0x18],r3
80009778:	6e 08       	ld.w	r8,r7[0x0]
8000977a:	70 08       	ld.w	r8,r8[0x0]
8000977c:	0e 9c       	mov	r12,r7
8000977e:	5d 18       	icall	r8
    /* OK, save away the quantization table */
    qtbl = (JQUANT_TBL *)
80009780:	6e 18       	ld.w	r8,r7[0x4]
80009782:	70 08       	ld.w	r8,r8[0x0]
80009784:	04 9a       	mov	r10,r2
80009786:	02 9b       	mov	r11,r1
80009788:	0e 9c       	mov	r12,r7
8000978a:	5d 18       	icall	r8
8000978c:	18 90       	mov	r0,r12
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(JQUANT_TBL));
    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
8000978e:	2d 73       	sub	r3,-41
80009790:	04 9a       	mov	r10,r2
80009792:	ee 03 03 2b 	ld.w	r11,r7[r3<<0x2]
80009796:	f0 1f 00 0f 	mcall	800097d0 <start_input_pass+0x1c0>
    compptr->quant_table = qtbl;
8000979a:	ed 40 00 4c 	st.w	r6[76],r0
{
  int ci, qtblno;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
8000979e:	2f f4       	sub	r4,-1
800097a0:	2f c5       	sub	r5,-4
800097a2:	ee f8 01 48 	ld.w	r8,r7[328]
800097a6:	10 34       	cp.w	r4,r8
800097a8:	cd 55       	brlt	80009752 <start_input_pass+0x142>
METHODDEF(void)
start_input_pass (j_decompress_ptr cinfo)
{
  per_scan_setup(cinfo);
  latch_quant_tables(cinfo);
  (*cinfo->entropy->start_pass) (cinfo);
800097aa:	ee f8 01 bc 	ld.w	r8,r7[444]
800097ae:	70 08       	ld.w	r8,r8[0x0]
800097b0:	0e 9c       	mov	r12,r7
800097b2:	5d 18       	icall	r8
  (*cinfo->coef->start_input_pass) (cinfo);
800097b4:	ee f8 01 ac 	ld.w	r8,r7[428]
800097b8:	70 08       	ld.w	r8,r8[0x0]
800097ba:	0e 9c       	mov	r12,r7
800097bc:	5d 18       	icall	r8
  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
800097be:	ee f8 01 b4 	ld.w	r8,r7[436]
800097c2:	ee f9 01 ac 	ld.w	r9,r7[428]
800097c6:	72 19       	ld.w	r9,r9[0x4]
800097c8:	91 09       	st.w	r8[0x0],r9
}
800097ca:	d8 32       	popm	r0-r7,pc
800097cc:	80 00       	ld.sh	r0,r0[0x0]
800097ce:	fd 04 80 01 	ld.sh	r4,lr[-32767]
800097d2:	54 ba       	stdsp	sp[0x12c],r10

800097d4 <consume_markers>:
 * we are reading a compressed data segment or inter-segment markers.
 */

METHODDEF(int)
consume_markers (j_decompress_ptr cinfo)
{
800097d4:	d4 31       	pushm	r0-r7,lr
800097d6:	18 97       	mov	r7,r12
  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
800097d8:	f8 f5 01 b4 	ld.w	r5,r12[436]
  int val;

  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
800097dc:	6a 58       	ld.w	r8,r5[0x14]
800097de:	58 08       	cp.w	r8,0
800097e0:	c0 30       	breq	800097e6 <consume_markers+0x12>
800097e2:	30 24       	mov	r4,2
800097e4:	cf 58       	rjmp	800099ce <consume_markers+0x1fa>
    return JPEG_REACHED_EOI;

  val = (*cinfo->marker->read_markers) (cinfo);
800097e6:	f8 f8 01 b8 	ld.w	r8,r12[440]
800097ea:	70 18       	ld.w	r8,r8[0x4]
800097ec:	5d 18       	icall	r8
800097ee:	18 94       	mov	r4,r12

  switch (val) {
800097f0:	58 1c       	cp.w	r12,1
800097f2:	c0 50       	breq	800097fc <consume_markers+0x28>
800097f4:	58 2c       	cp.w	r12,2
800097f6:	e0 81 00 ec 	brne	800099ce <consume_markers+0x1fa>
800097fa:	cd 18       	rjmp	8000999c <consume_markers+0x1c8>
  case JPEG_REACHED_SOS:	/* Found SOS */
    if (inputctl->inheaders) {	/* 1st SOS */
800097fc:	6a 68       	ld.w	r8,r5[0x18]
800097fe:	58 08       	cp.w	r8,0
80009800:	e0 80 00 c0 	breq	80009980 <consume_markers+0x1ac>
{
  int ci;
  jpeg_component_info *compptr;

  /* Make sure image isn't bigger than I can handle */
  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
80009804:	6e 88       	ld.w	r8,r7[0x20]
80009806:	e0 48 ff dc 	cp.w	r8,65500
8000980a:	e0 89 00 07 	brgt	80009818 <consume_markers+0x44>
8000980e:	6e 78       	ld.w	r8,r7[0x1c]
80009810:	e0 48 ff dc 	cp.w	r8,65500
80009814:	e0 8a 00 0d 	brle	8000982e <consume_markers+0x5a>
      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
80009818:	6e 08       	ld.w	r8,r7[0x0]
8000981a:	32 99       	mov	r9,41
8000981c:	91 59       	st.w	r8[0x14],r9
8000981e:	6e 08       	ld.w	r8,r7[0x0]
80009820:	e0 69 ff dc 	mov	r9,65500
80009824:	91 69       	st.w	r8[0x18],r9
80009826:	6e 08       	ld.w	r8,r7[0x0]
80009828:	70 08       	ld.w	r8,r8[0x0]
8000982a:	0e 9c       	mov	r12,r7
8000982c:	5d 18       	icall	r8

  /* For now, precision must match compiled-in value... */
  if (cinfo->data_precision != BITS_IN_JSAMPLE)
8000982e:	ee f8 00 d4 	ld.w	r8,r7[212]
80009832:	58 88       	cp.w	r8,8
80009834:	c0 c0       	breq	8000984c <consume_markers+0x78>
    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
80009836:	6e 08       	ld.w	r8,r7[0x0]
80009838:	30 f9       	mov	r9,15
8000983a:	91 59       	st.w	r8[0x14],r9
8000983c:	6e 08       	ld.w	r8,r7[0x0]
8000983e:	ee f9 00 d4 	ld.w	r9,r7[212]
80009842:	91 69       	st.w	r8[0x18],r9
80009844:	6e 08       	ld.w	r8,r7[0x0]
80009846:	70 08       	ld.w	r8,r8[0x0]
80009848:	0e 9c       	mov	r12,r7
8000984a:	5d 18       	icall	r8

  /* Check that number of components won't exceed internal array sizes */
  if (cinfo->num_components > MAX_COMPONENTS)
8000984c:	6e 98       	ld.w	r8,r7[0x24]
8000984e:	58 48       	cp.w	r8,4
80009850:	e0 8a 00 0f 	brle	8000986e <consume_markers+0x9a>
    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
80009854:	6e 08       	ld.w	r8,r7[0x0]
80009856:	31 a9       	mov	r9,26
80009858:	91 59       	st.w	r8[0x14],r9
8000985a:	6e 08       	ld.w	r8,r7[0x0]
8000985c:	6e 99       	ld.w	r9,r7[0x24]
8000985e:	91 69       	st.w	r8[0x18],r9
80009860:	6e 08       	ld.w	r8,r7[0x0]
80009862:	30 49       	mov	r9,4
80009864:	91 79       	st.w	r8[0x1c],r9
80009866:	6e 08       	ld.w	r8,r7[0x0]
80009868:	70 08       	ld.w	r8,r8[0x0]
8000986a:	0e 9c       	mov	r12,r7
8000986c:	5d 18       	icall	r8
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
8000986e:	30 18       	mov	r8,1
80009870:	ef 48 01 34 	st.w	r7[308],r8
  cinfo->max_v_samp_factor = 1;
80009874:	ef 48 01 38 	st.w	r7[312],r8
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009878:	ee f6 00 d8 	ld.w	r6,r7[216]
8000987c:	6e 98       	ld.w	r8,r7[0x24]
8000987e:	58 08       	cp.w	r8,0
80009880:	e0 8a 00 2a 	brle	800098d4 <consume_markers+0x100>
80009884:	2f 86       	sub	r6,-8
80009886:	30 03       	mov	r3,0
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
80009888:	31 22       	mov	r2,18
  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
8000988a:	6c 08       	ld.w	r8,r6[0x0]
8000988c:	20 18       	sub	r8,1
8000988e:	58 38       	cp.w	r8,3
80009890:	e0 8b 00 09 	brhi	800098a2 <consume_markers+0xce>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
80009894:	6c 18       	ld.w	r8,r6[0x4]
  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
80009896:	58 08       	cp.w	r8,0
80009898:	e0 8a 00 05 	brle	800098a2 <consume_markers+0xce>
8000989c:	58 48       	cp.w	r8,4
8000989e:	e0 8a 00 08 	brle	800098ae <consume_markers+0xda>
	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
      ERREXIT(cinfo, JERR_BAD_SAMPLING);
800098a2:	6e 08       	ld.w	r8,r7[0x0]
800098a4:	91 52       	st.w	r8[0x14],r2
800098a6:	6e 08       	ld.w	r8,r7[0x0]
800098a8:	70 08       	ld.w	r8,r8[0x0]
800098aa:	0e 9c       	mov	r12,r7
800098ac:	5d 18       	icall	r8
    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
800098ae:	ee f9 01 34 	ld.w	r9,r7[308]
800098b2:	6c 08       	ld.w	r8,r6[0x0]
800098b4:	f2 08 0c 48 	max	r8,r9,r8
800098b8:	ef 48 01 34 	st.w	r7[308],r8
				   compptr->h_samp_factor);
    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
800098bc:	ee f9 01 38 	ld.w	r9,r7[312]
800098c0:	6c 18       	ld.w	r8,r6[0x4]
800098c2:	f2 08 0c 48 	max	r8,r9,r8
800098c6:	ef 48 01 38 	st.w	r7[312],r8

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
800098ca:	2f f3       	sub	r3,-1
800098cc:	2a c6       	sub	r6,-84
	     MAX_COMPONENTS);

  /* Compute maximum sampling factors; check factor validity */
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
800098ce:	6e 98       	ld.w	r8,r7[0x24]
800098d0:	10 33       	cp.w	r3,r8
800098d2:	cd c5       	brlt	8000988a <consume_markers+0xb6>

  /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
   * In the full decompressor, this will be overridden by jdmaster.c;
   * but in the transcoder, jdmaster.c is not used, so we must do it here.
   */
  cinfo->min_DCT_scaled_size = DCTSIZE;
800098d4:	30 88       	mov	r8,8
800098d6:	ef 48 01 3c 	st.w	r7[316],r8

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
800098da:	ee f6 00 d8 	ld.w	r6,r7[216]
800098de:	6e 98       	ld.w	r8,r7[0x24]
800098e0:	58 08       	cp.w	r8,0
800098e2:	e0 8a 00 32 	brle	80009946 <consume_markers+0x172>
800098e6:	2f 86       	sub	r6,-8
800098e8:	30 03       	mov	r3,0
       ci++, compptr++) {
    compptr->DCT_scaled_size = DCTSIZE;
800098ea:	30 82       	mov	r2,8
		    (long) cinfo->max_h_samp_factor);
    compptr->downsampled_height = (JDIMENSION)
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) cinfo->max_v_samp_factor);
    /* Mark component needed, until color conversion says otherwise */
    compptr->component_needed = TRUE;
800098ec:	30 11       	mov	r1,1
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
800098ee:	06 90       	mov	r0,r3
  cinfo->min_DCT_scaled_size = DCTSIZE;

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->DCT_scaled_size = DCTSIZE;
800098f0:	8d 72       	st.w	r6[0x1c],r2
    /* Size in DCT blocks */
    compptr->width_in_blocks = (JDIMENSION)
800098f2:	ee fb 01 34 	ld.w	r11,r7[308]
800098f6:	6e 7c       	ld.w	r12,r7[0x1c]
800098f8:	6c 08       	ld.w	r8,r6[0x0]
800098fa:	a3 7b       	lsl	r11,0x3
800098fc:	b1 3c       	mul	r12,r8
800098fe:	f0 1f 00 36 	mcall	800099d4 <consume_markers+0x200>
80009902:	8d 5c       	st.w	r6[0x14],r12
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
    compptr->height_in_blocks = (JDIMENSION)
80009904:	ee fb 01 38 	ld.w	r11,r7[312]
80009908:	6e 8c       	ld.w	r12,r7[0x20]
8000990a:	6c 18       	ld.w	r8,r6[0x4]
8000990c:	a3 7b       	lsl	r11,0x3
8000990e:	b1 3c       	mul	r12,r8
80009910:	f0 1f 00 31 	mcall	800099d4 <consume_markers+0x200>
80009914:	8d 6c       	st.w	r6[0x18],r12
    /* downsampled_width and downsampled_height will also be overridden by
     * jdmaster.c if we are doing full decompression.  The transcoder library
     * doesn't use these values, but the calling application might.
     */
    /* Size in samples */
    compptr->downsampled_width = (JDIMENSION)
80009916:	6e 7c       	ld.w	r12,r7[0x1c]
80009918:	6c 08       	ld.w	r8,r6[0x0]
8000991a:	ee fb 01 34 	ld.w	r11,r7[308]
8000991e:	b1 3c       	mul	r12,r8
80009920:	f0 1f 00 2d 	mcall	800099d4 <consume_markers+0x200>
80009924:	8d 8c       	st.w	r6[0x20],r12
      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
		    (long) cinfo->max_h_samp_factor);
    compptr->downsampled_height = (JDIMENSION)
80009926:	6e 8c       	ld.w	r12,r7[0x20]
80009928:	6c 18       	ld.w	r8,r6[0x4]
8000992a:	ee fb 01 38 	ld.w	r11,r7[312]
8000992e:	b1 3c       	mul	r12,r8
80009930:	f0 1f 00 29 	mcall	800099d4 <consume_markers+0x200>
80009934:	8d 9c       	st.w	r6[0x24],r12
      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
		    (long) cinfo->max_v_samp_factor);
    /* Mark component needed, until color conversion says otherwise */
    compptr->component_needed = TRUE;
80009936:	8d a1       	st.w	r6[0x28],r1
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
80009938:	ed 40 00 44 	st.w	r6[68],r0
   */
  cinfo->min_DCT_scaled_size = DCTSIZE;

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
8000993c:	2f f3       	sub	r3,-1
8000993e:	2a c6       	sub	r6,-84
   * but in the transcoder, jdmaster.c is not used, so we must do it here.
   */
  cinfo->min_DCT_scaled_size = DCTSIZE;

  /* Compute dimensions of components */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009940:	6e 98       	ld.w	r8,r7[0x24]
80009942:	10 33       	cp.w	r3,r8
80009944:	cd 65       	brlt	800098f0 <consume_markers+0x11c>
    /* Mark no quantization table yet saved for component */
    compptr->quant_table = NULL;
  }

  /* Compute number of fully interleaved MCU rows. */
  cinfo->total_iMCU_rows = (JDIMENSION)
80009946:	ee fb 01 38 	ld.w	r11,r7[312]
8000994a:	a3 7b       	lsl	r11,0x3
8000994c:	6e 8c       	ld.w	r12,r7[0x20]
8000994e:	f0 1f 00 22 	mcall	800099d4 <consume_markers+0x200>
80009952:	ef 4c 01 40 	st.w	r7[320],r12
    jdiv_round_up((long) cinfo->image_height,
		  (long) (cinfo->max_v_samp_factor*DCTSIZE));

  /* Decide whether file contains multiple scans */
  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
80009956:	ee f9 01 48 	ld.w	r9,r7[328]
8000995a:	6e 98       	ld.w	r8,r7[0x24]
8000995c:	10 39       	cp.w	r9,r8
8000995e:	c0 55       	brlt	80009968 <consume_markers+0x194>
80009960:	ee f8 00 dc 	ld.w	r8,r7[220]
80009964:	58 08       	cp.w	r8,0
80009966:	c0 60       	breq	80009972 <consume_markers+0x19e>
    cinfo->inputctl->has_multiple_scans = TRUE;
80009968:	ee f8 01 b4 	ld.w	r8,r7[436]
8000996c:	30 19       	mov	r9,1
8000996e:	91 49       	st.w	r8[0x10],r9
80009970:	c0 58       	rjmp	8000997a <consume_markers+0x1a6>
  else
    cinfo->inputctl->has_multiple_scans = FALSE;
80009972:	ee f8 01 b4 	ld.w	r8,r7[436]
80009976:	30 09       	mov	r9,0
80009978:	91 49       	st.w	r8[0x10],r9

  switch (val) {
  case JPEG_REACHED_SOS:	/* Found SOS */
    if (inputctl->inheaders) {	/* 1st SOS */
      initial_setup(cinfo);
      inputctl->inheaders = FALSE;
8000997a:	30 08       	mov	r8,0
8000997c:	8b 68       	st.w	r5[0x18],r8
8000997e:	c2 88       	rjmp	800099ce <consume_markers+0x1fa>
      /* Note: start_input_pass must be called by jdmaster.c
       * before any more input can be consumed.  jdapimin.c is
       * responsible for enforcing this sequencing.
       */
    } else {			/* 2nd or later SOS marker */
      if (! inputctl->pub.has_multiple_scans)
80009980:	6a 48       	ld.w	r8,r5[0x10]
80009982:	58 08       	cp.w	r8,0
80009984:	c0 81       	brne	80009994 <consume_markers+0x1c0>
	ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
80009986:	6e 08       	ld.w	r8,r7[0x0]
80009988:	32 39       	mov	r9,35
8000998a:	91 59       	st.w	r8[0x14],r9
8000998c:	6e 08       	ld.w	r8,r7[0x0]
8000998e:	70 08       	ld.w	r8,r8[0x0]
80009990:	0e 9c       	mov	r12,r7
80009992:	5d 18       	icall	r8
      start_input_pass(cinfo);
80009994:	0e 9c       	mov	r12,r7
80009996:	f0 1f 00 11 	mcall	800099d8 <consume_markers+0x204>
8000999a:	c1 a8       	rjmp	800099ce <consume_markers+0x1fa>
    }
    break;
  case JPEG_REACHED_EOI:	/* Found EOI */
    inputctl->pub.eoi_reached = TRUE;
8000999c:	30 18       	mov	r8,1
8000999e:	8b 58       	st.w	r5[0x14],r8
    if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
800099a0:	6a 68       	ld.w	r8,r5[0x18]
800099a2:	58 08       	cp.w	r8,0
800099a4:	c0 e0       	breq	800099c0 <consume_markers+0x1ec>
      if (cinfo->marker->saw_SOF)
800099a6:	ee f8 01 b8 	ld.w	r8,r7[440]
800099aa:	70 48       	ld.w	r8,r8[0x10]
800099ac:	58 08       	cp.w	r8,0
800099ae:	c1 00       	breq	800099ce <consume_markers+0x1fa>
	ERREXIT(cinfo, JERR_SOF_NO_SOS);
800099b0:	6e 08       	ld.w	r8,r7[0x0]
800099b2:	33 b9       	mov	r9,59
800099b4:	91 59       	st.w	r8[0x14],r9
800099b6:	6e 08       	ld.w	r8,r7[0x0]
800099b8:	70 08       	ld.w	r8,r8[0x0]
800099ba:	0e 9c       	mov	r12,r7
800099bc:	5d 18       	icall	r8
800099be:	c0 88       	rjmp	800099ce <consume_markers+0x1fa>
    } else {
      /* Prevent infinite loop in coef ctlr's decompress_data routine
       * if user set output_scan_number larger than number of scans.
       */
      if (cinfo->output_scan_number > cinfo->input_scan_number)
800099c0:	ee f8 00 90 	ld.w	r8,r7[144]
800099c4:	ee f9 00 98 	ld.w	r9,r7[152]
	cinfo->output_scan_number = cinfo->input_scan_number;
800099c8:	10 39       	cp.w	r9,r8
800099ca:	ef f8 9a 26 	st.wgt	r7[0x98],r8
  case JPEG_SUSPENDED:
    break;
  }

  return val;
}
800099ce:	08 9c       	mov	r12,r4
800099d0:	d8 32       	popm	r0-r7,pc
800099d2:	00 00       	add	r0,r0
800099d4:	80 00       	ld.sh	r0,r0[0x0]
800099d6:	fd 04 80 00 	ld.sh	r4,lr[-32768]
800099da:	96 10       	ld.sh	r0,r11[0x2]

800099dc <start_pass_main>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
800099dc:	d4 31       	pushm	r0-r7,lr
800099de:	20 5d       	sub	sp,20
  my_main_ptr main = (my_main_ptr) cinfo->main;
800099e0:	f8 f3 01 a8 	ld.w	r3,r12[424]

  switch (pass_mode) {
800099e4:	58 0b       	cp.w	r11,0
800099e6:	c0 50       	breq	800099f0 <start_pass_main+0x14>
800099e8:	58 2b       	cp.w	r11,2
800099ea:	e0 81 00 81 	brne	80009aec <start_pass_main+0x110>
800099ee:	c7 c8       	rjmp	80009ae6 <start_pass_main+0x10a>
  case JBUF_PASS_THRU:
    if (cinfo->upsample->need_context_rows) {
800099f0:	f8 f8 01 c4 	ld.w	r8,r12[452]
800099f4:	70 28       	ld.w	r8,r8[0x8]
800099f6:	58 08       	cp.w	r8,0
800099f8:	c7 10       	breq	80009ada <start_pass_main+0xfe>
      main->pub.process_data = process_data_context_main;
800099fa:	4c 18       	lddpc	r8,80009afc <start_pass_main+0x120>
800099fc:	87 18       	st.w	r3[0x4],r8
 * and the space for the pointer lists is allocated too.
 * This routine just fills in the curiously ordered lists.
 * This will be repeated at the beginning of each pass.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
800099fe:	f8 f0 01 a8 	ld.w	r0,r12[424]
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
80009a02:	f8 fe 01 3c 	ld.w	lr,r12[316]
80009a06:	50 0e       	stdsp	sp[0x0],lr
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009a08:	f8 f1 00 d8 	ld.w	r1,r12[216]
80009a0c:	78 98       	ld.w	r8,r12[0x24]
80009a0e:	58 08       	cp.w	r8,0
80009a10:	e0 8a 00 60 	brle	80009ad0 <start_pass_main+0xf4>
80009a14:	2f 41       	sub	r1,-12
80009a16:	e0 c8 ff f8 	sub	r8,r0,-8
80009a1a:	30 02       	mov	r2,0
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
    for (i = 0; i < rgroup * (M + 2); i++) {
80009a1c:	2f ee       	sub	lr,-2
80009a1e:	50 1e       	stdsp	sp[0x4],lr
80009a20:	50 22       	stdsp	sp[0x8],r2
/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
80009a22:	40 0a       	lddsp	r10,sp[0x0]
80009a24:	20 2a       	sub	r10,2
80009a26:	50 3a       	stdsp	sp[0xc],r10
80009a28:	50 43       	stdsp	sp[0x10],r3
80009a2a:	10 93       	mov	r3,r8
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
80009a2c:	62 69       	ld.w	r9,r1[0x18]
80009a2e:	62 08       	ld.w	r8,r1[0x0]
80009a30:	b1 39       	mul	r9,r8
80009a32:	f8 f8 01 3c 	ld.w	r8,r12[316]
80009a36:	f2 08 0c 08 	divs	r8,r9,r8
80009a3a:	10 95       	mov	r5,r8
80009a3c:	e4 08 15 02 	lsl	r8,r2,0x2
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
80009a40:	60 89       	ld.w	r9,r0[0x20]
80009a42:	f2 08 03 09 	ld.w	r9,r9[r8]
    xbuf1 = main->xbuffer[1][ci];
80009a46:	60 9a       	ld.w	r10,r0[0x24]
80009a48:	f4 08 03 08 	ld.w	r8,r10[r8]
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
80009a4c:	66 06       	ld.w	r6,r3[0x0]
    for (i = 0; i < rgroup * (M + 2); i++) {
80009a4e:	40 1e       	lddsp	lr,sp[0x4]
80009a50:	ea 0e 02 47 	mul	r7,r5,lr
80009a54:	58 07       	cp.w	r7,0
80009a56:	e0 8a 00 0e 	brle	80009a72 <start_pass_main+0x96>
80009a5a:	30 0a       	mov	r10,0
80009a5c:	40 2b       	lddsp	r11,sp[0x8]
      xbuf0[i] = xbuf1[i] = buf[i];
80009a5e:	ec 0a 03 0e 	ld.w	lr,r6[r10]
80009a62:	f0 0a 09 0e 	st.w	r8[r10],lr
80009a66:	f2 0a 09 0e 	st.w	r9[r10],lr
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    /* First copy the workspace pointers as-is */
    buf = main->buffer[ci];
    for (i = 0; i < rgroup * (M + 2); i++) {
80009a6a:	2f fb       	sub	r11,-1
80009a6c:	2f ca       	sub	r10,-4
80009a6e:	0e 3b       	cp.w	r11,r7
80009a70:	cf 71       	brne	80009a5e <start_pass_main+0x82>
      xbuf0[i] = xbuf1[i] = buf[i];
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
80009a72:	ea 04 15 01 	lsl	r4,r5,0x1
80009a76:	58 04       	cp.w	r4,0
80009a78:	e0 8a 00 1a 	brle	80009aac <start_pass_main+0xd0>
/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
80009a7c:	40 0b       	lddsp	r11,sp[0x0]
80009a7e:	ea 0b 02 4a 	mul	r10,r5,r11
80009a82:	a3 6a       	lsl	r10,0x2
80009a84:	ec 0a 00 07 	add	r7,r6,r10
80009a88:	40 3e       	lddsp	lr,sp[0xc]
80009a8a:	ea 0e 02 4b 	mul	r11,r5,lr
80009a8e:	a3 6b       	lsl	r11,0x2
80009a90:	f0 0b 00 0e 	add	lr,r8,r11
80009a94:	ec 0b 00 0b 	add	r11,r6,r11
80009a98:	f0 0a 00 0a 	add	r10,r8,r10
80009a9c:	30 08       	mov	r8,0
    for (i = 0; i < rgroup * (M + 2); i++) {
      xbuf0[i] = xbuf1[i] = buf[i];
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
80009a9e:	0f 06       	ld.w	r6,r7++
80009aa0:	1c a6       	st.w	lr++,r6
      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
80009aa2:	17 06       	ld.w	r6,r11++
80009aa4:	14 a6       	st.w	r10++,r6
    buf = main->buffer[ci];
    for (i = 0; i < rgroup * (M + 2); i++) {
      xbuf0[i] = xbuf1[i] = buf[i];
    }
    /* In the second list, put the last four row groups in swapped order */
    for (i = 0; i < rgroup * 2; i++) {
80009aa6:	2f f8       	sub	r8,-1
80009aa8:	08 38       	cp.w	r8,r4
80009aaa:	cf a1       	brne	80009a9e <start_pass_main+0xc2>
    /* The wraparound pointers at top and bottom will be filled later
     * (see set_wraparound_pointers, below).  Initially we want the "above"
     * pointers to duplicate the first actual data line.  This only needs
     * to happen in xbuffer[0].
     */
    for (i = 0; i < rgroup; i++) {
80009aac:	58 05       	cp.w	r5,0
80009aae:	e0 8a 00 0a 	brle	80009ac2 <start_pass_main+0xe6>
80009ab2:	f2 05 01 2a 	sub	r10,r9,r5<<0x2
80009ab6:	30 08       	mov	r8,0
      xbuf0[i - rgroup] = xbuf0[0];
80009ab8:	72 0b       	ld.w	r11,r9[0x0]
80009aba:	14 ab       	st.w	r10++,r11
    /* The wraparound pointers at top and bottom will be filled later
     * (see set_wraparound_pointers, below).  Initially we want the "above"
     * pointers to duplicate the first actual data line.  This only needs
     * to happen in xbuffer[0].
     */
    for (i = 0; i < rgroup; i++) {
80009abc:	2f f8       	sub	r8,-1
80009abe:	0a 38       	cp.w	r8,r5
80009ac0:	cf c1       	brne	80009ab8 <start_pass_main+0xdc>
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80009ac2:	2f f2       	sub	r2,-1
80009ac4:	2a c1       	sub	r1,-84
80009ac6:	2f c3       	sub	r3,-4
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY buf, xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009ac8:	78 98       	ld.w	r8,r12[0x24]
80009aca:	10 32       	cp.w	r2,r8
80009acc:	cb 05       	brlt	80009a2c <start_pass_main+0x50>
80009ace:	40 43       	lddsp	r3,sp[0x10]
  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (cinfo->upsample->need_context_rows) {
      main->pub.process_data = process_data_context_main;
      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
80009ad0:	30 08       	mov	r8,0
80009ad2:	87 a8       	st.w	r3[0x28],r8
      main->context_state = CTX_PREPARE_FOR_IMCU;
80009ad4:	87 b8       	st.w	r3[0x2c],r8
      main->iMCU_row_ctr = 0;
80009ad6:	87 d8       	st.w	r3[0x34],r8
80009ad8:	c0 38       	rjmp	80009ade <start_pass_main+0x102>
    } else {
      /* Simple case with no context needed */
      main->pub.process_data = process_data_simple_main;
80009ada:	48 a8       	lddpc	r8,80009b00 <start_pass_main+0x124>
80009adc:	87 18       	st.w	r3[0x4],r8
    }
    main->buffer_full = FALSE;	/* Mark buffer empty */
80009ade:	30 08       	mov	r8,0
80009ae0:	87 68       	st.w	r3[0x18],r8
    main->rowgroup_ctr = 0;
80009ae2:	87 78       	st.w	r3[0x1c],r8
    break;
80009ae4:	c0 a8       	rjmp	80009af8 <start_pass_main+0x11c>
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_CRANK_DEST:
    /* For last pass of 2-pass quantization, just crank the postprocessor */
    main->pub.process_data = process_data_crank_post;
80009ae6:	48 88       	lddpc	r8,80009b04 <start_pass_main+0x128>
80009ae8:	87 18       	st.w	r3[0x4],r8
    break;
80009aea:	c0 78       	rjmp	80009af8 <start_pass_main+0x11c>
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
80009aec:	78 08       	ld.w	r8,r12[0x0]
80009aee:	30 49       	mov	r9,4
80009af0:	91 59       	st.w	r8[0x14],r9
80009af2:	78 08       	ld.w	r8,r12[0x0]
80009af4:	70 08       	ld.w	r8,r8[0x0]
80009af6:	5d 18       	icall	r8
    break;
  }
}
80009af8:	2f bd       	sub	sp,-20
80009afa:	d8 32       	popm	r0-r7,pc
80009afc:	80 00       	ld.sh	r0,r0[0x0]
80009afe:	9b 64       	st.w	sp[0x18],r4
80009b00:	80 00       	ld.sh	r0,r0[0x0]
80009b02:	9b 08       	st.w	sp[0x0],r8
80009b04:	80 00       	ld.sh	r0,r0[0x0]
80009b06:	9d 72       	st.w	lr[0x1c],r2

80009b08 <process_data_simple_main>:

METHODDEF(void)
process_data_simple_main (j_decompress_ptr cinfo,
			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			  JDIMENSION out_rows_avail)
{
80009b08:	eb cd 40 fc 	pushm	r2-r7,lr
80009b0c:	18 97       	mov	r7,r12
80009b0e:	16 92       	mov	r2,r11
80009b10:	14 93       	mov	r3,r10
80009b12:	12 96       	mov	r6,r9
  my_main_ptr main = (my_main_ptr) cinfo->main;
80009b14:	f8 f5 01 a8 	ld.w	r5,r12[424]
  JDIMENSION rowgroups_avail;

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
80009b18:	6a 68       	ld.w	r8,r5[0x18]
80009b1a:	58 08       	cp.w	r8,0
80009b1c:	c0 a1       	brne	80009b30 <process_data_simple_main+0x28>
    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
80009b1e:	f8 f8 01 ac 	ld.w	r8,r12[428]
80009b22:	70 38       	ld.w	r8,r8[0xc]
80009b24:	ea cb ff f8 	sub	r11,r5,-8
80009b28:	5d 18       	icall	r8
80009b2a:	c1 b0       	breq	80009b60 <process_data_simple_main+0x58>
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
80009b2c:	30 18       	mov	r8,1
80009b2e:	8b 68       	st.w	r5[0x18],r8
  }

  /* There are always min_DCT_scaled_size row groups in an iMCU row. */
  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
80009b30:	ee f4 01 3c 	ld.w	r4,r7[316]
   * to the postprocessor.  The postprocessor has to check for bottom
   * of image anyway (at row resolution), so no point in us doing it too.
   */

  /* Feed the postprocessor */
  (*cinfo->post->post_process_data) (cinfo, main->buffer,
80009b34:	ee f8 01 b0 	ld.w	r8,r7[432]
80009b38:	1a d6       	st.w	--sp,r6
80009b3a:	1a d3       	st.w	--sp,r3
80009b3c:	70 16       	ld.w	r6,r8[0x4]
80009b3e:	04 98       	mov	r8,r2
80009b40:	08 99       	mov	r9,r4
80009b42:	ea ca ff e4 	sub	r10,r5,-28
80009b46:	ea cb ff f8 	sub	r11,r5,-8
80009b4a:	0e 9c       	mov	r12,r7
80009b4c:	5d 16       	icall	r6
				     &main->rowgroup_ctr, rowgroups_avail,
				     output_buf, out_row_ctr, out_rows_avail);

  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
  if (main->rowgroup_ctr >= rowgroups_avail) {
80009b4e:	2f ed       	sub	sp,-8
80009b50:	6a 78       	ld.w	r8,r5[0x1c]
    main->buffer_full = FALSE;
80009b52:	10 34       	cp.w	r4,r8
80009b54:	f9 b8 08 00 	movls	r8,0
80009b58:	eb f8 8a 06 	st.wls	r5[0x18],r8
    main->rowgroup_ctr = 0;
80009b5c:	eb f8 8a 07 	st.wls	r5[0x1c],r8
80009b60:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

80009b64 <process_data_context_main>:

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			   JDIMENSION out_rows_avail)
{
80009b64:	d4 31       	pushm	r0-r7,lr
80009b66:	20 5d       	sub	sp,20
80009b68:	18 95       	mov	r5,r12
80009b6a:	16 92       	mov	r2,r11
80009b6c:	14 94       	mov	r4,r10
80009b6e:	12 93       	mov	r3,r9
  my_main_ptr main = (my_main_ptr) cinfo->main;
80009b70:	f8 f7 01 a8 	ld.w	r7,r12[424]

  /* Read input data if we haven't filled the main buffer yet */
  if (! main->buffer_full) {
80009b74:	6e 68       	ld.w	r8,r7[0x18]
80009b76:	58 08       	cp.w	r8,0
80009b78:	c1 01       	brne	80009b98 <process_data_context_main+0x34>
    if (! (*cinfo->coef->decompress_data) (cinfo,
80009b7a:	f8 f8 01 ac 	ld.w	r8,r12[428]
80009b7e:	6e a9       	ld.w	r9,r7[0x28]
80009b80:	2f 89       	sub	r9,-8
80009b82:	70 38       	ld.w	r8,r8[0xc]
80009b84:	ee 09 03 2b 	ld.w	r11,r7[r9<<0x2]
80009b88:	5d 18       	icall	r8
80009b8a:	e0 80 00 f2 	breq	80009d6e <process_data_context_main+0x20a>
					   main->xbuffer[main->whichptr]))
      return;			/* suspension forced, can do nothing more */
    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
80009b8e:	30 18       	mov	r8,1
80009b90:	8f 68       	st.w	r7[0x18],r8
    main->iMCU_row_ctr++;	/* count rows received */
80009b92:	6e d8       	ld.w	r8,r7[0x34]
80009b94:	2f f8       	sub	r8,-1
80009b96:	8f d8       	st.w	r7[0x34],r8
  /* Postprocessor typically will not swallow all the input data it is handed
   * in one call (due to filling the output buffer first).  Must be prepared
   * to exit and restart.  This switch lets us keep track of how far we got.
   * Note that each case falls through to the next on successful completion.
   */
  switch (main->context_state) {
80009b98:	6e b8       	ld.w	r8,r7[0x2c]
80009b9a:	58 18       	cp.w	r8,1
80009b9c:	c7 10       	breq	80009c7e <process_data_context_main+0x11a>
80009b9e:	58 28       	cp.w	r8,2
80009ba0:	c0 40       	breq	80009ba8 <process_data_context_main+0x44>
80009ba2:	58 08       	cp.w	r8,0
80009ba4:	c1 d0       	breq	80009bde <process_data_context_main+0x7a>
80009ba6:	ce 48       	rjmp	80009d6e <process_data_context_main+0x20a>
  case CTX_POSTPONED_ROW:
    /* Call postprocessor using previously set pointers for postponed row */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
80009ba8:	ea f8 01 b0 	ld.w	r8,r5[432]
80009bac:	6e ab       	ld.w	r11,r7[0x28]
80009bae:	2f 8b       	sub	r11,-8
80009bb0:	1a d3       	st.w	--sp,r3
80009bb2:	1a d4       	st.w	--sp,r4
80009bb4:	70 16       	ld.w	r6,r8[0x4]
80009bb6:	04 98       	mov	r8,r2
80009bb8:	6e c9       	ld.w	r9,r7[0x30]
80009bba:	ee ca ff e4 	sub	r10,r7,-28
80009bbe:	ee 0b 03 2b 	ld.w	r11,r7[r11<<0x2]
80009bc2:	0a 9c       	mov	r12,r5
80009bc4:	5d 16       	icall	r6
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
80009bc6:	2f ed       	sub	sp,-8
80009bc8:	6e 79       	ld.w	r9,r7[0x1c]
80009bca:	6e c8       	ld.w	r8,r7[0x30]
80009bcc:	10 39       	cp.w	r9,r8
80009bce:	e0 83 00 d0 	brlo	80009d6e <process_data_context_main+0x20a>
      return;			/* Need to suspend */
    main->context_state = CTX_PREPARE_FOR_IMCU;
80009bd2:	30 08       	mov	r8,0
80009bd4:	8f b8       	st.w	r7[0x2c],r8
    if (*out_row_ctr >= out_rows_avail)
80009bd6:	68 08       	ld.w	r8,r4[0x0]
80009bd8:	10 33       	cp.w	r3,r8
80009bda:	e0 88 00 ca 	brls	80009d6e <process_data_context_main+0x20a>
      return;			/* Postprocessor exactly filled output buf */
    /*FALLTHROUGH*/
  case CTX_PREPARE_FOR_IMCU:
    /* Prepare to process first M-1 row groups of this iMCU row */
    main->rowgroup_ctr = 0;
80009bde:	30 08       	mov	r8,0
80009be0:	8f 78       	st.w	r7[0x1c],r8
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
80009be2:	ea f8 01 3c 	ld.w	r8,r5[316]
80009be6:	20 18       	sub	r8,1
80009be8:	8f c8       	st.w	r7[0x30],r8
    /* Check for bottom of image: if so, tweak pointers to "duplicate"
     * the last sample row, and adjust rowgroups_avail to ignore padding rows.
     */
    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
80009bea:	6e d9       	ld.w	r9,r7[0x34]
80009bec:	ea f8 01 40 	ld.w	r8,r5[320]
80009bf0:	10 39       	cp.w	r9,r8
80009bf2:	c4 41       	brne	80009c7a <process_data_context_main+0x116>
/* Change the pointer lists to duplicate the last sample row at the bottom
 * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
 * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
80009bf4:	ea f1 01 a8 	ld.w	r1,r5[424]
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009bf8:	ea f6 00 d8 	ld.w	r6,r5[216]
80009bfc:	6a 98       	ld.w	r8,r5[0x24]
80009bfe:	58 08       	cp.w	r8,0
80009c00:	e0 8a 00 3d 	brle	80009c7a <process_data_context_main+0x116>
80009c04:	2f 46       	sub	r6,-12
80009c06:	30 0e       	mov	lr,0
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
    for (i = 0; i < rgroup * 2; i++) {
      xbuf[rows_left + i] = xbuf[rows_left-1];
80009c08:	1c 90       	mov	r0,lr
80009c0a:	50 22       	stdsp	sp[0x8],r2
80009c0c:	50 33       	stdsp	sp[0xc],r3
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Count sample rows in one iMCU row and in one row group */
    iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
80009c0e:	6c 6a       	ld.w	r10,r6[0x18]
80009c10:	6c 08       	ld.w	r8,r6[0x0]
80009c12:	b1 3a       	mul	r10,r8
    rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
80009c14:	ea f9 01 3c 	ld.w	r9,r5[316]
80009c18:	f4 09 0c 08 	divs	r8,r10,r9
80009c1c:	10 9b       	mov	r11,r8
    /* Count nondummy sample rows remaining for this component */
    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
80009c1e:	6c 89       	ld.w	r9,r6[0x20]
80009c20:	f2 0a 0d 08 	divu	r8,r9,r10
    if (rows_left == 0) rows_left = iMCUheight;
80009c24:	58 09       	cp.w	r9,0
80009c26:	f4 09 17 00 	moveq	r9,r10
    /* Count nondummy row groups.  Should get same answer for each component,
     * so we need only do it once.
     */
    if (ci == 0) {
80009c2a:	58 0e       	cp.w	lr,0
80009c2c:	c0 a1       	brne	80009c40 <process_data_context_main+0xdc>
      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
80009c2e:	f2 c8 00 01 	sub	r8,r9,1
80009c32:	f0 0b 0c 02 	divs	r2,r8,r11
80009c36:	fa e3 00 00 	st.d	sp[0],r2
80009c3a:	40 18       	lddsp	r8,sp[0x4]
80009c3c:	2f f8       	sub	r8,-1
80009c3e:	83 c8       	st.w	r1[0x30],r8
    }
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
80009c40:	62 a8       	ld.w	r8,r1[0x28]
80009c42:	2f 88       	sub	r8,-8
80009c44:	e2 08 03 28 	ld.w	r8,r1[r8<<0x2]
80009c48:	f0 0e 03 28 	ld.w	r8,r8[lr<<0x2]
    for (i = 0; i < rgroup * 2; i++) {
80009c4c:	a1 7b       	lsl	r11,0x1
80009c4e:	58 0b       	cp.w	r11,0
80009c50:	e0 8a 00 0e 	brle	80009c6c <process_data_context_main+0x108>
      xbuf[rows_left + i] = xbuf[rows_left-1];
80009c54:	f2 cc 00 01 	sub	r12,r9,1
80009c58:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009c5c:	f0 09 00 29 	add	r9,r8,r9<<0x2
80009c60:	00 98       	mov	r8,r0
80009c62:	78 0a       	ld.w	r10,r12[0x0]
80009c64:	12 aa       	st.w	r9++,r10
    }
    /* Duplicate the last real sample row rgroup*2 times; this pads out the
     * last partial rowgroup and ensures at least one full rowgroup of context.
     */
    xbuf = main->xbuffer[main->whichptr][ci];
    for (i = 0; i < rgroup * 2; i++) {
80009c66:	2f f8       	sub	r8,-1
80009c68:	16 38       	cp.w	r8,r11
80009c6a:	cf c1       	brne	80009c62 <process_data_context_main+0xfe>
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80009c6c:	2f fe       	sub	lr,-1
80009c6e:	2a c6       	sub	r6,-84
  my_main_ptr main = (my_main_ptr) cinfo->main;
  int ci, i, rgroup, iMCUheight, rows_left;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009c70:	6a 98       	ld.w	r8,r5[0x24]
80009c72:	10 3e       	cp.w	lr,r8
80009c74:	cc d5       	brlt	80009c0e <process_data_context_main+0xaa>
80009c76:	40 22       	lddsp	r2,sp[0x8]
80009c78:	40 33       	lddsp	r3,sp[0xc]
    /* Check for bottom of image: if so, tweak pointers to "duplicate"
     * the last sample row, and adjust rowgroups_avail to ignore padding rows.
     */
    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
      set_bottom_pointers(cinfo);
    main->context_state = CTX_PROCESS_IMCU;
80009c7a:	30 18       	mov	r8,1
80009c7c:	8f b8       	st.w	r7[0x2c],r8
    /*FALLTHROUGH*/
  case CTX_PROCESS_IMCU:
    /* Call postprocessor using previously set pointers */
    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
80009c7e:	ea f8 01 b0 	ld.w	r8,r5[432]
80009c82:	6e ab       	ld.w	r11,r7[0x28]
80009c84:	2f 8b       	sub	r11,-8
80009c86:	1a d3       	st.w	--sp,r3
80009c88:	1a d4       	st.w	--sp,r4
80009c8a:	70 16       	ld.w	r6,r8[0x4]
80009c8c:	04 98       	mov	r8,r2
80009c8e:	6e c9       	ld.w	r9,r7[0x30]
80009c90:	ee ca ff e4 	sub	r10,r7,-28
80009c94:	ee 0b 03 2b 	ld.w	r11,r7[r11<<0x2]
80009c98:	0a 9c       	mov	r12,r5
80009c9a:	5d 16       	icall	r6
			&main->rowgroup_ctr, main->rowgroups_avail,
			output_buf, out_row_ctr, out_rows_avail);
    if (main->rowgroup_ctr < main->rowgroups_avail)
80009c9c:	2f ed       	sub	sp,-8
80009c9e:	6e 79       	ld.w	r9,r7[0x1c]
80009ca0:	6e c8       	ld.w	r8,r7[0x30]
80009ca2:	10 39       	cp.w	r9,r8
80009ca4:	c6 53       	brcs	80009d6e <process_data_context_main+0x20a>
      return;			/* Need to suspend */
    /* After the first iMCU, change wraparound pointers to normal state */
    if (main->iMCU_row_ctr == 1)
80009ca6:	6e d8       	ld.w	r8,r7[0x34]
80009ca8:	58 18       	cp.w	r8,1
80009caa:	c5 21       	brne	80009d4e <process_data_context_main+0x1ea>
set_wraparound_pointers (j_decompress_ptr cinfo)
/* Set up the "wraparound" pointers at top and bottom of the pointer lists.
 * This changes the pointer list state from top-of-image to the normal state.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
80009cac:	ea f2 01 a8 	ld.w	r2,r5[424]
80009cb0:	50 02       	stdsp	sp[0x0],r2
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
80009cb2:	ea f8 01 3c 	ld.w	r8,r5[316]
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009cb6:	ea f0 00 d8 	ld.w	r0,r5[216]
80009cba:	6a 99       	ld.w	r9,r5[0x24]
80009cbc:	58 09       	cp.w	r9,0
80009cbe:	e0 8a 00 48 	brle	80009d4e <process_data_context_main+0x1ea>
80009cc2:	2f 40       	sub	r0,-12
80009cc4:	30 01       	mov	r1,0
 * Process some data.
 * This handles the case where context rows must be provided.
 */

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
80009cc6:	f0 cb ff ff 	sub	r11,r8,-1
80009cca:	50 2b       	stdsp	sp[0x8],r11
80009ccc:	2f e8       	sub	r8,-2
80009cce:	50 38       	stdsp	sp[0xc],r8
80009cd0:	50 47       	stdsp	sp[0x10],r7
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
80009cd2:	60 67       	ld.w	r7,r0[0x18]
80009cd4:	60 08       	ld.w	r8,r0[0x0]
80009cd6:	b1 37       	mul	r7,r8
80009cd8:	ea f8 01 3c 	ld.w	r8,r5[316]
80009cdc:	ee 08 0c 06 	divs	r6,r7,r8
80009ce0:	0c 92       	mov	r2,r6
80009ce2:	e2 08 15 02 	lsl	r8,r1,0x2
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
80009ce6:	40 0a       	lddsp	r10,sp[0x0]
80009ce8:	74 89       	ld.w	r9,r10[0x20]
80009cea:	f2 08 03 0a 	ld.w	r10,r9[r8]
    xbuf1 = main->xbuffer[1][ci];
80009cee:	40 03       	lddsp	r3,sp[0x0]
80009cf0:	66 99       	ld.w	r9,r3[0x24]
80009cf2:	f2 08 03 09 	ld.w	r9,r9[r8]
    for (i = 0; i < rgroup; i++) {
80009cf6:	58 06       	cp.w	r6,0
80009cf8:	e0 8a 00 25 	brle	80009d42 <process_data_context_main+0x1de>
 * Process some data.
 * This handles the case where context rows must be provided.
 */

METHODDEF(void)
process_data_context_main (j_decompress_ptr cinfo,
80009cfc:	40 28       	lddsp	r8,sp[0x8]
80009cfe:	ec 08 02 47 	mul	r7,r6,r8
80009d02:	a3 67       	lsl	r7,0x2
80009d04:	f4 07 00 04 	add	r4,r10,r7
80009d08:	ec 0e 15 02 	lsl	lr,r6,0x2
80009d0c:	5c 3e       	neg	lr
80009d0e:	f4 0e 00 06 	add	r6,r10,lr
80009d12:	f2 07 00 07 	add	r7,r9,r7
80009d16:	f2 0e 00 0e 	add	lr,r9,lr
80009d1a:	40 33       	lddsp	r3,sp[0xc]
80009d1c:	e4 03 02 4b 	mul	r11,r2,r3
80009d20:	a3 6b       	lsl	r11,0x2
80009d22:	f4 0b 00 0c 	add	r12,r10,r11
80009d26:	f2 0b 00 0b 	add	r11,r9,r11
80009d2a:	30 08       	mov	r8,0
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    for (i = 0; i < rgroup; i++) {
      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
80009d2c:	09 03       	ld.w	r3,r4++
80009d2e:	0c a3       	st.w	r6++,r3
      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
80009d30:	0f 03       	ld.w	r3,r7++
80009d32:	1c a3       	st.w	lr++,r3
      xbuf0[rgroup*(M+2) + i] = xbuf0[i];
80009d34:	15 03       	ld.w	r3,r10++
80009d36:	18 a3       	st.w	r12++,r3
      xbuf1[rgroup*(M+2) + i] = xbuf1[i];
80009d38:	13 03       	ld.w	r3,r9++
80009d3a:	16 a3       	st.w	r11++,r3
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    xbuf0 = main->xbuffer[0][ci];
    xbuf1 = main->xbuffer[1][ci];
    for (i = 0; i < rgroup; i++) {
80009d3c:	2f f8       	sub	r8,-1
80009d3e:	04 38       	cp.w	r8,r2
80009d40:	cf 61       	brne	80009d2c <process_data_context_main+0x1c8>
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80009d42:	2f f1       	sub	r1,-1
80009d44:	2a c0       	sub	r0,-84
  int ci, i, rgroup;
  int M = cinfo->min_DCT_scaled_size;
  jpeg_component_info *compptr;
  JSAMPARRAY xbuf0, xbuf1;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009d46:	6a 98       	ld.w	r8,r5[0x24]
80009d48:	10 31       	cp.w	r1,r8
80009d4a:	cc 45       	brlt	80009cd2 <process_data_context_main+0x16e>
80009d4c:	40 47       	lddsp	r7,sp[0x10]
      return;			/* Need to suspend */
    /* After the first iMCU, change wraparound pointers to normal state */
    if (main->iMCU_row_ctr == 1)
      set_wraparound_pointers(cinfo);
    /* Prepare to load new iMCU row using other xbuffer list */
    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
80009d4e:	6e a8       	ld.w	r8,r7[0x28]
80009d50:	ec 18 00 01 	eorl	r8,0x1
80009d54:	8f a8       	st.w	r7[0x28],r8
    main->buffer_full = FALSE;
80009d56:	30 08       	mov	r8,0
80009d58:	8f 68       	st.w	r7[0x18],r8
    /* Still need to process last row group of this iMCU row, */
    /* which is saved at index M+1 of the other xbuffer */
    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
80009d5a:	ea f8 01 3c 	ld.w	r8,r5[316]
80009d5e:	2f f8       	sub	r8,-1
80009d60:	8f 78       	st.w	r7[0x1c],r8
    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
80009d62:	ea f8 01 3c 	ld.w	r8,r5[316]
80009d66:	2f e8       	sub	r8,-2
80009d68:	8f c8       	st.w	r7[0x30],r8
    main->context_state = CTX_POSTPONED_ROW;
80009d6a:	30 28       	mov	r8,2
80009d6c:	8f b8       	st.w	r7[0x2c],r8
  }
}
80009d6e:	2f bd       	sub	sp,-20
80009d70:	d8 32       	popm	r0-r7,pc

80009d72 <process_data_crank_post>:

METHODDEF(void)
process_data_crank_post (j_decompress_ptr cinfo,
			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
			 JDIMENSION out_rows_avail)
{
80009d72:	eb cd 40 80 	pushm	r7,lr
  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
80009d76:	f8 f8 01 b0 	ld.w	r8,r12[432]
80009d7a:	1a d9       	st.w	--sp,r9
80009d7c:	1a da       	st.w	--sp,r10
80009d7e:	70 17       	ld.w	r7,r8[0x4]
80009d80:	16 98       	mov	r8,r11
80009d82:	30 09       	mov	r9,0
80009d84:	12 9a       	mov	r10,r9
80009d86:	12 9b       	mov	r11,r9
80009d88:	5d 17       	icall	r7
80009d8a:	2f ed       	sub	sp,-8
				     (JDIMENSION *) NULL, (JDIMENSION) 0,
				     output_buf, out_row_ctr, out_rows_avail);
}
80009d8c:	e3 cd 80 80 	ldm	sp++,r7,pc

80009d90 <jinit_d_main_controller>:
 * Initialize main buffer controller.
 */

GLOBAL(void)
jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
80009d90:	d4 31       	pushm	r0-r7,lr
80009d92:	20 2d       	sub	sp,8
80009d94:	18 97       	mov	r7,r12
80009d96:	16 96       	mov	r6,r11
  my_main_ptr main;
  int ci, rgroup, ngroups;
  jpeg_component_info *compptr;

  main = (my_main_ptr)
80009d98:	18 92       	mov	r2,r12
80009d9a:	78 18       	ld.w	r8,r12[0x4]
80009d9c:	70 08       	ld.w	r8,r8[0x0]
80009d9e:	33 8a       	mov	r10,56
80009da0:	30 1b       	mov	r11,1
80009da2:	5d 18       	icall	r8
80009da4:	50 0c       	stdsp	sp[0x0],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_main_controller));
  cinfo->main = (struct jpeg_d_main_controller *) main;
80009da6:	ef 4c 01 a8 	st.w	r7[424],r12
  main->pub.start_pass = start_pass_main;
80009daa:	4c 48       	lddpc	r8,80009eb8 <jinit_d_main_controller+0x128>
80009dac:	40 0a       	lddsp	r10,sp[0x0]
80009dae:	95 08       	st.w	r10[0x0],r8

  if (need_full_buffer)		/* shouldn't happen */
80009db0:	58 06       	cp.w	r6,0
80009db2:	c0 80       	breq	80009dc2 <jinit_d_main_controller+0x32>
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
80009db4:	6e 08       	ld.w	r8,r7[0x0]
80009db6:	30 49       	mov	r9,4
80009db8:	91 59       	st.w	r8[0x14],r9
80009dba:	6e 08       	ld.w	r8,r7[0x0]
80009dbc:	70 08       	ld.w	r8,r8[0x0]
80009dbe:	0e 9c       	mov	r12,r7
80009dc0:	5d 18       	icall	r8

  /* Allocate the workspace.
   * ngroups is the number of row groups we need.
   */
  if (cinfo->upsample->need_context_rows) {
80009dc2:	ee f8 01 c4 	ld.w	r8,r7[452]
80009dc6:	70 28       	ld.w	r8,r8[0x8]
80009dc8:	58 08       	cp.w	r8,0
80009dca:	c4 e0       	breq	80009e66 <jinit_d_main_controller+0xd6>
    if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
80009dcc:	ee f8 01 3c 	ld.w	r8,r7[316]
80009dd0:	58 18       	cp.w	r8,1
80009dd2:	e0 89 00 09 	brgt	80009de4 <jinit_d_main_controller+0x54>
      ERREXIT(cinfo, JERR_NOTIMPL);
80009dd6:	6e 08       	ld.w	r8,r7[0x0]
80009dd8:	32 f9       	mov	r9,47
80009dda:	91 59       	st.w	r8[0x14],r9
80009ddc:	6e 08       	ld.w	r8,r7[0x0]
80009dde:	70 08       	ld.w	r8,r8[0x0]
80009de0:	04 9c       	mov	r12,r2
80009de2:	5d 18       	icall	r8
alloc_funny_pointers (j_decompress_ptr cinfo)
/* Allocate space for the funny pointer lists.
 * This is done only once, not once per pass.
 */
{
  my_main_ptr main = (my_main_ptr) cinfo->main;
80009de4:	ee f5 01 a8 	ld.w	r5,r7[424]
  int ci, rgroup;
  int M = cinfo->min_DCT_scaled_size;
80009de8:	ee f0 01 3c 	ld.w	r0,r7[316]
  JSAMPARRAY xbuf;

  /* Get top-level space for component array pointers.
   * We alloc both arrays with one call to save a few cycles.
   */
  main->xbuffer[0] = (JSAMPIMAGE)
80009dec:	6e 18       	ld.w	r8,r7[0x4]
80009dee:	6e 9a       	ld.w	r10,r7[0x24]
80009df0:	70 08       	ld.w	r8,r8[0x0]
80009df2:	a3 7a       	lsl	r10,0x3
80009df4:	30 1b       	mov	r11,1
80009df6:	04 9c       	mov	r12,r2
80009df8:	5d 18       	icall	r8
80009dfa:	8b 8c       	st.w	r5[0x20],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
80009dfc:	6e 98       	ld.w	r8,r7[0x24]
80009dfe:	f8 08 00 2c 	add	r12,r12,r8<<0x2
80009e02:	8b 9c       	st.w	r5[0x24],r12

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009e04:	ee f6 00 d8 	ld.w	r6,r7[216]
80009e08:	6e 98       	ld.w	r8,r7[0x24]
80009e0a:	58 08       	cp.w	r8,0
80009e0c:	e0 8a 00 29 	brle	80009e5e <jinit_d_main_controller+0xce>
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    /* Get space for pointer lists --- M+4 row groups in each list.
     * We alloc both pointer lists with one call to save a few cycles.
     */
    xbuf = (JSAMPARRAY)
80009e10:	2f c0       	sub	r0,-4
80009e12:	e0 01 15 03 	lsl	r1,r0,0x3
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
    xbuf += rgroup;		/* want one row group at negative offsets */
    main->xbuffer[0][ci] = xbuf;
    xbuf += rgroup * (M + 4);
80009e16:	a3 60       	lsl	r0,0x2
80009e18:	2f 46       	sub	r6,-12
80009e1a:	30 04       	mov	r4,0
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
80009e1c:	6c 69       	ld.w	r9,r6[0x18]
80009e1e:	6c 08       	ld.w	r8,r6[0x0]
80009e20:	b1 39       	mul	r9,r8
80009e22:	ee f8 01 3c 	ld.w	r8,r7[316]
80009e26:	f2 08 0c 08 	divs	r8,r9,r8
80009e2a:	10 93       	mov	r3,r8
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    /* Get space for pointer lists --- M+4 row groups in each list.
     * We alloc both pointer lists with one call to save a few cycles.
     */
    xbuf = (JSAMPARRAY)
80009e2c:	6e 18       	ld.w	r8,r7[0x4]
80009e2e:	70 08       	ld.w	r8,r8[0x0]
80009e30:	e2 03 02 4a 	mul	r10,r1,r3
80009e34:	30 1b       	mov	r11,1
80009e36:	04 9c       	mov	r12,r2
80009e38:	5d 18       	icall	r8
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
    xbuf += rgroup;		/* want one row group at negative offsets */
80009e3a:	f8 03 00 2c 	add	r12,r12,r3<<0x2
80009e3e:	e8 08 15 02 	lsl	r8,r4,0x2
    main->xbuffer[0][ci] = xbuf;
80009e42:	6a 89       	ld.w	r9,r5[0x20]
80009e44:	f2 08 09 0c 	st.w	r9[r8],r12
    xbuf += rgroup * (M + 4);
    main->xbuffer[1][ci] = xbuf;
80009e48:	6a 99       	ld.w	r9,r5[0x24]
80009e4a:	e0 03 02 43 	mul	r3,r0,r3
80009e4e:	06 0c       	add	r12,r3
80009e50:	f2 08 09 0c 	st.w	r9[r8],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80009e54:	2f f4       	sub	r4,-1
80009e56:	2a c6       	sub	r6,-84
  main->xbuffer[0] = (JSAMPIMAGE)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009e58:	6e 98       	ld.w	r8,r7[0x24]
80009e5a:	10 34       	cp.w	r4,r8
80009e5c:	ce 05       	brlt	80009e1c <jinit_d_main_controller+0x8c>
   */
  if (cinfo->upsample->need_context_rows) {
    if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
      ERREXIT(cinfo, JERR_NOTIMPL);
    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
    ngroups = cinfo->min_DCT_scaled_size + 2;
80009e5e:	ee f3 01 3c 	ld.w	r3,r7[316]
80009e62:	2f e3       	sub	r3,-2
80009e64:	c0 38       	rjmp	80009e6a <jinit_d_main_controller+0xda>
  } else {
    ngroups = cinfo->min_DCT_scaled_size;
80009e66:	ee f3 01 3c 	ld.w	r3,r7[316]
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009e6a:	ee f6 00 d8 	ld.w	r6,r7[216]
80009e6e:	6e 98       	ld.w	r8,r7[0x24]
80009e70:	58 08       	cp.w	r8,0
80009e72:	e0 8a 00 21 	brle	80009eb4 <jinit_d_main_controller+0x124>
80009e76:	2f 46       	sub	r6,-12
80009e78:	40 04       	lddsp	r4,sp[0x0]
80009e7a:	2f 84       	sub	r4,-8
80009e7c:	30 05       	mov	r5,0
       ci++, compptr++) {
    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
80009e7e:	6c 6b       	ld.w	r11,r6[0x18]
      cinfo->min_DCT_scaled_size; /* height of a row group of component */
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
80009e80:	6e 18       	ld.w	r8,r7[0x4]
80009e82:	6c 09       	ld.w	r9,r6[0x0]
80009e84:	f6 09 02 49 	mul	r9,r11,r9
80009e88:	ee fa 01 3c 	ld.w	r10,r7[316]
80009e8c:	f2 0a 0c 00 	divs	r0,r9,r10
80009e90:	fa e1 00 00 	st.d	sp[0],r0
80009e94:	6c 4c       	ld.w	r12,r6[0x10]
80009e96:	70 28       	ld.w	r8,r8[0x8]
80009e98:	e6 00 02 49 	mul	r9,r3,r0
80009e9c:	f6 0c 02 4a 	mul	r10,r11,r12
80009ea0:	30 1b       	mov	r11,1
80009ea2:	04 9c       	mov	r12,r2
80009ea4:	5d 18       	icall	r8
80009ea6:	08 ac       	st.w	r4++,r12
  } else {
    ngroups = cinfo->min_DCT_scaled_size;
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
80009ea8:	2f f5       	sub	r5,-1
80009eaa:	2a c6       	sub	r6,-84
    ngroups = cinfo->min_DCT_scaled_size + 2;
  } else {
    ngroups = cinfo->min_DCT_scaled_size;
  }

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
80009eac:	6e 98       	ld.w	r8,r7[0x24]
80009eae:	0a 38       	cp.w	r8,r5
80009eb0:	fe 99 ff e7 	brgt	80009e7e <jinit_d_main_controller+0xee>
    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 compptr->width_in_blocks * compptr->DCT_scaled_size,
			 (JDIMENSION) (rgroup * ngroups));
  }
}
80009eb4:	2f ed       	sub	sp,-8
80009eb6:	d8 32       	popm	r0-r7,pc
80009eb8:	80 00       	ld.sh	r0,r0[0x0]
80009eba:	99 dc       	st.w	r12[0x34],r12

80009ebc <get_sof>:


LOCAL(boolean)
get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
/* Process a SOFn marker */
{
80009ebc:	d4 31       	pushm	r0-r7,lr
80009ebe:	18 96       	mov	r6,r12
  INT32 length;
  int c, ci;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
80009ec0:	78 65       	ld.w	r5,r12[0x18]
80009ec2:	6a 09       	ld.w	r9,r5[0x0]
80009ec4:	6a 18       	ld.w	r8,r5[0x4]

  cinfo->progressive_mode = is_prog;
80009ec6:	f9 4b 00 dc 	st.w	r12[220],r11
  cinfo->arith_code = is_arith;
80009eca:	f9 4a 00 e0 	st.w	r12[224],r10

  INPUT_2BYTES(cinfo, length, return FALSE);
80009ece:	58 08       	cp.w	r8,0
80009ed0:	c0 71       	brne	80009ede <get_sof+0x22>
80009ed2:	6a 38       	ld.w	r8,r5[0xc]
80009ed4:	5d 18       	icall	r8
80009ed6:	e0 80 01 11 	breq	8000a0f8 <get_sof+0x23c>
80009eda:	6a 09       	ld.w	r9,r5[0x0]
80009edc:	6a 18       	ld.w	r8,r5[0x4]
80009ede:	20 18       	sub	r8,1
80009ee0:	13 87       	ld.ub	r7,r9[0x0]
80009ee2:	c0 30       	breq	80009ee8 <get_sof+0x2c>
80009ee4:	2f f9       	sub	r9,-1
80009ee6:	c0 88       	rjmp	80009ef6 <get_sof+0x3a>
80009ee8:	6a 38       	ld.w	r8,r5[0xc]
80009eea:	0c 9c       	mov	r12,r6
80009eec:	5d 18       	icall	r8
80009eee:	e0 80 01 05 	breq	8000a0f8 <get_sof+0x23c>
80009ef2:	6a 09       	ld.w	r9,r5[0x0]
80009ef4:	6a 18       	ld.w	r8,r5[0x4]
80009ef6:	20 18       	sub	r8,1
80009ef8:	13 83       	ld.ub	r3,r9[0x0]

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
80009efa:	c0 30       	breq	80009f00 <get_sof+0x44>
  INPUT_VARS(cinfo);

  cinfo->progressive_mode = is_prog;
  cinfo->arith_code = is_arith;

  INPUT_2BYTES(cinfo, length, return FALSE);
80009efc:	2f f9       	sub	r9,-1
80009efe:	c0 88       	rjmp	80009f0e <get_sof+0x52>

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
80009f00:	6a 38       	ld.w	r8,r5[0xc]
80009f02:	0c 9c       	mov	r12,r6
80009f04:	5d 18       	icall	r8
80009f06:	e0 80 00 f9 	breq	8000a0f8 <get_sof+0x23c>
80009f0a:	6a 09       	ld.w	r9,r5[0x0]
80009f0c:	6a 18       	ld.w	r8,r5[0x4]
80009f0e:	20 18       	sub	r8,1
80009f10:	13 8a       	ld.ub	r10,r9[0x0]
80009f12:	ed 4a 00 d4 	st.w	r6[212],r10
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
80009f16:	c0 30       	breq	80009f1c <get_sof+0x60>
  cinfo->progressive_mode = is_prog;
  cinfo->arith_code = is_arith;

  INPUT_2BYTES(cinfo, length, return FALSE);

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
80009f18:	2f f9       	sub	r9,-1
80009f1a:	c0 88       	rjmp	80009f2a <get_sof+0x6e>
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
80009f1c:	6a 38       	ld.w	r8,r5[0xc]
80009f1e:	0c 9c       	mov	r12,r6
80009f20:	5d 18       	icall	r8
80009f22:	e0 80 00 eb 	breq	8000a0f8 <get_sof+0x23c>
80009f26:	6a 09       	ld.w	r9,r5[0x0]
80009f28:	6a 18       	ld.w	r8,r5[0x4]
80009f2a:	20 18       	sub	r8,1
80009f2c:	13 8a       	ld.ub	r10,r9[0x0]
80009f2e:	a9 6a       	lsl	r10,0x8
80009f30:	8d 8a       	st.w	r6[0x20],r10
80009f32:	58 08       	cp.w	r8,0
80009f34:	c0 30       	breq	80009f3a <get_sof+0x7e>
80009f36:	2f f9       	sub	r9,-1
80009f38:	c0 88       	rjmp	80009f48 <get_sof+0x8c>
80009f3a:	6a 38       	ld.w	r8,r5[0xc]
80009f3c:	0c 9c       	mov	r12,r6
80009f3e:	5d 18       	icall	r8
80009f40:	e0 80 00 dc 	breq	8000a0f8 <get_sof+0x23c>
80009f44:	6a 09       	ld.w	r9,r5[0x0]
80009f46:	6a 18       	ld.w	r8,r5[0x4]
80009f48:	20 18       	sub	r8,1
80009f4a:	13 8a       	ld.ub	r10,r9[0x0]
80009f4c:	6c 8b       	ld.w	r11,r6[0x20]
80009f4e:	f6 0a 00 0a 	add	r10,r11,r10
80009f52:	8d 8a       	st.w	r6[0x20],r10
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
80009f54:	58 08       	cp.w	r8,0
80009f56:	c0 30       	breq	80009f5c <get_sof+0xa0>
  cinfo->arith_code = is_arith;

  INPUT_2BYTES(cinfo, length, return FALSE);

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
80009f58:	2f f9       	sub	r9,-1
80009f5a:	c0 88       	rjmp	80009f6a <get_sof+0xae>
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
80009f5c:	6a 38       	ld.w	r8,r5[0xc]
80009f5e:	0c 9c       	mov	r12,r6
80009f60:	5d 18       	icall	r8
80009f62:	e0 80 00 cb 	breq	8000a0f8 <get_sof+0x23c>
80009f66:	6a 09       	ld.w	r9,r5[0x0]
80009f68:	6a 18       	ld.w	r8,r5[0x4]
80009f6a:	20 18       	sub	r8,1
80009f6c:	13 8a       	ld.ub	r10,r9[0x0]
80009f6e:	a9 6a       	lsl	r10,0x8
80009f70:	8d 7a       	st.w	r6[0x1c],r10
80009f72:	58 08       	cp.w	r8,0
80009f74:	c0 30       	breq	80009f7a <get_sof+0xbe>
80009f76:	2f f9       	sub	r9,-1
80009f78:	c0 88       	rjmp	80009f88 <get_sof+0xcc>
80009f7a:	6a 38       	ld.w	r8,r5[0xc]
80009f7c:	0c 9c       	mov	r12,r6
80009f7e:	5d 18       	icall	r8
80009f80:	e0 80 00 bc 	breq	8000a0f8 <get_sof+0x23c>
80009f84:	6a 09       	ld.w	r9,r5[0x0]
80009f86:	6a 18       	ld.w	r8,r5[0x4]
80009f88:	20 18       	sub	r8,1
80009f8a:	13 8a       	ld.ub	r10,r9[0x0]
80009f8c:	6c 7b       	ld.w	r11,r6[0x1c]
80009f8e:	f6 0a 00 0a 	add	r10,r11,r10
80009f92:	8d 7a       	st.w	r6[0x1c],r10
  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
80009f94:	58 08       	cp.w	r8,0
80009f96:	c0 40       	breq	80009f9e <get_sof+0xe2>

  INPUT_2BYTES(cinfo, length, return FALSE);

  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
80009f98:	f2 c4 ff ff 	sub	r4,r9,-1
80009f9c:	c0 88       	rjmp	80009fac <get_sof+0xf0>
  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
80009f9e:	6a 38       	ld.w	r8,r5[0xc]
80009fa0:	0c 9c       	mov	r12,r6
80009fa2:	5d 18       	icall	r8
80009fa4:	e0 80 00 aa 	breq	8000a0f8 <get_sof+0x23c>
80009fa8:	6a 04       	ld.w	r4,r5[0x0]
80009faa:	6a 18       	ld.w	r8,r5[0x4]
80009fac:	f0 c2 00 01 	sub	r2,r8,1
80009fb0:	09 38       	ld.ub	r8,r4++
80009fb2:	8d 98       	st.w	r6[0x24],r8

  length -= 8;

  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
80009fb4:	6c 09       	ld.w	r9,r6[0x0]
80009fb6:	f2 c8 ff e8 	sub	r8,r9,-24
80009fba:	ec fa 01 a0 	ld.w	r10,r6[416]
80009fbe:	93 6a       	st.w	r9[0x18],r10
80009fc0:	6c 79       	ld.w	r9,r6[0x1c]
80009fc2:	91 19       	st.w	r8[0x4],r9
80009fc4:	6c 89       	ld.w	r9,r6[0x20]
80009fc6:	91 29       	st.w	r8[0x8],r9
80009fc8:	6c 99       	ld.w	r9,r6[0x24]
80009fca:	91 39       	st.w	r8[0xc],r9
80009fcc:	6c 08       	ld.w	r8,r6[0x0]
80009fce:	36 49       	mov	r9,100
80009fd0:	91 59       	st.w	r8[0x14],r9
80009fd2:	0c 91       	mov	r1,r6
80009fd4:	6c 08       	ld.w	r8,r6[0x0]
80009fd6:	70 18       	ld.w	r8,r8[0x4]
80009fd8:	30 1b       	mov	r11,1
80009fda:	0c 9c       	mov	r12,r6
80009fdc:	5d 18       	icall	r8
	   (int) cinfo->image_width, (int) cinfo->image_height,
	   cinfo->num_components);

  if (cinfo->marker->saw_SOF)
80009fde:	ec f8 01 b8 	ld.w	r8,r6[440]
80009fe2:	70 48       	ld.w	r8,r8[0x10]
80009fe4:	58 08       	cp.w	r8,0
80009fe6:	c0 80       	breq	80009ff6 <get_sof+0x13a>
    ERREXIT(cinfo, JERR_SOF_DUPLICATE);
80009fe8:	6c 08       	ld.w	r8,r6[0x0]
80009fea:	33 a9       	mov	r9,58
80009fec:	91 59       	st.w	r8[0x14],r9
80009fee:	6c 08       	ld.w	r8,r6[0x0]
80009ff0:	70 08       	ld.w	r8,r8[0x0]
80009ff2:	0c 9c       	mov	r12,r6
80009ff4:	5d 18       	icall	r8

  /* We don't support files in which the image height is initially specified */
  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
80009ff6:	6c 88       	ld.w	r8,r6[0x20]
80009ff8:	58 08       	cp.w	r8,0
80009ffa:	c0 80       	breq	8000a00a <get_sof+0x14e>
80009ffc:	6c 78       	ld.w	r8,r6[0x1c]
80009ffe:	58 08       	cp.w	r8,0
8000a000:	c0 50       	breq	8000a00a <get_sof+0x14e>
      || cinfo->num_components <= 0)
8000a002:	6c 98       	ld.w	r8,r6[0x24]
8000a004:	58 08       	cp.w	r8,0
8000a006:	e0 89 00 09 	brgt	8000a018 <get_sof+0x15c>
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);
8000a00a:	6c 08       	ld.w	r8,r6[0x0]
8000a00c:	32 09       	mov	r9,32
8000a00e:	91 59       	st.w	r8[0x14],r9
8000a010:	6c 08       	ld.w	r8,r6[0x0]
8000a012:	70 08       	ld.w	r8,r8[0x0]
8000a014:	02 9c       	mov	r12,r1
8000a016:	5d 18       	icall	r8
  INPUT_VARS(cinfo);

  cinfo->progressive_mode = is_prog;
  cinfo->arith_code = is_arith;

  INPUT_2BYTES(cinfo, length, return FALSE);
8000a018:	a9 67       	lsl	r7,0x8
8000a01a:	20 87       	sub	r7,8
  /* might as well have a general sanity check. */
  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
      || cinfo->num_components <= 0)
    ERREXIT(cinfo, JERR_EMPTY_IMAGE);

  if (length != (cinfo->num_components * 3))
8000a01c:	6c 98       	ld.w	r8,r6[0x24]
8000a01e:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000a022:	ee 03 00 03 	add	r3,r7,r3
8000a026:	06 38       	cp.w	r8,r3
8000a028:	c0 80       	breq	8000a038 <get_sof+0x17c>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
8000a02a:	6c 08       	ld.w	r8,r6[0x0]
8000a02c:	30 b9       	mov	r9,11
8000a02e:	91 59       	st.w	r8[0x14],r9
8000a030:	6c 08       	ld.w	r8,r6[0x0]
8000a032:	70 08       	ld.w	r8,r8[0x0]
8000a034:	02 9c       	mov	r12,r1
8000a036:	5d 18       	icall	r8

  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
8000a038:	ec f8 00 d8 	ld.w	r8,r6[216]
8000a03c:	58 08       	cp.w	r8,0
8000a03e:	c0 b1       	brne	8000a054 <get_sof+0x198>
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
8000a040:	6c 18       	ld.w	r8,r6[0x4]
8000a042:	6c 9a       	ld.w	r10,r6[0x24]
8000a044:	70 08       	ld.w	r8,r8[0x0]
8000a046:	f4 0a 10 54 	mul	r10,r10,84
8000a04a:	30 1b       	mov	r11,1
8000a04c:	02 9c       	mov	r12,r1
8000a04e:	5d 18       	icall	r8
8000a050:	ed 4c 00 d8 	st.w	r6[216],r12
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000a054:	ec f7 00 d8 	ld.w	r7,r6[216]
8000a058:	6c 98       	ld.w	r8,r6[0x24]
8000a05a:	58 08       	cp.w	r8,0
8000a05c:	e0 8a 00 47 	brle	8000a0ea <get_sof+0x22e>
8000a060:	30 03       	mov	r3,0
    INPUT_BYTE(cinfo, c, return FALSE);
    compptr->h_samp_factor = (c >> 4) & 15;
    compptr->v_samp_factor = (c     ) & 15;
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);

    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
8000a062:	36 50       	mov	r0,101
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->component_index = ci;
8000a064:	8f 13       	st.w	r7[0x4],r3
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
8000a066:	58 02       	cp.w	r2,0
8000a068:	c0 71       	brne	8000a076 <get_sof+0x1ba>
8000a06a:	6a 38       	ld.w	r8,r5[0xc]
8000a06c:	0c 9c       	mov	r12,r6
8000a06e:	5d 18       	icall	r8
8000a070:	c4 40       	breq	8000a0f8 <get_sof+0x23c>
8000a072:	6a 04       	ld.w	r4,r5[0x0]
8000a074:	6a 12       	ld.w	r2,r5[0x4]
8000a076:	20 12       	sub	r2,1
8000a078:	09 88       	ld.ub	r8,r4[0x0]
8000a07a:	8f 08       	st.w	r7[0x0],r8
    INPUT_BYTE(cinfo, c, return FALSE);
8000a07c:	c0 30       	breq	8000a082 <get_sof+0x1c6>
			 cinfo->num_components * SIZEOF(jpeg_component_info));

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->component_index = ci;
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
8000a07e:	2f f4       	sub	r4,-1
8000a080:	c0 78       	rjmp	8000a08e <get_sof+0x1d2>
    INPUT_BYTE(cinfo, c, return FALSE);
8000a082:	6a 38       	ld.w	r8,r5[0xc]
8000a084:	0c 9c       	mov	r12,r6
8000a086:	5d 18       	icall	r8
8000a088:	c3 80       	breq	8000a0f8 <get_sof+0x23c>
8000a08a:	6a 04       	ld.w	r4,r5[0x0]
8000a08c:	6a 12       	ld.w	r2,r5[0x4]
8000a08e:	20 12       	sub	r2,1
8000a090:	09 88       	ld.ub	r8,r4[0x0]
    compptr->h_samp_factor = (c >> 4) & 15;
8000a092:	f0 09 16 04 	lsr	r9,r8,0x4
8000a096:	8f 29       	st.w	r7[0x8],r9
    compptr->v_samp_factor = (c     ) & 15;
8000a098:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a09c:	8f 38       	st.w	r7[0xc],r8
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
8000a09e:	58 02       	cp.w	r2,0
8000a0a0:	c0 30       	breq	8000a0a6 <get_sof+0x1ea>

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    compptr->component_index = ci;
    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
    INPUT_BYTE(cinfo, c, return FALSE);
8000a0a2:	2f f4       	sub	r4,-1
8000a0a4:	c0 78       	rjmp	8000a0b2 <get_sof+0x1f6>
    compptr->h_samp_factor = (c >> 4) & 15;
    compptr->v_samp_factor = (c     ) & 15;
    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
8000a0a6:	6a 38       	ld.w	r8,r5[0xc]
8000a0a8:	0c 9c       	mov	r12,r6
8000a0aa:	5d 18       	icall	r8
8000a0ac:	c2 60       	breq	8000a0f8 <get_sof+0x23c>
8000a0ae:	6a 04       	ld.w	r4,r5[0x0]
8000a0b0:	6a 12       	ld.w	r2,r5[0x4]
8000a0b2:	20 12       	sub	r2,1
8000a0b4:	09 38       	ld.ub	r8,r4++
8000a0b6:	8f 48       	st.w	r7[0x10],r8

    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
8000a0b8:	6c 09       	ld.w	r9,r6[0x0]
8000a0ba:	f2 c8 ff e8 	sub	r8,r9,-24
8000a0be:	6e 0a       	ld.w	r10,r7[0x0]
8000a0c0:	93 6a       	st.w	r9[0x18],r10
8000a0c2:	6e 29       	ld.w	r9,r7[0x8]
8000a0c4:	91 19       	st.w	r8[0x4],r9
8000a0c6:	6e 39       	ld.w	r9,r7[0xc]
8000a0c8:	91 29       	st.w	r8[0x8],r9
8000a0ca:	6e 49       	ld.w	r9,r7[0x10]
8000a0cc:	91 39       	st.w	r8[0xc],r9
8000a0ce:	6c 08       	ld.w	r8,r6[0x0]
8000a0d0:	91 50       	st.w	r8[0x14],r0
8000a0d2:	6c 08       	ld.w	r8,r6[0x0]
8000a0d4:	70 18       	ld.w	r8,r8[0x4]
8000a0d6:	30 1b       	mov	r11,1
8000a0d8:	02 9c       	mov	r12,r1
8000a0da:	5d 18       	icall	r8
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
8000a0dc:	2f f3       	sub	r3,-1
  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
			((j_common_ptr) cinfo, JPOOL_IMAGE,
			 cinfo->num_components * SIZEOF(jpeg_component_info));

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000a0de:	6c 98       	ld.w	r8,r6[0x24]
8000a0e0:	06 38       	cp.w	r8,r3
8000a0e2:	e0 8a 00 04 	brle	8000a0ea <get_sof+0x22e>
       ci++, compptr++) {
8000a0e6:	2a c7       	sub	r7,-84
8000a0e8:	cb eb       	rjmp	8000a064 <get_sof+0x1a8>
    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,
	     compptr->component_id, compptr->h_samp_factor,
	     compptr->v_samp_factor, compptr->quant_tbl_no);
  }

  cinfo->marker->saw_SOF = TRUE;
8000a0ea:	ec f8 01 b8 	ld.w	r8,r6[440]
8000a0ee:	30 1c       	mov	r12,1
8000a0f0:	91 4c       	st.w	r8[0x10],r12

  INPUT_SYNC(cinfo);
8000a0f2:	8b 04       	st.w	r5[0x0],r4
8000a0f4:	8b 12       	st.w	r5[0x4],r2
  return TRUE;
8000a0f6:	d8 32       	popm	r0-r7,pc
8000a0f8:	d8 3a       	popm	r0-r7,pc,r12=0

8000a0fa <examine_app0>:
	      unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP0.
 * Take appropriate action if it is a JFIF marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
8000a0fa:	eb cd 40 f8 	pushm	r3-r7,lr
8000a0fe:	18 97       	mov	r7,r12
8000a100:	16 96       	mov	r6,r11
  INT32 totallen = (INT32) datalen + remaining;
8000a102:	f2 0a 00 05 	add	r5,r9,r10

  if (datalen >= APP0_DATA_LEN &&
8000a106:	58 da       	cp.w	r10,13
8000a108:	e0 88 00 96 	brls	8000a234 <examine_app0+0x13a>
      GETJOCTET(data[0]) == 0x4A &&
8000a10c:	17 89       	ld.ub	r9,r11[0x0]
8000a10e:	34 a8       	mov	r8,74
8000a110:	f0 09 18 00 	cp.b	r9,r8
8000a114:	e0 81 00 90 	brne	8000a234 <examine_app0+0x13a>
      GETJOCTET(data[1]) == 0x46 &&
8000a118:	17 99       	ld.ub	r9,r11[0x1]
8000a11a:	34 68       	mov	r8,70
8000a11c:	f0 09 18 00 	cp.b	r9,r8
8000a120:	e0 81 00 8a 	brne	8000a234 <examine_app0+0x13a>
      GETJOCTET(data[2]) == 0x49 &&
8000a124:	17 a9       	ld.ub	r9,r11[0x2]
8000a126:	34 98       	mov	r8,73
8000a128:	f0 09 18 00 	cp.b	r9,r8
8000a12c:	e0 81 00 84 	brne	8000a234 <examine_app0+0x13a>
      GETJOCTET(data[3]) == 0x46 &&
8000a130:	17 b9       	ld.ub	r9,r11[0x3]
8000a132:	34 68       	mov	r8,70
8000a134:	f0 09 18 00 	cp.b	r9,r8
8000a138:	c7 e1       	brne	8000a234 <examine_app0+0x13a>
      GETJOCTET(data[4]) == 0) {
8000a13a:	17 c9       	ld.ub	r9,r11[0x4]
8000a13c:	30 08       	mov	r8,0
8000a13e:	f0 09 18 00 	cp.b	r9,r8
8000a142:	c7 91       	brne	8000a234 <examine_app0+0x13a>
    /* Found JFIF APP0 marker: save info */
    cinfo->saw_JFIF_marker = TRUE;
8000a144:	30 19       	mov	r9,1
8000a146:	f9 49 01 18 	st.w	r12[280],r9
    cinfo->JFIF_major_version = GETJOCTET(data[5]);
8000a14a:	17 d8       	ld.ub	r8,r11[0x5]
8000a14c:	f9 68 01 1c 	st.b	r12[284],r8
    cinfo->JFIF_minor_version = GETJOCTET(data[6]);
8000a150:	17 ea       	ld.ub	r10,r11[0x6]
8000a152:	f9 6a 01 1d 	st.b	r12[285],r10
    cinfo->density_unit = GETJOCTET(data[7]);
8000a156:	17 fa       	ld.ub	r10,r11[0x7]
8000a158:	f9 6a 01 1e 	st.b	r12[286],r10
    cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
8000a15c:	f7 3a 00 08 	ld.ub	r10,r11[8]
8000a160:	a9 6a       	lsl	r10,0x8
8000a162:	f7 3b 00 09 	ld.ub	r11,r11[9]
8000a166:	f6 0a 00 0a 	add	r10,r11,r10
8000a16a:	f9 5a 01 20 	st.h	r12[288],r10
    cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);
8000a16e:	ed 3a 00 0a 	ld.ub	r10,r6[10]
8000a172:	a9 6a       	lsl	r10,0x8
8000a174:	ed 3b 00 0b 	ld.ub	r11,r6[11]
8000a178:	f6 0a 00 0a 	add	r10,r11,r10
8000a17c:	f9 5a 01 22 	st.h	r12[290],r10
     * Major version must be 1, anything else signals an incompatible change.
     * (We used to treat this as an error, but now it's a nonfatal warning,
     * because some bozo at Hijaak couldn't read the spec.)
     * Minor version should be 0..2, but process anyway if newer.
     */
    if (cinfo->JFIF_major_version != 1)
8000a180:	f2 08 18 00 	cp.b	r8,r9
8000a184:	c1 00       	breq	8000a1a4 <examine_app0+0xaa>
      WARNMS2(cinfo, JWRN_JFIF_MAJOR,
8000a186:	78 08       	ld.w	r8,r12[0x0]
8000a188:	37 79       	mov	r9,119
8000a18a:	91 59       	st.w	r8[0x14],r9
8000a18c:	78 08       	ld.w	r8,r12[0x0]
8000a18e:	f9 39 01 1c 	ld.ub	r9,r12[284]
8000a192:	91 69       	st.w	r8[0x18],r9
8000a194:	78 08       	ld.w	r8,r12[0x0]
8000a196:	f9 39 01 1d 	ld.ub	r9,r12[285]
8000a19a:	91 79       	st.w	r8[0x1c],r9
8000a19c:	78 08       	ld.w	r8,r12[0x0]
8000a19e:	70 18       	ld.w	r8,r8[0x4]
8000a1a0:	3f fb       	mov	r11,-1
8000a1a2:	5d 18       	icall	r8
	      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);
    /* Generate trace messages */
    TRACEMS5(cinfo, 1, JTRC_JFIF,
8000a1a4:	6e 09       	ld.w	r9,r7[0x0]
8000a1a6:	f2 c8 ff e8 	sub	r8,r9,-24
8000a1aa:	ef 3a 01 1c 	ld.ub	r10,r7[284]
8000a1ae:	93 6a       	st.w	r9[0x18],r10
8000a1b0:	ef 39 01 1d 	ld.ub	r9,r7[285]
8000a1b4:	91 19       	st.w	r8[0x4],r9
8000a1b6:	ef 19 01 20 	ld.uh	r9,r7[288]
8000a1ba:	91 29       	st.w	r8[0x8],r9
8000a1bc:	ef 19 01 22 	ld.uh	r9,r7[290]
8000a1c0:	91 39       	st.w	r8[0xc],r9
8000a1c2:	ef 39 01 1e 	ld.ub	r9,r7[286]
8000a1c6:	91 49       	st.w	r8[0x10],r9
8000a1c8:	6e 08       	ld.w	r8,r7[0x0]
8000a1ca:	35 79       	mov	r9,87
8000a1cc:	91 59       	st.w	r8[0x14],r9
8000a1ce:	0e 93       	mov	r3,r7
8000a1d0:	6e 08       	ld.w	r8,r7[0x0]
8000a1d2:	70 18       	ld.w	r8,r8[0x4]
8000a1d4:	30 1b       	mov	r11,1
8000a1d6:	0e 9c       	mov	r12,r7
8000a1d8:	5d 18       	icall	r8
	     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,
	     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
    /* Validate thumbnail dimensions and issue appropriate messages */
    if (GETJOCTET(data[12]) | GETJOCTET(data[13]))
8000a1da:	ec c4 ff f4 	sub	r4,r6,-12
8000a1de:	2f 36       	sub	r6,-13
8000a1e0:	0d 89       	ld.ub	r9,r6[0x0]
8000a1e2:	09 88       	ld.ub	r8,r4[0x0]
8000a1e4:	10 49       	or	r9,r8
8000a1e6:	30 08       	mov	r8,0
8000a1e8:	f0 09 18 00 	cp.b	r9,r8
8000a1ec:	c0 f0       	breq	8000a20a <examine_app0+0x110>
      TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL,
8000a1ee:	6e 08       	ld.w	r8,r7[0x0]
8000a1f0:	35 a9       	mov	r9,90
8000a1f2:	91 59       	st.w	r8[0x14],r9
8000a1f4:	6e 08       	ld.w	r8,r7[0x0]
8000a1f6:	09 89       	ld.ub	r9,r4[0x0]
8000a1f8:	91 69       	st.w	r8[0x18],r9
8000a1fa:	6e 08       	ld.w	r8,r7[0x0]
8000a1fc:	0d 89       	ld.ub	r9,r6[0x0]
8000a1fe:	91 79       	st.w	r8[0x1c],r9
8000a200:	6e 08       	ld.w	r8,r7[0x0]
8000a202:	70 18       	ld.w	r8,r8[0x4]
8000a204:	30 1b       	mov	r11,1
8000a206:	0e 9c       	mov	r12,r7
8000a208:	5d 18       	icall	r8
	       GETJOCTET(data[12]), GETJOCTET(data[13]));
    totallen -= APP0_DATA_LEN;
8000a20a:	20 e5       	sub	r5,14
    if (totallen !=
	((INT32)GETJOCTET(data[12]) * (INT32)GETJOCTET(data[13]) * (INT32) 3))
8000a20c:	09 89       	ld.ub	r9,r4[0x0]
8000a20e:	0d 88       	ld.ub	r8,r6[0x0]
8000a210:	f2 08 02 48 	mul	r8,r9,r8
8000a214:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000a218:	0a 38       	cp.w	r8,r5
8000a21a:	c7 30       	breq	8000a300 <examine_app0+0x206>
      TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int) totallen);
8000a21c:	6e 08       	ld.w	r8,r7[0x0]
8000a21e:	35 89       	mov	r9,88
8000a220:	91 59       	st.w	r8[0x14],r9
8000a222:	6e 08       	ld.w	r8,r7[0x0]
8000a224:	91 65       	st.w	r8[0x18],r5
8000a226:	6e 08       	ld.w	r8,r7[0x0]
8000a228:	70 18       	ld.w	r8,r8[0x4]
8000a22a:	30 1b       	mov	r11,1
8000a22c:	06 9c       	mov	r12,r3
8000a22e:	5d 18       	icall	r8
8000a230:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
  } else if (datalen >= 6 &&
8000a234:	58 5a       	cp.w	r10,5
8000a236:	e0 88 00 5b 	brls	8000a2ec <examine_app0+0x1f2>
      GETJOCTET(data[0]) == 0x4A &&
8000a23a:	0d 89       	ld.ub	r9,r6[0x0]
8000a23c:	34 a8       	mov	r8,74
8000a23e:	f0 09 18 00 	cp.b	r9,r8
8000a242:	c5 51       	brne	8000a2ec <examine_app0+0x1f2>
      GETJOCTET(data[1]) == 0x46 &&
8000a244:	0d 99       	ld.ub	r9,r6[0x1]
8000a246:	34 68       	mov	r8,70
8000a248:	f0 09 18 00 	cp.b	r9,r8
8000a24c:	c5 01       	brne	8000a2ec <examine_app0+0x1f2>
      GETJOCTET(data[2]) == 0x58 &&
8000a24e:	0d a9       	ld.ub	r9,r6[0x2]
8000a250:	35 88       	mov	r8,88
8000a252:	f0 09 18 00 	cp.b	r9,r8
8000a256:	c4 b1       	brne	8000a2ec <examine_app0+0x1f2>
      GETJOCTET(data[3]) == 0x58 &&
8000a258:	0d b9       	ld.ub	r9,r6[0x3]
8000a25a:	f0 09 18 00 	cp.b	r9,r8
8000a25e:	c4 71       	brne	8000a2ec <examine_app0+0x1f2>
      GETJOCTET(data[4]) == 0) {
8000a260:	0d c9       	ld.ub	r9,r6[0x4]
8000a262:	30 08       	mov	r8,0
8000a264:	f0 09 18 00 	cp.b	r9,r8
8000a268:	c4 21       	brne	8000a2ec <examine_app0+0x1f2>
    /* Found JFIF "JFXX" extension APP0 marker */
    /* The library doesn't actually do anything with these,
     * but we try to produce a helpful trace message.
     */
    switch (GETJOCTET(data[5])) {
8000a26a:	2f b6       	sub	r6,-5
8000a26c:	0d 88       	ld.ub	r8,r6[0x0]
8000a26e:	31 19       	mov	r9,17
8000a270:	f2 08 18 00 	cp.b	r8,r9
8000a274:	c1 50       	breq	8000a29e <examine_app0+0x1a4>
8000a276:	31 39       	mov	r9,19
8000a278:	f2 08 18 00 	cp.b	r8,r9
8000a27c:	c1 d0       	breq	8000a2b6 <examine_app0+0x1bc>
8000a27e:	31 09       	mov	r9,16
8000a280:	f2 08 18 00 	cp.b	r8,r9
8000a284:	c2 51       	brne	8000a2ce <examine_app0+0x1d4>
    case 0x10:
      TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);
8000a286:	6e 08       	ld.w	r8,r7[0x0]
8000a288:	36 c9       	mov	r9,108
8000a28a:	91 59       	st.w	r8[0x14],r9
8000a28c:	6e 08       	ld.w	r8,r7[0x0]
8000a28e:	91 65       	st.w	r8[0x18],r5
8000a290:	6e 08       	ld.w	r8,r7[0x0]
8000a292:	70 18       	ld.w	r8,r8[0x4]
8000a294:	30 1b       	mov	r11,1
8000a296:	0e 9c       	mov	r12,r7
8000a298:	5d 18       	icall	r8
      break;
8000a29a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    case 0x11:
      TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);
8000a29e:	6e 08       	ld.w	r8,r7[0x0]
8000a2a0:	36 d9       	mov	r9,109
8000a2a2:	91 59       	st.w	r8[0x14],r9
8000a2a4:	6e 08       	ld.w	r8,r7[0x0]
8000a2a6:	91 65       	st.w	r8[0x18],r5
8000a2a8:	6e 08       	ld.w	r8,r7[0x0]
8000a2aa:	70 18       	ld.w	r8,r8[0x4]
8000a2ac:	30 1b       	mov	r11,1
8000a2ae:	0e 9c       	mov	r12,r7
8000a2b0:	5d 18       	icall	r8
      break;
8000a2b2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    case 0x13:
      TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
8000a2b6:	6e 08       	ld.w	r8,r7[0x0]
8000a2b8:	36 e9       	mov	r9,110
8000a2ba:	91 59       	st.w	r8[0x14],r9
8000a2bc:	6e 08       	ld.w	r8,r7[0x0]
8000a2be:	91 65       	st.w	r8[0x18],r5
8000a2c0:	6e 08       	ld.w	r8,r7[0x0]
8000a2c2:	70 18       	ld.w	r8,r8[0x4]
8000a2c4:	30 1b       	mov	r11,1
8000a2c6:	0e 9c       	mov	r12,r7
8000a2c8:	5d 18       	icall	r8
      break;
8000a2ca:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    default:
      TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
8000a2ce:	6e 08       	ld.w	r8,r7[0x0]
8000a2d0:	35 99       	mov	r9,89
8000a2d2:	91 59       	st.w	r8[0x14],r9
8000a2d4:	6e 08       	ld.w	r8,r7[0x0]
8000a2d6:	0d 89       	ld.ub	r9,r6[0x0]
8000a2d8:	91 69       	st.w	r8[0x18],r9
8000a2da:	6e 08       	ld.w	r8,r7[0x0]
8000a2dc:	91 75       	st.w	r8[0x1c],r5
8000a2de:	6e 08       	ld.w	r8,r7[0x0]
8000a2e0:	70 18       	ld.w	r8,r8[0x4]
8000a2e2:	30 1b       	mov	r11,1
8000a2e4:	0e 9c       	mov	r12,r7
8000a2e6:	5d 18       	icall	r8
8000a2e8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
	       GETJOCTET(data[5]), (int) totallen);
      break;
    }
  } else {
    /* Start of APP0 does not match "JFIF" or "JFXX", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
8000a2ec:	6e 08       	ld.w	r8,r7[0x0]
8000a2ee:	34 d9       	mov	r9,77
8000a2f0:	91 59       	st.w	r8[0x14],r9
8000a2f2:	6e 08       	ld.w	r8,r7[0x0]
8000a2f4:	91 65       	st.w	r8[0x18],r5
8000a2f6:	6e 08       	ld.w	r8,r7[0x0]
8000a2f8:	70 18       	ld.w	r8,r8[0x4]
8000a2fa:	30 1b       	mov	r11,1
8000a2fc:	0e 9c       	mov	r12,r7
8000a2fe:	5d 18       	icall	r8
8000a300:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8000a304 <examine_app14>:
	       unsigned int datalen, INT32 remaining)
/* Examine first few bytes from an APP14.
 * Take appropriate action if it is an Adobe marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
8000a304:	eb cd 40 c0 	pushm	r6-r7,lr
8000a308:	18 97       	mov	r7,r12
  unsigned int version, flags0, flags1, transform;

  if (datalen >= APP14_DATA_LEN &&
8000a30a:	58 ba       	cp.w	r10,11
8000a30c:	e0 88 00 43 	brls	8000a392 <examine_app14+0x8e>
      GETJOCTET(data[0]) == 0x41 &&
8000a310:	17 8c       	ld.ub	r12,r11[0x0]
8000a312:	34 18       	mov	r8,65
8000a314:	f0 0c 18 00 	cp.b	r12,r8
8000a318:	c3 d1       	brne	8000a392 <examine_app14+0x8e>
      GETJOCTET(data[1]) == 0x64 &&
8000a31a:	17 9c       	ld.ub	r12,r11[0x1]
8000a31c:	36 48       	mov	r8,100
8000a31e:	f0 0c 18 00 	cp.b	r12,r8
8000a322:	c3 81       	brne	8000a392 <examine_app14+0x8e>
      GETJOCTET(data[2]) == 0x6F &&
8000a324:	17 ac       	ld.ub	r12,r11[0x2]
8000a326:	36 f8       	mov	r8,111
8000a328:	f0 0c 18 00 	cp.b	r12,r8
8000a32c:	c3 31       	brne	8000a392 <examine_app14+0x8e>
      GETJOCTET(data[3]) == 0x62 &&
8000a32e:	17 bc       	ld.ub	r12,r11[0x3]
8000a330:	36 28       	mov	r8,98
8000a332:	f0 0c 18 00 	cp.b	r12,r8
8000a336:	c2 e1       	brne	8000a392 <examine_app14+0x8e>
      GETJOCTET(data[4]) == 0x65) {
8000a338:	17 cc       	ld.ub	r12,r11[0x4]
8000a33a:	36 58       	mov	r8,101
8000a33c:	f0 0c 18 00 	cp.b	r12,r8
8000a340:	c2 91       	brne	8000a392 <examine_app14+0x8e>
    /* Found Adobe APP14 marker */
    version = (GETJOCTET(data[5]) << 8) + GETJOCTET(data[6]);
    flags0 = (GETJOCTET(data[7]) << 8) + GETJOCTET(data[8]);
8000a342:	17 fc       	ld.ub	r12,r11[0x7]
8000a344:	a9 6c       	lsl	r12,0x8
8000a346:	f7 38 00 08 	ld.ub	r8,r11[8]
8000a34a:	10 0c       	add	r12,r8
    flags1 = (GETJOCTET(data[9]) << 8) + GETJOCTET(data[10]);
8000a34c:	f7 3a 00 09 	ld.ub	r10,r11[9]
8000a350:	a9 6a       	lsl	r10,0x8
8000a352:	f7 38 00 0a 	ld.ub	r8,r11[10]
8000a356:	10 0a       	add	r10,r8
    transform = GETJOCTET(data[11]);
8000a358:	f7 36 00 0b 	ld.ub	r6,r11[11]
    TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
8000a35c:	6e 09       	ld.w	r9,r7[0x0]
8000a35e:	f2 c8 ff e8 	sub	r8,r9,-24
8000a362:	17 de       	ld.ub	lr,r11[0x5]
8000a364:	a9 6e       	lsl	lr,0x8
8000a366:	17 eb       	ld.ub	r11,r11[0x6]
8000a368:	fc 0b 00 0b 	add	r11,lr,r11
8000a36c:	93 6b       	st.w	r9[0x18],r11
8000a36e:	91 1c       	st.w	r8[0x4],r12
8000a370:	91 2a       	st.w	r8[0x8],r10
8000a372:	91 36       	st.w	r8[0xc],r6
8000a374:	6e 08       	ld.w	r8,r7[0x0]
8000a376:	34 c9       	mov	r9,76
8000a378:	91 59       	st.w	r8[0x14],r9
8000a37a:	6e 08       	ld.w	r8,r7[0x0]
8000a37c:	70 18       	ld.w	r8,r8[0x4]
8000a37e:	30 1b       	mov	r11,1
8000a380:	0e 9c       	mov	r12,r7
8000a382:	5d 18       	icall	r8
    cinfo->saw_Adobe_marker = TRUE;
8000a384:	30 18       	mov	r8,1
8000a386:	ef 48 01 24 	st.w	r7[292],r8
    cinfo->Adobe_transform = (UINT8) transform;
8000a38a:	ef 66 01 28 	st.b	r7[296],r6
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
{
  unsigned int version, flags0, flags1, transform;

  if (datalen >= APP14_DATA_LEN &&
8000a38e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);
    cinfo->saw_Adobe_marker = TRUE;
    cinfo->Adobe_transform = (UINT8) transform;
  } else {
    /* Start of APP14 does not match "Adobe", or too short */
    TRACEMS1(cinfo, 1, JTRC_APP14, (int) (datalen + remaining));
8000a392:	6e 08       	ld.w	r8,r7[0x0]
8000a394:	34 eb       	mov	r11,78
8000a396:	91 5b       	st.w	r8[0x14],r11
8000a398:	6e 08       	ld.w	r8,r7[0x0]
8000a39a:	f2 0a 00 0a 	add	r10,r9,r10
8000a39e:	91 6a       	st.w	r8[0x18],r10
8000a3a0:	6e 08       	ld.w	r8,r7[0x0]
8000a3a2:	70 18       	ld.w	r8,r8[0x4]
8000a3a4:	30 1b       	mov	r11,1
8000a3a6:	0e 9c       	mov	r12,r7
8000a3a8:	5d 18       	icall	r8
8000a3aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a3ae:	d7 03       	nop

8000a3b0 <get_interesting_appn>:


METHODDEF(boolean)
get_interesting_appn (j_decompress_ptr cinfo)
/* Process an APP0 or APP14 marker without saving it */
{
8000a3b0:	d4 31       	pushm	r0-r7,lr
8000a3b2:	20 4d       	sub	sp,16
8000a3b4:	18 91       	mov	r1,r12
  INT32 length;
  JOCTET b[APPN_DATA_LEN];
  unsigned int i, numtoread;
  INPUT_VARS(cinfo);
8000a3b6:	78 64       	ld.w	r4,r12[0x18]
8000a3b8:	68 08       	ld.w	r8,r4[0x0]
8000a3ba:	68 16       	ld.w	r6,r4[0x4]

  INPUT_2BYTES(cinfo, length, return FALSE);
8000a3bc:	58 06       	cp.w	r6,0
8000a3be:	c0 61       	brne	8000a3ca <get_interesting_appn+0x1a>
8000a3c0:	68 38       	ld.w	r8,r4[0xc]
8000a3c2:	5d 18       	icall	r8
8000a3c4:	c6 60       	breq	8000a490 <get_interesting_appn+0xe0>
8000a3c6:	68 08       	ld.w	r8,r4[0x0]
8000a3c8:	68 16       	ld.w	r6,r4[0x4]
8000a3ca:	20 16       	sub	r6,1
8000a3cc:	11 87       	ld.ub	r7,r8[0x0]
8000a3ce:	c0 30       	breq	8000a3d4 <get_interesting_appn+0x24>
8000a3d0:	2f f8       	sub	r8,-1
8000a3d2:	c0 78       	rjmp	8000a3e0 <get_interesting_appn+0x30>
8000a3d4:	68 38       	ld.w	r8,r4[0xc]
8000a3d6:	02 9c       	mov	r12,r1
8000a3d8:	5d 18       	icall	r8
8000a3da:	c5 b0       	breq	8000a490 <get_interesting_appn+0xe0>
8000a3dc:	68 08       	ld.w	r8,r4[0x0]
8000a3de:	68 16       	ld.w	r6,r4[0x4]
8000a3e0:	20 16       	sub	r6,1
8000a3e2:	f0 c5 ff ff 	sub	r5,r8,-1
8000a3e6:	ee 00 15 08 	lsl	r0,r7,0x8
8000a3ea:	20 20       	sub	r0,2
  length -= 2;
8000a3ec:	11 88       	ld.ub	r8,r8[0x0]
8000a3ee:	10 00       	add	r0,r8

  /* get the interesting part of the marker data */
  if (length >= APPN_DATA_LEN)
8000a3f0:	58 d0       	cp.w	r0,13
8000a3f2:	e0 8a 00 06 	brle	8000a3fe <get_interesting_appn+0x4e>
8000a3f6:	30 e3       	mov	r3,14
8000a3f8:	30 07       	mov	r7,0
  else if (length > 0)
    numtoread = (unsigned int) length;
  else
    numtoread = 0;
  for (i = 0; i < numtoread; i++)
    INPUT_BYTE(cinfo, b[i], return FALSE);
8000a3fa:	1a 92       	mov	r2,sp
8000a3fc:	c0 a8       	rjmp	8000a410 <get_interesting_appn+0x60>
  length -= 2;

  /* get the interesting part of the marker data */
  if (length >= APPN_DATA_LEN)
    numtoread = APPN_DATA_LEN;
  else if (length > 0)
8000a3fe:	58 00       	cp.w	r0,0
8000a400:	e0 89 00 04 	brgt	8000a408 <get_interesting_appn+0x58>
8000a404:	30 03       	mov	r3,0
8000a406:	c1 48       	rjmp	8000a42e <get_interesting_appn+0x7e>
    numtoread = (unsigned int) length;
8000a408:	00 93       	mov	r3,r0
  else
    numtoread = 0;
  for (i = 0; i < numtoread; i++)
8000a40a:	58 00       	cp.w	r0,0
8000a40c:	cf 61       	brne	8000a3f8 <get_interesting_appn+0x48>
8000a40e:	c1 08       	rjmp	8000a42e <get_interesting_appn+0x7e>
    INPUT_BYTE(cinfo, b[i], return FALSE);
8000a410:	58 06       	cp.w	r6,0
8000a412:	c0 71       	brne	8000a420 <get_interesting_appn+0x70>
8000a414:	68 38       	ld.w	r8,r4[0xc]
8000a416:	02 9c       	mov	r12,r1
8000a418:	5d 18       	icall	r8
8000a41a:	c3 b0       	breq	8000a490 <get_interesting_appn+0xe0>
8000a41c:	68 05       	ld.w	r5,r4[0x0]
8000a41e:	68 16       	ld.w	r6,r4[0x4]
8000a420:	20 16       	sub	r6,1
8000a422:	0b 38       	ld.ub	r8,r5++
8000a424:	e4 07 0b 08 	st.b	r2[r7],r8
    numtoread = APPN_DATA_LEN;
  else if (length > 0)
    numtoread = (unsigned int) length;
  else
    numtoread = 0;
  for (i = 0; i < numtoread; i++)
8000a428:	2f f7       	sub	r7,-1
8000a42a:	06 37       	cp.w	r7,r3
8000a42c:	cf 23       	brcs	8000a410 <get_interesting_appn+0x60>
    INPUT_BYTE(cinfo, b[i], return FALSE);
  length -= numtoread;
8000a42e:	06 10       	sub	r0,r3

  /* process it */
  switch (cinfo->unread_marker) {
8000a430:	e2 f8 01 a0 	ld.w	r8,r1[416]
8000a434:	e0 48 00 e0 	cp.w	r8,224
8000a438:	c0 50       	breq	8000a442 <get_interesting_appn+0x92>
8000a43a:	e0 48 00 ee 	cp.w	r8,238
8000a43e:	c1 01       	brne	8000a45e <get_interesting_appn+0xae>
8000a440:	c0 88       	rjmp	8000a450 <get_interesting_appn+0xa0>
  case M_APP0:
    examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
8000a442:	00 99       	mov	r9,r0
8000a444:	06 9a       	mov	r10,r3
8000a446:	1a 9b       	mov	r11,sp
8000a448:	02 9c       	mov	r12,r1
8000a44a:	f0 1f 00 14 	mcall	8000a498 <get_interesting_appn+0xe8>
    break;
8000a44e:	c1 38       	rjmp	8000a474 <get_interesting_appn+0xc4>
  case M_APP14:
    examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
8000a450:	00 99       	mov	r9,r0
8000a452:	06 9a       	mov	r10,r3
8000a454:	1a 9b       	mov	r11,sp
8000a456:	02 9c       	mov	r12,r1
8000a458:	f0 1f 00 11 	mcall	8000a49c <get_interesting_appn+0xec>
    break;
8000a45c:	c0 c8       	rjmp	8000a474 <get_interesting_appn+0xc4>
  default:
    /* can't get here unless jpeg_save_markers chooses wrong processor */
    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
8000a45e:	62 08       	ld.w	r8,r1[0x0]
8000a460:	34 49       	mov	r9,68
8000a462:	91 59       	st.w	r8[0x14],r9
8000a464:	62 08       	ld.w	r8,r1[0x0]
8000a466:	e2 f9 01 a0 	ld.w	r9,r1[416]
8000a46a:	91 69       	st.w	r8[0x18],r9
8000a46c:	62 08       	ld.w	r8,r1[0x0]
8000a46e:	70 08       	ld.w	r8,r8[0x0]
8000a470:	02 9c       	mov	r12,r1
8000a472:	5d 18       	icall	r8
    break;
  }

  /* skip any remaining data -- could be lots */
  INPUT_SYNC(cinfo);
8000a474:	89 05       	st.w	r4[0x0],r5
8000a476:	89 16       	st.w	r4[0x4],r6
  if (length > 0)
8000a478:	58 00       	cp.w	r0,0
8000a47a:	e0 89 00 04 	brgt	8000a482 <get_interesting_appn+0xd2>
8000a47e:	30 1c       	mov	r12,1
8000a480:	c0 98       	rjmp	8000a492 <get_interesting_appn+0xe2>
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
8000a482:	62 68       	ld.w	r8,r1[0x18]
8000a484:	70 48       	ld.w	r8,r8[0x10]
8000a486:	00 9b       	mov	r11,r0
8000a488:	02 9c       	mov	r12,r1
8000a48a:	5d 18       	icall	r8
8000a48c:	30 1c       	mov	r12,1
8000a48e:	c0 28       	rjmp	8000a492 <get_interesting_appn+0xe2>
8000a490:	30 0c       	mov	r12,0

  return TRUE;
}
8000a492:	2f cd       	sub	sp,-16
8000a494:	d8 32       	popm	r0-r7,pc
8000a496:	00 00       	add	r0,r0
8000a498:	80 00       	ld.sh	r0,r0[0x0]
8000a49a:	a0 fa       	st.b	r0[0x7],r10
8000a49c:	80 00       	ld.sh	r0,r0[0x0]
8000a49e:	a3 04       	ld.d	r4,r1

8000a4a0 <skip_variable>:


METHODDEF(boolean)
skip_variable (j_decompress_ptr cinfo)
/* Skip over an unknown or uninteresting variable-length marker */
{
8000a4a0:	eb cd 40 f8 	pushm	r3-r7,lr
8000a4a4:	18 97       	mov	r7,r12
  INT32 length;
  INPUT_VARS(cinfo);
8000a4a6:	78 66       	ld.w	r6,r12[0x18]
8000a4a8:	6c 05       	ld.w	r5,r6[0x0]
8000a4aa:	6c 14       	ld.w	r4,r6[0x4]

  INPUT_2BYTES(cinfo, length, return FALSE);
8000a4ac:	58 04       	cp.w	r4,0
8000a4ae:	c0 61       	brne	8000a4ba <skip_variable+0x1a>
8000a4b0:	6c 38       	ld.w	r8,r6[0xc]
8000a4b2:	5d 18       	icall	r8
8000a4b4:	c2 f0       	breq	8000a512 <skip_variable+0x72>
8000a4b6:	6c 05       	ld.w	r5,r6[0x0]
8000a4b8:	6c 14       	ld.w	r4,r6[0x4]
8000a4ba:	20 14       	sub	r4,1
8000a4bc:	0b 83       	ld.ub	r3,r5[0x0]
8000a4be:	c0 30       	breq	8000a4c4 <skip_variable+0x24>
8000a4c0:	2f f5       	sub	r5,-1
8000a4c2:	c0 78       	rjmp	8000a4d0 <skip_variable+0x30>
8000a4c4:	6c 38       	ld.w	r8,r6[0xc]
8000a4c6:	0e 9c       	mov	r12,r7
8000a4c8:	5d 18       	icall	r8
8000a4ca:	c2 40       	breq	8000a512 <skip_variable+0x72>
8000a4cc:	6c 05       	ld.w	r5,r6[0x0]
8000a4ce:	6c 14       	ld.w	r4,r6[0x4]
8000a4d0:	a9 63       	lsl	r3,0x8
8000a4d2:	20 23       	sub	r3,2
  length -= 2;
8000a4d4:	0b 38       	ld.ub	r8,r5++
8000a4d6:	10 03       	add	r3,r8

  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);
8000a4d8:	6e 08       	ld.w	r8,r7[0x0]
8000a4da:	35 b9       	mov	r9,91
8000a4dc:	91 59       	st.w	r8[0x14],r9
8000a4de:	6e 08       	ld.w	r8,r7[0x0]
8000a4e0:	ee f9 01 a0 	ld.w	r9,r7[416]
8000a4e4:	91 69       	st.w	r8[0x18],r9
8000a4e6:	6e 08       	ld.w	r8,r7[0x0]
8000a4e8:	91 73       	st.w	r8[0x1c],r3
8000a4ea:	6e 08       	ld.w	r8,r7[0x0]
8000a4ec:	70 18       	ld.w	r8,r8[0x4]
8000a4ee:	30 1b       	mov	r11,1
8000a4f0:	0e 9c       	mov	r12,r7
8000a4f2:	5d 18       	icall	r8

  INPUT_SYNC(cinfo);		/* do before skip_input_data */
8000a4f4:	8d 05       	st.w	r6[0x0],r5
8000a4f6:	20 14       	sub	r4,1
8000a4f8:	8d 14       	st.w	r6[0x4],r4
  if (length > 0)
8000a4fa:	58 03       	cp.w	r3,0
8000a4fc:	e0 89 00 04 	brgt	8000a504 <skip_variable+0x64>
8000a500:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
    (*cinfo->src->skip_input_data) (cinfo, (long) length);
8000a504:	6e 68       	ld.w	r8,r7[0x18]
8000a506:	70 48       	ld.w	r8,r8[0x10]
8000a508:	06 9b       	mov	r11,r3
8000a50a:	0e 9c       	mov	r12,r7
8000a50c:	5d 18       	icall	r8
8000a50e:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
8000a512:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

8000a516 <next_marker>:
 * but it will never be 0 or FF.
 */

LOCAL(boolean)
next_marker (j_decompress_ptr cinfo)
{
8000a516:	eb cd 40 fc 	pushm	r2-r7,lr
8000a51a:	18 94       	mov	r4,r12
  int c;
  INPUT_VARS(cinfo);
8000a51c:	78 65       	ld.w	r5,r12[0x18]
8000a51e:	6a 06       	ld.w	r6,r5[0x0]
8000a520:	6a 17       	ld.w	r7,r5[0x4]
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
8000a522:	3f f3       	mov	r3,-1
{
  int c;
  INPUT_VARS(cinfo);

  for (;;) {
    INPUT_BYTE(cinfo, c, return FALSE);
8000a524:	58 07       	cp.w	r7,0
8000a526:	c0 71       	brne	8000a534 <next_marker+0x1e>
8000a528:	6a 38       	ld.w	r8,r5[0xc]
8000a52a:	08 9c       	mov	r12,r4
8000a52c:	5d 18       	icall	r8
8000a52e:	c5 10       	breq	8000a5d0 <next_marker+0xba>
8000a530:	6a 06       	ld.w	r6,r5[0x0]
8000a532:	6a 17       	ld.w	r7,r5[0x4]
8000a534:	20 17       	sub	r7,1
8000a536:	0d 38       	ld.ub	r8,r6++
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
8000a538:	e6 08 18 00 	cp.b	r8,r3
8000a53c:	c1 50       	breq	8000a566 <next_marker+0x50>
      cinfo->marker->discarded_bytes++;
8000a53e:	e8 f8 01 b8 	ld.w	r8,r4[440]
8000a542:	70 69       	ld.w	r9,r8[0x18]
8000a544:	2f f9       	sub	r9,-1
8000a546:	91 69       	st.w	r8[0x18],r9
      INPUT_SYNC(cinfo);
8000a548:	8b 06       	st.w	r5[0x0],r6
8000a54a:	8b 17       	st.w	r5[0x4],r7
      INPUT_BYTE(cinfo, c, return FALSE);
8000a54c:	58 07       	cp.w	r7,0
8000a54e:	c0 71       	brne	8000a55c <next_marker+0x46>
8000a550:	6a 38       	ld.w	r8,r5[0xc]
8000a552:	08 9c       	mov	r12,r4
8000a554:	5d 18       	icall	r8
8000a556:	c3 d0       	breq	8000a5d0 <next_marker+0xba>
8000a558:	6a 06       	ld.w	r6,r5[0x0]
8000a55a:	6a 17       	ld.w	r7,r5[0x4]
8000a55c:	20 17       	sub	r7,1
8000a55e:	0d 38       	ld.ub	r8,r6++
    /* Skip any non-FF bytes.
     * This may look a bit inefficient, but it will not occur in a valid file.
     * We sync after each discarded byte so that a suspending data source
     * can discard the byte from its buffer.
     */
    while (c != 0xFF) {
8000a560:	e6 08 18 00 	cp.b	r8,r3
8000a564:	ce d1       	brne	8000a53e <next_marker+0x28>
     * pad bytes, so don't count them in discarded_bytes.  We assume there
     * will not be so many consecutive FF bytes as to overflow a suspending
     * data source's input buffer.
     */
    do {
      INPUT_BYTE(cinfo, c, return FALSE);
8000a566:	58 07       	cp.w	r7,0
8000a568:	c0 71       	brne	8000a576 <next_marker+0x60>
8000a56a:	6a 38       	ld.w	r8,r5[0xc]
8000a56c:	08 9c       	mov	r12,r4
8000a56e:	5d 18       	icall	r8
8000a570:	c3 00       	breq	8000a5d0 <next_marker+0xba>
8000a572:	6a 06       	ld.w	r6,r5[0x0]
8000a574:	6a 17       	ld.w	r7,r5[0x4]
8000a576:	20 17       	sub	r7,1
8000a578:	0d 32       	ld.ub	r2,r6++
    } while (c == 0xFF);
8000a57a:	e0 42 00 ff 	cp.w	r2,255
8000a57e:	cf 40       	breq	8000a566 <next_marker+0x50>
    if (c != 0)
8000a580:	58 02       	cp.w	r2,0
8000a582:	c0 91       	brne	8000a594 <next_marker+0x7e>
      break;			/* found a valid marker, exit loop */
    /* Reach here if we found a stuffed-zero data sequence (FF/00).
     * Discard it and loop back to try again.
     */
    cinfo->marker->discarded_bytes += 2;
8000a584:	e8 f8 01 b8 	ld.w	r8,r4[440]
8000a588:	70 6b       	ld.w	r11,r8[0x18]
8000a58a:	2f eb       	sub	r11,-2
8000a58c:	91 6b       	st.w	r8[0x18],r11
    INPUT_SYNC(cinfo);
8000a58e:	8b 06       	st.w	r5[0x0],r6
8000a590:	8b 17       	st.w	r5[0x4],r7
  }
8000a592:	cc 9b       	rjmp	8000a524 <next_marker+0xe>

  if (cinfo->marker->discarded_bytes != 0) {
8000a594:	e8 f8 01 b8 	ld.w	r8,r4[440]
8000a598:	70 68       	ld.w	r8,r8[0x18]
8000a59a:	58 08       	cp.w	r8,0
8000a59c:	c1 40       	breq	8000a5c4 <next_marker+0xae>
    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
8000a59e:	68 08       	ld.w	r8,r4[0x0]
8000a5a0:	37 49       	mov	r9,116
8000a5a2:	91 59       	st.w	r8[0x14],r9
8000a5a4:	68 08       	ld.w	r8,r4[0x0]
8000a5a6:	e8 f9 01 b8 	ld.w	r9,r4[440]
8000a5aa:	72 69       	ld.w	r9,r9[0x18]
8000a5ac:	91 69       	st.w	r8[0x18],r9
8000a5ae:	68 08       	ld.w	r8,r4[0x0]
8000a5b0:	91 72       	st.w	r8[0x1c],r2
8000a5b2:	68 08       	ld.w	r8,r4[0x0]
8000a5b4:	70 18       	ld.w	r8,r8[0x4]
8000a5b6:	3f fb       	mov	r11,-1
8000a5b8:	08 9c       	mov	r12,r4
8000a5ba:	5d 18       	icall	r8
    cinfo->marker->discarded_bytes = 0;
8000a5bc:	e8 f8 01 b8 	ld.w	r8,r4[440]
8000a5c0:	30 09       	mov	r9,0
8000a5c2:	91 69       	st.w	r8[0x18],r9
  }

  cinfo->unread_marker = c;
8000a5c4:	e9 42 01 a0 	st.w	r4[416],r2

  INPUT_SYNC(cinfo);
8000a5c8:	8b 06       	st.w	r5[0x0],r6
8000a5ca:	8b 17       	st.w	r5[0x4],r7
8000a5cc:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
  return TRUE;
8000a5d0:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

8000a5d4 <read_restart_marker>:
 * it holds a marker which the decoder will be unable to read past.
 */

METHODDEF(boolean)
read_restart_marker (j_decompress_ptr cinfo)
{
8000a5d4:	eb cd 40 80 	pushm	r7,lr
8000a5d8:	18 97       	mov	r7,r12
  /* Obtain a marker unless we already did. */
  /* Note that next_marker will complain if it skips any data. */
  if (cinfo->unread_marker == 0) {
8000a5da:	f8 f8 01 a0 	ld.w	r8,r12[416]
8000a5de:	58 08       	cp.w	r8,0
8000a5e0:	c0 41       	brne	8000a5e8 <read_restart_marker+0x14>
    if (! next_marker(cinfo))
8000a5e2:	f0 1f 00 17 	mcall	8000a63c <read_restart_marker+0x68>
8000a5e6:	c2 90       	breq	8000a638 <read_restart_marker+0x64>
      return FALSE;
  }

  if (cinfo->unread_marker ==
      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
8000a5e8:	ee f8 01 b8 	ld.w	r8,r7[440]
8000a5ec:	70 5b       	ld.w	r11,r8[0x14]
  if (cinfo->unread_marker == 0) {
    if (! next_marker(cinfo))
      return FALSE;
  }

  if (cinfo->unread_marker ==
8000a5ee:	f6 c8 ff 30 	sub	r8,r11,-208
8000a5f2:	ee f9 01 a0 	ld.w	r9,r7[416]
8000a5f6:	10 39       	cp.w	r9,r8
8000a5f8:	c1 21       	brne	8000a61c <read_restart_marker+0x48>
      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
    /* Normal case --- swallow the marker and let entropy decoder continue */
    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
8000a5fa:	6e 08       	ld.w	r8,r7[0x0]
8000a5fc:	36 29       	mov	r9,98
8000a5fe:	91 59       	st.w	r8[0x14],r9
8000a600:	6e 08       	ld.w	r8,r7[0x0]
8000a602:	ee f9 01 b8 	ld.w	r9,r7[440]
8000a606:	72 59       	ld.w	r9,r9[0x14]
8000a608:	91 69       	st.w	r8[0x18],r9
8000a60a:	6e 08       	ld.w	r8,r7[0x0]
8000a60c:	70 18       	ld.w	r8,r8[0x4]
8000a60e:	30 3b       	mov	r11,3
8000a610:	0e 9c       	mov	r12,r7
8000a612:	5d 18       	icall	r8
    cinfo->unread_marker = 0;
8000a614:	30 08       	mov	r8,0
8000a616:	ef 48 01 a0 	st.w	r7[416],r8
8000a61a:	c0 68       	rjmp	8000a626 <read_restart_marker+0x52>
  } else {
    /* Uh-oh, the restart markers have been messed up. */
    /* Let the data source manager determine how to resync. */
    if (! (*cinfo->src->resync_to_restart) (cinfo,
8000a61c:	6e 68       	ld.w	r8,r7[0x18]
8000a61e:	70 58       	ld.w	r8,r8[0x14]
8000a620:	0e 9c       	mov	r12,r7
8000a622:	5d 18       	icall	r8
8000a624:	c0 a0       	breq	8000a638 <read_restart_marker+0x64>
					    cinfo->marker->next_restart_num))
      return FALSE;
  }

  /* Update next-restart state */
  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
8000a626:	ee f8 01 b8 	ld.w	r8,r7[440]
8000a62a:	70 59       	ld.w	r9,r8[0x14]
8000a62c:	2f f9       	sub	r9,-1
8000a62e:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
8000a632:	91 59       	st.w	r8[0x14],r9
8000a634:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1

  return TRUE;
8000a638:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000a63c:	80 00       	ld.sh	r0,r0[0x0]
8000a63e:	a5 16       	ld.d	r6,--r2

8000a640 <jpeg_resync_to_restart>:
 * any other marker would have to be bogus data in that case.
 */

GLOBAL(boolean)
jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
{
8000a640:	eb cd 40 fe 	pushm	r1-r7,lr
8000a644:	18 97       	mov	r7,r12
8000a646:	16 95       	mov	r5,r11
  int marker = cinfo->unread_marker;
8000a648:	f8 f6 01 a0 	ld.w	r6,r12[416]
  int action = 1;

  /* Always put up a warning. */
  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);
8000a64c:	78 08       	ld.w	r8,r12[0x0]
8000a64e:	37 99       	mov	r9,121
8000a650:	91 59       	st.w	r8[0x14],r9
8000a652:	78 08       	ld.w	r8,r12[0x0]
8000a654:	91 66       	st.w	r8[0x18],r6
8000a656:	78 08       	ld.w	r8,r12[0x0]
8000a658:	91 7b       	st.w	r8[0x1c],r11
8000a65a:	18 94       	mov	r4,r12
8000a65c:	78 08       	ld.w	r8,r12[0x0]
8000a65e:	70 18       	ld.w	r8,r8[0x4]
8000a660:	3f fb       	mov	r11,-1
8000a662:	5d 18       	icall	r8
    if (marker < (int) M_SOF0)
      action = 2;		/* invalid marker */
    else if (marker < (int) M_RST0 || marker > (int) M_RST7)
      action = 3;		/* valid non-restart marker */
    else {
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
8000a664:	ea c3 ff ff 	sub	r3,r5,-1
8000a668:	e7 d3 c0 03 	bfextu	r3,r3,0x0,0x3
8000a66c:	e6 c3 ff 30 	sub	r3,r3,-208
8000a670:	ea c2 ff fe 	sub	r2,r5,-2
8000a674:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
8000a678:	e4 c2 ff 30 	sub	r2,r2,-208
	  marker == ((int) M_RST0 + ((desired+2) & 7)))
	action = 3;		/* one of the next two expected restarts */
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
8000a67c:	ea c1 00 01 	sub	r1,r5,1
8000a680:	e3 d1 c0 03 	bfextu	r1,r1,0x0,0x3
8000a684:	e2 c1 ff 30 	sub	r1,r1,-208
  /* Always put up a warning. */
  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);

  /* Outer loop handles repeated decision after scanning forward. */
  for (;;) {
    if (marker < (int) M_SOF0)
8000a688:	e0 46 00 bf 	cp.w	r6,191
8000a68c:	e0 8a 00 15 	brle	8000a6b6 <jpeg_resync_to_restart+0x76>
      action = 2;		/* invalid marker */
    else if (marker < (int) M_RST0 || marker > (int) M_RST7)
8000a690:	ec c8 00 d0 	sub	r8,r6,208
8000a694:	58 78       	cp.w	r8,7
8000a696:	e0 8b 00 26 	brhi	8000a6e2 <jpeg_resync_to_restart+0xa2>
      action = 3;		/* valid non-restart marker */
    else {
      if (marker == ((int) M_RST0 + ((desired+1) & 7)) ||
8000a69a:	0c 33       	cp.w	r3,r6
8000a69c:	c2 30       	breq	8000a6e2 <jpeg_resync_to_restart+0xa2>
8000a69e:	0c 32       	cp.w	r2,r6
8000a6a0:	c2 10       	breq	8000a6e2 <jpeg_resync_to_restart+0xa2>
	  marker == ((int) M_RST0 + ((desired+2) & 7)))
	action = 3;		/* one of the next two expected restarts */
      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
8000a6a2:	0c 31       	cp.w	r1,r6
8000a6a4:	c0 90       	breq	8000a6b6 <jpeg_resync_to_restart+0x76>
8000a6a6:	ea c8 00 02 	sub	r8,r5,2
8000a6aa:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000a6ae:	f0 c8 ff 30 	sub	r8,r8,-208
8000a6b2:	0c 38       	cp.w	r8,r6
8000a6b4:	c2 61       	brne	8000a700 <jpeg_resync_to_restart+0xc0>
	       marker == ((int) M_RST0 + ((desired-2) & 7)))
	action = 2;		/* a prior restart, so advance */
      else
	action = 1;		/* desired restart or too far away */
    }
    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
8000a6b6:	6e 08       	ld.w	r8,r7[0x0]
8000a6b8:	36 19       	mov	r9,97
8000a6ba:	91 59       	st.w	r8[0x14],r9
8000a6bc:	6e 08       	ld.w	r8,r7[0x0]
8000a6be:	91 66       	st.w	r8[0x18],r6
8000a6c0:	6e 08       	ld.w	r8,r7[0x0]
8000a6c2:	30 29       	mov	r9,2
8000a6c4:	91 79       	st.w	r8[0x1c],r9
8000a6c6:	6e 08       	ld.w	r8,r7[0x0]
8000a6c8:	70 18       	ld.w	r8,r8[0x4]
8000a6ca:	30 4b       	mov	r11,4
8000a6cc:	08 9c       	mov	r12,r4
8000a6ce:	5d 18       	icall	r8
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
      return TRUE;
    case 2:
      /* Scan to the next marker, and repeat the decision loop. */
      if (! next_marker(cinfo))
8000a6d0:	0e 9c       	mov	r12,r7
8000a6d2:	f0 1f 00 16 	mcall	8000a728 <jpeg_resync_to_restart+0xe8>
8000a6d6:	c0 40       	breq	8000a6de <jpeg_resync_to_restart+0x9e>
	return FALSE;
      marker = cinfo->unread_marker;
8000a6d8:	ee f6 01 a0 	ld.w	r6,r7[416]
      break;
8000a6dc:	cd 6b       	rjmp	8000a688 <jpeg_resync_to_restart+0x48>
8000a6de:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
	       marker == ((int) M_RST0 + ((desired-2) & 7)))
	action = 2;		/* a prior restart, so advance */
      else
	action = 1;		/* desired restart or too far away */
    }
    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);
8000a6e2:	6e 08       	ld.w	r8,r7[0x0]
8000a6e4:	36 19       	mov	r9,97
8000a6e6:	91 59       	st.w	r8[0x14],r9
8000a6e8:	6e 08       	ld.w	r8,r7[0x0]
8000a6ea:	91 66       	st.w	r8[0x18],r6
8000a6ec:	6e 08       	ld.w	r8,r7[0x0]
8000a6ee:	30 39       	mov	r9,3
8000a6f0:	91 79       	st.w	r8[0x1c],r9
8000a6f2:	6e 08       	ld.w	r8,r7[0x0]
8000a6f4:	70 18       	ld.w	r8,r8[0x4]
8000a6f6:	30 4b       	mov	r11,4
8000a6f8:	08 9c       	mov	r12,r4
8000a6fa:	5d 18       	icall	r8
8000a6fc:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
8000a700:	6e 08       	ld.w	r8,r7[0x0]
8000a702:	36 19       	mov	r9,97
8000a704:	91 59       	st.w	r8[0x14],r9
8000a706:	6e 08       	ld.w	r8,r7[0x0]
8000a708:	91 66       	st.w	r8[0x18],r6
8000a70a:	6e 08       	ld.w	r8,r7[0x0]
8000a70c:	30 16       	mov	r6,1
8000a70e:	91 76       	st.w	r8[0x1c],r6
8000a710:	6e 08       	ld.w	r8,r7[0x0]
8000a712:	70 18       	ld.w	r8,r8[0x4]
8000a714:	30 4b       	mov	r11,4
8000a716:	08 9c       	mov	r12,r4
8000a718:	5d 18       	icall	r8
    switch (action) {
    case 1:
      /* Discard marker and let entropy decoder resume processing. */
      cinfo->unread_marker = 0;
8000a71a:	30 08       	mov	r8,0
8000a71c:	ef 48 01 a0 	st.w	r7[416],r8
8000a720:	0c 9c       	mov	r12,r6
      return TRUE;
8000a722:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000a726:	00 00       	add	r0,r0
8000a728:	80 00       	ld.sh	r0,r0[0x0]
8000a72a:	a5 16       	ld.d	r6,--r2

8000a72c <reset_marker_reader>:
 */

METHODDEF(void)
reset_marker_reader (j_decompress_ptr cinfo)
{
  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
8000a72c:	f8 f9 01 b8 	ld.w	r9,r12[440]

  cinfo->comp_info = NULL;		/* until allocated by get_sof */
8000a730:	30 08       	mov	r8,0
8000a732:	f9 48 00 d8 	st.w	r12[216],r8
  cinfo->input_scan_number = 0;		/* no SOS seen yet */
8000a736:	f9 48 00 90 	st.w	r12[144],r8
  cinfo->unread_marker = 0;		/* no pending marker */
8000a73a:	f9 48 01 a0 	st.w	r12[416],r8
  marker->pub.saw_SOI = FALSE;		/* set internal state too */
8000a73e:	93 38       	st.w	r9[0xc],r8
  marker->pub.saw_SOF = FALSE;
8000a740:	93 48       	st.w	r9[0x10],r8
  marker->pub.discarded_bytes = 0;
8000a742:	93 68       	st.w	r9[0x18],r8
  marker->cur_marker = NULL;
8000a744:	f3 48 00 a4 	st.w	r9[164],r8
}
8000a748:	5e fc       	retal	r12
8000a74a:	d7 03       	nop

8000a74c <jinit_marker_reader>:
 * This is called only once, when the decompression object is created.
 */

GLOBAL(void)
jinit_marker_reader (j_decompress_ptr cinfo)
{
8000a74c:	eb cd 40 80 	pushm	r7,lr
8000a750:	18 97       	mov	r7,r12
  my_marker_ptr marker;
  int i;

  /* Create subobject in permanent pool */
  marker = (my_marker_ptr)
8000a752:	78 18       	ld.w	r8,r12[0x4]
8000a754:	70 08       	ld.w	r8,r8[0x0]
8000a756:	e0 6a 00 ac 	mov	r10,172
8000a75a:	30 0b       	mov	r11,0
8000a75c:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
				SIZEOF(my_marker_reader));
  cinfo->marker = (struct jpeg_marker_reader *) marker;
8000a75e:	ef 4c 01 b8 	st.w	r7[440],r12
  /* Initialize public method pointers */
  marker->pub.reset_marker_reader = reset_marker_reader;
8000a762:	49 08       	lddpc	r8,8000a7a0 <jinit_marker_reader+0x54>
8000a764:	99 08       	st.w	r12[0x0],r8
  marker->pub.read_markers = read_markers;
8000a766:	49 08       	lddpc	r8,8000a7a4 <jinit_marker_reader+0x58>
8000a768:	99 18       	st.w	r12[0x4],r8
  marker->pub.read_restart_marker = read_restart_marker;
8000a76a:	49 08       	lddpc	r8,8000a7a8 <jinit_marker_reader+0x5c>
8000a76c:	99 28       	st.w	r12[0x8],r8
  /* Initialize COM/APPn processing.
   * By default, we examine and then discard APP0 and APP14,
   * but simply discard COM and all other APPn.
   */
  marker->process_COM = skip_variable;
8000a76e:	49 08       	lddpc	r8,8000a7ac <jinit_marker_reader+0x60>
8000a770:	99 78       	st.w	r12[0x1c],r8
  marker->length_limit_COM = 0;
8000a772:	30 09       	mov	r9,0
8000a774:	f9 49 00 60 	st.w	r12[96],r9
8000a778:	f8 c8 ff e0 	sub	r8,r12,-32
  for (i = 0; i < 16; i++) {
    marker->process_APPn[i] = skip_variable;
8000a77c:	48 cb       	lddpc	r11,8000a7ac <jinit_marker_reader+0x60>
    marker->length_limit_APPn[i] = 0;
8000a77e:	12 9a       	mov	r10,r9
   * but simply discard COM and all other APPn.
   */
  marker->process_COM = skip_variable;
  marker->length_limit_COM = 0;
  for (i = 0; i < 16; i++) {
    marker->process_APPn[i] = skip_variable;
8000a780:	91 0b       	st.w	r8[0x0],r11
    marker->length_limit_APPn[i] = 0;
8000a782:	f1 4a 00 44 	st.w	r8[68],r10
   * By default, we examine and then discard APP0 and APP14,
   * but simply discard COM and all other APPn.
   */
  marker->process_COM = skip_variable;
  marker->length_limit_COM = 0;
  for (i = 0; i < 16; i++) {
8000a786:	2f f9       	sub	r9,-1
8000a788:	2f c8       	sub	r8,-4
8000a78a:	59 09       	cp.w	r9,16
8000a78c:	cf a1       	brne	8000a780 <jinit_marker_reader+0x34>
    marker->process_APPn[i] = skip_variable;
    marker->length_limit_APPn[i] = 0;
  }
  marker->process_APPn[0] = get_interesting_appn;
8000a78e:	48 98       	lddpc	r8,8000a7b0 <jinit_marker_reader+0x64>
8000a790:	99 88       	st.w	r12[0x20],r8
  marker->process_APPn[14] = get_interesting_appn;
8000a792:	f9 48 00 58 	st.w	r12[88],r8
  /* Reset marker processing state */
  reset_marker_reader(cinfo);
8000a796:	0e 9c       	mov	r12,r7
8000a798:	f0 1f 00 02 	mcall	8000a7a0 <jinit_marker_reader+0x54>
}
8000a79c:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a7a0:	80 00       	ld.sh	r0,r0[0x0]
8000a7a2:	a7 2c       	st.d	r3++,r12
8000a7a4:	80 00       	ld.sh	r0,r0[0x0]
8000a7a6:	a9 f4       	*unknown*
8000a7a8:	80 00       	ld.sh	r0,r0[0x0]
8000a7aa:	a5 d4       	cbr	r4,0x5
8000a7ac:	80 00       	ld.sh	r0,r0[0x0]
8000a7ae:	a4 a0       	st.b	r2[0x2],r0
8000a7b0:	80 00       	ld.sh	r0,r0[0x0]
8000a7b2:	a3 b0       	sbr	r0,0x3

8000a7b4 <get_dht>:


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
/* Process a DHT marker */
{
8000a7b4:	d4 31       	pushm	r0-r7,lr
8000a7b6:	fa cd 01 24 	sub	sp,sp,292
8000a7ba:	18 92       	mov	r2,r12
  INT32 length;
  UINT8 bits[17];
  UINT8 huffval[256];
  int i, index, count;
  JHUFF_TBL **htblptr;
  INPUT_VARS(cinfo);
8000a7bc:	78 63       	ld.w	r3,r12[0x18]
8000a7be:	66 08       	ld.w	r8,r3[0x0]
8000a7c0:	66 17       	ld.w	r7,r3[0x4]

  INPUT_2BYTES(cinfo, length, return FALSE);
8000a7c2:	58 07       	cp.w	r7,0
8000a7c4:	c0 71       	brne	8000a7d2 <get_dht+0x1e>
8000a7c6:	66 38       	ld.w	r8,r3[0xc]
8000a7c8:	5d 18       	icall	r8
8000a7ca:	e0 80 01 0d 	breq	8000a9e4 <get_dht+0x230>
8000a7ce:	66 08       	ld.w	r8,r3[0x0]
8000a7d0:	66 17       	ld.w	r7,r3[0x4]
8000a7d2:	20 17       	sub	r7,1
8000a7d4:	11 85       	ld.ub	r5,r8[0x0]
8000a7d6:	c0 30       	breq	8000a7dc <get_dht+0x28>
8000a7d8:	2f f8       	sub	r8,-1
8000a7da:	c0 88       	rjmp	8000a7ea <get_dht+0x36>
8000a7dc:	66 38       	ld.w	r8,r3[0xc]
8000a7de:	04 9c       	mov	r12,r2
8000a7e0:	5d 18       	icall	r8
8000a7e2:	e0 80 01 01 	breq	8000a9e4 <get_dht+0x230>
8000a7e6:	66 08       	ld.w	r8,r3[0x0]
8000a7e8:	66 17       	ld.w	r7,r3[0x4]
8000a7ea:	20 17       	sub	r7,1
8000a7ec:	f0 c6 ff ff 	sub	r6,r8,-1
8000a7f0:	a9 65       	lsl	r5,0x8
8000a7f2:	20 25       	sub	r5,2
  length -= 2;
8000a7f4:	11 88       	ld.ub	r8,r8[0x0]
8000a7f6:	ea 08 00 08 	add	r8,r5,r8
8000a7fa:	50 08       	stdsp	sp[0x0],r8

  while (length > 16) {
8000a7fc:	59 08       	cp.w	r8,16
8000a7fe:	e0 8a 00 e5 	brle	8000a9c8 <get_dht+0x214>

#endif /* D_ARITH_CODING_SUPPORTED */


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
8000a802:	fa c0 fe df 	sub	r0,sp,-289
     */
    if (count > 256 || ((INT32) count) > length)
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);

    for (i = 0; i < count; i++)
      INPUT_BYTE(cinfo, huffval[i], return FALSE);
8000a806:	fa c1 ff f0 	sub	r1,sp,-16
8000a80a:	50 31       	stdsp	sp[0xc],r1

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  while (length > 16) {
    INPUT_BYTE(cinfo, index, return FALSE);
8000a80c:	58 07       	cp.w	r7,0
8000a80e:	c0 81       	brne	8000a81e <get_dht+0x6a>
8000a810:	66 38       	ld.w	r8,r3[0xc]
8000a812:	04 9c       	mov	r12,r2
8000a814:	5d 18       	icall	r8
8000a816:	e0 80 00 e7 	breq	8000a9e4 <get_dht+0x230>
8000a81a:	66 06       	ld.w	r6,r3[0x0]
8000a81c:	66 17       	ld.w	r7,r3[0x4]
8000a81e:	20 17       	sub	r7,1
8000a820:	0d 39       	ld.ub	r9,r6++
8000a822:	50 19       	stdsp	sp[0x4],r9

    TRACEMS1(cinfo, 1, JTRC_DHT, index);
8000a824:	64 08       	ld.w	r8,r2[0x0]
8000a826:	35 09       	mov	r9,80
8000a828:	91 59       	st.w	r8[0x14],r9
8000a82a:	64 08       	ld.w	r8,r2[0x0]
8000a82c:	40 19       	lddsp	r9,sp[0x4]
8000a82e:	91 69       	st.w	r8[0x18],r9
8000a830:	50 22       	stdsp	sp[0x8],r2
8000a832:	64 08       	ld.w	r8,r2[0x0]
8000a834:	70 18       	ld.w	r8,r8[0x4]
8000a836:	30 1b       	mov	r11,1
8000a838:	04 9c       	mov	r12,r2
8000a83a:	5d 18       	icall	r8

    bits[0] = 0;
8000a83c:	30 08       	mov	r8,0
8000a83e:	fb 68 01 10 	st.b	sp[272],r8
8000a842:	fa c5 fe ef 	sub	r5,sp,-273

#endif /* D_ARITH_CODING_SUPPORTED */


LOCAL(boolean)
get_dht (j_decompress_ptr cinfo)
8000a846:	30 04       	mov	r4,0
    TRACEMS1(cinfo, 1, JTRC_DHT, index);

    bits[0] = 0;
    count = 0;
    for (i = 1; i <= 16; i++) {
      INPUT_BYTE(cinfo, bits[i], return FALSE);
8000a848:	58 07       	cp.w	r7,0
8000a84a:	c0 81       	brne	8000a85a <get_dht+0xa6>
8000a84c:	66 38       	ld.w	r8,r3[0xc]
8000a84e:	04 9c       	mov	r12,r2
8000a850:	5d 18       	icall	r8
8000a852:	e0 80 00 c9 	breq	8000a9e4 <get_dht+0x230>
8000a856:	66 06       	ld.w	r6,r3[0x0]
8000a858:	66 17       	ld.w	r7,r3[0x4]
8000a85a:	20 17       	sub	r7,1
8000a85c:	0d 38       	ld.ub	r8,r6++
8000a85e:	0a c8       	st.b	r5++,r8
      count += bits[i];
8000a860:	10 04       	add	r4,r8

    TRACEMS1(cinfo, 1, JTRC_DHT, index);

    bits[0] = 0;
    count = 0;
    for (i = 1; i <= 16; i++) {
8000a862:	00 35       	cp.w	r5,r0
8000a864:	cf 21       	brne	8000a848 <get_dht+0x94>
      INPUT_BYTE(cinfo, bits[i], return FALSE);
      count += bits[i];
    }

    length -= 1 + 16;
8000a866:	40 09       	lddsp	r9,sp[0x0]
8000a868:	21 19       	sub	r9,17
8000a86a:	50 09       	stdsp	sp[0x0],r9

    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
8000a86c:	64 09       	ld.w	r9,r2[0x0]
8000a86e:	f2 c8 ff e8 	sub	r8,r9,-24
8000a872:	fb 3a 01 11 	ld.ub	r10,sp[273]
8000a876:	93 6a       	st.w	r9[0x18],r10
8000a878:	fb 39 01 12 	ld.ub	r9,sp[274]
8000a87c:	91 19       	st.w	r8[0x4],r9
8000a87e:	fb 39 01 13 	ld.ub	r9,sp[275]
8000a882:	91 29       	st.w	r8[0x8],r9
8000a884:	fb 39 01 14 	ld.ub	r9,sp[276]
8000a888:	91 39       	st.w	r8[0xc],r9
8000a88a:	fb 39 01 15 	ld.ub	r9,sp[277]
8000a88e:	91 49       	st.w	r8[0x10],r9
8000a890:	fb 39 01 16 	ld.ub	r9,sp[278]
8000a894:	91 59       	st.w	r8[0x14],r9
8000a896:	fb 39 01 17 	ld.ub	r9,sp[279]
8000a89a:	91 69       	st.w	r8[0x18],r9
8000a89c:	fb 39 01 18 	ld.ub	r9,sp[280]
8000a8a0:	91 79       	st.w	r8[0x1c],r9
8000a8a2:	64 08       	ld.w	r8,r2[0x0]
8000a8a4:	35 69       	mov	r9,86
8000a8a6:	91 59       	st.w	r8[0x14],r9
8000a8a8:	64 08       	ld.w	r8,r2[0x0]
8000a8aa:	70 18       	ld.w	r8,r8[0x4]
8000a8ac:	30 2b       	mov	r11,2
8000a8ae:	40 2c       	lddsp	r12,sp[0x8]
8000a8b0:	5d 18       	icall	r8
	     bits[1], bits[2], bits[3], bits[4],
	     bits[5], bits[6], bits[7], bits[8]);
    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
8000a8b2:	64 09       	ld.w	r9,r2[0x0]
8000a8b4:	f2 c8 ff e8 	sub	r8,r9,-24
8000a8b8:	fb 3a 01 19 	ld.ub	r10,sp[281]
8000a8bc:	93 6a       	st.w	r9[0x18],r10
8000a8be:	fb 39 01 1a 	ld.ub	r9,sp[282]
8000a8c2:	91 19       	st.w	r8[0x4],r9
8000a8c4:	fb 39 01 1b 	ld.ub	r9,sp[283]
8000a8c8:	91 29       	st.w	r8[0x8],r9
8000a8ca:	fb 39 01 1c 	ld.ub	r9,sp[284]
8000a8ce:	91 39       	st.w	r8[0xc],r9
8000a8d0:	fb 39 01 1d 	ld.ub	r9,sp[285]
8000a8d4:	91 49       	st.w	r8[0x10],r9
8000a8d6:	fb 39 01 1e 	ld.ub	r9,sp[286]
8000a8da:	91 59       	st.w	r8[0x14],r9
8000a8dc:	fb 39 01 1f 	ld.ub	r9,sp[287]
8000a8e0:	91 69       	st.w	r8[0x18],r9
8000a8e2:	fb 39 01 20 	ld.ub	r9,sp[288]
8000a8e6:	91 79       	st.w	r8[0x1c],r9
8000a8e8:	64 08       	ld.w	r8,r2[0x0]
8000a8ea:	35 69       	mov	r9,86
8000a8ec:	91 59       	st.w	r8[0x14],r9
8000a8ee:	64 08       	ld.w	r8,r2[0x0]
8000a8f0:	70 18       	ld.w	r8,r8[0x4]
8000a8f2:	30 2b       	mov	r11,2
8000a8f4:	40 2c       	lddsp	r12,sp[0x8]
8000a8f6:	5d 18       	icall	r8
	     bits[13], bits[14], bits[15], bits[16]);

    /* Here we just do minimal validation of the counts to avoid walking
     * off the end of our table space.  jdhuff.c will check more carefully.
     */
    if (count > 256 || ((INT32) count) > length)
8000a8f8:	e0 44 01 00 	cp.w	r4,256
8000a8fc:	5f 99       	srgt	r9
8000a8fe:	40 08       	lddsp	r8,sp[0x0]
8000a900:	10 34       	cp.w	r4,r8
8000a902:	5f 98       	srgt	r8
8000a904:	f3 e8 10 08 	or	r8,r9,r8
8000a908:	30 09       	mov	r9,0
8000a90a:	f2 08 18 00 	cp.b	r8,r9
8000a90e:	c0 80       	breq	8000a91e <get_dht+0x16a>
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
8000a910:	64 08       	ld.w	r8,r2[0x0]
8000a912:	30 89       	mov	r9,8
8000a914:	91 59       	st.w	r8[0x14],r9
8000a916:	64 08       	ld.w	r8,r2[0x0]
8000a918:	70 08       	ld.w	r8,r8[0x0]
8000a91a:	40 2c       	lddsp	r12,sp[0x8]
8000a91c:	5d 18       	icall	r8

    for (i = 0; i < count; i++)
8000a91e:	58 04       	cp.w	r4,0
8000a920:	e0 8a 00 12 	brle	8000a944 <get_dht+0x190>
8000a924:	30 05       	mov	r5,0
      INPUT_BYTE(cinfo, huffval[i], return FALSE);
8000a926:	58 07       	cp.w	r7,0
8000a928:	c0 71       	brne	8000a936 <get_dht+0x182>
8000a92a:	66 38       	ld.w	r8,r3[0xc]
8000a92c:	04 9c       	mov	r12,r2
8000a92e:	5d 18       	icall	r8
8000a930:	c5 a0       	breq	8000a9e4 <get_dht+0x230>
8000a932:	66 06       	ld.w	r6,r3[0x0]
8000a934:	66 17       	ld.w	r7,r3[0x4]
8000a936:	20 17       	sub	r7,1
8000a938:	0d 38       	ld.ub	r8,r6++
8000a93a:	e2 05 0b 08 	st.b	r1[r5],r8
     * off the end of our table space.  jdhuff.c will check more carefully.
     */
    if (count > 256 || ((INT32) count) > length)
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);

    for (i = 0; i < count; i++)
8000a93e:	2f f5       	sub	r5,-1
8000a940:	08 35       	cp.w	r5,r4
8000a942:	cf 25       	brlt	8000a926 <get_dht+0x172>
      INPUT_BYTE(cinfo, huffval[i], return FALSE);

    length -= count;
8000a944:	40 08       	lddsp	r8,sp[0x0]
8000a946:	08 18       	sub	r8,r4
8000a948:	50 08       	stdsp	sp[0x0],r8

    if (index & 0x10) {		/* AC table definition */
8000a94a:	40 18       	lddsp	r8,sp[0x4]
8000a94c:	e2 18 00 10 	andl	r8,0x10,COH
8000a950:	c0 90       	breq	8000a962 <get_dht+0x1ae>
      index -= 0x10;
8000a952:	40 19       	lddsp	r9,sp[0x4]
8000a954:	21 09       	sub	r9,16
8000a956:	50 19       	stdsp	sp[0x4],r9
      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
8000a958:	12 95       	mov	r5,r9
8000a95a:	2c f5       	sub	r5,-49
8000a95c:	e4 05 00 25 	add	r5,r2,r5<<0x2
8000a960:	c0 58       	rjmp	8000a96a <get_dht+0x1b6>
    } else {			/* DC table definition */
      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
8000a962:	40 15       	lddsp	r5,sp[0x4]
8000a964:	2d 35       	sub	r5,-45
8000a966:	e4 05 00 25 	add	r5,r2,r5<<0x2
    }

    if (index < 0 || index >= NUM_HUFF_TBLS)
8000a96a:	40 18       	lddsp	r8,sp[0x4]
8000a96c:	58 38       	cp.w	r8,3
8000a96e:	e0 88 00 0c 	brls	8000a986 <get_dht+0x1d2>
      ERREXIT1(cinfo, JERR_DHT_INDEX, index);
8000a972:	64 08       	ld.w	r8,r2[0x0]
8000a974:	31 e9       	mov	r9,30
8000a976:	91 59       	st.w	r8[0x14],r9
8000a978:	64 08       	ld.w	r8,r2[0x0]
8000a97a:	40 19       	lddsp	r9,sp[0x4]
8000a97c:	91 69       	st.w	r8[0x18],r9
8000a97e:	64 08       	ld.w	r8,r2[0x0]
8000a980:	70 08       	ld.w	r8,r8[0x0]
8000a982:	40 2c       	lddsp	r12,sp[0x8]
8000a984:	5d 18       	icall	r8

    if (*htblptr == NULL)
8000a986:	6a 08       	ld.w	r8,r5[0x0]
8000a988:	58 08       	cp.w	r8,0
8000a98a:	c0 51       	brne	8000a994 <get_dht+0x1e0>
      *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
8000a98c:	40 2c       	lddsp	r12,sp[0x8]
8000a98e:	f0 1f 00 18 	mcall	8000a9ec <get_dht+0x238>
8000a992:	8b 0c       	st.w	r5[0x0],r12

    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
8000a994:	6a 08       	ld.w	r8,r5[0x0]
8000a996:	fa c9 fe f0 	sub	r9,sp,-272
8000a99a:	f2 ea 00 00 	ld.d	r10,r9[0]
8000a99e:	f0 eb 00 00 	st.d	r8[0],r10
8000a9a2:	f2 ea 00 08 	ld.d	r10,r9[8]
8000a9a6:	f0 eb 00 08 	st.d	r8[8],r10
8000a9aa:	f3 39 00 10 	ld.ub	r9,r9[16]
8000a9ae:	f1 69 00 10 	st.b	r8[16],r9
    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
8000a9b2:	6a 0c       	ld.w	r12,r5[0x0]
8000a9b4:	e0 6a 01 00 	mov	r10,256
8000a9b8:	40 3b       	lddsp	r11,sp[0xc]
8000a9ba:	2e fc       	sub	r12,-17
8000a9bc:	f0 1f 00 0d 	mcall	8000a9f0 <get_dht+0x23c>
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  while (length > 16) {
8000a9c0:	40 08       	lddsp	r8,sp[0x0]
8000a9c2:	59 08       	cp.w	r8,16
8000a9c4:	fe 99 ff 24 	brgt	8000a80c <get_dht+0x58>

    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
  }

  if (length != 0)
8000a9c8:	40 09       	lddsp	r9,sp[0x0]
8000a9ca:	58 09       	cp.w	r9,0
8000a9cc:	c0 80       	breq	8000a9dc <get_dht+0x228>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
8000a9ce:	64 08       	ld.w	r8,r2[0x0]
8000a9d0:	30 b9       	mov	r9,11
8000a9d2:	91 59       	st.w	r8[0x14],r9
8000a9d4:	64 08       	ld.w	r8,r2[0x0]
8000a9d6:	70 08       	ld.w	r8,r8[0x0]
8000a9d8:	04 9c       	mov	r12,r2
8000a9da:	5d 18       	icall	r8

  INPUT_SYNC(cinfo);
8000a9dc:	87 06       	st.w	r3[0x0],r6
8000a9de:	87 17       	st.w	r3[0x4],r7
8000a9e0:	30 1c       	mov	r12,1
  return TRUE;
8000a9e2:	c0 28       	rjmp	8000a9e6 <get_dht+0x232>
8000a9e4:	30 0c       	mov	r12,0
}
8000a9e6:	2b 7d       	sub	sp,-292
8000a9e8:	d8 32       	popm	r0-r7,pc
8000a9ea:	00 00       	add	r0,r0
8000a9ec:	80 00       	ld.sh	r0,r0[0x0]
8000a9ee:	74 ae       	ld.w	lr,r10[0x28]
8000a9f0:	80 01       	ld.sh	r1,r0[0x0]
8000a9f2:	54 ba       	stdsp	sp[0x12c],r10

8000a9f4 <read_markers>:
 * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
{
8000a9f4:	d4 31       	pushm	r0-r7,lr
8000a9f6:	20 3d       	sub	sp,12
8000a9f8:	18 97       	mov	r7,r12
 * Returns same codes as are defined for jpeg_consume_input:
 * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
8000a9fa:	fe fc 07 36 	ld.w	r12,pc[1846]
8000a9fe:	f8 cc ff 00 	sub	r12,r12,-256
8000aa02:	50 1c       	stdsp	sp[0x4],r12
{
  /* Outer loop repeats once for each marker. */
  for (;;) {
    /* Collect the marker proper, unless we already did. */
    /* NB: first_marker() enforces the requirement that SOI appear first. */
    if (cinfo->unread_marker == 0) {
8000aa04:	ee f8 01 a0 	ld.w	r8,r7[416]
8000aa08:	58 08       	cp.w	r8,0
8000aa0a:	c4 31       	brne	8000aa90 <read_markers+0x9c>
      if (! cinfo->marker->saw_SOI) {
8000aa0c:	ee f8 01 b8 	ld.w	r8,r7[440]
8000aa10:	70 38       	ld.w	r8,r8[0xc]
8000aa12:	58 08       	cp.w	r8,0
8000aa14:	c3 91       	brne	8000aa86 <read_markers+0x92>
 * If an application wants to process non-JFIF files, it must seek to the
 * SOI before calling the JPEG library.
 */
{
  int c, c2;
  INPUT_VARS(cinfo);
8000aa16:	6e 66       	ld.w	r6,r7[0x18]
8000aa18:	6c 03       	ld.w	r3,r6[0x0]
8000aa1a:	6c 15       	ld.w	r5,r6[0x4]

  INPUT_BYTE(cinfo, c, return FALSE);
8000aa1c:	58 05       	cp.w	r5,0
8000aa1e:	c0 81       	brne	8000aa2e <read_markers+0x3a>
8000aa20:	6c 38       	ld.w	r8,r6[0xc]
8000aa22:	0e 9c       	mov	r12,r7
8000aa24:	5d 18       	icall	r8
8000aa26:	e0 80 03 82 	breq	8000b12a <read_markers+0x736>
8000aa2a:	6c 03       	ld.w	r3,r6[0x0]
8000aa2c:	6c 15       	ld.w	r5,r6[0x4]
8000aa2e:	20 15       	sub	r5,1
8000aa30:	07 84       	ld.ub	r4,r3[0x0]
  INPUT_BYTE(cinfo, c2, return FALSE);
8000aa32:	c0 30       	breq	8000aa38 <read_markers+0x44>
 */
{
  int c, c2;
  INPUT_VARS(cinfo);

  INPUT_BYTE(cinfo, c, return FALSE);
8000aa34:	2f f3       	sub	r3,-1
8000aa36:	c0 88       	rjmp	8000aa46 <read_markers+0x52>
  INPUT_BYTE(cinfo, c2, return FALSE);
8000aa38:	6c 38       	ld.w	r8,r6[0xc]
8000aa3a:	0e 9c       	mov	r12,r7
8000aa3c:	5d 18       	icall	r8
8000aa3e:	e0 80 03 76 	breq	8000b12a <read_markers+0x736>
8000aa42:	6c 03       	ld.w	r3,r6[0x0]
8000aa44:	6c 15       	ld.w	r5,r6[0x4]
 */
{
  int c, c2;
  INPUT_VARS(cinfo);

  INPUT_BYTE(cinfo, c, return FALSE);
8000aa46:	08 98       	mov	r8,r4
  INPUT_BYTE(cinfo, c2, return FALSE);
8000aa48:	07 84       	ld.ub	r4,r3[0x0]
  if (c != 0xFF || c2 != (int) M_SOI)
8000aa4a:	e0 48 00 ff 	cp.w	r8,255
8000aa4e:	5f 1a       	srne	r10
8000aa50:	e0 44 00 d8 	cp.w	r4,216
8000aa54:	5f 19       	srne	r9
8000aa56:	f5 e9 10 09 	or	r9,r10,r9
8000aa5a:	30 0a       	mov	r10,0
8000aa5c:	f4 09 18 00 	cp.b	r9,r10
8000aa60:	c0 c0       	breq	8000aa78 <read_markers+0x84>
    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);
8000aa62:	6e 09       	ld.w	r9,r7[0x0]
8000aa64:	33 5a       	mov	r10,53
8000aa66:	93 5a       	st.w	r9[0x14],r10
8000aa68:	6e 09       	ld.w	r9,r7[0x0]
8000aa6a:	93 68       	st.w	r9[0x18],r8
8000aa6c:	6e 08       	ld.w	r8,r7[0x0]
8000aa6e:	91 74       	st.w	r8[0x1c],r4
8000aa70:	6e 08       	ld.w	r8,r7[0x0]
8000aa72:	70 08       	ld.w	r8,r8[0x0]
8000aa74:	0e 9c       	mov	r12,r7
8000aa76:	5d 18       	icall	r8

  cinfo->unread_marker = c2;
8000aa78:	ef 44 01 a0 	st.w	r7[416],r4

  INPUT_SYNC(cinfo);
8000aa7c:	2f f3       	sub	r3,-1
8000aa7e:	8d 03       	st.w	r6[0x0],r3
8000aa80:	20 15       	sub	r5,1
8000aa82:	8d 15       	st.w	r6[0x4],r5
8000aa84:	c0 68       	rjmp	8000aa90 <read_markers+0x9c>
    if (cinfo->unread_marker == 0) {
      if (! cinfo->marker->saw_SOI) {
	if (! first_marker(cinfo))
	  return JPEG_SUSPENDED;
      } else {
	if (! next_marker(cinfo))
8000aa86:	0e 9c       	mov	r12,r7
8000aa88:	f0 1f 01 ab 	mcall	8000b134 <read_markers+0x740>
8000aa8c:	e0 80 03 4f 	breq	8000b12a <read_markers+0x736>
    }
    /* At this point cinfo->unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo->unread_marker) {
8000aa90:	ee f8 01 a0 	ld.w	r8,r7[416]
8000aa94:	e0 48 00 cf 	cp.w	r8,207
8000aa98:	e0 89 00 2f 	brgt	8000aaf6 <read_markers+0x102>
8000aa9c:	e0 48 00 cd 	cp.w	r8,205
8000aaa0:	e0 84 00 bd 	brge	8000ac1a <read_markers+0x226>
8000aaa4:	e0 48 00 c4 	cp.w	r8,196
8000aaa8:	e0 80 01 e5 	breq	8000ae72 <read_markers+0x47e>
8000aaac:	e0 89 00 18 	brgt	8000aadc <read_markers+0xe8>
8000aab0:	e0 48 00 c1 	cp.w	r8,193
8000aab4:	e0 89 00 0b 	brgt	8000aaca <read_markers+0xd6>
8000aab8:	e0 48 00 c0 	cp.w	r8,192
8000aabc:	e0 84 00 8b 	brge	8000abd2 <read_markers+0x1de>
8000aac0:	58 18       	cp.w	r8,1
8000aac2:	e0 81 03 24 	brne	8000b10a <read_markers+0x716>
8000aac6:	e0 8f 03 10 	bral	8000b0e6 <read_markers+0x6f2>
8000aaca:	e0 48 00 c2 	cp.w	r8,194
8000aace:	e0 80 00 8b 	breq	8000abe4 <read_markers+0x1f0>
8000aad2:	e0 48 00 c3 	cp.w	r8,195
8000aad6:	e0 81 03 1a 	brne	8000b10a <read_markers+0x716>
8000aada:	ca 08       	rjmp	8000ac1a <read_markers+0x226>
8000aadc:	e0 48 00 c9 	cp.w	r8,201
8000aae0:	e0 80 00 8b 	breq	8000abf6 <read_markers+0x202>
8000aae4:	e0 85 00 9b 	brlt	8000ac1a <read_markers+0x226>
8000aae8:	e0 48 00 cb 	cp.w	r8,203
8000aaec:	e0 80 00 97 	breq	8000ac1a <read_markers+0x226>
8000aaf0:	e0 89 01 bb 	brgt	8000ae66 <read_markers+0x472>
8000aaf4:	c8 a8       	rjmp	8000ac08 <read_markers+0x214>
8000aaf6:	e0 48 00 db 	cp.w	r8,219
8000aafa:	e0 80 01 c2 	breq	8000ae7e <read_markers+0x48a>
8000aafe:	e0 89 00 10 	brgt	8000ab1e <read_markers+0x12a>
8000ab02:	e0 48 00 d8 	cp.w	r8,216
8000ab06:	c2 40       	breq	8000ab4e <read_markers+0x15a>
8000ab08:	e0 85 02 ef 	brlt	8000b0e6 <read_markers+0x6f2>
8000ab0c:	e0 48 00 d9 	cp.w	r8,217
8000ab10:	e0 80 01 9e 	breq	8000ae4c <read_markers+0x458>
8000ab14:	e0 48 00 da 	cp.w	r8,218
8000ab18:	e0 81 02 f9 	brne	8000b10a <read_markers+0x716>
8000ab1c:	c8 c8       	rjmp	8000ac34 <read_markers+0x240>
8000ab1e:	e0 48 00 ef 	cp.w	r8,239
8000ab22:	e0 89 00 10 	brgt	8000ab42 <read_markers+0x14e>
8000ab26:	e0 48 00 e0 	cp.w	r8,224
8000ab2a:	e0 84 02 cd 	brge	8000b0c4 <read_markers+0x6d0>
8000ab2e:	e0 48 00 dc 	cp.w	r8,220
8000ab32:	e0 80 02 e7 	breq	8000b100 <read_markers+0x70c>
8000ab36:	e0 48 00 dd 	cp.w	r8,221
8000ab3a:	e0 81 02 e8 	brne	8000b10a <read_markers+0x716>
8000ab3e:	e0 8f 02 75 	bral	8000b028 <read_markers+0x634>
8000ab42:	e0 48 00 fe 	cp.w	r8,254
8000ab46:	e0 81 02 e2 	brne	8000b10a <read_markers+0x716>
8000ab4a:	e0 8f 02 c7 	bral	8000b0d8 <read_markers+0x6e4>
get_soi (j_decompress_ptr cinfo)
/* Process an SOI marker */
{
  int i;

  TRACEMS(cinfo, 1, JTRC_SOI);
8000ab4e:	6e 08       	ld.w	r8,r7[0x0]
8000ab50:	36 69       	mov	r9,102
8000ab52:	91 59       	st.w	r8[0x14],r9
8000ab54:	0e 96       	mov	r6,r7
8000ab56:	6e 08       	ld.w	r8,r7[0x0]
8000ab58:	70 18       	ld.w	r8,r8[0x4]
8000ab5a:	30 1b       	mov	r11,1
8000ab5c:	0e 9c       	mov	r12,r7
8000ab5e:	5d 18       	icall	r8

  if (cinfo->marker->saw_SOI)
8000ab60:	ee f8 01 b8 	ld.w	r8,r7[440]
8000ab64:	70 38       	ld.w	r8,r8[0xc]
8000ab66:	58 08       	cp.w	r8,0
8000ab68:	c0 80       	breq	8000ab78 <read_markers+0x184>
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);
8000ab6a:	6e 08       	ld.w	r8,r7[0x0]
8000ab6c:	33 d9       	mov	r9,61
8000ab6e:	91 59       	st.w	r8[0x14],r9
8000ab70:	6e 08       	ld.w	r8,r7[0x0]
8000ab72:	70 08       	ld.w	r8,r8[0x0]
8000ab74:	0e 9c       	mov	r12,r7
8000ab76:	5d 18       	icall	r8
8000ab78:	ee c8 ff 1c 	sub	r8,r7,-228
8000ab7c:	30 09       	mov	r9,0

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    cinfo->arith_dc_L[i] = 0;
    cinfo->arith_dc_U[i] = 1;
8000ab7e:	30 1b       	mov	r11,1
    cinfo->arith_ac_K[i] = 5;
8000ab80:	30 5a       	mov	r10,5
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    cinfo->arith_dc_L[i] = 0;
8000ab82:	30 0c       	mov	r12,0
8000ab84:	b0 8c       	st.b	r8[0x0],r12
    cinfo->arith_dc_U[i] = 1;
8000ab86:	f1 6b 00 10 	st.b	r8[16],r11
    cinfo->arith_ac_K[i] = 5;
8000ab8a:	f1 6a 00 20 	st.b	r8[32],r10
  if (cinfo->marker->saw_SOI)
    ERREXIT(cinfo, JERR_SOI_DUPLICATE);

  /* Reset all parameters that are defined to be reset by SOI */

  for (i = 0; i < NUM_ARITH_TBLS; i++) {
8000ab8e:	2f f9       	sub	r9,-1
8000ab90:	2f f8       	sub	r8,-1
8000ab92:	59 09       	cp.w	r9,16
8000ab94:	cf 71       	brne	8000ab82 <read_markers+0x18e>
    cinfo->arith_dc_L[i] = 0;
    cinfo->arith_dc_U[i] = 1;
    cinfo->arith_ac_K[i] = 5;
  }
  cinfo->restart_interval = 0;
8000ab96:	30 08       	mov	r8,0
8000ab98:	ef 48 01 14 	st.w	r7[276],r8

  /* Set initial assumptions for colorspace etc */

  cinfo->jpeg_color_space = JCS_UNKNOWN;
8000ab9c:	8f a8       	st.w	r7[0x28],r8
  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */
8000ab9e:	ef 48 01 2c 	st.w	r7[300],r8

  cinfo->saw_JFIF_marker = FALSE;
8000aba2:	ef 48 01 18 	st.w	r7[280],r8
  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */
8000aba6:	30 19       	mov	r9,1
8000aba8:	ef 69 01 1c 	st.b	r7[284],r9
  cinfo->JFIF_minor_version = 1;
8000abac:	ef 69 01 1d 	st.b	r7[285],r9
  cinfo->density_unit = 0;
8000abb0:	ef 68 01 1e 	st.b	r7[286],r8
  cinfo->X_density = 1;
8000abb4:	30 19       	mov	r9,1
8000abb6:	ef 59 01 20 	st.h	r7[288],r9
  cinfo->Y_density = 1;
8000abba:	ef 59 01 22 	st.h	r7[290],r9
  cinfo->saw_Adobe_marker = FALSE;
8000abbe:	ef 48 01 24 	st.w	r7[292],r8
  cinfo->Adobe_transform = 0;
8000abc2:	ef 68 01 28 	st.b	r7[296],r8

  cinfo->marker->saw_SOI = TRUE;
8000abc6:	ee f8 01 b8 	ld.w	r8,r7[440]
8000abca:	30 19       	mov	r9,1
8000abcc:	91 39       	st.w	r8[0xc],r9
8000abce:	e0 8f 02 a9 	bral	8000b120 <read_markers+0x72c>
	return JPEG_SUSPENDED;
      break;

    case M_SOF0:		/* Baseline */
    case M_SOF1:		/* Extended sequential, Huffman */
      if (! get_sof(cinfo, FALSE, FALSE))
8000abd2:	30 0a       	mov	r10,0
8000abd4:	14 9b       	mov	r11,r10
8000abd6:	0e 9c       	mov	r12,r7
8000abd8:	f0 1f 01 58 	mcall	8000b138 <read_markers+0x744>
8000abdc:	e0 81 02 a2 	brne	8000b120 <read_markers+0x72c>
8000abe0:	e0 8f 02 a5 	bral	8000b12a <read_markers+0x736>
	return JPEG_SUSPENDED;
      break;

    case M_SOF2:		/* Progressive, Huffman */
      if (! get_sof(cinfo, TRUE, FALSE))
8000abe4:	30 0a       	mov	r10,0
8000abe6:	30 1b       	mov	r11,1
8000abe8:	0e 9c       	mov	r12,r7
8000abea:	f0 1f 01 54 	mcall	8000b138 <read_markers+0x744>
8000abee:	e0 81 02 99 	brne	8000b120 <read_markers+0x72c>
8000abf2:	e0 8f 02 9c 	bral	8000b12a <read_markers+0x736>
	return JPEG_SUSPENDED;
      break;

    case M_SOF9:		/* Extended sequential, arithmetic */
      if (! get_sof(cinfo, FALSE, TRUE))
8000abf6:	30 1a       	mov	r10,1
8000abf8:	30 0b       	mov	r11,0
8000abfa:	0e 9c       	mov	r12,r7
8000abfc:	f0 1f 01 4f 	mcall	8000b138 <read_markers+0x744>
8000ac00:	e0 81 02 90 	brne	8000b120 <read_markers+0x72c>
8000ac04:	e0 8f 02 93 	bral	8000b12a <read_markers+0x736>
	return JPEG_SUSPENDED;
      break;

    case M_SOF10:		/* Progressive, arithmetic */
      if (! get_sof(cinfo, TRUE, TRUE))
8000ac08:	30 1a       	mov	r10,1
8000ac0a:	14 9b       	mov	r11,r10
8000ac0c:	0e 9c       	mov	r12,r7
8000ac0e:	f0 1f 01 4b 	mcall	8000b138 <read_markers+0x744>
8000ac12:	e0 81 02 87 	brne	8000b120 <read_markers+0x72c>
8000ac16:	e0 8f 02 8a 	bral	8000b12a <read_markers+0x736>
    case M_JPG:			/* Reserved for JPEG extensions */
    case M_SOF11:		/* Lossless, arithmetic */
    case M_SOF13:		/* Differential sequential, arithmetic */
    case M_SOF14:		/* Differential progressive, arithmetic */
    case M_SOF15:		/* Differential lossless, arithmetic */
      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
8000ac1a:	6e 08       	ld.w	r8,r7[0x0]
8000ac1c:	33 c9       	mov	r9,60
8000ac1e:	91 59       	st.w	r8[0x14],r9
8000ac20:	6e 08       	ld.w	r8,r7[0x0]
8000ac22:	ee f9 01 a0 	ld.w	r9,r7[416]
8000ac26:	91 69       	st.w	r8[0x18],r9
8000ac28:	6e 08       	ld.w	r8,r7[0x0]
8000ac2a:	70 08       	ld.w	r8,r8[0x0]
8000ac2c:	0e 9c       	mov	r12,r7
8000ac2e:	5d 18       	icall	r8
      break;
8000ac30:	e0 8f 02 78 	bral	8000b120 <read_markers+0x72c>
/* Process a SOS marker */
{
  INT32 length;
  int i, ci, n, c, cc;
  jpeg_component_info * compptr;
  INPUT_VARS(cinfo);
8000ac34:	6e 60       	ld.w	r0,r7[0x18]
8000ac36:	60 05       	ld.w	r5,r0[0x0]
8000ac38:	60 16       	ld.w	r6,r0[0x4]

  if (! cinfo->marker->saw_SOF)
8000ac3a:	ee f8 01 b8 	ld.w	r8,r7[440]
8000ac3e:	70 48       	ld.w	r8,r8[0x10]
8000ac40:	58 08       	cp.w	r8,0
8000ac42:	c0 81       	brne	8000ac52 <read_markers+0x25e>
    ERREXIT(cinfo, JERR_SOS_NO_SOF);
8000ac44:	6e 08       	ld.w	r8,r7[0x0]
8000ac46:	33 e9       	mov	r9,62
8000ac48:	91 59       	st.w	r8[0x14],r9
8000ac4a:	6e 08       	ld.w	r8,r7[0x0]
8000ac4c:	70 08       	ld.w	r8,r8[0x0]
8000ac4e:	0e 9c       	mov	r12,r7
8000ac50:	5d 18       	icall	r8

  INPUT_2BYTES(cinfo, length, return FALSE);
8000ac52:	58 06       	cp.w	r6,0
8000ac54:	c0 81       	brne	8000ac64 <read_markers+0x270>
8000ac56:	60 38       	ld.w	r8,r0[0xc]
8000ac58:	0e 9c       	mov	r12,r7
8000ac5a:	5d 18       	icall	r8
8000ac5c:	e0 80 02 67 	breq	8000b12a <read_markers+0x736>
8000ac60:	60 05       	ld.w	r5,r0[0x0]
8000ac62:	60 16       	ld.w	r6,r0[0x4]
8000ac64:	20 16       	sub	r6,1
8000ac66:	0b 82       	ld.ub	r2,r5[0x0]
8000ac68:	c0 30       	breq	8000ac6e <read_markers+0x27a>
8000ac6a:	2f f5       	sub	r5,-1
8000ac6c:	c0 88       	rjmp	8000ac7c <read_markers+0x288>
8000ac6e:	60 38       	ld.w	r8,r0[0xc]
8000ac70:	0e 9c       	mov	r12,r7
8000ac72:	5d 18       	icall	r8
8000ac74:	e0 80 02 5b 	breq	8000b12a <read_markers+0x736>
8000ac78:	60 05       	ld.w	r5,r0[0x0]
8000ac7a:	60 16       	ld.w	r6,r0[0x4]
8000ac7c:	ec c3 00 01 	sub	r3,r6,1
8000ac80:	0b 86       	ld.ub	r6,r5[0x0]

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */
8000ac82:	c0 40       	breq	8000ac8a <read_markers+0x296>
  INPUT_VARS(cinfo);

  if (! cinfo->marker->saw_SOF)
    ERREXIT(cinfo, JERR_SOS_NO_SOF);

  INPUT_2BYTES(cinfo, length, return FALSE);
8000ac84:	ea c4 ff ff 	sub	r4,r5,-1
8000ac88:	c0 88       	rjmp	8000ac98 <read_markers+0x2a4>

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */
8000ac8a:	60 38       	ld.w	r8,r0[0xc]
8000ac8c:	0e 9c       	mov	r12,r7
8000ac8e:	5d 18       	icall	r8
8000ac90:	e0 80 02 4d 	breq	8000b12a <read_markers+0x736>
8000ac94:	60 04       	ld.w	r4,r0[0x0]
8000ac96:	60 13       	ld.w	r3,r0[0x4]
8000ac98:	20 13       	sub	r3,1
8000ac9a:	09 3a       	ld.ub	r10,r4++
8000ac9c:	50 2a       	stdsp	sp[0x8],r10

  TRACEMS1(cinfo, 1, JTRC_SOS, n);
8000ac9e:	6e 08       	ld.w	r8,r7[0x0]
8000aca0:	36 79       	mov	r9,103
8000aca2:	91 59       	st.w	r8[0x14],r9
8000aca4:	6e 08       	ld.w	r8,r7[0x0]
8000aca6:	91 6a       	st.w	r8[0x18],r10
8000aca8:	50 17       	stdsp	sp[0x4],r7
8000acaa:	6e 08       	ld.w	r8,r7[0x0]
8000acac:	70 18       	ld.w	r8,r8[0x4]
8000acae:	30 1b       	mov	r11,1
8000acb0:	0e 9c       	mov	r12,r7
8000acb2:	5d 18       	icall	r8
  INPUT_VARS(cinfo);

  if (! cinfo->marker->saw_SOF)
    ERREXIT(cinfo, JERR_SOS_NO_SOF);

  INPUT_2BYTES(cinfo, length, return FALSE);
8000acb4:	a9 62       	lsl	r2,0x8

  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */

  TRACEMS1(cinfo, 1, JTRC_SOS, n);

  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)
8000acb6:	04 06       	add	r6,r2
8000acb8:	40 28       	lddsp	r8,sp[0x8]
8000acba:	2f d8       	sub	r8,-3
8000acbc:	a1 78       	lsl	r8,0x1
8000acbe:	10 36       	cp.w	r6,r8
8000acc0:	5f 19       	srne	r9
8000acc2:	40 28       	lddsp	r8,sp[0x8]
8000acc4:	58 08       	cp.w	r8,0
8000acc6:	5f a8       	srle	r8
8000acc8:	f3 e8 10 08 	or	r8,r9,r8
8000accc:	c0 51       	brne	8000acd6 <read_markers+0x2e2>
8000acce:	40 2c       	lddsp	r12,sp[0x8]
8000acd0:	58 4c       	cp.w	r12,4
8000acd2:	e0 8a 00 09 	brle	8000ace4 <read_markers+0x2f0>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
8000acd6:	6e 08       	ld.w	r8,r7[0x0]
8000acd8:	30 b9       	mov	r9,11
8000acda:	91 59       	st.w	r8[0x14],r9
8000acdc:	6e 08       	ld.w	r8,r7[0x0]
8000acde:	70 08       	ld.w	r8,r8[0x0]
8000ace0:	40 1c       	lddsp	r12,sp[0x4]
8000ace2:	5d 18       	icall	r8

  cinfo->comps_in_scan = n;
8000ace4:	40 2a       	lddsp	r10,sp[0x8]
8000ace6:	ef 4a 01 48 	st.w	r7[328],r10

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
8000acea:	58 0a       	cp.w	r10,0
8000acec:	e0 8a 00 58 	brle	8000ad9c <read_markers+0x3a8>
8000acf0:	ee c9 fe b4 	sub	r9,r7,-332
8000acf4:	50 09       	stdsp	sp[0x0],r9
8000acf6:	30 02       	mov	r2,0

    cinfo->cur_comp_info[i] = compptr;
    compptr->dc_tbl_no = (c >> 4) & 15;
    compptr->ac_tbl_no = (c     ) & 15;

    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
8000acf8:	0e 95       	mov	r5,r7
  cinfo->comps_in_scan = n;

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
    INPUT_BYTE(cinfo, cc, return FALSE);
8000acfa:	58 03       	cp.w	r3,0
8000acfc:	c0 81       	brne	8000ad0c <read_markers+0x318>
8000acfe:	60 38       	ld.w	r8,r0[0xc]
8000ad00:	0a 9c       	mov	r12,r5
8000ad02:	5d 18       	icall	r8
8000ad04:	e0 80 02 13 	breq	8000b12a <read_markers+0x736>
8000ad08:	60 04       	ld.w	r4,r0[0x0]
8000ad0a:	60 13       	ld.w	r3,r0[0x4]
8000ad0c:	20 13       	sub	r3,1
8000ad0e:	09 86       	ld.ub	r6,r4[0x0]
    INPUT_BYTE(cinfo, c, return FALSE);
8000ad10:	c0 30       	breq	8000ad16 <read_markers+0x322>
  cinfo->comps_in_scan = n;

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
    INPUT_BYTE(cinfo, cc, return FALSE);
8000ad12:	2f f4       	sub	r4,-1
8000ad14:	c0 88       	rjmp	8000ad24 <read_markers+0x330>
    INPUT_BYTE(cinfo, c, return FALSE);
8000ad16:	60 38       	ld.w	r8,r0[0xc]
8000ad18:	0a 9c       	mov	r12,r5
8000ad1a:	5d 18       	icall	r8
8000ad1c:	e0 80 02 07 	breq	8000b12a <read_markers+0x736>
8000ad20:	60 04       	ld.w	r4,r0[0x0]
8000ad22:	60 13       	ld.w	r3,r0[0x4]
8000ad24:	20 13       	sub	r3,1
8000ad26:	09 31       	ld.ub	r1,r4++

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000ad28:	ea f7 00 d8 	ld.w	r7,r5[216]
8000ad2c:	6a 9a       	ld.w	r10,r5[0x24]
8000ad2e:	58 0a       	cp.w	r10,0
8000ad30:	e0 8a 00 0e 	brle	8000ad4c <read_markers+0x358>
	 ci++, compptr++) {
      if (cc == compptr->component_id)
8000ad34:	6e 08       	ld.w	r8,r7[0x0]
8000ad36:	10 36       	cp.w	r6,r8
8000ad38:	c1 30       	breq	8000ad5e <read_markers+0x36a>
8000ad3a:	30 08       	mov	r8,0
8000ad3c:	c0 48       	rjmp	8000ad44 <read_markers+0x350>
8000ad3e:	6e 09       	ld.w	r9,r7[0x0]
8000ad40:	12 36       	cp.w	r6,r9
8000ad42:	c0 e0       	breq	8000ad5e <read_markers+0x36a>
  for (i = 0; i < n; i++) {
    INPUT_BYTE(cinfo, cc, return FALSE);
    INPUT_BYTE(cinfo, c, return FALSE);

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
8000ad44:	2f f8       	sub	r8,-1
8000ad46:	2a c7       	sub	r7,-84

  for (i = 0; i < n; i++) {
    INPUT_BYTE(cinfo, cc, return FALSE);
    INPUT_BYTE(cinfo, c, return FALSE);

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000ad48:	14 38       	cp.w	r8,r10
8000ad4a:	cf a5       	brlt	8000ad3e <read_markers+0x34a>
	 ci++, compptr++) {
      if (cc == compptr->component_id)
	goto id_found;
    }

    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);
8000ad4c:	6a 08       	ld.w	r8,r5[0x0]
8000ad4e:	30 5c       	mov	r12,5
8000ad50:	91 5c       	st.w	r8[0x14],r12
8000ad52:	6a 08       	ld.w	r8,r5[0x0]
8000ad54:	91 66       	st.w	r8[0x18],r6
8000ad56:	6a 08       	ld.w	r8,r5[0x0]
8000ad58:	70 08       	ld.w	r8,r8[0x0]
8000ad5a:	40 1c       	lddsp	r12,sp[0x4]
8000ad5c:	5d 18       	icall	r8

  id_found:

    cinfo->cur_comp_info[i] = compptr;
8000ad5e:	40 0a       	lddsp	r10,sp[0x0]
8000ad60:	14 a7       	st.w	r10++,r7
8000ad62:	50 0a       	stdsp	sp[0x0],r10
    compptr->dc_tbl_no = (c >> 4) & 15;
8000ad64:	e2 08 16 04 	lsr	r8,r1,0x4
8000ad68:	8f 58       	st.w	r7[0x14],r8
    compptr->ac_tbl_no = (c     ) & 15;
8000ad6a:	e3 d1 c0 04 	bfextu	r1,r1,0x0,0x4
8000ad6e:	8f 61       	st.w	r7[0x18],r1

    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
8000ad70:	6a 09       	ld.w	r9,r5[0x0]
8000ad72:	f2 c8 ff e8 	sub	r8,r9,-24
8000ad76:	93 66       	st.w	r9[0x18],r6
8000ad78:	6e 59       	ld.w	r9,r7[0x14]
8000ad7a:	91 19       	st.w	r8[0x4],r9
8000ad7c:	6e 69       	ld.w	r9,r7[0x18]
8000ad7e:	91 29       	st.w	r8[0x8],r9
8000ad80:	6a 08       	ld.w	r8,r5[0x0]
8000ad82:	36 89       	mov	r9,104
8000ad84:	91 59       	st.w	r8[0x14],r9
8000ad86:	6a 08       	ld.w	r8,r5[0x0]
8000ad88:	70 18       	ld.w	r8,r8[0x4]
8000ad8a:	30 1b       	mov	r11,1
8000ad8c:	40 1c       	lddsp	r12,sp[0x4]
8000ad8e:	5d 18       	icall	r8

  cinfo->comps_in_scan = n;

  /* Collect the component-spec parameters */

  for (i = 0; i < n; i++) {
8000ad90:	2f f2       	sub	r2,-1
8000ad92:	40 28       	lddsp	r8,sp[0x8]
8000ad94:	04 38       	cp.w	r8,r2
8000ad96:	fe 99 ff b2 	brgt	8000acfa <read_markers+0x306>
8000ad9a:	0a 97       	mov	r7,r5
    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
	     compptr->dc_tbl_no, compptr->ac_tbl_no);
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
8000ad9c:	58 03       	cp.w	r3,0
8000ad9e:	c0 81       	brne	8000adae <read_markers+0x3ba>
8000ada0:	60 38       	ld.w	r8,r0[0xc]
8000ada2:	0e 9c       	mov	r12,r7
8000ada4:	5d 18       	icall	r8
8000ada6:	e0 80 01 c2 	breq	8000b12a <read_markers+0x736>
8000adaa:	60 04       	ld.w	r4,r0[0x0]
8000adac:	60 13       	ld.w	r3,r0[0x4]
8000adae:	e6 c6 00 01 	sub	r6,r3,1
  cinfo->Ss = c;
8000adb2:	09 88       	ld.ub	r8,r4[0x0]
8000adb4:	ef 48 01 90 	st.w	r7[400],r8
  INPUT_BYTE(cinfo, c, return FALSE);
8000adb8:	c0 30       	breq	8000adbe <read_markers+0x3ca>
    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
	     compptr->dc_tbl_no, compptr->ac_tbl_no);
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
8000adba:	2f f4       	sub	r4,-1
8000adbc:	c0 88       	rjmp	8000adcc <read_markers+0x3d8>
  cinfo->Ss = c;
  INPUT_BYTE(cinfo, c, return FALSE);
8000adbe:	60 38       	ld.w	r8,r0[0xc]
8000adc0:	0e 9c       	mov	r12,r7
8000adc2:	5d 18       	icall	r8
8000adc4:	e0 80 01 b3 	breq	8000b12a <read_markers+0x736>
8000adc8:	60 04       	ld.w	r4,r0[0x0]
8000adca:	60 16       	ld.w	r6,r0[0x4]
8000adcc:	20 16       	sub	r6,1
  cinfo->Se = c;
8000adce:	09 88       	ld.ub	r8,r4[0x0]
8000add0:	ef 48 01 94 	st.w	r7[404],r8
  INPUT_BYTE(cinfo, c, return FALSE);
8000add4:	c0 40       	breq	8000addc <read_markers+0x3e8>
  }

  /* Collect the additional scan parameters Ss, Se, Ah/Al. */
  INPUT_BYTE(cinfo, c, return FALSE);
  cinfo->Ss = c;
  INPUT_BYTE(cinfo, c, return FALSE);
8000add6:	e8 c5 ff ff 	sub	r5,r4,-1
8000adda:	c0 88       	rjmp	8000adea <read_markers+0x3f6>
  cinfo->Se = c;
  INPUT_BYTE(cinfo, c, return FALSE);
8000addc:	60 38       	ld.w	r8,r0[0xc]
8000adde:	0e 9c       	mov	r12,r7
8000ade0:	5d 18       	icall	r8
8000ade2:	e0 80 01 a4 	breq	8000b12a <read_markers+0x736>
8000ade6:	60 05       	ld.w	r5,r0[0x0]
8000ade8:	60 16       	ld.w	r6,r0[0x4]
8000adea:	0b 38       	ld.ub	r8,r5++
  cinfo->Ah = (c >> 4) & 15;
8000adec:	f0 09 16 04 	lsr	r9,r8,0x4
8000adf0:	ef 49 01 98 	st.w	r7[408],r9
  cinfo->Al = (c     ) & 15;
8000adf4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000adf8:	ef 48 01 9c 	st.w	r7[412],r8

  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
8000adfc:	6e 09       	ld.w	r9,r7[0x0]
8000adfe:	f2 c8 ff e8 	sub	r8,r9,-24
8000ae02:	ee fa 01 90 	ld.w	r10,r7[400]
8000ae06:	93 6a       	st.w	r9[0x18],r10
8000ae08:	ee f9 01 94 	ld.w	r9,r7[404]
8000ae0c:	91 19       	st.w	r8[0x4],r9
8000ae0e:	ee f9 01 98 	ld.w	r9,r7[408]
8000ae12:	91 29       	st.w	r8[0x8],r9
8000ae14:	ee f9 01 9c 	ld.w	r9,r7[412]
8000ae18:	91 39       	st.w	r8[0xc],r9
8000ae1a:	6e 08       	ld.w	r8,r7[0x0]
8000ae1c:	36 99       	mov	r9,105
8000ae1e:	91 59       	st.w	r8[0x14],r9
8000ae20:	6e 08       	ld.w	r8,r7[0x0]
8000ae22:	70 18       	ld.w	r8,r8[0x4]
8000ae24:	30 1b       	mov	r11,1
8000ae26:	40 1c       	lddsp	r12,sp[0x4]
8000ae28:	5d 18       	icall	r8
	   cinfo->Ah, cinfo->Al);

  /* Prepare to scan data & restart markers */
  cinfo->marker->next_restart_num = 0;
8000ae2a:	ee f9 01 b8 	ld.w	r9,r7[440]
8000ae2e:	30 08       	mov	r8,0
8000ae30:	93 58       	st.w	r9[0x14],r8

  /* Count another SOS marker */
  cinfo->input_scan_number++;
8000ae32:	ee f9 00 90 	ld.w	r9,r7[144]
8000ae36:	2f f9       	sub	r9,-1
8000ae38:	ef 49 00 90 	st.w	r7[144],r9

  INPUT_SYNC(cinfo);
8000ae3c:	81 05       	st.w	r0[0x0],r5
8000ae3e:	20 16       	sub	r6,1
8000ae40:	81 16       	st.w	r0[0x4],r6
      break;

    case M_SOS:
      if (! get_sos(cinfo))
	return JPEG_SUSPENDED;
      cinfo->unread_marker = 0;	/* processed the marker */
8000ae42:	ef 48 01 a0 	st.w	r7[416],r8
8000ae46:	30 1c       	mov	r12,1
      return JPEG_REACHED_SOS;
8000ae48:	e0 8f 01 72 	bral	8000b12c <read_markers+0x738>

    case M_EOI:
      TRACEMS(cinfo, 1, JTRC_EOI);
8000ae4c:	6e 08       	ld.w	r8,r7[0x0]
8000ae4e:	35 59       	mov	r9,85
8000ae50:	91 59       	st.w	r8[0x14],r9
8000ae52:	6e 08       	ld.w	r8,r7[0x0]
8000ae54:	70 18       	ld.w	r8,r8[0x4]
8000ae56:	30 1b       	mov	r11,1
8000ae58:	0e 9c       	mov	r12,r7
8000ae5a:	5d 18       	icall	r8
      cinfo->unread_marker = 0;	/* processed the marker */
8000ae5c:	30 08       	mov	r8,0
8000ae5e:	ef 48 01 a0 	st.w	r7[416],r8
8000ae62:	30 2c       	mov	r12,2
      return JPEG_REACHED_EOI;
8000ae64:	c6 49       	rjmp	8000b12c <read_markers+0x738>

    case M_DAC:
      if (! get_dac(cinfo))
8000ae66:	0e 9c       	mov	r12,r7
8000ae68:	f0 1f 00 b5 	mcall	8000b13c <read_markers+0x748>
8000ae6c:	e0 81 01 5a 	brne	8000b120 <read_markers+0x72c>
8000ae70:	c5 d9       	rjmp	8000b12a <read_markers+0x736>
	return JPEG_SUSPENDED;
      break;

    case M_DHT:
      if (! get_dht(cinfo))
8000ae72:	0e 9c       	mov	r12,r7
8000ae74:	f0 1f 00 b3 	mcall	8000b140 <read_markers+0x74c>
8000ae78:	e0 81 01 54 	brne	8000b120 <read_markers+0x72c>
8000ae7c:	c5 79       	rjmp	8000b12a <read_markers+0x736>
{
  INT32 length;
  int n, i, prec;
  unsigned int tmp;
  JQUANT_TBL *quant_ptr;
  INPUT_VARS(cinfo);
8000ae7e:	6e 63       	ld.w	r3,r7[0x18]
8000ae80:	66 09       	ld.w	r9,r3[0x0]
8000ae82:	66 18       	ld.w	r8,r3[0x4]

  INPUT_2BYTES(cinfo, length, return FALSE);
8000ae84:	58 08       	cp.w	r8,0
8000ae86:	c0 81       	brne	8000ae96 <read_markers+0x4a2>
8000ae88:	66 38       	ld.w	r8,r3[0xc]
8000ae8a:	0e 9c       	mov	r12,r7
8000ae8c:	5d 18       	icall	r8
8000ae8e:	e0 80 01 4e 	breq	8000b12a <read_markers+0x736>
8000ae92:	66 09       	ld.w	r9,r3[0x0]
8000ae94:	66 18       	ld.w	r8,r3[0x4]
8000ae96:	20 18       	sub	r8,1
8000ae98:	13 84       	ld.ub	r4,r9[0x0]
8000ae9a:	c0 30       	breq	8000aea0 <read_markers+0x4ac>
8000ae9c:	2f f9       	sub	r9,-1
8000ae9e:	c0 88       	rjmp	8000aeae <read_markers+0x4ba>
8000aea0:	66 38       	ld.w	r8,r3[0xc]
8000aea2:	0e 9c       	mov	r12,r7
8000aea4:	5d 18       	icall	r8
8000aea6:	e0 80 01 42 	breq	8000b12a <read_markers+0x736>
8000aeaa:	66 09       	ld.w	r9,r3[0x0]
8000aeac:	66 18       	ld.w	r8,r3[0x4]
8000aeae:	f0 c5 00 01 	sub	r5,r8,1
8000aeb2:	f2 c6 ff ff 	sub	r6,r9,-1
8000aeb6:	e8 0a 15 08 	lsl	r10,r4,0x8
8000aeba:	20 2a       	sub	r10,2
  length -= 2;
8000aebc:	13 88       	ld.ub	r8,r9[0x0]
8000aebe:	f4 08 00 08 	add	r8,r10,r8
8000aec2:	50 08       	stdsp	sp[0x0],r8

  while (length > 0) {
8000aec4:	58 08       	cp.w	r8,0
8000aec6:	e0 8a 00 a4 	brle	8000b00e <read_markers+0x61a>
      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
    }

    if (cinfo->err->trace_level >= 2) {
      for (i = 0; i < DCTSIZE2; i += 8) {
	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
8000aeca:	0e 94       	mov	r4,r7

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  while (length > 0) {
    INPUT_BYTE(cinfo, n, return FALSE);
8000aecc:	58 05       	cp.w	r5,0
8000aece:	c0 81       	brne	8000aede <read_markers+0x4ea>
8000aed0:	66 38       	ld.w	r8,r3[0xc]
8000aed2:	08 9c       	mov	r12,r4
8000aed4:	5d 18       	icall	r8
8000aed6:	e0 80 01 2a 	breq	8000b12a <read_markers+0x736>
8000aeda:	66 06       	ld.w	r6,r3[0x0]
8000aedc:	66 15       	ld.w	r5,r3[0x4]
8000aede:	0d 87       	ld.ub	r7,r6[0x0]
    prec = n >> 4;
8000aee0:	ee 01 14 04 	asr	r1,r7,0x4
    n &= 0x0F;
8000aee4:	ef d7 c0 04 	bfextu	r7,r7,0x0,0x4

    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);
8000aee8:	68 08       	ld.w	r8,r4[0x0]
8000aeea:	35 1c       	mov	r12,81
8000aeec:	91 5c       	st.w	r8[0x14],r12
8000aeee:	68 08       	ld.w	r8,r4[0x0]
8000aef0:	91 67       	st.w	r8[0x18],r7
8000aef2:	68 08       	ld.w	r8,r4[0x0]
8000aef4:	91 71       	st.w	r8[0x1c],r1
8000aef6:	50 24       	stdsp	sp[0x8],r4
8000aef8:	68 08       	ld.w	r8,r4[0x0]
8000aefa:	70 18       	ld.w	r8,r8[0x4]
8000aefc:	30 1b       	mov	r11,1
8000aefe:	08 9c       	mov	r12,r4
8000af00:	5d 18       	icall	r8

    if (n >= NUM_QUANT_TBLS)
8000af02:	58 37       	cp.w	r7,3
8000af04:	e0 8a 00 0b 	brle	8000af1a <read_markers+0x526>
      ERREXIT1(cinfo, JERR_DQT_INDEX, n);
8000af08:	68 08       	ld.w	r8,r4[0x0]
8000af0a:	31 fa       	mov	r10,31
8000af0c:	91 5a       	st.w	r8[0x14],r10
8000af0e:	68 08       	ld.w	r8,r4[0x0]
8000af10:	91 67       	st.w	r8[0x18],r7
8000af12:	68 08       	ld.w	r8,r4[0x0]
8000af14:	70 08       	ld.w	r8,r8[0x0]
8000af16:	40 2c       	lddsp	r12,sp[0x8]
8000af18:	5d 18       	icall	r8

    if (cinfo->quant_tbl_ptrs[n] == NULL)
8000af1a:	ee c8 ff d7 	sub	r8,r7,-41
8000af1e:	e8 08 03 28 	ld.w	r8,r4[r8<<0x2]
8000af22:	58 08       	cp.w	r8,0
8000af24:	c0 81       	brne	8000af34 <read_markers+0x540>
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
8000af26:	40 2c       	lddsp	r12,sp[0x8]
8000af28:	f0 1f 00 87 	mcall	8000b144 <read_markers+0x750>
8000af2c:	ee c8 ff d7 	sub	r8,r7,-41
8000af30:	e8 08 09 2c 	st.w	r4[r8<<0x2],r12

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  while (length > 0) {
    INPUT_BYTE(cinfo, n, return FALSE);
8000af34:	20 15       	sub	r5,1
8000af36:	2f f6       	sub	r6,-1
    if (n >= NUM_QUANT_TBLS)
      ERREXIT1(cinfo, JERR_DQT_INDEX, n);

    if (cinfo->quant_tbl_ptrs[n] == NULL)
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
    quant_ptr = cinfo->quant_tbl_ptrs[n];
8000af38:	2d 77       	sub	r7,-41
8000af3a:	e8 07 03 22 	ld.w	r2,r4[r7<<0x2]
8000af3e:	4f d7       	lddpc	r7,8000b130 <read_markers+0x73c>
8000af40:	0a 98       	mov	r8,r5
8000af42:	08 95       	mov	r5,r4
8000af44:	40 10       	lddsp	r0,sp[0x4]

    for (i = 0; i < DCTSIZE2; i++) {
      if (prec)
8000af46:	58 01       	cp.w	r1,0
8000af48:	c1 c0       	breq	8000af80 <read_markers+0x58c>
	INPUT_2BYTES(cinfo, tmp, return FALSE);
8000af4a:	58 08       	cp.w	r8,0
8000af4c:	c0 81       	brne	8000af5c <read_markers+0x568>
8000af4e:	66 38       	ld.w	r8,r3[0xc]
8000af50:	0a 9c       	mov	r12,r5
8000af52:	5d 18       	icall	r8
8000af54:	e0 80 00 eb 	breq	8000b12a <read_markers+0x736>
8000af58:	66 06       	ld.w	r6,r3[0x0]
8000af5a:	66 18       	ld.w	r8,r3[0x4]
8000af5c:	20 18       	sub	r8,1
8000af5e:	0d 84       	ld.ub	r4,r6[0x0]
8000af60:	c0 30       	breq	8000af66 <read_markers+0x572>
8000af62:	2f f6       	sub	r6,-1
8000af64:	c0 88       	rjmp	8000af74 <read_markers+0x580>
8000af66:	66 38       	ld.w	r8,r3[0xc]
8000af68:	0a 9c       	mov	r12,r5
8000af6a:	5d 18       	icall	r8
8000af6c:	e0 80 00 df 	breq	8000b12a <read_markers+0x736>
8000af70:	66 06       	ld.w	r6,r3[0x0]
8000af72:	66 18       	ld.w	r8,r3[0x4]
8000af74:	20 18       	sub	r8,1
8000af76:	a9 64       	lsl	r4,0x8
8000af78:	0d 39       	ld.ub	r9,r6++
8000af7a:	f2 04 00 04 	add	r4,r9,r4
8000af7e:	c0 c8       	rjmp	8000af96 <read_markers+0x5a2>
      else
	INPUT_BYTE(cinfo, tmp, return FALSE);
8000af80:	58 08       	cp.w	r8,0
8000af82:	c0 81       	brne	8000af92 <read_markers+0x59e>
8000af84:	66 38       	ld.w	r8,r3[0xc]
8000af86:	0a 9c       	mov	r12,r5
8000af88:	5d 18       	icall	r8
8000af8a:	e0 80 00 d0 	breq	8000b12a <read_markers+0x736>
8000af8e:	66 06       	ld.w	r6,r3[0x0]
8000af90:	66 18       	ld.w	r8,r3[0x4]
8000af92:	20 18       	sub	r8,1
8000af94:	0d 34       	ld.ub	r4,r6++
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
8000af96:	0f 09       	ld.w	r9,r7++
8000af98:	e4 09 0a 14 	st.h	r2[r9<<0x1],r4

    if (cinfo->quant_tbl_ptrs[n] == NULL)
      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
    quant_ptr = cinfo->quant_tbl_ptrs[n];

    for (i = 0; i < DCTSIZE2; i++) {
8000af9c:	00 37       	cp.w	r7,r0
8000af9e:	cd 41       	brne	8000af46 <read_markers+0x552>
8000afa0:	0a 94       	mov	r4,r5
8000afa2:	10 95       	mov	r5,r8
	INPUT_BYTE(cinfo, tmp, return FALSE);
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
    }

    if (cinfo->err->trace_level >= 2) {
8000afa4:	68 08       	ld.w	r8,r4[0x0]
8000afa6:	71 a8       	ld.w	r8,r8[0x68]
8000afa8:	58 18       	cp.w	r8,1
8000afaa:	e0 8a 00 25 	brle	8000aff4 <read_markers+0x600>
8000afae:	04 97       	mov	r7,r2
 * Returns same codes as are defined for jpeg_consume_input:
 * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
 */

METHODDEF(int)
read_markers (j_decompress_ptr cinfo)
8000afb0:	28 02       	sub	r2,-128
8000afb2:	0c 90       	mov	r0,r6
8000afb4:	40 26       	lddsp	r6,sp[0x8]
      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
    }

    if (cinfo->err->trace_level >= 2) {
      for (i = 0; i < DCTSIZE2; i += 8) {
	TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
8000afb6:	68 09       	ld.w	r9,r4[0x0]
8000afb8:	f2 c8 ff e8 	sub	r8,r9,-24
8000afbc:	8e 8a       	ld.uh	r10,r7[0x0]
8000afbe:	93 6a       	st.w	r9[0x18],r10
8000afc0:	8e 99       	ld.uh	r9,r7[0x2]
8000afc2:	91 19       	st.w	r8[0x4],r9
8000afc4:	8e a9       	ld.uh	r9,r7[0x4]
8000afc6:	91 29       	st.w	r8[0x8],r9
8000afc8:	8e b9       	ld.uh	r9,r7[0x6]
8000afca:	91 39       	st.w	r8[0xc],r9
8000afcc:	8e c9       	ld.uh	r9,r7[0x8]
8000afce:	91 49       	st.w	r8[0x10],r9
8000afd0:	8e d9       	ld.uh	r9,r7[0xa]
8000afd2:	91 59       	st.w	r8[0x14],r9
8000afd4:	8e e9       	ld.uh	r9,r7[0xc]
8000afd6:	91 69       	st.w	r8[0x18],r9
8000afd8:	8e f9       	ld.uh	r9,r7[0xe]
8000afda:	91 79       	st.w	r8[0x1c],r9
8000afdc:	68 08       	ld.w	r8,r4[0x0]
8000afde:	35 d9       	mov	r9,93
8000afe0:	91 59       	st.w	r8[0x14],r9
8000afe2:	68 08       	ld.w	r8,r4[0x0]
8000afe4:	70 18       	ld.w	r8,r8[0x4]
8000afe6:	30 2b       	mov	r11,2
8000afe8:	0c 9c       	mov	r12,r6
8000afea:	5d 18       	icall	r8
8000afec:	2f 07       	sub	r7,-16
      /* We convert the zigzag-order table to natural array order. */
      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
    }

    if (cinfo->err->trace_level >= 2) {
      for (i = 0; i < DCTSIZE2; i += 8) {
8000afee:	04 37       	cp.w	r7,r2
8000aff0:	ce 31       	brne	8000afb6 <read_markers+0x5c2>
8000aff2:	00 96       	mov	r6,r0
		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
      }
    }

    length -= DCTSIZE2+1;
8000aff4:	40 08       	lddsp	r8,sp[0x0]
8000aff6:	24 18       	sub	r8,65
8000aff8:	50 08       	stdsp	sp[0x0],r8
    if (prec) length -= DCTSIZE2;
8000affa:	58 01       	cp.w	r1,0
8000affc:	f7 b8 01 40 	subne	r8,64
8000b000:	fb f8 1a 00 	st.wne	sp[0x0],r8
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  while (length > 0) {
8000b004:	40 0c       	lddsp	r12,sp[0x0]
8000b006:	58 0c       	cp.w	r12,0
8000b008:	fe 99 ff 62 	brgt	8000aecc <read_markers+0x4d8>
8000b00c:	08 97       	mov	r7,r4

    length -= DCTSIZE2+1;
    if (prec) length -= DCTSIZE2;
  }

  if (length != 0)
8000b00e:	40 0a       	lddsp	r10,sp[0x0]
8000b010:	58 0a       	cp.w	r10,0
8000b012:	c0 80       	breq	8000b022 <read_markers+0x62e>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
8000b014:	6e 08       	ld.w	r8,r7[0x0]
8000b016:	30 b9       	mov	r9,11
8000b018:	91 59       	st.w	r8[0x14],r9
8000b01a:	6e 08       	ld.w	r8,r7[0x0]
8000b01c:	70 08       	ld.w	r8,r8[0x0]
8000b01e:	0e 9c       	mov	r12,r7
8000b020:	5d 18       	icall	r8

  INPUT_SYNC(cinfo);
8000b022:	87 06       	st.w	r3[0x0],r6
8000b024:	87 15       	st.w	r3[0x4],r5
8000b026:	c7 d8       	rjmp	8000b120 <read_markers+0x72c>
get_dri (j_decompress_ptr cinfo)
/* Process a DRI marker */
{
  INT32 length;
  unsigned int tmp;
  INPUT_VARS(cinfo);
8000b028:	6e 66       	ld.w	r6,r7[0x18]
8000b02a:	6c 04       	ld.w	r4,r6[0x0]
8000b02c:	6c 18       	ld.w	r8,r6[0x4]

  INPUT_2BYTES(cinfo, length, return FALSE);
8000b02e:	58 08       	cp.w	r8,0
8000b030:	c0 71       	brne	8000b03e <read_markers+0x64a>
8000b032:	6c 38       	ld.w	r8,r6[0xc]
8000b034:	0e 9c       	mov	r12,r7
8000b036:	5d 18       	icall	r8
8000b038:	c7 90       	breq	8000b12a <read_markers+0x736>
8000b03a:	6c 04       	ld.w	r4,r6[0x0]
8000b03c:	6c 18       	ld.w	r8,r6[0x4]
8000b03e:	20 18       	sub	r8,1
8000b040:	09 83       	ld.ub	r3,r4[0x0]
8000b042:	c0 30       	breq	8000b048 <read_markers+0x654>
8000b044:	2f f4       	sub	r4,-1
8000b046:	c0 78       	rjmp	8000b054 <read_markers+0x660>
8000b048:	6c 38       	ld.w	r8,r6[0xc]
8000b04a:	0e 9c       	mov	r12,r7
8000b04c:	5d 18       	icall	r8
8000b04e:	c6 e0       	breq	8000b12a <read_markers+0x736>
8000b050:	6c 04       	ld.w	r4,r6[0x0]
8000b052:	6c 18       	ld.w	r8,r6[0x4]
8000b054:	f0 c5 00 01 	sub	r5,r8,1
8000b058:	a9 63       	lsl	r3,0x8

  if (length != 4)
8000b05a:	09 88       	ld.ub	r8,r4[0x0]
8000b05c:	06 08       	add	r8,r3
8000b05e:	58 48       	cp.w	r8,4
8000b060:	c0 80       	breq	8000b070 <read_markers+0x67c>
    ERREXIT(cinfo, JERR_BAD_LENGTH);
8000b062:	6e 08       	ld.w	r8,r7[0x0]
8000b064:	30 b9       	mov	r9,11
8000b066:	91 59       	st.w	r8[0x14],r9
8000b068:	6e 08       	ld.w	r8,r7[0x0]
8000b06a:	70 08       	ld.w	r8,r8[0x0]
8000b06c:	0e 9c       	mov	r12,r7
8000b06e:	5d 18       	icall	r8

  INPUT_2BYTES(cinfo, tmp, return FALSE);
8000b070:	58 05       	cp.w	r5,0
8000b072:	c0 30       	breq	8000b078 <read_markers+0x684>
{
  INT32 length;
  unsigned int tmp;
  INPUT_VARS(cinfo);

  INPUT_2BYTES(cinfo, length, return FALSE);
8000b074:	2f f4       	sub	r4,-1
8000b076:	c0 78       	rjmp	8000b084 <read_markers+0x690>

  if (length != 4)
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  INPUT_2BYTES(cinfo, tmp, return FALSE);
8000b078:	6c 38       	ld.w	r8,r6[0xc]
8000b07a:	0e 9c       	mov	r12,r7
8000b07c:	5d 18       	icall	r8
8000b07e:	c5 60       	breq	8000b12a <read_markers+0x736>
8000b080:	6c 04       	ld.w	r4,r6[0x0]
8000b082:	6c 15       	ld.w	r5,r6[0x4]
8000b084:	ea c3 00 01 	sub	r3,r5,1
8000b088:	09 82       	ld.ub	r2,r4[0x0]
8000b08a:	c0 40       	breq	8000b092 <read_markers+0x69e>
8000b08c:	e8 c5 ff ff 	sub	r5,r4,-1
8000b090:	c0 78       	rjmp	8000b09e <read_markers+0x6aa>
8000b092:	6c 38       	ld.w	r8,r6[0xc]
8000b094:	0e 9c       	mov	r12,r7
8000b096:	5d 18       	icall	r8
8000b098:	c4 90       	breq	8000b12a <read_markers+0x736>
8000b09a:	6c 05       	ld.w	r5,r6[0x0]
8000b09c:	6c 13       	ld.w	r3,r6[0x4]
8000b09e:	a9 62       	lsl	r2,0x8
8000b0a0:	0b 34       	ld.ub	r4,r5++
8000b0a2:	04 04       	add	r4,r2

  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);
8000b0a4:	6e 08       	ld.w	r8,r7[0x0]
8000b0a6:	35 29       	mov	r9,82
8000b0a8:	91 59       	st.w	r8[0x14],r9
8000b0aa:	6e 08       	ld.w	r8,r7[0x0]
8000b0ac:	91 64       	st.w	r8[0x18],r4
8000b0ae:	6e 08       	ld.w	r8,r7[0x0]
8000b0b0:	70 18       	ld.w	r8,r8[0x4]
8000b0b2:	30 1b       	mov	r11,1
8000b0b4:	0e 9c       	mov	r12,r7
8000b0b6:	5d 18       	icall	r8

  cinfo->restart_interval = tmp;
8000b0b8:	ef 44 01 14 	st.w	r7[276],r4

  INPUT_SYNC(cinfo);
8000b0bc:	8d 05       	st.w	r6[0x0],r5
8000b0be:	20 13       	sub	r3,1
8000b0c0:	8d 13       	st.w	r6[0x4],r3
8000b0c2:	c2 f8       	rjmp	8000b120 <read_markers+0x72c>
    case M_APP11:
    case M_APP12:
    case M_APP13:
    case M_APP14:
    case M_APP15:
      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
8000b0c4:	ee f9 01 b8 	ld.w	r9,r7[440]
8000b0c8:	f0 c8 00 d8 	sub	r8,r8,216
8000b0cc:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000b0d0:	0e 9c       	mov	r12,r7
8000b0d2:	5d 18       	icall	r8
8000b0d4:	c2 61       	brne	8000b120 <read_markers+0x72c>
8000b0d6:	c2 a8       	rjmp	8000b12a <read_markers+0x736>
		cinfo->unread_marker - (int) M_APP0]) (cinfo))
	return JPEG_SUSPENDED;
      break;

    case M_COM:
      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
8000b0d8:	ee f8 01 b8 	ld.w	r8,r7[440]
8000b0dc:	70 78       	ld.w	r8,r8[0x1c]
8000b0de:	0e 9c       	mov	r12,r7
8000b0e0:	5d 18       	icall	r8
8000b0e2:	c1 f1       	brne	8000b120 <read_markers+0x72c>
8000b0e4:	c2 38       	rjmp	8000b12a <read_markers+0x736>
    case M_RST4:
    case M_RST5:
    case M_RST6:
    case M_RST7:
    case M_TEM:
      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
8000b0e6:	6e 08       	ld.w	r8,r7[0x0]
8000b0e8:	35 c9       	mov	r9,92
8000b0ea:	91 59       	st.w	r8[0x14],r9
8000b0ec:	6e 08       	ld.w	r8,r7[0x0]
8000b0ee:	ee f9 01 a0 	ld.w	r9,r7[416]
8000b0f2:	91 69       	st.w	r8[0x18],r9
8000b0f4:	6e 08       	ld.w	r8,r7[0x0]
8000b0f6:	70 18       	ld.w	r8,r8[0x4]
8000b0f8:	30 1b       	mov	r11,1
8000b0fa:	0e 9c       	mov	r12,r7
8000b0fc:	5d 18       	icall	r8
      break;
8000b0fe:	c1 18       	rjmp	8000b120 <read_markers+0x72c>

    case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
      if (! skip_variable(cinfo))
8000b100:	0e 9c       	mov	r12,r7
8000b102:	f0 1f 00 0f 	mcall	8000b13c <read_markers+0x748>
8000b106:	c0 d1       	brne	8000b120 <read_markers+0x72c>
8000b108:	c1 18       	rjmp	8000b12a <read_markers+0x736>
      /* For now, we treat the reserved markers as fatal errors since they are
       * likely to be used to signal incompatible JPEG Part 3 extensions.
       * Once the JPEG 3 version-number marker is well defined, this code
       * ought to change!
       */
      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
8000b10a:	6e 08       	ld.w	r8,r7[0x0]
8000b10c:	34 49       	mov	r9,68
8000b10e:	91 59       	st.w	r8[0x14],r9
8000b110:	6e 08       	ld.w	r8,r7[0x0]
8000b112:	ee f9 01 a0 	ld.w	r9,r7[416]
8000b116:	91 69       	st.w	r8[0x18],r9
8000b118:	6e 08       	ld.w	r8,r7[0x0]
8000b11a:	70 08       	ld.w	r8,r8[0x0]
8000b11c:	0e 9c       	mov	r12,r7
8000b11e:	5d 18       	icall	r8
      break;
    }
    /* Successfully processed marker, so reset state variable */
    cinfo->unread_marker = 0;
8000b120:	30 08       	mov	r8,0
8000b122:	ef 48 01 a0 	st.w	r7[416],r8
  } /* end loop */
8000b126:	fe 9f fc 6f 	bral	8000aa04 <read_markers+0x10>
8000b12a:	30 0c       	mov	r12,0
}
8000b12c:	2f dd       	sub	sp,-12
8000b12e:	d8 32       	popm	r0-r7,pc
8000b130:	80 01       	ld.sh	r1,r0[0x0]
8000b132:	fc 54 80 00 	cp.w	r4,-163840
8000b136:	a5 16       	ld.d	r6,--r2
8000b138:	80 00       	ld.sh	r0,r0[0x0]
8000b13a:	9e bc       	ld.uh	r12,pc[0x6]
8000b13c:	80 00       	ld.sh	r0,r0[0x0]
8000b13e:	a4 a0       	st.b	r2[0x2],r0
8000b140:	80 00       	ld.sh	r0,r0[0x0]
8000b142:	a7 b4       	sbr	r4,0x7
8000b144:	80 00       	ld.sh	r0,r0[0x0]
8000b146:	74 98       	ld.w	r8,r10[0x24]

8000b148 <use_merged_upsample>:
LOCAL(boolean)
use_merged_upsample (j_decompress_ptr cinfo)
{
#ifdef UPSAMPLE_MERGING_SUPPORTED
  /* Merging is the equivalent of plain box-filter upsampling */
  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
8000b148:	79 38       	ld.w	r8,r12[0x4c]
8000b14a:	58 08       	cp.w	r8,0
8000b14c:	c3 61       	brne	8000b1b8 <use_merged_upsample+0x70>
8000b14e:	f8 f8 01 2c 	ld.w	r8,r12[300]
8000b152:	58 08       	cp.w	r8,0
8000b154:	c3 21       	brne	8000b1b8 <use_merged_upsample+0x70>
    return FALSE;
  /* jdmerge.c only supports YCC=>RGB color conversion */
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
8000b156:	78 a8       	ld.w	r8,r12[0x28]
8000b158:	58 38       	cp.w	r8,3
8000b15a:	c2 f1       	brne	8000b1b8 <use_merged_upsample+0x70>
8000b15c:	78 98       	ld.w	r8,r12[0x24]
8000b15e:	58 38       	cp.w	r8,3
8000b160:	c2 c1       	brne	8000b1b8 <use_merged_upsample+0x70>
      cinfo->out_color_space != JCS_RGB ||
8000b162:	78 b8       	ld.w	r8,r12[0x2c]
8000b164:	58 28       	cp.w	r8,2
8000b166:	c2 91       	brne	8000b1b8 <use_merged_upsample+0x70>
      cinfo->out_color_components != RGB_PIXELSIZE)
8000b168:	79 e8       	ld.w	r8,r12[0x78]
8000b16a:	58 38       	cp.w	r8,3
8000b16c:	c2 61       	brne	8000b1b8 <use_merged_upsample+0x70>
    return FALSE;
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
8000b16e:	f8 f8 00 d8 	ld.w	r8,r12[216]
8000b172:	70 29       	ld.w	r9,r8[0x8]
8000b174:	58 29       	cp.w	r9,2
8000b176:	c2 11       	brne	8000b1b8 <use_merged_upsample+0x70>
      cinfo->comp_info[1].h_samp_factor != 1 ||
8000b178:	f0 c9 ff ac 	sub	r9,r8,-84
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
      cinfo->out_color_space != JCS_RGB ||
      cinfo->out_color_components != RGB_PIXELSIZE)
    return FALSE;
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
8000b17c:	72 2a       	ld.w	r10,r9[0x8]
8000b17e:	58 1a       	cp.w	r10,1
8000b180:	c1 c1       	brne	8000b1b8 <use_merged_upsample+0x70>
      cinfo->comp_info[1].h_samp_factor != 1 ||
      cinfo->comp_info[2].h_samp_factor != 1 ||
8000b182:	f0 ca ff 58 	sub	r10,r8,-168
  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
      cinfo->out_color_space != JCS_RGB ||
      cinfo->out_color_components != RGB_PIXELSIZE)
    return FALSE;
  /* and it only handles 2h1v or 2h2v sampling ratios */
  if (cinfo->comp_info[0].h_samp_factor != 2 ||
8000b186:	74 2b       	ld.w	r11,r10[0x8]
8000b188:	58 1b       	cp.w	r11,1
8000b18a:	c1 71       	brne	8000b1b8 <use_merged_upsample+0x70>
      cinfo->comp_info[1].h_samp_factor != 1 ||
      cinfo->comp_info[2].h_samp_factor != 1 ||
      cinfo->comp_info[0].v_samp_factor >  2 ||
8000b18c:	70 3b       	ld.w	r11,r8[0xc]
8000b18e:	58 2b       	cp.w	r11,2
8000b190:	e0 89 00 14 	brgt	8000b1b8 <use_merged_upsample+0x70>
      cinfo->comp_info[1].v_samp_factor != 1 ||
8000b194:	72 3b       	ld.w	r11,r9[0xc]
8000b196:	58 1b       	cp.w	r11,1
8000b198:	c1 01       	brne	8000b1b8 <use_merged_upsample+0x70>
      cinfo->comp_info[2].v_samp_factor != 1)
8000b19a:	74 3b       	ld.w	r11,r10[0xc]
8000b19c:	58 1b       	cp.w	r11,1
8000b19e:	c0 d1       	brne	8000b1b8 <use_merged_upsample+0x70>
    return FALSE;
  /* furthermore, it doesn't work if we've scaled the IDCTs differently */
  if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
8000b1a0:	70 98       	ld.w	r8,r8[0x24]
8000b1a2:	f8 fb 01 3c 	ld.w	r11,r12[316]
8000b1a6:	16 38       	cp.w	r8,r11
8000b1a8:	c0 81       	brne	8000b1b8 <use_merged_upsample+0x70>
      cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
8000b1aa:	72 99       	ld.w	r9,r9[0x24]
8000b1ac:	12 38       	cp.w	r8,r9
8000b1ae:	c0 51       	brne	8000b1b8 <use_merged_upsample+0x70>
8000b1b0:	74 99       	ld.w	r9,r10[0x24]
8000b1b2:	12 38       	cp.w	r8,r9
8000b1b4:	5f 0c       	sreq	r12
8000b1b6:	5e fc       	retal	r12
8000b1b8:	5e fd       	retal	0

8000b1ba <prepare_for_output_pass>:
 * (In the latter case, jdapistd.c will crank the pass to completion.)
 */

METHODDEF(void)
prepare_for_output_pass (j_decompress_ptr cinfo)
{
8000b1ba:	eb cd 40 c0 	pushm	r6-r7,lr
8000b1be:	18 97       	mov	r7,r12
  my_master_ptr master = (my_master_ptr) cinfo->master;
8000b1c0:	f8 f6 01 a4 	ld.w	r6,r12[420]

  if (master->pub.is_dummy_pass) {
8000b1c4:	6c 28       	ld.w	r8,r6[0x8]
8000b1c6:	58 08       	cp.w	r8,0
8000b1c8:	c1 40       	breq	8000b1f0 <prepare_for_output_pass+0x36>
#ifdef QUANT_2PASS_SUPPORTED
    /* Final pass of 2-pass quantization */
    master->pub.is_dummy_pass = FALSE;
8000b1ca:	30 0b       	mov	r11,0
8000b1cc:	8d 2b       	st.w	r6[0x8],r11
    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
8000b1ce:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000b1d2:	70 08       	ld.w	r8,r8[0x0]
8000b1d4:	5d 18       	icall	r8
    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
8000b1d6:	ee f8 01 b0 	ld.w	r8,r7[432]
8000b1da:	70 08       	ld.w	r8,r8[0x0]
8000b1dc:	30 2b       	mov	r11,2
8000b1de:	0e 9c       	mov	r12,r7
8000b1e0:	5d 18       	icall	r8
    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
8000b1e2:	ee f8 01 a8 	ld.w	r8,r7[424]
8000b1e6:	70 08       	ld.w	r8,r8[0x0]
8000b1e8:	30 2b       	mov	r11,2
8000b1ea:	0e 9c       	mov	r12,r7
8000b1ec:	5d 18       	icall	r8
8000b1ee:	c5 68       	rjmp	8000b29a <prepare_for_output_pass+0xe0>
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  } else {
    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
8000b1f0:	79 58       	ld.w	r8,r12[0x54]
8000b1f2:	58 08       	cp.w	r8,0
8000b1f4:	c1 f0       	breq	8000b232 <prepare_for_output_pass+0x78>
8000b1f6:	f8 f8 00 88 	ld.w	r8,r12[136]
8000b1fa:	58 08       	cp.w	r8,0
8000b1fc:	c1 b1       	brne	8000b232 <prepare_for_output_pass+0x78>
      /* Select new quantization method */
      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
8000b1fe:	79 78       	ld.w	r8,r12[0x5c]
8000b200:	58 08       	cp.w	r8,0
8000b202:	c0 a0       	breq	8000b216 <prepare_for_output_pass+0x5c>
8000b204:	79 b8       	ld.w	r8,r12[0x6c]
8000b206:	58 08       	cp.w	r8,0
8000b208:	c0 70       	breq	8000b216 <prepare_for_output_pass+0x5c>
	cinfo->cquantize = master->quantizer_2pass;
8000b20a:	6c 68       	ld.w	r8,r6[0x18]
8000b20c:	f9 48 01 cc 	st.w	r12[460],r8
	master->pub.is_dummy_pass = TRUE;
8000b210:	30 18       	mov	r8,1
8000b212:	8d 28       	st.w	r6[0x8],r8
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif /* QUANT_2PASS_SUPPORTED */
  } else {
    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
      /* Select new quantization method */
      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
8000b214:	c0 f8       	rjmp	8000b232 <prepare_for_output_pass+0x78>
	cinfo->cquantize = master->quantizer_2pass;
	master->pub.is_dummy_pass = TRUE;
      } else if (cinfo->enable_1pass_quant) {
8000b216:	6f 98       	ld.w	r8,r7[0x64]
8000b218:	58 08       	cp.w	r8,0
8000b21a:	c0 50       	breq	8000b224 <prepare_for_output_pass+0x6a>
	cinfo->cquantize = master->quantizer_1pass;
8000b21c:	6c 58       	ld.w	r8,r6[0x14]
8000b21e:	ef 48 01 cc 	st.w	r7[460],r8
8000b222:	c0 88       	rjmp	8000b232 <prepare_for_output_pass+0x78>
      } else {
	ERREXIT(cinfo, JERR_MODE_CHANGE);
8000b224:	6e 08       	ld.w	r8,r7[0x0]
8000b226:	32 e9       	mov	r9,46
8000b228:	91 59       	st.w	r8[0x14],r9
8000b22a:	6e 08       	ld.w	r8,r7[0x0]
8000b22c:	70 08       	ld.w	r8,r8[0x0]
8000b22e:	0e 9c       	mov	r12,r7
8000b230:	5d 18       	icall	r8
      }
    }
    (*cinfo->idct->start_pass) (cinfo);
8000b232:	ee f8 01 c0 	ld.w	r8,r7[448]
8000b236:	70 08       	ld.w	r8,r8[0x0]
8000b238:	0e 9c       	mov	r12,r7
8000b23a:	5d 18       	icall	r8
    (*cinfo->coef->start_output_pass) (cinfo);
8000b23c:	ee f8 01 ac 	ld.w	r8,r7[428]
8000b240:	70 28       	ld.w	r8,r8[0x8]
8000b242:	0e 9c       	mov	r12,r7
8000b244:	5d 18       	icall	r8
    if (! cinfo->raw_data_out) {
8000b246:	6f 18       	ld.w	r8,r7[0x44]
8000b248:	58 08       	cp.w	r8,0
8000b24a:	c2 81       	brne	8000b29a <prepare_for_output_pass+0xe0>
      if (! master->using_merged_upsample)
8000b24c:	6c 48       	ld.w	r8,r6[0x10]
8000b24e:	58 08       	cp.w	r8,0
8000b250:	c0 61       	brne	8000b25c <prepare_for_output_pass+0xa2>
	(*cinfo->cconvert->start_pass) (cinfo);
8000b252:	ee f8 01 c8 	ld.w	r8,r7[456]
8000b256:	70 08       	ld.w	r8,r8[0x0]
8000b258:	0e 9c       	mov	r12,r7
8000b25a:	5d 18       	icall	r8
      (*cinfo->upsample->start_pass) (cinfo);
8000b25c:	ee f8 01 c4 	ld.w	r8,r7[452]
8000b260:	70 08       	ld.w	r8,r8[0x0]
8000b262:	0e 9c       	mov	r12,r7
8000b264:	5d 18       	icall	r8
      if (cinfo->quantize_colors)
8000b266:	6f 58       	ld.w	r8,r7[0x54]
8000b268:	58 08       	cp.w	r8,0
8000b26a:	c0 70       	breq	8000b278 <prepare_for_output_pass+0xbe>
	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
8000b26c:	ee f8 01 cc 	ld.w	r8,r7[460]
8000b270:	70 08       	ld.w	r8,r8[0x0]
8000b272:	6c 2b       	ld.w	r11,r6[0x8]
8000b274:	0e 9c       	mov	r12,r7
8000b276:	5d 18       	icall	r8
      (*cinfo->post->start_pass) (cinfo,
8000b278:	ee f8 01 b0 	ld.w	r8,r7[432]
8000b27c:	70 08       	ld.w	r8,r8[0x0]
	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
8000b27e:	6c 2b       	ld.w	r11,r6[0x8]
      if (! master->using_merged_upsample)
	(*cinfo->cconvert->start_pass) (cinfo);
      (*cinfo->upsample->start_pass) (cinfo);
      if (cinfo->quantize_colors)
	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
      (*cinfo->post->start_pass) (cinfo,
8000b280:	58 0b       	cp.w	r11,0
8000b282:	f9 bb 01 03 	movne	r11,3
8000b286:	f9 bb 00 00 	moveq	r11,0
8000b28a:	0e 9c       	mov	r12,r7
8000b28c:	5d 18       	icall	r8
	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
8000b28e:	ee f8 01 a8 	ld.w	r8,r7[424]
8000b292:	70 08       	ld.w	r8,r8[0x0]
8000b294:	30 0b       	mov	r11,0
8000b296:	0e 9c       	mov	r12,r7
8000b298:	5d 18       	icall	r8
    }
  }

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
8000b29a:	6e 28       	ld.w	r8,r7[0x8]
8000b29c:	58 08       	cp.w	r8,0
8000b29e:	c1 f0       	breq	8000b2dc <prepare_for_output_pass+0x122>
    cinfo->progress->completed_passes = master->pass_number;
8000b2a0:	6c 39       	ld.w	r9,r6[0xc]
8000b2a2:	91 39       	st.w	r8[0xc],r9
    cinfo->progress->total_passes = master->pass_number +
8000b2a4:	6e 29       	ld.w	r9,r7[0x8]
8000b2a6:	6c 3a       	ld.w	r10,r6[0xc]
				    (master->pub.is_dummy_pass ? 2 : 1);
8000b2a8:	6c 28       	ld.w	r8,r6[0x8]
8000b2aa:	58 08       	cp.w	r8,0
8000b2ac:	f9 b8 01 02 	movne	r8,2
8000b2b0:	f9 b8 00 01 	moveq	r8,1
  }

  /* Set up progress monitor's pass info if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->completed_passes = master->pass_number;
    cinfo->progress->total_passes = master->pass_number +
8000b2b4:	14 08       	add	r8,r10
8000b2b6:	93 48       	st.w	r9[0x10],r8
				    (master->pub.is_dummy_pass ? 2 : 1);
    /* In buffered-image mode, we assume one more output pass if EOI not
     * yet reached, but no more passes if EOI has been reached.
     */
    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
8000b2b8:	6f 08       	ld.w	r8,r7[0x40]
8000b2ba:	58 08       	cp.w	r8,0
8000b2bc:	c1 00       	breq	8000b2dc <prepare_for_output_pass+0x122>
8000b2be:	ee f8 01 b4 	ld.w	r8,r7[436]
8000b2c2:	70 58       	ld.w	r8,r8[0x14]
8000b2c4:	58 08       	cp.w	r8,0
8000b2c6:	c0 b1       	brne	8000b2dc <prepare_for_output_pass+0x122>
      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
8000b2c8:	6e 28       	ld.w	r8,r7[0x8]
8000b2ca:	70 4a       	ld.w	r10,r8[0x10]
8000b2cc:	6f b9       	ld.w	r9,r7[0x6c]
8000b2ce:	58 09       	cp.w	r9,0
8000b2d0:	f9 b9 01 02 	movne	r9,2
8000b2d4:	f9 b9 00 01 	moveq	r9,1
8000b2d8:	14 09       	add	r9,r10
8000b2da:	91 49       	st.w	r8[0x10],r9
8000b2dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000b2e0 <finish_output_pass>:
 * Finish up at end of an output pass.
 */

METHODDEF(void)
finish_output_pass (j_decompress_ptr cinfo)
{
8000b2e0:	eb cd 40 80 	pushm	r7,lr
  my_master_ptr master = (my_master_ptr) cinfo->master;
8000b2e4:	f8 f7 01 a4 	ld.w	r7,r12[420]

  if (cinfo->quantize_colors)
8000b2e8:	79 58       	ld.w	r8,r12[0x54]
8000b2ea:	58 08       	cp.w	r8,0
8000b2ec:	c0 50       	breq	8000b2f6 <finish_output_pass+0x16>
    (*cinfo->cquantize->finish_pass) (cinfo);
8000b2ee:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000b2f2:	70 28       	ld.w	r8,r8[0x8]
8000b2f4:	5d 18       	icall	r8
  master->pass_number++;
8000b2f6:	6e 38       	ld.w	r8,r7[0xc]
8000b2f8:	2f f8       	sub	r8,-1
8000b2fa:	8f 38       	st.w	r7[0xc],r8
}
8000b2fc:	e3 cd 80 80 	ldm	sp++,r7,pc

8000b300 <jpeg_calc_output_dimensions>:
 */

GLOBAL(void)
jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
/* Do computations that are needed before master selection phase */
{
8000b300:	eb cd 40 e0 	pushm	r5-r7,lr
8000b304:	18 97       	mov	r7,r12
  int ci;
  jpeg_component_info *compptr;
#endif

  /* Prevent application from calling me at wrong times */
  if (cinfo->global_state != DSTATE_READY)
8000b306:	78 58       	ld.w	r8,r12[0x14]
8000b308:	e0 48 00 ca 	cp.w	r8,202
8000b30c:	c0 a0       	breq	8000b320 <jpeg_calc_output_dimensions+0x20>
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
8000b30e:	78 08       	ld.w	r8,r12[0x0]
8000b310:	31 49       	mov	r9,20
8000b312:	91 59       	st.w	r8[0x14],r9
8000b314:	78 08       	ld.w	r8,r12[0x0]
8000b316:	78 59       	ld.w	r9,r12[0x14]
8000b318:	91 69       	st.w	r8[0x18],r9
8000b31a:	78 08       	ld.w	r8,r12[0x0]
8000b31c:	70 08       	ld.w	r8,r8[0x0]
8000b31e:	5d 18       	icall	r8

#ifdef IDCT_SCALING_SUPPORTED

  /* Compute actual output image dimensions and DCT scaling choices. */
  if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
8000b320:	6e c9       	ld.w	r9,r7[0x30]
8000b322:	6e d8       	ld.w	r8,r7[0x34]
8000b324:	f2 0a 15 03 	lsl	r10,r9,0x3
8000b328:	10 3a       	cp.w	r10,r8
8000b32a:	e0 8b 00 12 	brhi	8000b34e <jpeg_calc_output_dimensions+0x4e>
    /* Provide 1/8 scaling */
    cinfo->output_width = (JDIMENSION)
8000b32e:	30 8b       	mov	r11,8
8000b330:	6e 7c       	ld.w	r12,r7[0x1c]
8000b332:	f0 1f 00 68 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b336:	ef 4c 00 70 	st.w	r7[112],r12
      jdiv_round_up((long) cinfo->image_width, 8L);
    cinfo->output_height = (JDIMENSION)
8000b33a:	30 8b       	mov	r11,8
8000b33c:	6e 8c       	ld.w	r12,r7[0x20]
8000b33e:	f0 1f 00 65 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b342:	ef 4c 00 74 	st.w	r7[116],r12
      jdiv_round_up((long) cinfo->image_height, 8L);
    cinfo->min_DCT_scaled_size = 1;
8000b346:	30 18       	mov	r8,1
8000b348:	ef 48 01 3c 	st.w	r7[316],r8
8000b34c:	c3 18       	rjmp	8000b3ae <jpeg_calc_output_dimensions+0xae>
  } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
8000b34e:	f2 0a 15 02 	lsl	r10,r9,0x2
8000b352:	14 38       	cp.w	r8,r10
8000b354:	c1 13       	brcs	8000b376 <jpeg_calc_output_dimensions+0x76>
    /* Provide 1/4 scaling */
    cinfo->output_width = (JDIMENSION)
8000b356:	30 4b       	mov	r11,4
8000b358:	6e 7c       	ld.w	r12,r7[0x1c]
8000b35a:	f0 1f 00 5e 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b35e:	ef 4c 00 70 	st.w	r7[112],r12
      jdiv_round_up((long) cinfo->image_width, 4L);
    cinfo->output_height = (JDIMENSION)
8000b362:	30 4b       	mov	r11,4
8000b364:	6e 8c       	ld.w	r12,r7[0x20]
8000b366:	f0 1f 00 5b 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b36a:	ef 4c 00 74 	st.w	r7[116],r12
      jdiv_round_up((long) cinfo->image_height, 4L);
    cinfo->min_DCT_scaled_size = 2;
8000b36e:	30 28       	mov	r8,2
8000b370:	ef 48 01 3c 	st.w	r7[316],r8
8000b374:	c1 d8       	rjmp	8000b3ae <jpeg_calc_output_dimensions+0xae>
  } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
8000b376:	a1 79       	lsl	r9,0x1
8000b378:	12 38       	cp.w	r8,r9
8000b37a:	c1 13       	brcs	8000b39c <jpeg_calc_output_dimensions+0x9c>
    /* Provide 1/2 scaling */
    cinfo->output_width = (JDIMENSION)
8000b37c:	30 2b       	mov	r11,2
8000b37e:	6e 7c       	ld.w	r12,r7[0x1c]
8000b380:	f0 1f 00 54 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b384:	ef 4c 00 70 	st.w	r7[112],r12
      jdiv_round_up((long) cinfo->image_width, 2L);
    cinfo->output_height = (JDIMENSION)
8000b388:	30 2b       	mov	r11,2
8000b38a:	6e 8c       	ld.w	r12,r7[0x20]
8000b38c:	f0 1f 00 51 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b390:	ef 4c 00 74 	st.w	r7[116],r12
      jdiv_round_up((long) cinfo->image_height, 2L);
    cinfo->min_DCT_scaled_size = 4;
8000b394:	30 48       	mov	r8,4
8000b396:	ef 48 01 3c 	st.w	r7[316],r8
8000b39a:	c0 a8       	rjmp	8000b3ae <jpeg_calc_output_dimensions+0xae>
  } else {
    /* Provide 1/1 scaling */
    cinfo->output_width = cinfo->image_width;
8000b39c:	6e 78       	ld.w	r8,r7[0x1c]
8000b39e:	ef 48 00 70 	st.w	r7[112],r8
    cinfo->output_height = cinfo->image_height;
8000b3a2:	6e 88       	ld.w	r8,r7[0x20]
8000b3a4:	ef 48 00 74 	st.w	r7[116],r8
    cinfo->min_DCT_scaled_size = DCTSIZE;
8000b3a8:	30 88       	mov	r8,8
8000b3aa:	ef 48 01 3c 	st.w	r7[316],r8
  /* In selecting the actual DCT scaling for each component, we try to
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000b3ae:	ee f5 00 d8 	ld.w	r5,r7[216]
8000b3b2:	6e 98       	ld.w	r8,r7[0x24]
8000b3b4:	58 08       	cp.w	r8,0
8000b3b6:	e0 8a 00 5d 	brle	8000b470 <jpeg_calc_output_dimensions+0x170>
8000b3ba:	2d c5       	sub	r5,-36
8000b3bc:	30 0e       	mov	lr,0
       ci++, compptr++) {
    int ssize = cinfo->min_DCT_scaled_size;
8000b3be:	ee f8 01 3c 	ld.w	r8,r7[316]
    while (ssize < DCTSIZE &&
8000b3c2:	58 78       	cp.w	r8,7
8000b3c4:	e0 89 00 2a 	brgt	8000b418 <jpeg_calc_output_dimensions+0x118>
	   (compptr->h_samp_factor * ssize * 2 <=
8000b3c8:	ea fc ff e4 	ld.w	r12,r5[-28]
	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
8000b3cc:	ee fa 01 34 	ld.w	r10,r7[308]
8000b3d0:	f0 0a 02 4a 	mul	r10,r8,r10
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    int ssize = cinfo->min_DCT_scaled_size;
    while (ssize < DCTSIZE &&
8000b3d4:	f0 0c 02 49 	mul	r9,r8,r12
8000b3d8:	a1 79       	lsl	r9,0x1
8000b3da:	14 39       	cp.w	r9,r10
8000b3dc:	e0 89 00 1e 	brgt	8000b418 <jpeg_calc_output_dimensions+0x118>
	   (compptr->h_samp_factor * ssize * 2 <=
	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
	   (compptr->v_samp_factor * ssize * 2 <=
8000b3e0:	ea f6 ff e8 	ld.w	r6,r5[-24]
	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
8000b3e4:	ee fb 01 38 	ld.w	r11,r7[312]
8000b3e8:	f0 0b 02 4b 	mul	r11,r8,r11
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    int ssize = cinfo->min_DCT_scaled_size;
    while (ssize < DCTSIZE &&
8000b3ec:	f0 06 02 49 	mul	r9,r8,r6
8000b3f0:	a1 79       	lsl	r9,0x1
8000b3f2:	16 39       	cp.w	r9,r11
8000b3f4:	e0 89 00 12 	brgt	8000b418 <jpeg_calc_output_dimensions+0x118>
	   (compptr->h_samp_factor * ssize * 2 <=
8000b3f8:	a1 7c       	lsl	r12,0x1
	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
	   (compptr->v_samp_factor * ssize * 2 <=
8000b3fa:	a1 76       	lsl	r6,0x1
	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
      ssize = ssize * 2;
8000b3fc:	a1 78       	lsl	r8,0x1
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    int ssize = cinfo->min_DCT_scaled_size;
    while (ssize < DCTSIZE &&
8000b3fe:	58 78       	cp.w	r8,7
8000b400:	e0 89 00 0c 	brgt	8000b418 <jpeg_calc_output_dimensions+0x118>
8000b404:	f0 0c 02 49 	mul	r9,r8,r12
8000b408:	14 39       	cp.w	r9,r10
8000b40a:	e0 89 00 07 	brgt	8000b418 <jpeg_calc_output_dimensions+0x118>
8000b40e:	f0 06 02 49 	mul	r9,r8,r6
8000b412:	16 39       	cp.w	r9,r11
8000b414:	fe 9a ff f4 	brle	8000b3fc <jpeg_calc_output_dimensions+0xfc>
	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
	   (compptr->v_samp_factor * ssize * 2 <=
	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
      ssize = ssize * 2;
    }
    compptr->DCT_scaled_size = ssize;
8000b418:	8b 08       	st.w	r5[0x0],r8
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
8000b41a:	2f fe       	sub	lr,-1
8000b41c:	2a c5       	sub	r5,-84
  /* In selecting the actual DCT scaling for each component, we try to
   * scale up the chroma components via IDCT scaling rather than upsampling.
   * This saves time if the upsampler gets to use 1:1 scaling.
   * Note this code assumes that the supported DCT scalings are powers of 2.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000b41e:	6e 98       	ld.w	r8,r7[0x24]
8000b420:	1c 38       	cp.w	r8,lr
8000b422:	fe 99 ff ce 	brgt	8000b3be <jpeg_calc_output_dimensions+0xbe>
  }

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000b426:	ee f6 00 d8 	ld.w	r6,r7[216]
8000b42a:	58 08       	cp.w	r8,0
8000b42c:	e0 8a 00 22 	brle	8000b470 <jpeg_calc_output_dimensions+0x170>
8000b430:	2d c6       	sub	r6,-36
8000b432:	30 05       	mov	r5,0
       ci++, compptr++) {
    /* Size in samples, after IDCT scaling */
    compptr->downsampled_width = (JDIMENSION)
8000b434:	ee fb 01 34 	ld.w	r11,r7[308]
8000b438:	6c 0c       	ld.w	r12,r6[0x0]
8000b43a:	ec f8 ff e4 	ld.w	r8,r6[-28]
8000b43e:	b1 3c       	mul	r12,r8
8000b440:	6e 78       	ld.w	r8,r7[0x1c]
8000b442:	a3 7b       	lsl	r11,0x3
8000b444:	b1 3c       	mul	r12,r8
8000b446:	f0 1f 00 23 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b44a:	8d 1c       	st.w	r6[0x4],r12
      jdiv_round_up((long) cinfo->image_width *
		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
    compptr->downsampled_height = (JDIMENSION)
8000b44c:	ee fb 01 38 	ld.w	r11,r7[312]
8000b450:	6c 0c       	ld.w	r12,r6[0x0]
8000b452:	ec f8 ff e8 	ld.w	r8,r6[-24]
8000b456:	b1 3c       	mul	r12,r8
8000b458:	6e 88       	ld.w	r8,r7[0x20]
8000b45a:	a3 7b       	lsl	r11,0x3
8000b45c:	b1 3c       	mul	r12,r8
8000b45e:	f0 1f 00 1d 	mcall	8000b4d0 <jpeg_calc_output_dimensions+0x1d0>
8000b462:	8d 2c       	st.w	r6[0x8],r12

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
8000b464:	2f f5       	sub	r5,-1
  }

  /* Recompute downsampled dimensions of components;
   * application needs to know these if using raw downsampled data.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000b466:	6e 98       	ld.w	r8,r7[0x24]
8000b468:	2a c6       	sub	r6,-84
8000b46a:	0a 38       	cp.w	r8,r5
8000b46c:	fe 99 ff e4 	brgt	8000b434 <jpeg_calc_output_dimensions+0x134>

#endif /* IDCT_SCALING_SUPPORTED */

  /* Report number of components in selected colorspace. */
  /* Probably this should be in the color conversion module... */
  switch (cinfo->out_color_space) {
8000b470:	6e b9       	ld.w	r9,r7[0x2c]
8000b472:	58 39       	cp.w	r9,3
8000b474:	e0 8b 00 07 	brhi	8000b482 <jpeg_calc_output_dimensions+0x182>
8000b478:	58 29       	cp.w	r9,2
8000b47a:	c0 c2       	brcc	8000b492 <jpeg_calc_output_dimensions+0x192>
8000b47c:	58 19       	cp.w	r9,1
8000b47e:	c1 21       	brne	8000b4a2 <jpeg_calc_output_dimensions+0x1a2>
8000b480:	c0 58       	rjmp	8000b48a <jpeg_calc_output_dimensions+0x18a>
8000b482:	58 59       	cp.w	r9,5
8000b484:	e0 8b 00 0f 	brhi	8000b4a2 <jpeg_calc_output_dimensions+0x1a2>
8000b488:	c0 98       	rjmp	8000b49a <jpeg_calc_output_dimensions+0x19a>
  case JCS_GRAYSCALE:
    cinfo->out_color_components = 1;
8000b48a:	30 18       	mov	r8,1
8000b48c:	ef 48 00 78 	st.w	r7[120],r8
    break;
8000b490:	c0 b8       	rjmp	8000b4a6 <jpeg_calc_output_dimensions+0x1a6>
#if RGB_PIXELSIZE != 3
    cinfo->out_color_components = RGB_PIXELSIZE;
    break;
#endif /* else share code with YCbCr */
  case JCS_YCbCr:
    cinfo->out_color_components = 3;
8000b492:	30 38       	mov	r8,3
8000b494:	ef 48 00 78 	st.w	r7[120],r8
    break;
8000b498:	c0 78       	rjmp	8000b4a6 <jpeg_calc_output_dimensions+0x1a6>
  case JCS_CMYK:
  case JCS_YCCK:
    cinfo->out_color_components = 4;
8000b49a:	30 48       	mov	r8,4
8000b49c:	ef 48 00 78 	st.w	r7[120],r8
    break;
8000b4a0:	c0 38       	rjmp	8000b4a6 <jpeg_calc_output_dimensions+0x1a6>
  default:			/* else must be same colorspace as in file */
    cinfo->out_color_components = cinfo->num_components;
8000b4a2:	ef 48 00 78 	st.w	r7[120],r8
    break;
  }
  cinfo->output_components = (cinfo->quantize_colors ? 1 :
8000b4a6:	6f 58       	ld.w	r8,r7[0x54]
8000b4a8:	58 08       	cp.w	r8,0
8000b4aa:	f9 b8 01 01 	movne	r8,1
8000b4ae:	ef f8 00 1e 	ld.weq	r8,r7[0x78]
8000b4b2:	ef 48 00 7c 	st.w	r7[124],r8
			      cinfo->out_color_components);

  /* See if upsampler will want to emit more than one row at a time */
  if (use_merged_upsample(cinfo))
8000b4b6:	0e 9c       	mov	r12,r7
8000b4b8:	f0 1f 00 07 	mcall	8000b4d4 <jpeg_calc_output_dimensions+0x1d4>
    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
8000b4bc:	ef f8 10 4e 	ld.wne	r8,r7[0x138]
8000b4c0:	ef f8 1a 20 	st.wne	r7[0x80],r8
  else
    cinfo->rec_outbuf_height = 1;
8000b4c4:	f9 b8 00 01 	moveq	r8,1
8000b4c8:	ef f8 0a 20 	st.weq	r7[0x80],r8
8000b4cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b4d0:	80 00       	ld.sh	r0,r0[0x0]
8000b4d2:	fd 04 80 00 	ld.sh	r4,lr[-32768]
8000b4d6:	b1 48       	asr	r8,0x10

8000b4d8 <jinit_master_decompress>:
 * This is performed at the start of jpeg_start_decompress.
 */

GLOBAL(void)
jinit_master_decompress (j_decompress_ptr cinfo)
{
8000b4d8:	eb cd 40 fe 	pushm	r1-r7,lr
8000b4dc:	18 97       	mov	r7,r12
  my_master_ptr master;

  master = (my_master_ptr)
8000b4de:	18 92       	mov	r2,r12
8000b4e0:	78 18       	ld.w	r8,r12[0x4]
8000b4e2:	70 08       	ld.w	r8,r8[0x0]
8000b4e4:	31 ca       	mov	r10,28
8000b4e6:	30 1b       	mov	r11,1
8000b4e8:	5d 18       	icall	r8
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(my_decomp_master));
  cinfo->master = (struct jpeg_decomp_master *) master;
8000b4ea:	ef 4c 01 a4 	st.w	r7[420],r12
  master->pub.prepare_for_output_pass = prepare_for_output_pass;
8000b4ee:	fe f8 02 1a 	ld.w	r8,pc[538]
8000b4f2:	99 08       	st.w	r12[0x0],r8
  master->pub.finish_output_pass = finish_output_pass;
8000b4f4:	fe f8 02 18 	ld.w	r8,pc[536]
8000b4f8:	99 18       	st.w	r12[0x4],r8

  master->pub.is_dummy_pass = FALSE;
8000b4fa:	30 05       	mov	r5,0
8000b4fc:	99 25       	st.w	r12[0x8],r5
 */

LOCAL(void)
master_selection (j_decompress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;
8000b4fe:	ee f6 01 a4 	ld.w	r6,r7[420]
  boolean use_c_buffer;
  long samplesperrow;
  JDIMENSION jd_samplesperrow;

  /* Initialize dimensions and other stuff */
  jpeg_calc_output_dimensions(cinfo);
8000b502:	0e 9c       	mov	r12,r7
8000b504:	f0 1f 00 83 	mcall	8000b710 <jinit_master_decompress+0x238>
/* Allocate and fill in the sample_range_limit table */
{
  JSAMPLE * table;
  int i;

  table = (JSAMPLE *)
8000b508:	6e 18       	ld.w	r8,r7[0x4]
8000b50a:	70 08       	ld.w	r8,r8[0x0]
8000b50c:	e0 6a 05 80 	mov	r10,1408
8000b510:	30 1b       	mov	r11,1
8000b512:	0e 9c       	mov	r12,r7
8000b514:	5d 18       	icall	r8
8000b516:	18 93       	mov	r3,r12
8000b518:	18 91       	mov	r1,r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
8000b51a:	f8 c4 ff 00 	sub	r4,r12,-256
  cinfo->sample_range_limit = table;
8000b51e:	ef 44 01 44 	st.w	r7[324],r4
  /* First segment of "simple" table: limit[x] = 0 for x < 0 */
  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
8000b522:	e0 6a 01 00 	mov	r10,256
8000b526:	0a 9b       	mov	r11,r5
8000b528:	f0 1f 00 7b 	mcall	8000b714 <jinit_master_decompress+0x23c>
8000b52c:	08 98       	mov	r8,r4
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
    table[i] = (JSAMPLE) i;
8000b52e:	10 c5       	st.b	r8++,r5
  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
  cinfo->sample_range_limit = table;
  /* First segment of "simple" table: limit[x] = 0 for x < 0 */
  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
8000b530:	2f f5       	sub	r5,-1
8000b532:	e0 45 01 00 	cp.w	r5,256
8000b536:	cf c1       	brne	8000b52e <jinit_master_decompress+0x56>
    table[i] = (JSAMPLE) i;
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
8000b538:	28 04       	sub	r4,-128
8000b53a:	e2 c1 fe 00 	sub	r1,r1,-512
 * Initialize master decompression control and select active modules.
 * This is performed at the start of jpeg_start_decompress.
 */

GLOBAL(void)
jinit_master_decompress (j_decompress_ptr cinfo)
8000b53e:	e6 c3 fc 80 	sub	r3,r3,-896
  for (i = 0; i <= MAXJSAMPLE; i++)
    table[i] = (JSAMPLE) i;
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
  /* End of simple table, rest of first half of post-IDCT table */
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
    table[i] = MAXJSAMPLE;
8000b542:	3f f8       	mov	r8,-1
8000b544:	02 c8       	st.b	r1++,r8
  /* Main part of "simple" table: limit[x] = x */
  for (i = 0; i <= MAXJSAMPLE; i++)
    table[i] = (JSAMPLE) i;
  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
  /* End of simple table, rest of first half of post-IDCT table */
  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
8000b546:	06 31       	cp.w	r1,r3
8000b548:	cf e1       	brne	8000b544 <jinit_master_decompress+0x6c>
    table[i] = MAXJSAMPLE;
  /* Second half of post-IDCT table */
  MEMZERO(table + (2 * (MAXJSAMPLE+1)),
8000b54a:	e0 6a 01 80 	mov	r10,384
8000b54e:	30 0b       	mov	r11,0
8000b550:	e8 cc fe 00 	sub	r12,r4,-512
8000b554:	f0 1f 00 70 	mcall	8000b714 <jinit_master_decompress+0x23c>
	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
8000b558:	e0 6a 00 80 	mov	r10,128
8000b55c:	ee fb 01 44 	ld.w	r11,r7[324]
8000b560:	e8 cc fc 80 	sub	r12,r4,-896
8000b564:	f0 1f 00 6d 	mcall	8000b718 <jinit_master_decompress+0x240>
  jd_samplesperrow = (JDIMENSION) samplesperrow;
  if ((long) jd_samplesperrow != samplesperrow)
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);

  /* Initialize my private state */
  master->pass_number = 0;
8000b568:	30 05       	mov	r5,0
8000b56a:	8d 35       	st.w	r6[0xc],r5
  master->using_merged_upsample = use_merged_upsample(cinfo);
8000b56c:	0e 9c       	mov	r12,r7
8000b56e:	f0 1f 00 6c 	mcall	8000b71c <jinit_master_decompress+0x244>
8000b572:	8d 4c       	st.w	r6[0x10],r12

  /* Color quantizer selection */
  master->quantizer_1pass = NULL;
8000b574:	8d 55       	st.w	r6[0x14],r5
  master->quantizer_2pass = NULL;
8000b576:	8d 65       	st.w	r6[0x18],r5
  /* No mode changes if not using buffered-image mode. */
  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
8000b578:	6f 58       	ld.w	r8,r7[0x54]
8000b57a:	58 08       	cp.w	r8,0
8000b57c:	c0 40       	breq	8000b584 <jinit_master_decompress+0xac>
8000b57e:	6f 08       	ld.w	r8,r7[0x40]
8000b580:	58 08       	cp.w	r8,0
8000b582:	c0 b1       	brne	8000b598 <jinit_master_decompress+0xc0>
    cinfo->enable_1pass_quant = FALSE;
8000b584:	30 08       	mov	r8,0
8000b586:	ef 48 00 64 	st.w	r7[100],r8
    cinfo->enable_external_quant = FALSE;
8000b58a:	ef 48 00 68 	st.w	r7[104],r8
    cinfo->enable_2pass_quant = FALSE;
8000b58e:	ef 48 00 6c 	st.w	r7[108],r8
  }
  if (cinfo->quantize_colors) {
8000b592:	6f 58       	ld.w	r8,r7[0x54]
8000b594:	58 08       	cp.w	r8,0
8000b596:	c4 10       	breq	8000b618 <jinit_master_decompress+0x140>
    if (cinfo->raw_data_out)
8000b598:	6f 18       	ld.w	r8,r7[0x44]
8000b59a:	58 08       	cp.w	r8,0
8000b59c:	c0 80       	breq	8000b5ac <jinit_master_decompress+0xd4>
      ERREXIT(cinfo, JERR_NOTIMPL);
8000b59e:	6e 08       	ld.w	r8,r7[0x0]
8000b5a0:	32 f9       	mov	r9,47
8000b5a2:	91 59       	st.w	r8[0x14],r9
8000b5a4:	6e 08       	ld.w	r8,r7[0x0]
8000b5a6:	70 08       	ld.w	r8,r8[0x0]
8000b5a8:	04 9c       	mov	r12,r2
8000b5aa:	5d 18       	icall	r8
    /* 2-pass quantizer only works in 3-component color space. */
    if (cinfo->out_color_components != 3) {
8000b5ac:	6f e8       	ld.w	r8,r7[0x78]
8000b5ae:	58 38       	cp.w	r8,3
8000b5b0:	c0 c0       	breq	8000b5c8 <jinit_master_decompress+0xf0>
      cinfo->enable_1pass_quant = TRUE;
8000b5b2:	30 18       	mov	r8,1
8000b5b4:	ef 48 00 64 	st.w	r7[100],r8
      cinfo->enable_external_quant = FALSE;
8000b5b8:	30 08       	mov	r8,0
8000b5ba:	ef 48 00 68 	st.w	r7[104],r8
      cinfo->enable_2pass_quant = FALSE;
8000b5be:	ef 48 00 6c 	st.w	r7[108],r8
      cinfo->colormap = NULL;
8000b5c2:	ef 48 00 88 	st.w	r7[136],r8
8000b5c6:	c1 48       	rjmp	8000b5ee <jinit_master_decompress+0x116>
    } else if (cinfo->colormap != NULL) {
8000b5c8:	ee f8 00 88 	ld.w	r8,r7[136]
8000b5cc:	58 08       	cp.w	r8,0
8000b5ce:	c0 50       	breq	8000b5d8 <jinit_master_decompress+0x100>
      cinfo->enable_external_quant = TRUE;
8000b5d0:	30 18       	mov	r8,1
8000b5d2:	ef 48 00 68 	st.w	r7[104],r8
8000b5d6:	c0 c8       	rjmp	8000b5ee <jinit_master_decompress+0x116>
    } else if (cinfo->two_pass_quantize) {
8000b5d8:	6f 78       	ld.w	r8,r7[0x5c]
8000b5da:	58 08       	cp.w	r8,0
8000b5dc:	c0 50       	breq	8000b5e6 <jinit_master_decompress+0x10e>
      cinfo->enable_2pass_quant = TRUE;
8000b5de:	30 18       	mov	r8,1
8000b5e0:	ef 48 00 6c 	st.w	r7[108],r8
8000b5e4:	c0 58       	rjmp	8000b5ee <jinit_master_decompress+0x116>
    } else {
      cinfo->enable_1pass_quant = TRUE;
8000b5e6:	30 18       	mov	r8,1
8000b5e8:	ef 48 00 64 	st.w	r7[100],r8
8000b5ec:	c0 48       	rjmp	8000b5f4 <jinit_master_decompress+0x11c>
    }

    if (cinfo->enable_1pass_quant) {
8000b5ee:	6f 98       	ld.w	r8,r7[0x64]
8000b5f0:	58 08       	cp.w	r8,0
8000b5f2:	c0 70       	breq	8000b600 <jinit_master_decompress+0x128>
#ifdef QUANT_1PASS_SUPPORTED
      jinit_1pass_quantizer(cinfo);
8000b5f4:	0e 9c       	mov	r12,r7
8000b5f6:	f0 1f 00 4b 	mcall	8000b720 <jinit_master_decompress+0x248>
      master->quantizer_1pass = cinfo->cquantize;
8000b5fa:	ee f8 01 cc 	ld.w	r8,r7[460]
8000b5fe:	8d 58       	st.w	r6[0x14],r8
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    }

    /* We use the 2-pass code to map to external colormaps. */
    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
8000b600:	6f b8       	ld.w	r8,r7[0x6c]
8000b602:	58 08       	cp.w	r8,0
8000b604:	c0 41       	brne	8000b60c <jinit_master_decompress+0x134>
8000b606:	6f a8       	ld.w	r8,r7[0x68]
8000b608:	58 08       	cp.w	r8,0
8000b60a:	c0 70       	breq	8000b618 <jinit_master_decompress+0x140>
#ifdef QUANT_2PASS_SUPPORTED
      jinit_2pass_quantizer(cinfo);
8000b60c:	0e 9c       	mov	r12,r7
8000b60e:	f0 1f 00 46 	mcall	8000b724 <jinit_master_decompress+0x24c>
      master->quantizer_2pass = cinfo->cquantize;
8000b612:	ee f8 01 cc 	ld.w	r8,r7[460]
8000b616:	8d 68       	st.w	r6[0x18],r8
     * this is necessary for starting with quantization to an external map.
     */
  }

  /* Post-processing: in particular, color conversion first */
  if (! cinfo->raw_data_out) {
8000b618:	6f 18       	ld.w	r8,r7[0x44]
8000b61a:	58 08       	cp.w	r8,0
8000b61c:	c1 21       	brne	8000b640 <jinit_master_decompress+0x168>
    if (master->using_merged_upsample) {
8000b61e:	6c 48       	ld.w	r8,r6[0x10]
8000b620:	58 08       	cp.w	r8,0
8000b622:	c0 50       	breq	8000b62c <jinit_master_decompress+0x154>
#ifdef UPSAMPLE_MERGING_SUPPORTED
      jinit_merged_upsampler(cinfo); /* does color conversion too */
8000b624:	0e 9c       	mov	r12,r7
8000b626:	f0 1f 00 41 	mcall	8000b728 <jinit_master_decompress+0x250>
8000b62a:	c0 78       	rjmp	8000b638 <jinit_master_decompress+0x160>
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else {
      jinit_color_deconverter(cinfo);
8000b62c:	0e 9c       	mov	r12,r7
8000b62e:	f0 1f 00 40 	mcall	8000b72c <jinit_master_decompress+0x254>
      jinit_upsampler(cinfo);
8000b632:	0e 9c       	mov	r12,r7
8000b634:	f0 1f 00 3f 	mcall	8000b730 <jinit_master_decompress+0x258>
    }
    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
8000b638:	6f bb       	ld.w	r11,r7[0x6c]
8000b63a:	0e 9c       	mov	r12,r7
8000b63c:	f0 1f 00 3e 	mcall	8000b734 <jinit_master_decompress+0x25c>
  }
  /* Inverse DCT */
  jinit_inverse_dct(cinfo);
8000b640:	0e 9c       	mov	r12,r7
8000b642:	f0 1f 00 3e 	mcall	8000b738 <jinit_master_decompress+0x260>
  /* Entropy decoding: either Huffman or arithmetic coding. */
  if (cinfo->arith_code) {
8000b646:	ee f8 00 e0 	ld.w	r8,r7[224]
8000b64a:	58 08       	cp.w	r8,0
8000b64c:	c0 90       	breq	8000b65e <jinit_master_decompress+0x186>
    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
8000b64e:	6e 08       	ld.w	r8,r7[0x0]
8000b650:	30 19       	mov	r9,1
8000b652:	91 59       	st.w	r8[0x14],r9
8000b654:	6e 08       	ld.w	r8,r7[0x0]
8000b656:	70 08       	ld.w	r8,r8[0x0]
8000b658:	04 9c       	mov	r12,r2
8000b65a:	5d 18       	icall	r8
8000b65c:	c0 c8       	rjmp	8000b674 <jinit_master_decompress+0x19c>
  } else {
    if (cinfo->progressive_mode) {
8000b65e:	ee f8 00 dc 	ld.w	r8,r7[220]
8000b662:	58 08       	cp.w	r8,0
8000b664:	c0 50       	breq	8000b66e <jinit_master_decompress+0x196>
#ifdef D_PROGRESSIVE_SUPPORTED
      jinit_phuff_decoder(cinfo);
8000b666:	0e 9c       	mov	r12,r7
8000b668:	f0 1f 00 35 	mcall	8000b73c <jinit_master_decompress+0x264>
8000b66c:	c0 48       	rjmp	8000b674 <jinit_master_decompress+0x19c>
#else
      ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
    } else
      jinit_huff_decoder(cinfo);
8000b66e:	0e 9c       	mov	r12,r7
8000b670:	f0 1f 00 34 	mcall	8000b740 <jinit_master_decompress+0x268>
  }

  /* Initialize principal buffer controllers. */
  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
8000b674:	ee f8 01 b4 	ld.w	r8,r7[436]
8000b678:	70 48       	ld.w	r8,r8[0x10]
8000b67a:	58 08       	cp.w	r8,0
8000b67c:	c0 30       	breq	8000b682 <jinit_master_decompress+0x1aa>
8000b67e:	30 1b       	mov	r11,1
8000b680:	c0 48       	rjmp	8000b688 <jinit_master_decompress+0x1b0>
8000b682:	6f 08       	ld.w	r8,r7[0x40]
8000b684:	58 08       	cp.w	r8,0
8000b686:	5f 1b       	srne	r11
  jinit_d_coef_controller(cinfo, use_c_buffer);
8000b688:	0e 9c       	mov	r12,r7
8000b68a:	f0 1f 00 2f 	mcall	8000b744 <jinit_master_decompress+0x26c>

  if (! cinfo->raw_data_out)
8000b68e:	6f 18       	ld.w	r8,r7[0x44]
8000b690:	58 08       	cp.w	r8,0
8000b692:	c0 51       	brne	8000b69c <jinit_master_decompress+0x1c4>
    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
8000b694:	30 0b       	mov	r11,0
8000b696:	0e 9c       	mov	r12,r7
8000b698:	f0 1f 00 2c 	mcall	8000b748 <jinit_master_decompress+0x270>

  /* We can now tell the memory manager to allocate virtual arrays. */
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
8000b69c:	6e 18       	ld.w	r8,r7[0x4]
8000b69e:	70 68       	ld.w	r8,r8[0x18]
8000b6a0:	04 9c       	mov	r12,r2
8000b6a2:	5d 18       	icall	r8

  /* Initialize input side of decompressor to consume first scan. */
  (*cinfo->inputctl->start_input_pass) (cinfo);
8000b6a4:	ee f8 01 b4 	ld.w	r8,r7[436]
8000b6a8:	70 28       	ld.w	r8,r8[0x8]
8000b6aa:	0e 9c       	mov	r12,r7
8000b6ac:	5d 18       	icall	r8
#ifdef D_MULTISCAN_FILES_SUPPORTED
  /* If jpeg_start_decompress will read the whole file, initialize
   * progress monitoring appropriately.  The input step is counted
   * as one pass.
   */
  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
8000b6ae:	6e 28       	ld.w	r8,r7[0x8]
8000b6b0:	58 08       	cp.w	r8,0
8000b6b2:	c2 80       	breq	8000b702 <jinit_master_decompress+0x22a>
8000b6b4:	6f 09       	ld.w	r9,r7[0x40]
8000b6b6:	58 09       	cp.w	r9,0
8000b6b8:	c2 51       	brne	8000b702 <jinit_master_decompress+0x22a>
8000b6ba:	ee f9 01 b4 	ld.w	r9,r7[436]
8000b6be:	72 49       	ld.w	r9,r9[0x10]
8000b6c0:	58 09       	cp.w	r9,0
8000b6c2:	c2 00       	breq	8000b702 <jinit_master_decompress+0x22a>
      cinfo->inputctl->has_multiple_scans) {
    int nscans;
    /* Estimate number of scans to set pass_limit. */
    if (cinfo->progressive_mode) {
8000b6c4:	ee f9 00 dc 	ld.w	r9,r7[220]
8000b6c8:	58 09       	cp.w	r9,0
8000b6ca:	c0 60       	breq	8000b6d6 <jinit_master_decompress+0x1fe>
      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
      nscans = 2 + 3 * cinfo->num_components;
8000b6cc:	6e 9b       	ld.w	r11,r7[0x24]
8000b6ce:	f6 0b 00 1b 	add	r11,r11,r11<<0x1
8000b6d2:	2f eb       	sub	r11,-2
8000b6d4:	c0 28       	rjmp	8000b6d8 <jinit_master_decompress+0x200>
    } else {
      /* For a nonprogressive multiscan file, estimate 1 scan per component. */
      nscans = cinfo->num_components;
8000b6d6:	6e 9b       	ld.w	r11,r7[0x24]
    }
    cinfo->progress->pass_counter = 0L;
8000b6d8:	30 09       	mov	r9,0
8000b6da:	91 19       	st.w	r8[0x4],r9
    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
8000b6dc:	6e 28       	ld.w	r8,r7[0x8]
8000b6de:	ee fa 01 40 	ld.w	r10,r7[320]
8000b6e2:	f6 0a 02 4a 	mul	r10,r11,r10
8000b6e6:	91 2a       	st.w	r8[0x8],r10
    cinfo->progress->completed_passes = 0;
8000b6e8:	6e 28       	ld.w	r8,r7[0x8]
8000b6ea:	91 39       	st.w	r8[0xc],r9
    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
8000b6ec:	6e 29       	ld.w	r9,r7[0x8]
8000b6ee:	6f b8       	ld.w	r8,r7[0x6c]
8000b6f0:	58 08       	cp.w	r8,0
8000b6f2:	f9 b8 01 03 	movne	r8,3
8000b6f6:	f9 b8 00 02 	moveq	r8,2
8000b6fa:	93 48       	st.w	r9[0x10],r8
    /* Count the input pass as done */
    master->pass_number++;
8000b6fc:	6c 38       	ld.w	r8,r6[0xc]
8000b6fe:	2f f8       	sub	r8,-1
8000b700:	8d 38       	st.w	r6[0xc],r8
8000b702:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000b706:	00 00       	add	r0,r0
8000b708:	80 00       	ld.sh	r0,r0[0x0]
8000b70a:	b1 ba       	sbr	r10,0x11
8000b70c:	80 00       	ld.sh	r0,r0[0x0]
8000b70e:	b2 e0       	st.b	r9[0x6],r0
8000b710:	80 00       	ld.sh	r0,r0[0x0]
8000b712:	b3 00       	ld.d	r0,r9
8000b714:	80 01       	ld.sh	r1,r0[0x0]
8000b716:	56 02       	stdsp	sp[0x180],r2
8000b718:	80 01       	ld.sh	r1,r0[0x0]
8000b71a:	54 ba       	stdsp	sp[0x12c],r10
8000b71c:	80 00       	ld.sh	r0,r0[0x0]
8000b71e:	b1 48       	asr	r8,0x10
8000b720:	80 00       	ld.sh	r0,r0[0x0]
8000b722:	e8 38 80 00 	sub	r8,622592
8000b726:	fb 08 80 00 	ld.sh	r8,sp[-32768]
8000b72a:	ba 18       	st.h	sp[0x2],r8
8000b72c:	80 00       	ld.sh	r0,r0[0x0]
8000b72e:	89 c4       	st.w	r4[0x30],r4
8000b730:	80 00       	ld.sh	r0,r0[0x0]
8000b732:	ca 7c       	rcall	8000b880 <h2v1_merged_upsample+0xfe>
8000b734:	80 00       	ld.sh	r0,r0[0x0]
8000b736:	c7 78       	rjmp	8000b824 <h2v1_merged_upsample+0xa2>
8000b738:	80 00       	ld.sh	r0,r0[0x0]
8000b73a:	8c ec       	ld.uh	r12,r6[0xc]
8000b73c:	80 00       	ld.sh	r0,r0[0x0]
8000b73e:	bc 30       	st.h	lr[0x6],r0
8000b740:	80 00       	ld.sh	r0,r0[0x0]
8000b742:	92 14       	ld.sh	r4,r9[0x2]
8000b744:	80 00       	ld.sh	r0,r0[0x0]
8000b746:	7e b8       	ld.w	r8,pc[0x2c]
8000b748:	80 00       	ld.sh	r0,r0[0x0]
8000b74a:	9d 90       	st.w	lr[0x24],r0

8000b74c <start_pass_merged_upsample>:
 */

METHODDEF(void)
start_pass_merged_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000b74c:	f8 f8 01 c4 	ld.w	r8,r12[452]

  /* Mark the spare buffer empty */
  upsample->spare_full = FALSE;
8000b750:	30 09       	mov	r9,0
8000b752:	91 99       	st.w	r8[0x24],r9
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
8000b754:	79 d9       	ld.w	r9,r12[0x74]
8000b756:	91 b9       	st.w	r8[0x2c],r9
}
8000b758:	5e fc       	retal	r12

8000b75a <merged_1v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 1:1 vertical sampling case: much easier, never need a spare row. */
{
8000b75a:	eb cd 40 e0 	pushm	r5-r7,lr
8000b75e:	14 95       	mov	r5,r10
8000b760:	40 47       	lddsp	r7,sp[0x10]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;

  /* Just do the upsampling. */
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
8000b762:	f8 fa 01 c4 	ld.w	r10,r12[452]
8000b766:	6e 09       	ld.w	r9,r7[0x0]
8000b768:	74 36       	ld.w	r6,r10[0xc]
8000b76a:	f0 09 00 29 	add	r9,r8,r9<<0x2
8000b76e:	6a 0a       	ld.w	r10,r5[0x0]
8000b770:	5d 16       	icall	r6
			 output_buf + *out_row_ctr);
  /* Adjust counts */
  (*out_row_ctr)++;
8000b772:	6e 08       	ld.w	r8,r7[0x0]
8000b774:	2f f8       	sub	r8,-1
8000b776:	8f 08       	st.w	r7[0x0],r8
  (*in_row_group_ctr)++;
8000b778:	6a 08       	ld.w	r8,r5[0x0]
8000b77a:	2f f8       	sub	r8,-1
8000b77c:	8b 08       	st.w	r5[0x0],r8
}
8000b77e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b782 <h2v1_merged_upsample>:

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
8000b782:	d4 31       	pushm	r0-r7,lr
8000b784:	20 5d       	sub	sp,20
8000b786:	50 3c       	stdsp	sp[0xc],r12
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000b788:	f8 fc 01 c4 	ld.w	r12,r12[452]
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
8000b78c:	40 3e       	lddsp	lr,sp[0xc]
8000b78e:	fc f8 01 44 	ld.w	r8,lr[324]
  int * Crrtab = upsample->Cr_r_tab;
8000b792:	78 46       	ld.w	r6,r12[0x10]
8000b794:	50 16       	stdsp	sp[0x4],r6
  int * Cbbtab = upsample->Cb_b_tab;
8000b796:	78 55       	ld.w	r5,r12[0x14]
8000b798:	50 05       	stdsp	sp[0x0],r5
  INT32 * Crgtab = upsample->Cr_g_tab;
8000b79a:	78 6e       	ld.w	lr,r12[0x18]
  INT32 * Cbgtab = upsample->Cb_g_tab;
8000b79c:	78 7c       	ld.w	r12,r12[0x1c]
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
8000b79e:	a3 6a       	lsl	r10,0x2
8000b7a0:	76 07       	ld.w	r7,r11[0x0]
8000b7a2:	ee 0a 03 01 	ld.w	r1,r7[r10]
8000b7a6:	50 41       	stdsp	sp[0x10],r1
  inptr1 = input_buf[1][in_row_group_ctr];
8000b7a8:	76 17       	ld.w	r7,r11[0x4]
8000b7aa:	ee 0a 03 07 	ld.w	r7,r7[r10]
  inptr2 = input_buf[2][in_row_group_ctr];
8000b7ae:	76 2b       	ld.w	r11,r11[0x8]
8000b7b0:	f6 0a 03 0a 	ld.w	r10,r11[r10]
  outptr = output_buf[0];
8000b7b4:	72 09       	ld.w	r9,r9[0x0]
8000b7b6:	50 29       	stdsp	sp[0x8],r9
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
8000b7b8:	40 3b       	lddsp	r11,sp[0xc]
8000b7ba:	77 c0       	ld.w	r0,r11[0x70]
8000b7bc:	a1 90       	lsr	r0,0x1
8000b7be:	c4 30       	breq	8000b844 <h2v1_merged_upsample+0xc2>
8000b7c0:	02 96       	mov	r6,r1
8000b7c2:	30 0b       	mov	r11,0
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
8000b7c4:	f4 0b 07 04 	ld.ub	r4,r10[r11]
8000b7c8:	a3 64       	lsl	r4,0x2
8000b7ca:	40 15       	lddsp	r5,sp[0x4]
8000b7cc:	ea 04 03 02 	ld.w	r2,r5[r4]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
8000b7d0:	ee 0b 07 05 	ld.ub	r5,r7[r11]
8000b7d4:	a3 65       	lsl	r5,0x2
8000b7d6:	fc 04 03 03 	ld.w	r3,lr[r4]
8000b7da:	f8 05 03 04 	ld.w	r4,r12[r5]
8000b7de:	08 03       	add	r3,r4
8000b7e0:	b1 43       	asr	r3,0x10
    cblue = Cbbtab[cb];
8000b7e2:	40 01       	lddsp	r1,sp[0x0]
8000b7e4:	e2 05 03 04 	ld.w	r4,r1[r5]
    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
8000b7e8:	0d 85       	ld.ub	r5,r6[0x0]
    outptr[RGB_RED] =   range_limit[y + cred];
8000b7ea:	f0 02 00 01 	add	r1,r8,r2
8000b7ee:	e2 05 07 01 	ld.ub	r1,r1[r5]
8000b7f2:	b2 a1       	st.b	r9[0x2],r1
    outptr[RGB_GREEN] = range_limit[y + cgreen];
8000b7f4:	f0 03 00 01 	add	r1,r8,r3
8000b7f8:	e2 05 07 01 	ld.ub	r1,r1[r5]
8000b7fc:	b2 91       	st.b	r9[0x1],r1
    outptr[RGB_BLUE] =  range_limit[y + cblue];
8000b7fe:	f0 04 00 01 	add	r1,r8,r4
8000b802:	e2 05 07 05 	ld.ub	r5,r1[r5]
8000b806:	b2 85       	st.b	r9[0x0],r5
    outptr += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr0++);
8000b808:	0d 95       	ld.ub	r5,r6[0x1]
/*
 * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
 */

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
8000b80a:	2f e6       	sub	r6,-2
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
    outptr += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr0++);
    outptr[RGB_RED] =   range_limit[y + cred];
8000b80c:	f0 05 00 05 	add	r5,r8,r5
8000b810:	ea 02 07 02 	ld.ub	r2,r5[r2]
8000b814:	b2 d2       	st.b	r9[0x5],r2
    outptr[RGB_GREEN] = range_limit[y + cgreen];
8000b816:	ea 03 07 03 	ld.ub	r3,r5[r3]
8000b81a:	b2 c3       	st.b	r9[0x4],r3
    outptr[RGB_BLUE] =  range_limit[y + cblue];
8000b81c:	ea 04 07 05 	ld.ub	r5,r5[r4]
8000b820:	b2 b5       	st.b	r9[0x3],r5
/*
 * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
 */

METHODDEF(void)
h2v1_merged_upsample (j_decompress_ptr cinfo,
8000b822:	2f a9       	sub	r9,-6
8000b824:	2f fb       	sub	r11,-1
  inptr0 = input_buf[0][in_row_group_ctr];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr = output_buf[0];
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
8000b826:	16 30       	cp.w	r0,r11
8000b828:	cc e1       	brne	8000b7c4 <h2v1_merged_upsample+0x42>
8000b82a:	00 07       	add	r7,r0
8000b82c:	00 0a       	add	r10,r0
8000b82e:	e0 09 15 01 	lsl	r9,r0,0x1
8000b832:	40 4b       	lddsp	r11,sp[0x10]
8000b834:	12 0b       	add	r11,r9
8000b836:	50 4b       	stdsp	sp[0x10],r11
8000b838:	f2 00 00 00 	add	r0,r9,r0
8000b83c:	40 29       	lddsp	r9,sp[0x8]
8000b83e:	f2 00 00 19 	add	r9,r9,r0<<0x1
8000b842:	50 29       	stdsp	sp[0x8],r9
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
    outptr += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
8000b844:	40 36       	lddsp	r6,sp[0xc]
8000b846:	6d c9       	ld.w	r9,r6[0x70]
8000b848:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000b84c:	c2 10       	breq	8000b88e <h2v1_merged_upsample+0x10c>
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
8000b84e:	15 8a       	ld.ub	r10,r10[0x0]
8000b850:	a3 6a       	lsl	r10,0x2
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
8000b852:	0f 89       	ld.ub	r9,r7[0x0]
8000b854:	a3 69       	lsl	r9,0x2
8000b856:	fc 0a 03 0e 	ld.w	lr,lr[r10]
8000b85a:	f8 09 03 0b 	ld.w	r11,r12[r9]
8000b85e:	fc 0b 00 0c 	add	r12,lr,r11
8000b862:	b1 4c       	asr	r12,0x10
    cblue = Cbbtab[cb];
8000b864:	40 05       	lddsp	r5,sp[0x0]
8000b866:	ea 09 03 0b 	ld.w	r11,r5[r9]
    y  = GETJSAMPLE(*inptr0);
8000b86a:	40 41       	lddsp	r1,sp[0x10]
8000b86c:	03 89       	ld.ub	r9,r1[0x0]
    outptr[RGB_RED] =   range_limit[y + cred];
8000b86e:	40 1e       	lddsp	lr,sp[0x4]
8000b870:	fc 0a 03 0a 	ld.w	r10,lr[r10]
8000b874:	f0 0a 00 0a 	add	r10,r8,r10
8000b878:	f4 09 07 0a 	ld.ub	r10,r10[r9]
8000b87c:	40 26       	lddsp	r6,sp[0x8]
8000b87e:	ac aa       	st.b	r6[0x2],r10
    outptr[RGB_GREEN] = range_limit[y + cgreen];
8000b880:	12 08       	add	r8,r9
8000b882:	f0 0c 07 09 	ld.ub	r9,r8[r12]
8000b886:	ac 99       	st.b	r6[0x1],r9
    outptr[RGB_BLUE] =  range_limit[y + cblue];
8000b888:	f0 0b 07 08 	ld.ub	r8,r8[r11]
8000b88c:	ac 88       	st.b	r6[0x0],r8
  }
}
8000b88e:	2f bd       	sub	sp,-20
8000b890:	d8 32       	popm	r0-r7,pc

8000b892 <h2v2_merged_upsample>:

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
		      JSAMPARRAY output_buf)
{
8000b892:	d4 31       	pushm	r0-r7,lr
8000b894:	20 9d       	sub	sp,36
8000b896:	50 6c       	stdsp	sp[0x18],r12
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000b898:	f8 f8 01 c4 	ld.w	r8,r12[452]
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE * range_limit = cinfo->sample_range_limit;
8000b89c:	f8 fc 01 44 	ld.w	r12,r12[324]
  int * Crrtab = upsample->Cr_r_tab;
8000b8a0:	70 4e       	ld.w	lr,r8[0x10]
8000b8a2:	50 3e       	stdsp	sp[0xc],lr
  int * Cbbtab = upsample->Cb_b_tab;
8000b8a4:	70 57       	ld.w	r7,r8[0x14]
8000b8a6:	50 27       	stdsp	sp[0x8],r7
  INT32 * Crgtab = upsample->Cr_g_tab;
8000b8a8:	70 64       	ld.w	r4,r8[0x18]
8000b8aa:	50 14       	stdsp	sp[0x4],r4
  INT32 * Cbgtab = upsample->Cb_g_tab;
8000b8ac:	70 71       	ld.w	r1,r8[0x1c]
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr*2];
8000b8ae:	76 08       	ld.w	r8,r11[0x0]
8000b8b0:	f0 0a 03 30 	ld.w	r0,r8[r10<<0x3]
8000b8b4:	50 80       	stdsp	sp[0x20],r0
  inptr01 = input_buf[0][in_row_group_ctr*2 + 1];
8000b8b6:	f0 0a 00 38 	add	r8,r8,r10<<0x3
8000b8ba:	70 18       	ld.w	r8,r8[0x4]
8000b8bc:	50 78       	stdsp	sp[0x1c],r8
  inptr1 = input_buf[1][in_row_group_ctr];
8000b8be:	a3 6a       	lsl	r10,0x2
8000b8c0:	76 18       	ld.w	r8,r11[0x4]
8000b8c2:	f0 0a 03 08 	ld.w	r8,r8[r10]
8000b8c6:	50 08       	stdsp	sp[0x0],r8
  inptr2 = input_buf[2][in_row_group_ctr];
8000b8c8:	76 28       	ld.w	r8,r11[0x8]
8000b8ca:	f0 0a 03 02 	ld.w	r2,r8[r10]
  outptr0 = output_buf[0];
8000b8ce:	72 0e       	ld.w	lr,r9[0x0]
8000b8d0:	50 4e       	stdsp	sp[0x10],lr
  outptr1 = output_buf[1];
8000b8d2:	72 19       	ld.w	r9,r9[0x4]
8000b8d4:	50 59       	stdsp	sp[0x14],r9
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
8000b8d6:	40 6b       	lddsp	r11,sp[0x18]
8000b8d8:	77 c3       	ld.w	r3,r11[0x70]
8000b8da:	a1 93       	lsr	r3,0x1
8000b8dc:	c6 a0       	breq	8000b9b0 <h2v2_merged_upsample+0x11e>
8000b8de:	40 75       	lddsp	r5,sp[0x1c]
8000b8e0:	00 96       	mov	r6,r0
8000b8e2:	1c 98       	mov	r8,lr
8000b8e4:	30 0a       	mov	r10,0
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
8000b8e6:	e4 0a 07 0e 	ld.ub	lr,r2[r10]
8000b8ea:	a3 6e       	lsl	lr,0x2
8000b8ec:	40 34       	lddsp	r4,sp[0xc]
8000b8ee:	e8 0e 03 07 	ld.w	r7,r4[lr]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
8000b8f2:	40 00       	lddsp	r0,sp[0x0]
8000b8f4:	e0 0a 07 0b 	ld.ub	r11,r0[r10]
8000b8f8:	a3 6b       	lsl	r11,0x2
8000b8fa:	40 10       	lddsp	r0,sp[0x4]
8000b8fc:	e0 0e 03 04 	ld.w	r4,r0[lr]
8000b900:	e2 0b 03 0e 	ld.w	lr,r1[r11]
8000b904:	e8 0e 00 0e 	add	lr,r4,lr
8000b908:	b1 4e       	asr	lr,0x10
    cblue = Cbbtab[cb];
8000b90a:	40 24       	lddsp	r4,sp[0x8]
8000b90c:	e8 0b 03 0b 	ld.w	r11,r4[r11]
    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
8000b910:	0d 84       	ld.ub	r4,r6[0x0]
    outptr0[RGB_RED] =   range_limit[y + cred];
8000b912:	f8 07 00 00 	add	r0,r12,r7
8000b916:	e0 04 07 00 	ld.ub	r0,r0[r4]
8000b91a:	b0 a0       	st.b	r8[0x2],r0
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
8000b91c:	f8 0e 00 00 	add	r0,r12,lr
8000b920:	e0 04 07 00 	ld.ub	r0,r0[r4]
8000b924:	b0 90       	st.b	r8[0x1],r0
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
8000b926:	f8 0b 00 00 	add	r0,r12,r11
8000b92a:	e0 04 07 04 	ld.ub	r4,r0[r4]
8000b92e:	b0 84       	st.b	r8[0x0],r4
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr00++);
8000b930:	0d 94       	ld.ub	r4,r6[0x1]
/*
 * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
 */

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
8000b932:	2f e6       	sub	r6,-2
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
8000b934:	f8 04 00 04 	add	r4,r12,r4
8000b938:	e8 07 07 00 	ld.ub	r0,r4[r7]
8000b93c:	b0 d0       	st.b	r8[0x5],r0
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
8000b93e:	e8 0e 07 00 	ld.ub	r0,r4[lr]
8000b942:	b0 c0       	st.b	r8[0x4],r0
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
8000b944:	e8 0b 07 04 	ld.ub	r4,r4[r11]
8000b948:	b0 b4       	st.b	r8[0x3],r4
/*
 * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
 */

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
8000b94a:	2f a8       	sub	r8,-6
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
8000b94c:	0b 84       	ld.ub	r4,r5[0x0]
    outptr1[RGB_RED] =   range_limit[y + cred];
8000b94e:	f8 04 00 04 	add	r4,r12,r4
8000b952:	e8 07 07 00 	ld.ub	r0,r4[r7]
8000b956:	b2 a0       	st.b	r9[0x2],r0
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
8000b958:	e8 0e 07 00 	ld.ub	r0,r4[lr]
8000b95c:	b2 90       	st.b	r9[0x1],r0
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
8000b95e:	e8 0b 07 04 	ld.ub	r4,r4[r11]
8000b962:	b2 84       	st.b	r9[0x0],r4
    outptr1 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
8000b964:	0b 94       	ld.ub	r4,r5[0x1]
/*
 * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
 */

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
8000b966:	2f e5       	sub	r5,-2
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
    outptr1 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
    outptr1[RGB_RED] =   range_limit[y + cred];
8000b968:	f8 04 00 04 	add	r4,r12,r4
8000b96c:	e8 07 07 07 	ld.ub	r7,r4[r7]
8000b970:	b2 d7       	st.b	r9[0x5],r7
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
8000b972:	e8 0e 07 0e 	ld.ub	lr,r4[lr]
8000b976:	b2 ce       	st.b	r9[0x4],lr
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
8000b978:	e8 0b 07 0b 	ld.ub	r11,r4[r11]
8000b97c:	b2 bb       	st.b	r9[0x3],r11
/*
 * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
 */

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
8000b97e:	2f a9       	sub	r9,-6
8000b980:	2f fa       	sub	r10,-1
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr0 = output_buf[0];
  outptr1 = output_buf[1];
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
8000b982:	14 33       	cp.w	r3,r10
8000b984:	cb 11       	brne	8000b8e6 <h2v2_merged_upsample+0x54>
8000b986:	40 00       	lddsp	r0,sp[0x0]
8000b988:	06 00       	add	r0,r3
8000b98a:	50 00       	stdsp	sp[0x0],r0
8000b98c:	06 02       	add	r2,r3
/*
 * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
 */

METHODDEF(void)
h2v2_merged_upsample (j_decompress_ptr cinfo,
8000b98e:	e6 08 15 01 	lsl	r8,r3,0x1
8000b992:	40 8e       	lddsp	lr,sp[0x20]
8000b994:	10 0e       	add	lr,r8
8000b996:	50 8e       	stdsp	sp[0x20],lr
8000b998:	f0 03 00 03 	add	r3,r8,r3
8000b99c:	a1 73       	lsl	r3,0x1
8000b99e:	40 4b       	lddsp	r11,sp[0x10]
8000b9a0:	06 0b       	add	r11,r3
8000b9a2:	50 4b       	stdsp	sp[0x10],r11
8000b9a4:	40 7a       	lddsp	r10,sp[0x1c]
8000b9a6:	10 0a       	add	r10,r8
8000b9a8:	50 7a       	stdsp	sp[0x1c],r10
8000b9aa:	40 59       	lddsp	r9,sp[0x14]
8000b9ac:	06 09       	add	r9,r3
8000b9ae:	50 59       	stdsp	sp[0x14],r9
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
    outptr1 += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
8000b9b0:	40 67       	lddsp	r7,sp[0x18]
8000b9b2:	6f c8       	ld.w	r8,r7[0x70]
8000b9b4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b9b8:	c2 e0       	breq	8000ba14 <h2v2_merged_upsample+0x182>
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
8000b9ba:	05 89       	ld.ub	r9,r2[0x0]
8000b9bc:	a3 69       	lsl	r9,0x2
8000b9be:	40 34       	lddsp	r4,sp[0xc]
8000b9c0:	e8 09 03 0b 	ld.w	r11,r4[r9]
    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
8000b9c4:	40 00       	lddsp	r0,sp[0x0]
8000b9c6:	01 88       	ld.ub	r8,r0[0x0]
8000b9c8:	a3 68       	lsl	r8,0x2
8000b9ca:	40 1e       	lddsp	lr,sp[0x4]
8000b9cc:	fc 09 03 0a 	ld.w	r10,lr[r9]
8000b9d0:	e2 08 03 09 	ld.w	r9,r1[r8]
8000b9d4:	12 0a       	add	r10,r9
8000b9d6:	b1 4a       	asr	r10,0x10
    cblue = Cbbtab[cb];
8000b9d8:	40 27       	lddsp	r7,sp[0x8]
8000b9da:	ee 08 03 09 	ld.w	r9,r7[r8]
    y  = GETJSAMPLE(*inptr00);
8000b9de:	40 84       	lddsp	r4,sp[0x20]
8000b9e0:	09 88       	ld.ub	r8,r4[0x0]
    outptr0[RGB_RED] =   range_limit[y + cred];
8000b9e2:	f8 08 00 08 	add	r8,r12,r8
8000b9e6:	f0 0b 07 0e 	ld.ub	lr,r8[r11]
8000b9ea:	40 40       	lddsp	r0,sp[0x10]
8000b9ec:	a0 ae       	st.b	r0[0x2],lr
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
8000b9ee:	f0 0a 07 0e 	ld.ub	lr,r8[r10]
8000b9f2:	a0 9e       	st.b	r0[0x1],lr
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
8000b9f4:	f0 09 07 08 	ld.ub	r8,r8[r9]
8000b9f8:	a0 88       	st.b	r0[0x0],r8
    y  = GETJSAMPLE(*inptr01);
8000b9fa:	40 7e       	lddsp	lr,sp[0x1c]
8000b9fc:	1d 88       	ld.ub	r8,lr[0x0]
    outptr1[RGB_RED] =   range_limit[y + cred];
8000b9fe:	10 0c       	add	r12,r8
8000ba00:	f8 0b 07 08 	ld.ub	r8,r12[r11]
8000ba04:	40 5b       	lddsp	r11,sp[0x14]
8000ba06:	b6 a8       	st.b	r11[0x2],r8
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
8000ba08:	f8 0a 07 08 	ld.ub	r8,r12[r10]
8000ba0c:	b6 98       	st.b	r11[0x1],r8
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
8000ba0e:	f8 09 07 08 	ld.ub	r8,r12[r9]
8000ba12:	b6 88       	st.b	r11[0x0],r8
  }
}
8000ba14:	2f 7d       	sub	sp,-36
8000ba16:	d8 32       	popm	r0-r7,pc

8000ba18 <jinit_merged_upsampler>:
 * of this module; no safety checks are made here.
 */

GLOBAL(void)
jinit_merged_upsampler (j_decompress_ptr cinfo)
{
8000ba18:	eb cd 40 e0 	pushm	r5-r7,lr
8000ba1c:	18 96       	mov	r6,r12
  my_upsample_ptr upsample;

  upsample = (my_upsample_ptr)
8000ba1e:	18 95       	mov	r5,r12
8000ba20:	78 18       	ld.w	r8,r12[0x4]
8000ba22:	70 08       	ld.w	r8,r8[0x0]
8000ba24:	33 0a       	mov	r10,48
8000ba26:	30 1b       	mov	r11,1
8000ba28:	5d 18       	icall	r8
8000ba2a:	18 97       	mov	r7,r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
8000ba2c:	ed 4c 01 c4 	st.w	r6[452],r12
  upsample->pub.start_pass = start_pass_merged_upsample;
8000ba30:	4b 78       	lddpc	r8,8000bb0c <jinit_merged_upsampler+0xf4>
8000ba32:	99 08       	st.w	r12[0x0],r8
  upsample->pub.need_context_rows = FALSE;
8000ba34:	30 08       	mov	r8,0
8000ba36:	99 28       	st.w	r12[0x8],r8

  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
8000ba38:	6d ea       	ld.w	r10,r6[0x78]
8000ba3a:	6d c8       	ld.w	r8,r6[0x70]
8000ba3c:	b1 3a       	mul	r10,r8
8000ba3e:	99 aa       	st.w	r12[0x28],r10

  if (cinfo->max_v_samp_factor == 2) {
8000ba40:	ec f8 01 38 	ld.w	r8,r6[312]
8000ba44:	58 28       	cp.w	r8,2
8000ba46:	c0 c1       	brne	8000ba5e <jinit_merged_upsampler+0x46>
    upsample->pub.upsample = merged_2v_upsample;
8000ba48:	4b 28       	lddpc	r8,8000bb10 <jinit_merged_upsampler+0xf8>
8000ba4a:	99 18       	st.w	r12[0x4],r8
    upsample->upmethod = h2v2_merged_upsample;
8000ba4c:	4b 28       	lddpc	r8,8000bb14 <jinit_merged_upsampler+0xfc>
8000ba4e:	99 38       	st.w	r12[0xc],r8
    /* Allocate a spare row buffer */
    upsample->spare_row = (JSAMPROW)
8000ba50:	6c 18       	ld.w	r8,r6[0x4]
8000ba52:	70 18       	ld.w	r8,r8[0x4]
8000ba54:	30 1b       	mov	r11,1
8000ba56:	0c 9c       	mov	r12,r6
8000ba58:	5d 18       	icall	r8
8000ba5a:	8f 8c       	st.w	r7[0x20],r12
8000ba5c:	c0 78       	rjmp	8000ba6a <jinit_merged_upsampler+0x52>
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
  } else {
    upsample->pub.upsample = merged_1v_upsample;
8000ba5e:	4a f8       	lddpc	r8,8000bb18 <jinit_merged_upsampler+0x100>
8000ba60:	99 18       	st.w	r12[0x4],r8
    upsample->upmethod = h2v1_merged_upsample;
8000ba62:	4a f8       	lddpc	r8,8000bb1c <jinit_merged_upsampler+0x104>
8000ba64:	99 38       	st.w	r12[0xc],r8
    /* No spare row needed */
    upsample->spare_row = NULL;
8000ba66:	30 08       	mov	r8,0
8000ba68:	99 88       	st.w	r12[0x20],r8
 */

LOCAL(void)
build_ycc_rgb_table (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000ba6a:	ec f7 01 c4 	ld.w	r7,r6[452]
  int i;
  INT32 x;
  SHIFT_TEMPS

  upsample->Cr_r_tab = (int *)
8000ba6e:	6c 18       	ld.w	r8,r6[0x4]
8000ba70:	70 08       	ld.w	r8,r8[0x0]
8000ba72:	e0 6a 04 00 	mov	r10,1024
8000ba76:	30 1b       	mov	r11,1
8000ba78:	0a 9c       	mov	r12,r5
8000ba7a:	5d 18       	icall	r8
8000ba7c:	8f 4c       	st.w	r7[0x10],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cb_b_tab = (int *)
8000ba7e:	6c 18       	ld.w	r8,r6[0x4]
8000ba80:	70 08       	ld.w	r8,r8[0x0]
8000ba82:	e0 6a 04 00 	mov	r10,1024
8000ba86:	30 1b       	mov	r11,1
8000ba88:	0a 9c       	mov	r12,r5
8000ba8a:	5d 18       	icall	r8
8000ba8c:	8f 5c       	st.w	r7[0x14],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(int));
  upsample->Cr_g_tab = (INT32 *)
8000ba8e:	6c 18       	ld.w	r8,r6[0x4]
8000ba90:	70 08       	ld.w	r8,r8[0x0]
8000ba92:	e0 6a 04 00 	mov	r10,1024
8000ba96:	30 1b       	mov	r11,1
8000ba98:	0a 9c       	mov	r12,r5
8000ba9a:	5d 18       	icall	r8
8000ba9c:	8f 6c       	st.w	r7[0x18],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  upsample->Cb_g_tab = (INT32 *)
8000ba9e:	6c 18       	ld.w	r8,r6[0x4]
8000baa0:	70 08       	ld.w	r8,r8[0x0]
8000baa2:	e0 6a 04 00 	mov	r10,1024
8000baa6:	30 1b       	mov	r11,1
8000baa8:	0a 9c       	mov	r12,r5
8000baaa:	5d 18       	icall	r8
8000baac:	8f 7c       	st.w	r7[0x1c],r12
8000baae:	e0 6c 8d 00 	mov	r12,36096
8000bab2:	ea 1c 00 2c 	orh	r12,0x2c
8000bab6:	e0 6b 69 00 	mov	r11,26880
8000baba:	ea 1b 00 5b 	orh	r11,0x5b
8000babe:	e0 6a af 00 	mov	r10,44800
8000bac2:	ea 1a ff 1d 	orh	r10,0xff1d
8000bac6:	e0 69 0b 80 	mov	r9,2944
8000baca:	ea 19 ff 4d 	orh	r9,0xff4d
8000bace:	30 08       	mov	r8,0

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    upsample->Cr_r_tab[i] = (int)
8000bad0:	6e 46       	ld.w	r6,r7[0x10]
8000bad2:	f2 05 14 10 	asr	r5,r9,0x10
8000bad6:	ec 08 09 05 	st.w	r6[r8],r5
		    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    upsample->Cb_b_tab[i] = (int)
8000bada:	6e 56       	ld.w	r6,r7[0x14]
8000badc:	f4 05 14 10 	asr	r5,r10,0x10
8000bae0:	ec 08 09 05 	st.w	r6[r8],r5
		    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
8000bae4:	6e 66       	ld.w	r6,r7[0x18]
8000bae6:	ec 08 09 0b 	st.w	r6[r8],r11
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
8000baea:	6e 76       	ld.w	r6,r7[0x1c]
8000baec:	ec 08 09 0c 	st.w	r6[r8],r12
8000baf0:	2f c8       	sub	r8,-4
8000baf2:	fe 29 99 17 	sub	r9,-91881
8000baf6:	fe 2a 3a 5e 	sub	r10,-116130
8000bafa:	e0 2b b6 d2 	sub	r11,46802
8000bafe:	f8 cc 58 1a 	sub	r12,r12,22554
				(MAXJSAMPLE+1) * SIZEOF(INT32));
  upsample->Cb_g_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(MAXJSAMPLE+1) * SIZEOF(INT32));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
8000bb02:	e0 48 04 00 	cp.w	r8,1024
8000bb06:	ce 51       	brne	8000bad0 <jinit_merged_upsampler+0xb8>
    /* No spare row needed */
    upsample->spare_row = NULL;
  }

  build_ycc_rgb_table(cinfo);
}
8000bb08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bb0c:	80 00       	ld.sh	r0,r0[0x0]
8000bb0e:	b7 4c       	asr	r12,0x16
8000bb10:	80 00       	ld.sh	r0,r0[0x0]
8000bb12:	bb 20       	st.d	sp++,r0
8000bb14:	80 00       	ld.sh	r0,r0[0x0]
8000bb16:	b8 92       	st.b	r12[0x1],r2
8000bb18:	80 00       	ld.sh	r0,r0[0x0]
8000bb1a:	b7 5a       	asr	r10,0x17
8000bb1c:	80 00       	ld.sh	r0,r0[0x0]
8000bb1e:	b7 82       	lsr	r2,0x16

8000bb20 <merged_2v_upsample>:
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
/* 2:1 vertical sampling case: may need a spare row. */
{
8000bb20:	eb cd 40 f8 	pushm	r3-r7,lr
8000bb24:	20 2d       	sub	sp,8
8000bb26:	fa c4 ff e0 	sub	r4,sp,-32
8000bb2a:	14 93       	mov	r3,r10
8000bb2c:	10 9a       	mov	r10,r8
8000bb2e:	68 06       	ld.w	r6,r4[0x0]
8000bb30:	68 15       	ld.w	r5,r4[0x4]
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000bb32:	f8 f7 01 c4 	ld.w	r7,r12[452]
  JSAMPROW work_ptrs[2];
  JDIMENSION num_rows;		/* number of rows returned to caller */

  if (upsample->spare_full) {
8000bb36:	6e 98       	ld.w	r8,r7[0x24]
8000bb38:	58 08       	cp.w	r8,0
8000bb3a:	c1 20       	breq	8000bb5e <merged_2v_upsample+0x3e>
    /* If we have a spare row saved from a previous cycle, just return it. */
    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
8000bb3c:	6c 0b       	ld.w	r11,r6[0x0]
8000bb3e:	6e a8       	ld.w	r8,r7[0x28]
8000bb40:	1a d8       	st.w	--sp,r8
8000bb42:	30 18       	mov	r8,1
8000bb44:	30 09       	mov	r9,0
8000bb46:	f4 0b 00 2a 	add	r10,r10,r11<<0x2
8000bb4a:	12 9b       	mov	r11,r9
8000bb4c:	ee cc ff e0 	sub	r12,r7,-32
8000bb50:	f0 1f 00 1b 	mcall	8000bbbc <merged_2v_upsample+0x9c>
		      1, upsample->out_row_width);
    num_rows = 1;
    upsample->spare_full = FALSE;
8000bb54:	30 08       	mov	r8,0
8000bb56:	8f 98       	st.w	r7[0x24],r8
8000bb58:	30 15       	mov	r5,1
8000bb5a:	2f fd       	sub	sp,-4
8000bb5c:	c1 e8       	rjmp	8000bb98 <merged_2v_upsample+0x78>
  } else {
    /* Figure number of rows to return to caller. */
    num_rows = 2;
    /* Not more than the distance to the end of the image. */
    if (num_rows > upsample->rows_to_go)
8000bb5e:	6e b8       	ld.w	r8,r7[0x2c]
8000bb60:	58 28       	cp.w	r8,2
8000bb62:	f9 b8 02 02 	movhs	r8,2
      num_rows = upsample->rows_to_go;
    /* And not more than what the client can accept: */
    out_rows_avail -= *out_row_ctr;
8000bb66:	6c 09       	ld.w	r9,r6[0x0]
8000bb68:	12 15       	sub	r5,r9
8000bb6a:	0a 38       	cp.w	r8,r5
8000bb6c:	f0 05 17 80 	movls	r5,r8
    if (num_rows > out_rows_avail)
      num_rows = out_rows_avail;
    /* Create output pointer array for upsampler. */
    work_ptrs[0] = output_buf[*out_row_ctr];
8000bb70:	f4 09 03 28 	ld.w	r8,r10[r9<<0x2]
8000bb74:	50 08       	stdsp	sp[0x0],r8
    if (num_rows > 1) {
8000bb76:	58 15       	cp.w	r5,1
8000bb78:	e0 88 00 08 	brls	8000bb88 <merged_2v_upsample+0x68>
      work_ptrs[1] = output_buf[*out_row_ctr + 1];
8000bb7c:	6c 08       	ld.w	r8,r6[0x0]
8000bb7e:	2f f8       	sub	r8,-1
8000bb80:	f4 08 03 28 	ld.w	r8,r10[r8<<0x2]
8000bb84:	50 18       	stdsp	sp[0x4],r8
8000bb86:	c0 58       	rjmp	8000bb90 <merged_2v_upsample+0x70>
    } else {
      work_ptrs[1] = upsample->spare_row;
8000bb88:	6e 88       	ld.w	r8,r7[0x20]
8000bb8a:	50 18       	stdsp	sp[0x4],r8
      upsample->spare_full = TRUE;
8000bb8c:	30 18       	mov	r8,1
8000bb8e:	8f 98       	st.w	r7[0x24],r8
    }
    /* Now do the upsampling. */
    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
8000bb90:	6e 38       	ld.w	r8,r7[0xc]
8000bb92:	1a 99       	mov	r9,sp
8000bb94:	66 0a       	ld.w	r10,r3[0x0]
8000bb96:	5d 18       	icall	r8
  }

  /* Adjust counts */
  *out_row_ctr += num_rows;
8000bb98:	6c 08       	ld.w	r8,r6[0x0]
8000bb9a:	0a 08       	add	r8,r5
8000bb9c:	8d 08       	st.w	r6[0x0],r8
  upsample->rows_to_go -= num_rows;
8000bb9e:	6e b8       	ld.w	r8,r7[0x2c]
8000bba0:	0a 18       	sub	r8,r5
8000bba2:	8f b8       	st.w	r7[0x2c],r8
  /* When the buffer is emptied, declare this input row group consumed */
  if (! upsample->spare_full)
8000bba4:	6e 98       	ld.w	r8,r7[0x24]
    (*in_row_group_ctr)++;
8000bba6:	58 08       	cp.w	r8,0
8000bba8:	e7 f8 00 00 	ld.weq	r8,r3[0x0]
8000bbac:	f7 b8 00 ff 	subeq	r8,-1
8000bbb0:	e7 f8 0a 00 	st.weq	r3[0x0],r8
}
8000bbb4:	2f ed       	sub	sp,-8
8000bbb6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000bbba:	00 00       	add	r0,r0
8000bbbc:	80 00       	ld.sh	r0,r0[0x0]
8000bbbe:	fd 44 eb cd 	st.w	lr[-5171],r4

8000bbc0 <process_restart>:
 * Returns FALSE if must suspend.
 */

LOCAL(boolean)
process_restart (j_decompress_ptr cinfo)
{
8000bbc0:	eb cd 40 c0 	pushm	r6-r7,lr
8000bbc4:	18 97       	mov	r7,r12
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
8000bbc6:	f8 f6 01 bc 	ld.w	r6,r12[444]
  int ci;

  /* Throw away any unused bits remaining in bit buffer; */
  /* include any full bytes in next_marker's count of discarded bytes */
  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
8000bbca:	f8 f9 01 b8 	ld.w	r9,r12[440]
8000bbce:	6c 48       	ld.w	r8,r6[0x10]
8000bbd0:	58 08       	cp.w	r8,0
8000bbd2:	f7 b8 05 f9 	sublt	r8,-7
8000bbd6:	a3 58       	asr	r8,0x3
8000bbd8:	72 6a       	ld.w	r10,r9[0x18]
8000bbda:	f4 08 00 08 	add	r8,r10,r8
8000bbde:	93 68       	st.w	r9[0x18],r8
  entropy->bitstate.bits_left = 0;
8000bbe0:	30 08       	mov	r8,0
8000bbe2:	8d 48       	st.w	r6[0x10],r8

  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
8000bbe4:	f8 f8 01 b8 	ld.w	r8,r12[440]
8000bbe8:	70 28       	ld.w	r8,r8[0x8]
8000bbea:	5d 18       	icall	r8
8000bbec:	c1 f0       	breq	8000bc2a <process_restart+0x6a>
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
8000bbee:	ee f8 01 48 	ld.w	r8,r7[328]
8000bbf2:	58 08       	cp.w	r8,0
8000bbf4:	e0 8a 00 0d 	brle	8000bc0e <process_restart+0x4e>
8000bbf8:	ec c9 ff e8 	sub	r9,r6,-24
8000bbfc:	30 08       	mov	r8,0
    entropy->saved.last_dc_val[ci] = 0;
8000bbfe:	10 9b       	mov	r11,r8
8000bc00:	12 ab       	st.w	r9++,r11
  /* Advance past the RSTn marker */
  if (! (*cinfo->marker->read_restart_marker) (cinfo))
    return FALSE;

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
8000bc02:	2f f8       	sub	r8,-1
8000bc04:	ee fa 01 48 	ld.w	r10,r7[328]
8000bc08:	10 3a       	cp.w	r10,r8
8000bc0a:	fe 99 ff fb 	brgt	8000bc00 <process_restart+0x40>
    entropy->saved.last_dc_val[ci] = 0;
  /* Re-init EOB run count, too */
  entropy->saved.EOBRUN = 0;
8000bc0e:	30 08       	mov	r8,0
8000bc10:	8d 58       	st.w	r6[0x14],r8

  /* Reset restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
8000bc12:	ee f8 01 14 	ld.w	r8,r7[276]
8000bc16:	8d a8       	st.w	r6[0x28],r8
  /* Reset out-of-data flag, unless read_restart_marker left us smack up
   * against a marker.  In that case we will end up treating the next data
   * segment as empty, and we can avoid producing bogus output pixels by
   * leaving the flag set.
   */
  if (cinfo->unread_marker == 0)
8000bc18:	ee f8 01 a0 	ld.w	r8,r7[416]
8000bc1c:	58 08       	cp.w	r8,0
8000bc1e:	c0 30       	breq	8000bc24 <process_restart+0x64>
8000bc20:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
    entropy->pub.insufficient_data = FALSE;
8000bc24:	30 08       	mov	r8,0
8000bc26:	8d 28       	st.w	r6[0x8],r8
8000bc28:	30 1c       	mov	r12,1

  return TRUE;
}
8000bc2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000bc2e:	d7 03       	nop

8000bc30 <jinit_phuff_decoder>:
 * Module initialization routine for progressive Huffman entropy decoding.
 */

GLOBAL(void)
jinit_phuff_decoder (j_decompress_ptr cinfo)
{
8000bc30:	eb cd 40 80 	pushm	r7,lr
8000bc34:	18 97       	mov	r7,r12
  phuff_entropy_ptr entropy;
  int *coef_bit_ptr;
  int ci, i;

  entropy = (phuff_entropy_ptr)
8000bc36:	78 18       	ld.w	r8,r12[0x4]
8000bc38:	70 08       	ld.w	r8,r8[0x0]
8000bc3a:	34 0a       	mov	r10,64
8000bc3c:	30 1b       	mov	r11,1
8000bc3e:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(phuff_entropy_decoder));
  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
8000bc40:	ef 4c 01 bc 	st.w	r7[444],r12
  entropy->pub.start_pass = start_pass_phuff_decoder;
8000bc44:	49 48       	lddpc	r8,8000bc94 <jinit_phuff_decoder+0x64>
8000bc46:	99 08       	st.w	r12[0x0],r8

  /* Mark derived tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->derived_tbls[i] = NULL;
8000bc48:	30 08       	mov	r8,0
8000bc4a:	99 b8       	st.w	r12[0x2c],r8
8000bc4c:	99 c8       	st.w	r12[0x30],r8
8000bc4e:	99 d8       	st.w	r12[0x34],r8
8000bc50:	99 e8       	st.w	r12[0x38],r8
  }

  /* Create progression status table */
  cinfo->coef_bits = (int (*)[DCTSIZE2])
8000bc52:	6e 18       	ld.w	r8,r7[0x4]
8000bc54:	6e 9a       	ld.w	r10,r7[0x24]
8000bc56:	70 08       	ld.w	r8,r8[0x0]
8000bc58:	a9 6a       	lsl	r10,0x8
8000bc5a:	30 1b       	mov	r11,1
8000bc5c:	0e 9c       	mov	r12,r7
8000bc5e:	5d 18       	icall	r8
8000bc60:	ef 4c 00 a0 	st.w	r7[160],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components*DCTSIZE2*SIZEOF(int));
  coef_bit_ptr = & cinfo->coef_bits[0][0];
  for (ci = 0; ci < cinfo->num_components; ci++)
8000bc64:	6e 98       	ld.w	r8,r7[0x24]
8000bc66:	58 08       	cp.w	r8,0
8000bc68:	e0 8a 00 14 	brle	8000bc90 <jinit_phuff_decoder+0x60>

  /* Create progression status table */
  cinfo->coef_bits = (int (*)[DCTSIZE2])
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components*DCTSIZE2*SIZEOF(int));
  coef_bit_ptr = & cinfo->coef_bits[0][0];
8000bc6c:	18 9b       	mov	r11,r12
8000bc6e:	30 0c       	mov	r12,0
  for (ci = 0; ci < cinfo->num_components; ci++)
    for (i = 0; i < DCTSIZE2; i++)
      *coef_bit_ptr++ = -1;
8000bc70:	3f fa       	mov	r10,-1
8000bc72:	c0 b8       	rjmp	8000bc88 <jinit_phuff_decoder+0x58>
8000bc74:	10 aa       	st.w	r8++,r10
  cinfo->coef_bits = (int (*)[DCTSIZE2])
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components*DCTSIZE2*SIZEOF(int));
  coef_bit_ptr = & cinfo->coef_bits[0][0];
  for (ci = 0; ci < cinfo->num_components; ci++)
    for (i = 0; i < DCTSIZE2; i++)
8000bc76:	12 38       	cp.w	r8,r9
8000bc78:	cf e1       	brne	8000bc74 <jinit_phuff_decoder+0x44>
8000bc7a:	f6 cb ff 00 	sub	r11,r11,-256
  /* Create progression status table */
  cinfo->coef_bits = (int (*)[DCTSIZE2])
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				cinfo->num_components*DCTSIZE2*SIZEOF(int));
  coef_bit_ptr = & cinfo->coef_bits[0][0];
  for (ci = 0; ci < cinfo->num_components; ci++)
8000bc7e:	2f fc       	sub	r12,-1
8000bc80:	6e 98       	ld.w	r8,r7[0x24]
8000bc82:	18 38       	cp.w	r8,r12
8000bc84:	e0 8a 00 06 	brle	8000bc90 <jinit_phuff_decoder+0x60>
8000bc88:	f6 c9 ff 00 	sub	r9,r11,-256
8000bc8c:	16 98       	mov	r8,r11
8000bc8e:	cf 3b       	rjmp	8000bc74 <jinit_phuff_decoder+0x44>
8000bc90:	e3 cd 80 80 	ldm	sp++,r7,pc
8000bc94:	80 00       	ld.sh	r0,r0[0x0]
8000bc96:	bc 98       	st.b	lr[0x1],r8

8000bc98 <start_pass_phuff_decoder>:
 * Initialize for a Huffman-compressed scan.
 */

METHODDEF(void)
start_pass_phuff_decoder (j_decompress_ptr cinfo)
{
8000bc98:	d4 31       	pushm	r0-r7,lr
8000bc9a:	20 3d       	sub	sp,12
8000bc9c:	18 97       	mov	r7,r12
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
8000bc9e:	f8 f9 01 bc 	ld.w	r9,r12[444]
8000bca2:	50 19       	stdsp	sp[0x4],r9
  boolean is_DC_band, bad;
  int ci, coefi, tbl;
  int *coef_bit_ptr;
  jpeg_component_info * compptr;

  is_DC_band = (cinfo->Ss == 0);
8000bca4:	f8 f8 01 90 	ld.w	r8,r12[400]
8000bca8:	58 08       	cp.w	r8,0
8000bcaa:	5f 09       	sreq	r9
8000bcac:	50 29       	stdsp	sp[0x8],r9

  /* Validate scan parameters */
  bad = FALSE;
  if (is_DC_band) {
8000bcae:	58 09       	cp.w	r9,0
8000bcb0:	c0 60       	breq	8000bcbc <start_pass_phuff_decoder+0x24>
8000bcb2:	f8 f8 01 94 	ld.w	r8,r12[404]
8000bcb6:	58 08       	cp.w	r8,0
8000bcb8:	5f 18       	srne	r8
8000bcba:	c1 08       	rjmp	8000bcda <start_pass_phuff_decoder+0x42>
    if (cinfo->Se != 0)
      bad = TRUE;
  } else {
    /* need not check Ss/Se < 0 since they came from unsigned bytes */
    if (cinfo->Ss > cinfo->Se || cinfo->Se >= DCTSIZE2)
8000bcbc:	f8 f9 01 94 	ld.w	r9,r12[404]
8000bcc0:	12 38       	cp.w	r8,r9
8000bcc2:	e0 8a 00 04 	brle	8000bcca <start_pass_phuff_decoder+0x32>
8000bcc6:	30 18       	mov	r8,1
8000bcc8:	c0 48       	rjmp	8000bcd0 <start_pass_phuff_decoder+0x38>
8000bcca:	e0 49 00 3f 	cp.w	r9,63
8000bcce:	5f 98       	srgt	r8
      bad = TRUE;
    /* AC scans may have only one component */
    if (cinfo->comps_in_scan != 1)
8000bcd0:	ee f9 01 48 	ld.w	r9,r7[328]
8000bcd4:	58 19       	cp.w	r9,1
8000bcd6:	f9 b8 01 01 	movne	r8,1
      bad = TRUE;
  }
  if (cinfo->Ah != 0) {
8000bcda:	ee f9 01 98 	ld.w	r9,r7[408]
8000bcde:	58 09       	cp.w	r9,0
8000bce0:	c0 70       	breq	8000bcee <start_pass_phuff_decoder+0x56>
    /* Successive approximation refinement scan: must have Al = Ah-1. */
    if (cinfo->Al != cinfo->Ah-1)
8000bce2:	20 19       	sub	r9,1
8000bce4:	ee fa 01 9c 	ld.w	r10,r7[412]
8000bce8:	12 3a       	cp.w	r10,r9
8000bcea:	f9 b8 01 01 	movne	r8,1
      bad = TRUE;
  }
  if (cinfo->Al > 13)		/* need not check for < 0 */
8000bcee:	ee f9 01 9c 	ld.w	r9,r7[412]
8000bcf2:	58 d9       	cp.w	r9,13
8000bcf4:	e0 89 00 04 	brgt	8000bcfc <start_pass_phuff_decoder+0x64>
   * but the spec doesn't say so, and we try to be liberal about what we
   * accept.  Note: large Al values could result in out-of-range DC
   * coefficients during early scans, leading to bizarre displays due to
   * overflows in the IDCT math.  But we won't crash.
   */
  if (bad)
8000bcf8:	58 08       	cp.w	r8,0
8000bcfa:	c1 80       	breq	8000bd2a <start_pass_phuff_decoder+0x92>
    ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
8000bcfc:	6e 08       	ld.w	r8,r7[0x0]
8000bcfe:	31 09       	mov	r9,16
8000bd00:	91 59       	st.w	r8[0x14],r9
8000bd02:	6e 08       	ld.w	r8,r7[0x0]
8000bd04:	ee f9 01 90 	ld.w	r9,r7[400]
8000bd08:	91 69       	st.w	r8[0x18],r9
8000bd0a:	6e 08       	ld.w	r8,r7[0x0]
8000bd0c:	ee f9 01 94 	ld.w	r9,r7[404]
8000bd10:	91 79       	st.w	r8[0x1c],r9
8000bd12:	6e 08       	ld.w	r8,r7[0x0]
8000bd14:	ee f9 01 98 	ld.w	r9,r7[408]
8000bd18:	91 89       	st.w	r8[0x20],r9
8000bd1a:	6e 08       	ld.w	r8,r7[0x0]
8000bd1c:	ee f9 01 9c 	ld.w	r9,r7[412]
8000bd20:	91 99       	st.w	r8[0x24],r9
8000bd22:	6e 08       	ld.w	r8,r7[0x0]
8000bd24:	70 08       	ld.w	r8,r8[0x0]
8000bd26:	0e 9c       	mov	r12,r7
8000bd28:	5d 18       	icall	r8
	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
  /* Update progression status, and verify that scan order is legal.
   * Note that inter-scan inconsistencies are treated as warnings
   * not fatal errors ... not clear if this is right way to behave.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
8000bd2a:	ee f8 01 48 	ld.w	r8,r7[328]
8000bd2e:	58 08       	cp.w	r8,0
8000bd30:	e0 8a 00 4e 	brle	8000bdcc <start_pass_phuff_decoder+0x134>
8000bd34:	ee c0 fe b4 	sub	r0,r7,-332
8000bd38:	30 08       	mov	r8,0
8000bd3a:	50 08       	stdsp	sp[0x0],r8
    int cindex = cinfo->cur_comp_info[ci]->component_index;
    coef_bit_ptr = & cinfo->coef_bits[cindex][0];
    if (!is_DC_band && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
      WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
8000bd3c:	37 32       	mov	r2,115
8000bd3e:	10 94       	mov	r4,r8
8000bd40:	3f f1       	mov	r1,-1
  /* Update progression status, and verify that scan order is legal.
   * Note that inter-scan inconsistencies are treated as warnings
   * not fatal errors ... not clear if this is right way to behave.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    int cindex = cinfo->cur_comp_info[ci]->component_index;
8000bd42:	60 08       	ld.w	r8,r0[0x0]
8000bd44:	70 13       	ld.w	r3,r8[0x4]
    coef_bit_ptr = & cinfo->coef_bits[cindex][0];
8000bd46:	e6 08 15 08 	lsl	r8,r3,0x8
8000bd4a:	ee f6 00 a0 	ld.w	r6,r7[160]
8000bd4e:	10 06       	add	r6,r8
    if (!is_DC_band && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
8000bd50:	40 29       	lddsp	r9,sp[0x8]
8000bd52:	58 09       	cp.w	r9,0
8000bd54:	c0 f1       	brne	8000bd72 <start_pass_phuff_decoder+0xda>
8000bd56:	6c 08       	ld.w	r8,r6[0x0]
8000bd58:	58 08       	cp.w	r8,0
8000bd5a:	c0 c4       	brge	8000bd72 <start_pass_phuff_decoder+0xda>
      WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
8000bd5c:	6e 08       	ld.w	r8,r7[0x0]
8000bd5e:	91 52       	st.w	r8[0x14],r2
8000bd60:	6e 08       	ld.w	r8,r7[0x0]
8000bd62:	91 63       	st.w	r8[0x18],r3
8000bd64:	6e 08       	ld.w	r8,r7[0x0]
8000bd66:	91 74       	st.w	r8[0x1c],r4
8000bd68:	6e 08       	ld.w	r8,r7[0x0]
8000bd6a:	70 18       	ld.w	r8,r8[0x4]
8000bd6c:	02 9b       	mov	r11,r1
8000bd6e:	0e 9c       	mov	r12,r7
8000bd70:	5d 18       	icall	r8
    for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
8000bd72:	ee f5 01 90 	ld.w	r5,r7[400]
8000bd76:	ee f8 01 94 	ld.w	r8,r7[404]
8000bd7a:	10 35       	cp.w	r5,r8
8000bd7c:	e0 89 00 1e 	brgt	8000bdb8 <start_pass_phuff_decoder+0x120>
8000bd80:	ec 05 00 26 	add	r6,r6,r5<<0x2
      int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
      if (cinfo->Ah != expected)
8000bd84:	6c 08       	ld.w	r8,r6[0x0]
8000bd86:	f0 04 0c 48 	max	r8,r8,r4
8000bd8a:	ee f9 01 98 	ld.w	r9,r7[408]
8000bd8e:	10 39       	cp.w	r9,r8
8000bd90:	c0 c0       	breq	8000bda8 <start_pass_phuff_decoder+0x110>
	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
8000bd92:	6e 08       	ld.w	r8,r7[0x0]
8000bd94:	91 52       	st.w	r8[0x14],r2
8000bd96:	6e 08       	ld.w	r8,r7[0x0]
8000bd98:	91 63       	st.w	r8[0x18],r3
8000bd9a:	6e 08       	ld.w	r8,r7[0x0]
8000bd9c:	91 75       	st.w	r8[0x1c],r5
8000bd9e:	6e 08       	ld.w	r8,r7[0x0]
8000bda0:	70 18       	ld.w	r8,r8[0x4]
8000bda2:	02 9b       	mov	r11,r1
8000bda4:	0e 9c       	mov	r12,r7
8000bda6:	5d 18       	icall	r8
      coef_bit_ptr[coefi] = cinfo->Al;
8000bda8:	ee f8 01 9c 	ld.w	r8,r7[412]
8000bdac:	0c a8       	st.w	r6++,r8
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    int cindex = cinfo->cur_comp_info[ci]->component_index;
    coef_bit_ptr = & cinfo->coef_bits[cindex][0];
    if (!is_DC_band && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
      WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
    for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
8000bdae:	2f f5       	sub	r5,-1
8000bdb0:	ee f8 01 94 	ld.w	r8,r7[404]
8000bdb4:	0a 38       	cp.w	r8,r5
8000bdb6:	ce 74       	brge	8000bd84 <start_pass_phuff_decoder+0xec>
	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
  /* Update progression status, and verify that scan order is legal.
   * Note that inter-scan inconsistencies are treated as warnings
   * not fatal errors ... not clear if this is right way to behave.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
8000bdb8:	40 08       	lddsp	r8,sp[0x0]
8000bdba:	2f f8       	sub	r8,-1
8000bdbc:	50 08       	stdsp	sp[0x0],r8
8000bdbe:	2f c0       	sub	r0,-4
8000bdc0:	ee f8 01 48 	ld.w	r8,r7[328]
8000bdc4:	40 09       	lddsp	r9,sp[0x0]
8000bdc6:	12 38       	cp.w	r8,r9
8000bdc8:	fe 99 ff bd 	brgt	8000bd42 <start_pass_phuff_decoder+0xaa>
      coef_bit_ptr[coefi] = cinfo->Al;
    }
  }

  /* Select MCU decoding routine */
  if (cinfo->Ah == 0) {
8000bdcc:	ee f8 01 98 	ld.w	r8,r7[408]
8000bdd0:	58 08       	cp.w	r8,0
8000bdd2:	c1 11       	brne	8000bdf4 <start_pass_phuff_decoder+0x15c>
    if (is_DC_band)
8000bdd4:	40 28       	lddsp	r8,sp[0x8]
8000bdd6:	58 08       	cp.w	r8,0
8000bdd8:	c0 50       	breq	8000bde2 <start_pass_phuff_decoder+0x14a>
      entropy->pub.decode_mcu = decode_mcu_DC_first;
8000bdda:	4a b8       	lddpc	r8,8000be84 <start_pass_phuff_decoder+0x1ec>
8000bddc:	40 19       	lddsp	r9,sp[0x4]
8000bdde:	93 18       	st.w	r9[0x4],r8
8000bde0:	c0 48       	rjmp	8000bde8 <start_pass_phuff_decoder+0x150>
    else
      entropy->pub.decode_mcu = decode_mcu_AC_first;
8000bde2:	4a a8       	lddpc	r8,8000be88 <start_pass_phuff_decoder+0x1f0>
8000bde4:	40 19       	lddsp	r9,sp[0x4]
8000bde6:	93 18       	st.w	r9[0x4],r8
      entropy->pub.decode_mcu = decode_mcu_DC_refine;
    else
      entropy->pub.decode_mcu = decode_mcu_AC_refine;
  }

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
8000bde8:	ee f8 01 48 	ld.w	r8,r7[328]
8000bdec:	58 08       	cp.w	r8,0
8000bdee:	e0 89 00 0e 	brgt	8000be0a <start_pass_phuff_decoder+0x172>
8000bdf2:	c3 e8       	rjmp	8000be6e <start_pass_phuff_decoder+0x1d6>
    if (is_DC_band)
      entropy->pub.decode_mcu = decode_mcu_DC_first;
    else
      entropy->pub.decode_mcu = decode_mcu_AC_first;
  } else {
    if (is_DC_band)
8000bdf4:	40 28       	lddsp	r8,sp[0x8]
8000bdf6:	58 08       	cp.w	r8,0
8000bdf8:	c0 50       	breq	8000be02 <start_pass_phuff_decoder+0x16a>
      entropy->pub.decode_mcu = decode_mcu_DC_refine;
8000bdfa:	4a 58       	lddpc	r8,8000be8c <start_pass_phuff_decoder+0x1f4>
8000bdfc:	40 19       	lddsp	r9,sp[0x4]
8000bdfe:	93 18       	st.w	r9[0x4],r8
8000be00:	cf 4b       	rjmp	8000bde8 <start_pass_phuff_decoder+0x150>
    else
      entropy->pub.decode_mcu = decode_mcu_AC_refine;
8000be02:	4a 48       	lddpc	r8,8000be90 <start_pass_phuff_decoder+0x1f8>
8000be04:	40 19       	lddsp	r9,sp[0x4]
8000be06:	93 18       	st.w	r9[0x4],r8
8000be08:	cf 0b       	rjmp	8000bde8 <start_pass_phuff_decoder+0x150>
8000be0a:	ee c5 fe b4 	sub	r5,r7,-332
8000be0e:	40 13       	lddsp	r3,sp[0x4]
8000be10:	2e 83       	sub	r3,-24
8000be12:	30 04       	mov	r4,0
	jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
				& entropy->derived_tbls[tbl]);
      }
    } else {
      tbl = compptr->ac_tbl_no;
      jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
8000be14:	08 92       	mov	r2,r4
     * We may build same derived table more than once, but it's not expensive.
     */
    if (is_DC_band) {
      if (cinfo->Ah == 0) {	/* DC refinement needs no table */
	tbl = compptr->dc_tbl_no;
	jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
8000be16:	30 11       	mov	r1,1
8000be18:	40 20       	lddsp	r0,sp[0x8]
8000be1a:	0e 96       	mov	r6,r7
    else
      entropy->pub.decode_mcu = decode_mcu_AC_refine;
  }

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
8000be1c:	6a 08       	ld.w	r8,r5[0x0]
    /* Make sure requested tables are present, and compute derived tables.
     * We may build same derived table more than once, but it's not expensive.
     */
    if (is_DC_band) {
8000be1e:	58 00       	cp.w	r0,0
8000be20:	c1 00       	breq	8000be40 <start_pass_phuff_decoder+0x1a8>
      if (cinfo->Ah == 0) {	/* DC refinement needs no table */
8000be22:	ec f9 01 98 	ld.w	r9,r6[408]
8000be26:	58 09       	cp.w	r9,0
8000be28:	c1 a1       	brne	8000be5c <start_pass_phuff_decoder+0x1c4>
	tbl = compptr->dc_tbl_no;
8000be2a:	70 5a       	ld.w	r10,r8[0x14]
	jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
8000be2c:	f4 c9 ff f5 	sub	r9,r10,-11
8000be30:	40 18       	lddsp	r8,sp[0x4]
8000be32:	f0 09 00 29 	add	r9,r8,r9<<0x2
8000be36:	02 9b       	mov	r11,r1
8000be38:	0c 9c       	mov	r12,r6
8000be3a:	f0 1f 00 17 	mcall	8000be94 <start_pass_phuff_decoder+0x1fc>
8000be3e:	c0 f8       	rjmp	8000be5c <start_pass_phuff_decoder+0x1c4>
				& entropy->derived_tbls[tbl]);
      }
    } else {
      tbl = compptr->ac_tbl_no;
8000be40:	70 6a       	ld.w	r10,r8[0x18]
      jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
8000be42:	f4 c7 ff f5 	sub	r7,r10,-11
8000be46:	40 18       	lddsp	r8,sp[0x4]
8000be48:	f0 07 00 29 	add	r9,r8,r7<<0x2
8000be4c:	04 9b       	mov	r11,r2
8000be4e:	0c 9c       	mov	r12,r6
8000be50:	f0 1f 00 11 	mcall	8000be94 <start_pass_phuff_decoder+0x1fc>
			      & entropy->derived_tbls[tbl]);
      /* remember the single active table */
      entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
8000be54:	40 19       	lddsp	r9,sp[0x4]
8000be56:	f2 07 03 28 	ld.w	r8,r9[r7<<0x2]
8000be5a:	93 f8       	st.w	r9[0x3c],r8
    }
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
8000be5c:	06 a2       	st.w	r3++,r2
      entropy->pub.decode_mcu = decode_mcu_DC_refine;
    else
      entropy->pub.decode_mcu = decode_mcu_AC_refine;
  }

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
8000be5e:	2f f4       	sub	r4,-1
8000be60:	2f c5       	sub	r5,-4
8000be62:	ec f8 01 48 	ld.w	r8,r6[328]
8000be66:	08 38       	cp.w	r8,r4
8000be68:	fe 99 ff da 	brgt	8000be1c <start_pass_phuff_decoder+0x184>
8000be6c:	0c 97       	mov	r7,r6
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Initialize bitread state variables */
  entropy->bitstate.bits_left = 0;
8000be6e:	30 08       	mov	r8,0
8000be70:	40 19       	lddsp	r9,sp[0x4]
8000be72:	93 48       	st.w	r9[0x10],r8
  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
8000be74:	93 38       	st.w	r9[0xc],r8
  entropy->pub.insufficient_data = FALSE;
8000be76:	93 28       	st.w	r9[0x8],r8

  /* Initialize private state variables */
  entropy->saved.EOBRUN = 0;
8000be78:	93 58       	st.w	r9[0x14],r8

  /* Initialize restart counter */
  entropy->restarts_to_go = cinfo->restart_interval;
8000be7a:	ee f8 01 14 	ld.w	r8,r7[276]
8000be7e:	93 a8       	st.w	r9[0x28],r8
}
8000be80:	2f dd       	sub	sp,-12
8000be82:	d8 32       	popm	r0-r7,pc
8000be84:	80 00       	ld.sh	r0,r0[0x0]
8000be86:	c3 f0       	breq	8000bf04 <decode_mcu_DC_refine+0x6c>
8000be88:	80 00       	ld.sh	r0,r0[0x0]
8000be8a:	c2 54       	brge	8000bed4 <decode_mcu_DC_refine+0x3c>
8000be8c:	80 00       	ld.sh	r0,r0[0x0]
8000be8e:	be 98       	st.b	pc[0x1],r8
8000be90:	80 00       	ld.sh	r0,r0[0x0]
8000be92:	bf 44       	asr	r4,0x1e
8000be94:	80 00       	ld.sh	r0,r0[0x0]
8000be96:	92 54       	ld.sh	r4,r9[0xa]

8000be98 <decode_mcu_DC_refine>:
 * is not very clear on the point.
 */

METHODDEF(boolean)
decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
8000be98:	d4 31       	pushm	r0-r7,lr
8000be9a:	20 5d       	sub	sp,20
8000be9c:	18 95       	mov	r5,r12
8000be9e:	16 97       	mov	r7,r11
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
8000bea0:	f8 f2 01 bc 	ld.w	r2,r12[444]
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
8000bea4:	f8 f8 01 9c 	ld.w	r8,r12[412]
8000bea8:	30 13       	mov	r3,1
8000beaa:	e6 08 09 43 	lsl	r3,r3,r8
  int blkn;
  JBLOCKROW block;
  BITREAD_STATE_VARS;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
8000beae:	f8 f8 01 14 	ld.w	r8,r12[276]
8000beb2:	58 08       	cp.w	r8,0
8000beb4:	c0 70       	breq	8000bec2 <decode_mcu_DC_refine+0x2a>
    if (entropy->restarts_to_go == 0)
8000beb6:	64 a8       	ld.w	r8,r2[0x28]
8000beb8:	58 08       	cp.w	r8,0
8000beba:	c0 41       	brne	8000bec2 <decode_mcu_DC_refine+0x2a>
      if (! process_restart(cinfo))
8000bebc:	f0 1f 00 20 	mcall	8000bf3c <decode_mcu_DC_refine+0xa4>
8000bec0:	c3 b0       	breq	8000bf36 <decode_mcu_DC_refine+0x9e>
  /* Not worth the cycles to check insufficient_data here,
   * since we will not change the data anyway if we read zeroes.
   */

  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
8000bec2:	50 45       	stdsp	sp[0x10],r5
8000bec4:	6a 68       	ld.w	r8,r5[0x18]
8000bec6:	70 09       	ld.w	r9,r8[0x0]
8000bec8:	50 09       	stdsp	sp[0x0],r9
8000beca:	70 18       	ld.w	r8,r8[0x4]
8000becc:	50 18       	stdsp	sp[0x4],r8
8000bece:	64 3b       	ld.w	r11,r2[0xc]
8000bed0:	64 4a       	ld.w	r10,r2[0x10]

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
8000bed2:	ea f8 01 64 	ld.w	r8,r5[356]
8000bed6:	58 08       	cp.w	r8,0
8000bed8:	e0 8a 00 22 	brle	8000bf1c <decode_mcu_DC_refine+0x84>
8000bedc:	30 06       	mov	r6,0
    block = MCU_data[blkn];

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
8000bede:	1a 91       	mov	r1,sp
8000bee0:	30 10       	mov	r0,1
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    block = MCU_data[blkn];
8000bee2:	6e 04       	ld.w	r4,r7[0x0]

    /* Encoded data is simply the next bit of the two's-complement DC value */
    CHECK_BIT_BUFFER(br_state, 1, return FALSE);
8000bee4:	58 0a       	cp.w	r10,0
8000bee6:	e0 89 00 09 	brgt	8000bef8 <decode_mcu_DC_refine+0x60>
8000beea:	00 99       	mov	r9,r0
8000beec:	1a 9c       	mov	r12,sp
8000beee:	f0 1f 00 15 	mcall	8000bf40 <decode_mcu_DC_refine+0xa8>
8000bef2:	c2 20       	breq	8000bf36 <decode_mcu_DC_refine+0x9e>
8000bef4:	40 2b       	lddsp	r11,sp[0x8]
8000bef6:	40 3a       	lddsp	r10,sp[0xc]
    if (GET_BITS(1))
8000bef8:	20 1a       	sub	r10,1
8000befa:	f6 0a 08 48 	asr	r8,r11,r10
8000befe:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
      (*block)[0] |= p1;
8000bf02:	e9 f8 12 00 	ld.shne	r8,r4[0x0]
8000bf06:	e7 d8 e1 38 	orne	r8,r3,r8
8000bf0a:	e9 f8 1c 00 	st.hne	r4[0x0],r8
  /* Load up working state */
  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);

  /* Outer loop handles each block in the MCU */

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
8000bf0e:	2f f6       	sub	r6,-1
8000bf10:	2f c7       	sub	r7,-4
8000bf12:	ea f8 01 64 	ld.w	r8,r5[356]
8000bf16:	0c 38       	cp.w	r8,r6
8000bf18:	fe 99 ff e5 	brgt	8000bee2 <decode_mcu_DC_refine+0x4a>
      (*block)[0] |= p1;
    /* Note: since we use |=, repeating the assignment later is safe */
  }

  /* Completed MCU, so update state */
  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
8000bf1c:	6a 68       	ld.w	r8,r5[0x18]
8000bf1e:	40 09       	lddsp	r9,sp[0x0]
8000bf20:	91 09       	st.w	r8[0x0],r9
8000bf22:	6a 68       	ld.w	r8,r5[0x18]
8000bf24:	40 19       	lddsp	r9,sp[0x4]
8000bf26:	91 19       	st.w	r8[0x4],r9
8000bf28:	85 3b       	st.w	r2[0xc],r11
8000bf2a:	85 4a       	st.w	r2[0x10],r10

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
8000bf2c:	64 a8       	ld.w	r8,r2[0x28]
8000bf2e:	20 18       	sub	r8,1
8000bf30:	85 a8       	st.w	r2[0x28],r8
8000bf32:	30 1c       	mov	r12,1

  return TRUE;
8000bf34:	c0 28       	rjmp	8000bf38 <decode_mcu_DC_refine+0xa0>
8000bf36:	30 0c       	mov	r12,0
}
8000bf38:	2f bd       	sub	sp,-20
8000bf3a:	d8 32       	popm	r0-r7,pc
8000bf3c:	80 00       	ld.sh	r0,r0[0x0]
8000bf3e:	bb c0       	cbr	r0,0x1a
8000bf40:	80 00       	ld.sh	r0,r0[0x0]
8000bf42:	8d 50       	st.w	r6[0x14],r0

8000bf44 <decode_mcu_AC_refine>:
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
8000bf44:	d4 31       	pushm	r0-r7,lr
8000bf46:	fa cd 01 3c 	sub	sp,sp,316
8000bf4a:	50 2c       	stdsp	sp[0x8],r12
8000bf4c:	16 97       	mov	r7,r11
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
8000bf4e:	f8 fb 01 bc 	ld.w	r11,r12[444]
8000bf52:	50 5b       	stdsp	sp[0x14],r11
  int Se = cinfo->Se;
8000bf54:	f8 fa 01 94 	ld.w	r10,r12[404]
8000bf58:	50 9a       	stdsp	sp[0x24],r10
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
8000bf5a:	f8 f6 01 9c 	ld.w	r6,r12[412]
  d_derived_tbl * tbl;
  int num_newnz;
  int newnz_pos[DCTSIZE2];

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
8000bf5e:	f8 f8 01 14 	ld.w	r8,r12[276]
8000bf62:	58 08       	cp.w	r8,0
8000bf64:	c0 80       	breq	8000bf74 <decode_mcu_AC_refine+0x30>
    if (entropy->restarts_to_go == 0)
8000bf66:	76 a8       	ld.w	r8,r11[0x28]
8000bf68:	58 08       	cp.w	r8,0
8000bf6a:	c0 51       	brne	8000bf74 <decode_mcu_AC_refine+0x30>
      if (! process_restart(cinfo))
8000bf6c:	f0 1f 00 b6 	mcall	8000c244 <decode_mcu_AC_refine+0x300>
8000bf70:	e0 80 01 67 	breq	8000c23e <decode_mcu_AC_refine+0x2fa>
	return FALSE;
  }

  /* If we've run out of data, don't modify the MCU.
   */
  if (! entropy->pub.insufficient_data) {
8000bf74:	40 59       	lddsp	r9,sp[0x14]
8000bf76:	72 28       	ld.w	r8,r9[0x8]
8000bf78:	58 08       	cp.w	r8,0
8000bf7a:	e0 81 01 4d 	brne	8000c214 <decode_mcu_AC_refine+0x2d0>
METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
  int Se = cinfo->Se;
  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
8000bf7e:	30 18       	mov	r8,1
8000bf80:	f0 06 09 48 	lsl	r8,r8,r6
8000bf84:	50 18       	stdsp	sp[0x4],r8
  int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
8000bf86:	3f f8       	mov	r8,-1
8000bf88:	f0 06 09 48 	lsl	r8,r8,r6
8000bf8c:	50 78       	stdsp	sp[0x1c],r8
  /* If we've run out of data, don't modify the MCU.
   */
  if (! entropy->pub.insufficient_data) {

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
8000bf8e:	40 28       	lddsp	r8,sp[0x8]
8000bf90:	54 e8       	stdsp	sp[0x138],r8
8000bf92:	10 9b       	mov	r11,r8
8000bf94:	70 68       	ld.w	r8,r8[0x18]
8000bf96:	70 09       	ld.w	r9,r8[0x0]
8000bf98:	54 a9       	stdsp	sp[0x128],r9
8000bf9a:	70 18       	ld.w	r8,r8[0x4]
8000bf9c:	54 b8       	stdsp	sp[0x12c],r8
8000bf9e:	40 5a       	lddsp	r10,sp[0x14]
8000bfa0:	74 30       	ld.w	r0,r10[0xc]
8000bfa2:	74 45       	ld.w	r5,r10[0x10]
    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
8000bfa4:	74 59       	ld.w	r9,r10[0x14]
8000bfa6:	50 89       	stdsp	sp[0x20],r9

    /* There is always only one block per MCU */
    block = MCU_data[0];
8000bfa8:	6e 02       	ld.w	r2,r7[0x0]
    tbl = entropy->ac_derived_tbl;
8000bfaa:	74 f8       	ld.w	r8,r10[0x3c]
8000bfac:	50 38       	stdsp	sp[0xc],r8
     * instead, we can test the current bit to see if we already did it.
     */
    num_newnz = 0;

    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;
8000bfae:	f6 f7 01 90 	ld.w	r7,r11[400]

    if (EOBRUN == 0) {
8000bfb2:	58 09       	cp.w	r9,0
8000bfb4:	c0 40       	breq	8000bfbc <decode_mcu_AC_refine+0x78>
8000bfb6:	30 0b       	mov	r11,0
8000bfb8:	50 4b       	stdsp	sp[0x10],r11
8000bfba:	ce 28       	rjmp	8000c17e <decode_mcu_AC_refine+0x23a>
      for (; k <= Se; k++) {
8000bfbc:	40 9a       	lddsp	r10,sp[0x24]
8000bfbe:	0e 3a       	cp.w	r10,r7
8000bfc0:	e0 85 01 1e 	brlt	8000c1fc <decode_mcu_AC_refine+0x2b8>
8000bfc4:	30 09       	mov	r9,0
8000bfc6:	50 49       	stdsp	sp[0x10],r9
	 * appending correction bits to the nonzeroes.  A correction bit is 1
	 * if the absolute value of the coefficient must be increased.
	 */
	do {
	  thiscoef = *block + jpeg_natural_order[k];
	  if (*thiscoef != 0) {
8000bfc8:	30 01       	mov	r1,0
8000bfca:	50 62       	stdsp	sp[0x18],r2
8000bfcc:	0e 96       	mov	r6,r7
8000bfce:	14 92       	mov	r2,r10
    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;

    if (EOBRUN == 0) {
      for (; k <= Se; k++) {
	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
8000bfd0:	58 75       	cp.w	r5,7
8000bfd2:	e0 89 00 0f 	brgt	8000bff0 <decode_mcu_AC_refine+0xac>
8000bfd6:	30 09       	mov	r9,0
8000bfd8:	0a 9a       	mov	r10,r5
8000bfda:	00 9b       	mov	r11,r0
8000bfdc:	fa cc fe d8 	sub	r12,sp,-296
8000bfe0:	f0 1f 00 9a 	mcall	8000c248 <decode_mcu_AC_refine+0x304>
8000bfe4:	c2 70       	breq	8000c032 <decode_mcu_AC_refine+0xee>
8000bfe6:	44 c0       	lddsp	r0,sp[0x130]
8000bfe8:	44 d5       	lddsp	r5,sp[0x134]
8000bfea:	58 75       	cp.w	r5,7
8000bfec:	e0 8a 00 18 	brle	8000c01c <decode_mcu_AC_refine+0xd8>
8000bff0:	ea c8 00 08 	sub	r8,r5,8
8000bff4:	e0 08 08 48 	asr	r8,r0,r8
8000bff8:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000bffc:	f0 c9 ff dc 	sub	r9,r8,-36
8000c000:	40 3b       	lddsp	r11,sp[0xc]
8000c002:	f6 09 03 29 	ld.w	r9,r11[r9<<0x2]
8000c006:	58 09       	cp.w	r9,0
8000c008:	c0 31       	brne	8000c00e <decode_mcu_AC_refine+0xca>
8000c00a:	30 98       	mov	r8,9
8000c00c:	c0 98       	rjmp	8000c01e <decode_mcu_AC_refine+0xda>
8000c00e:	12 15       	sub	r5,r9
8000c010:	40 3a       	lddsp	r10,sp[0xc]
8000c012:	f4 08 00 08 	add	r8,r10,r8
8000c016:	f1 3c 04 90 	ld.ub	r12,r8[1168]
8000c01a:	c1 88       	rjmp	8000c04a <decode_mcu_AC_refine+0x106>
8000c01c:	30 18       	mov	r8,1
8000c01e:	40 39       	lddsp	r9,sp[0xc]
8000c020:	0a 9a       	mov	r10,r5
8000c022:	00 9b       	mov	r11,r0
8000c024:	fa cc fe d8 	sub	r12,sp,-296
8000c028:	f0 1f 00 89 	mcall	8000c24c <decode_mcu_AC_refine+0x308>
8000c02c:	c0 d4       	brge	8000c046 <decode_mcu_AC_refine+0x102>
8000c02e:	40 62       	lddsp	r2,sp[0x18]
8000c030:	c0 68       	rjmp	8000c03c <decode_mcu_AC_refine+0xf8>
8000c032:	40 62       	lddsp	r2,sp[0x18]
8000c034:	c0 48       	rjmp	8000c03c <decode_mcu_AC_refine+0xf8>
8000c036:	40 62       	lddsp	r2,sp[0x18]
8000c038:	c0 28       	rjmp	8000c03c <decode_mcu_AC_refine+0xf8>
8000c03a:	0a 92       	mov	r2,r5

  return TRUE;

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
8000c03c:	40 49       	lddsp	r9,sp[0x10]
8000c03e:	58 09       	cp.w	r9,0
8000c040:	e0 89 00 f0 	brgt	8000c220 <decode_mcu_AC_refine+0x2dc>
8000c044:	cf d8       	rjmp	8000c23e <decode_mcu_AC_refine+0x2fa>
    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;

    if (EOBRUN == 0) {
      for (; k <= Se; k++) {
	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
8000c046:	44 c0       	lddsp	r0,sp[0x130]
8000c048:	44 d5       	lddsp	r5,sp[0x134]
	r = s >> 4;
8000c04a:	f8 03 14 04 	asr	r3,r12,0x4
	s &= 15;
8000c04e:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
8000c052:	50 0c       	stdsp	sp[0x0],r12
	if (s) {
8000c054:	c2 40       	breq	8000c09c <decode_mcu_AC_refine+0x158>
	  if (s != 1)		/* size of new coef should always be 1 */
8000c056:	58 1c       	cp.w	r12,1
8000c058:	c0 a0       	breq	8000c06c <decode_mcu_AC_refine+0x128>
	    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
8000c05a:	40 2b       	lddsp	r11,sp[0x8]
8000c05c:	76 08       	ld.w	r8,r11[0x0]
8000c05e:	37 6a       	mov	r10,118
8000c060:	91 5a       	st.w	r8[0x14],r10
8000c062:	76 08       	ld.w	r8,r11[0x0]
8000c064:	70 18       	ld.w	r8,r8[0x4]
8000c066:	3f fb       	mov	r11,-1
8000c068:	40 2c       	lddsp	r12,sp[0x8]
8000c06a:	5d 18       	icall	r8
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
8000c06c:	58 05       	cp.w	r5,0
8000c06e:	e0 89 00 0c 	brgt	8000c086 <decode_mcu_AC_refine+0x142>
8000c072:	30 19       	mov	r9,1
8000c074:	0a 9a       	mov	r10,r5
8000c076:	00 9b       	mov	r11,r0
8000c078:	fa cc fe d8 	sub	r12,sp,-296
8000c07c:	f0 1f 00 73 	mcall	8000c248 <decode_mcu_AC_refine+0x304>
8000c080:	cd b0       	breq	8000c036 <decode_mcu_AC_refine+0xf2>
8000c082:	44 c0       	lddsp	r0,sp[0x130]
8000c084:	44 d5       	lddsp	r5,sp[0x134]
	  if (GET_BITS(1))
8000c086:	20 15       	sub	r5,1
8000c088:	e0 05 08 48 	asr	r8,r0,r5
8000c08c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000c090:	40 19       	lddsp	r9,sp[0x4]
8000c092:	40 7b       	lddsp	r11,sp[0x1c]
8000c094:	f6 09 17 00 	moveq	r9,r11
8000c098:	50 09       	stdsp	sp[0x0],r9
8000c09a:	c2 08       	rjmp	8000c0da <decode_mcu_AC_refine+0x196>
	    s = p1;		/* newly nonzero coef is positive */
	  else
	    s = m1;		/* newly nonzero coef is negative */
	} else {
	  if (r != 15) {
8000c09c:	58 f3       	cp.w	r3,15
8000c09e:	c1 e0       	breq	8000c0da <decode_mcu_AC_refine+0x196>
8000c0a0:	40 62       	lddsp	r2,sp[0x18]
8000c0a2:	0c 97       	mov	r7,r6
8000c0a4:	0a 9a       	mov	r10,r5
8000c0a6:	00 9b       	mov	r11,r0
	    EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
8000c0a8:	30 16       	mov	r6,1
8000c0aa:	ec 03 09 46 	lsl	r6,r6,r3
8000c0ae:	50 86       	stdsp	sp[0x20],r6
	    if (r) {
8000c0b0:	58 03       	cp.w	r3,0
8000c0b2:	c6 30       	breq	8000c178 <decode_mcu_AC_refine+0x234>
	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
8000c0b4:	06 35       	cp.w	r5,r3
8000c0b6:	c0 94       	brge	8000c0c8 <decode_mcu_AC_refine+0x184>
8000c0b8:	06 99       	mov	r9,r3
8000c0ba:	fa cc fe d8 	sub	r12,sp,-296
8000c0be:	f0 1f 00 63 	mcall	8000c248 <decode_mcu_AC_refine+0x304>
8000c0c2:	cb d0       	breq	8000c03c <decode_mcu_AC_refine+0xf8>
8000c0c4:	44 c0       	lddsp	r0,sp[0x130]
8000c0c6:	44 d5       	lddsp	r5,sp[0x134]
	      r = GET_BITS(r);
8000c0c8:	06 15       	sub	r5,r3
	      EOBRUN += r;
8000c0ca:	e0 05 08 48 	asr	r8,r0,r5
8000c0ce:	20 16       	sub	r6,1
8000c0d0:	0c 68       	and	r8,r6
8000c0d2:	40 8a       	lddsp	r10,sp[0x20]
8000c0d4:	10 0a       	add	r10,r8
8000c0d6:	50 8a       	stdsp	sp[0x20],r10
8000c0d8:	c5 08       	rjmp	8000c178 <decode_mcu_AC_refine+0x234>
8000c0da:	4d e9       	lddpc	r9,8000c250 <decode_mcu_AC_refine+0x30c>
8000c0dc:	f2 06 00 27 	add	r7,r9,r6<<0x2
8000c0e0:	0a 9a       	mov	r10,r5
8000c0e2:	40 65       	lddsp	r5,sp[0x18]
	/* Advance over already-nonzero coefs and r still-zero coefs,
	 * appending correction bits to the nonzeroes.  A correction bit is 1
	 * if the absolute value of the coefficient must be increased.
	 */
	do {
	  thiscoef = *block + jpeg_natural_order[k];
8000c0e4:	6e 04       	ld.w	r4,r7[0x0]
8000c0e6:	ea 04 00 14 	add	r4,r5,r4<<0x1
	  if (*thiscoef != 0) {
8000c0ea:	88 08       	ld.sh	r8,r4[0x0]
8000c0ec:	e2 08 19 00 	cp.h	r8,r1
8000c0f0:	c2 50       	breq	8000c13a <decode_mcu_AC_refine+0x1f6>
	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
8000c0f2:	58 0a       	cp.w	r10,0
8000c0f4:	e0 89 00 0b 	brgt	8000c10a <decode_mcu_AC_refine+0x1c6>
8000c0f8:	30 19       	mov	r9,1
8000c0fa:	00 9b       	mov	r11,r0
8000c0fc:	fa cc fe d8 	sub	r12,sp,-296
8000c100:	f0 1f 00 52 	mcall	8000c248 <decode_mcu_AC_refine+0x304>
8000c104:	c9 b0       	breq	8000c03a <decode_mcu_AC_refine+0xf6>
8000c106:	44 c0       	lddsp	r0,sp[0x130]
8000c108:	44 da       	lddsp	r10,sp[0x134]
	    if (GET_BITS(1)) {
8000c10a:	20 1a       	sub	r10,1
8000c10c:	e0 0a 08 48 	asr	r8,r0,r10
8000c110:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000c114:	c1 50       	breq	8000c13e <decode_mcu_AC_refine+0x1fa>
	      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */
8000c116:	88 08       	ld.sh	r8,r4[0x0]
8000c118:	40 1b       	lddsp	r11,sp[0x4]
8000c11a:	f1 eb 00 09 	and	r9,r8,r11
8000c11e:	c1 01       	brne	8000c13e <decode_mcu_AC_refine+0x1fa>
		if (*thiscoef >= 0)
		  *thiscoef += p1;
8000c120:	e2 08 19 00 	cp.h	r8,r1
8000c124:	f1 db e4 08 	addge	r8,r8,r11
8000c128:	e9 f8 4c 00 	st.hge	r4[0x0],r8
		else
		  *thiscoef += m1;
8000c12c:	fb f9 50 07 	ld.wlt	r9,sp[0x1c]
8000c130:	f1 d9 e5 08 	addlt	r8,r8,r9
8000c134:	e9 f8 5c 00 	st.hlt	r4[0x0],r8
8000c138:	c0 38       	rjmp	8000c13e <decode_mcu_AC_refine+0x1fa>
	      }
	    }
	  } else {
	    if (--r < 0)
8000c13a:	20 13       	sub	r3,1
8000c13c:	c0 56       	brmi	8000c146 <decode_mcu_AC_refine+0x202>
	      break;		/* reached target zero coefficient */
	  }
	  k++;
8000c13e:	2f f6       	sub	r6,-1
8000c140:	2f c7       	sub	r7,-4
	} while (k <= Se);
8000c142:	0c 32       	cp.w	r2,r6
8000c144:	cd 04       	brge	8000c0e4 <decode_mcu_AC_refine+0x1a0>
8000c146:	14 95       	mov	r5,r10
	if (s) {
8000c148:	40 08       	lddsp	r8,sp[0x0]
8000c14a:	58 08       	cp.w	r8,0
8000c14c:	c1 10       	breq	8000c16e <decode_mcu_AC_refine+0x22a>
	  int pos = jpeg_natural_order[k];
8000c14e:	4c 1b       	lddpc	r11,8000c250 <decode_mcu_AC_refine+0x30c>
8000c150:	f6 06 03 28 	ld.w	r8,r11[r6<<0x2]
	  /* Output newly nonzero coefficient */
	  (*block)[pos] = (JCOEF) s;
8000c154:	40 09       	lddsp	r9,sp[0x0]
8000c156:	40 6a       	lddsp	r10,sp[0x18]
8000c158:	f4 08 0a 19 	st.h	r10[r8<<0x1],r9
	  /* Remember its position in case we have to suspend */
	  newnz_pos[num_newnz++] = pos;
8000c15c:	40 4b       	lddsp	r11,sp[0x10]
8000c15e:	fa ca fe c4 	sub	r10,sp,-316
8000c162:	f4 0b 00 29 	add	r9,r10,r11<<0x2
8000c166:	f3 48 fe ec 	st.w	r9[-276],r8
8000c16a:	2f fb       	sub	r11,-1
8000c16c:	50 4b       	stdsp	sp[0x10],r11

    /* initialize coefficient loop counter to start of band */
    k = cinfo->Ss;

    if (EOBRUN == 0) {
      for (; k <= Se; k++) {
8000c16e:	2f f6       	sub	r6,-1
8000c170:	0c 32       	cp.w	r2,r6
8000c172:	fe 94 ff 2f 	brge	8000bfd0 <decode_mcu_AC_refine+0x8c>
8000c176:	c4 38       	rjmp	8000c1fc <decode_mcu_AC_refine+0x2b8>
	  newnz_pos[num_newnz++] = pos;
	}
      }
    }

    if (EOBRUN > 0) {
8000c178:	40 89       	lddsp	r9,sp[0x20]
8000c17a:	58 09       	cp.w	r9,0
8000c17c:	c4 00       	breq	8000c1fc <decode_mcu_AC_refine+0x2b8>
      /* Scan any remaining coefficient positions after the end-of-band
       * (the last newly nonzero coefficient, if any).  Append a correction
       * bit to each already-nonzero coefficient.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      for (; k <= Se; k++) {
8000c17e:	40 98       	lddsp	r8,sp[0x24]
8000c180:	0e 38       	cp.w	r8,r7
8000c182:	c3 a5       	brlt	8000c1f6 <decode_mcu_AC_refine+0x2b2>
8000c184:	4b 36       	lddpc	r6,8000c250 <decode_mcu_AC_refine+0x30c>
8000c186:	ec 07 00 26 	add	r6,r6,r7<<0x2
	thiscoef = *block + jpeg_natural_order[k];
	if (*thiscoef != 0) {
8000c18a:	30 03       	mov	r3,0
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
8000c18c:	fa c1 fe d8 	sub	r1,sp,-296
8000c190:	0a 9a       	mov	r10,r5
8000c192:	00 9b       	mov	r11,r0
8000c194:	0e 94       	mov	r4,r7
8000c196:	40 10       	lddsp	r0,sp[0x4]
8000c198:	10 95       	mov	r5,r8
       * (the last newly nonzero coefficient, if any).  Append a correction
       * bit to each already-nonzero coefficient.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      for (; k <= Se; k++) {
	thiscoef = *block + jpeg_natural_order[k];
8000c19a:	6c 07       	ld.w	r7,r6[0x0]
8000c19c:	e4 07 00 17 	add	r7,r2,r7<<0x1
	if (*thiscoef != 0) {
8000c1a0:	8e 08       	ld.sh	r8,r7[0x0]
8000c1a2:	e6 08 19 00 	cp.h	r8,r3
8000c1a6:	c2 20       	breq	8000c1ea <decode_mcu_AC_refine+0x2a6>
	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
8000c1a8:	58 0a       	cp.w	r10,0
8000c1aa:	e0 89 00 0a 	brgt	8000c1be <decode_mcu_AC_refine+0x27a>
8000c1ae:	30 19       	mov	r9,1
8000c1b0:	02 9c       	mov	r12,r1
8000c1b2:	f0 1f 00 26 	mcall	8000c248 <decode_mcu_AC_refine+0x304>
8000c1b6:	fe 90 ff 43 	breq	8000c03c <decode_mcu_AC_refine+0xf8>
8000c1ba:	44 cb       	lddsp	r11,sp[0x130]
8000c1bc:	44 da       	lddsp	r10,sp[0x134]
	  if (GET_BITS(1)) {
8000c1be:	20 1a       	sub	r10,1
8000c1c0:	f6 0a 08 48 	asr	r8,r11,r10
8000c1c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000c1c8:	c1 10       	breq	8000c1ea <decode_mcu_AC_refine+0x2a6>
	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
8000c1ca:	8e 08       	ld.sh	r8,r7[0x0]
8000c1cc:	f1 e0 00 09 	and	r9,r8,r0
8000c1d0:	c0 d1       	brne	8000c1ea <decode_mcu_AC_refine+0x2a6>
	      if (*thiscoef >= 0)
		*thiscoef += p1;
8000c1d2:	e6 08 19 00 	cp.h	r8,r3
8000c1d6:	f1 d0 e4 08 	addge	r8,r8,r0
8000c1da:	ef f8 4c 00 	st.hge	r7[0x0],r8
	      else
		*thiscoef += m1;
8000c1de:	fb f9 50 07 	ld.wlt	r9,sp[0x1c]
8000c1e2:	f1 d9 e5 08 	addlt	r8,r8,r9
8000c1e6:	ef f8 5c 00 	st.hlt	r7[0x0],r8
      /* Scan any remaining coefficient positions after the end-of-band
       * (the last newly nonzero coefficient, if any).  Append a correction
       * bit to each already-nonzero coefficient.  A correction bit is 1
       * if the absolute value of the coefficient must be increased.
       */
      for (; k <= Se; k++) {
8000c1ea:	2f f4       	sub	r4,-1
8000c1ec:	2f c6       	sub	r6,-4
8000c1ee:	08 35       	cp.w	r5,r4
8000c1f0:	cd 54       	brge	8000c19a <decode_mcu_AC_refine+0x256>
8000c1f2:	14 95       	mov	r5,r10
8000c1f4:	16 90       	mov	r0,r11
	    }
	  }
	}
      }
      /* Count one block completed in EOB run */
      EOBRUN--;
8000c1f6:	40 88       	lddsp	r8,sp[0x20]
8000c1f8:	20 18       	sub	r8,1
8000c1fa:	50 88       	stdsp	sp[0x20],r8
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
8000c1fc:	40 2b       	lddsp	r11,sp[0x8]
8000c1fe:	76 68       	ld.w	r8,r11[0x18]
8000c200:	44 a9       	lddsp	r9,sp[0x128]
8000c202:	91 09       	st.w	r8[0x0],r9
8000c204:	76 68       	ld.w	r8,r11[0x18]
8000c206:	44 b9       	lddsp	r9,sp[0x12c]
8000c208:	91 19       	st.w	r8[0x4],r9
8000c20a:	40 5a       	lddsp	r10,sp[0x14]
8000c20c:	95 30       	st.w	r10[0xc],r0
8000c20e:	95 45       	st.w	r10[0x10],r5
    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
8000c210:	40 89       	lddsp	r9,sp[0x20]
8000c212:	95 59       	st.w	r10[0x14],r9
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
8000c214:	40 5b       	lddsp	r11,sp[0x14]
8000c216:	76 a8       	ld.w	r8,r11[0x28]
8000c218:	20 18       	sub	r8,1
8000c21a:	97 a8       	st.w	r11[0x28],r8
8000c21c:	30 1c       	mov	r12,1

  return TRUE;
8000c21e:	c1 18       	rjmp	8000c240 <decode_mcu_AC_refine+0x2fc>
8000c220:	40 49       	lddsp	r9,sp[0x10]
8000c222:	20 19       	sub	r9,1
8000c224:	fa c8 ff d8 	sub	r8,sp,-40
8000c228:	f0 09 00 28 	add	r8,r8,r9<<0x2
/*
 * MCU decoding for AC successive approximation refinement scan.
 */

METHODDEF(boolean)
decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
8000c22c:	fa cb ff dc 	sub	r11,sp,-36
  return TRUE;

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
    (*block)[newnz_pos[--num_newnz]] = 0;
8000c230:	30 0a       	mov	r10,0
8000c232:	70 09       	ld.w	r9,r8[0x0]
8000c234:	e4 09 0a 1a 	st.h	r2[r9<<0x1],r10
8000c238:	20 48       	sub	r8,4

  return TRUE;

undoit:
  /* Re-zero any output coefficients that we made newly nonzero */
  while (num_newnz > 0)
8000c23a:	16 38       	cp.w	r8,r11
8000c23c:	cf b1       	brne	8000c232 <decode_mcu_AC_refine+0x2ee>
8000c23e:	30 0c       	mov	r12,0
    (*block)[newnz_pos[--num_newnz]] = 0;

  return FALSE;
}
8000c240:	2b 1d       	sub	sp,-316
8000c242:	d8 32       	popm	r0-r7,pc
8000c244:	80 00       	ld.sh	r0,r0[0x0]
8000c246:	bb c0       	cbr	r0,0x1a
8000c248:	80 00       	ld.sh	r0,r0[0x0]
8000c24a:	8d 50       	st.w	r6[0x14],r0
8000c24c:	80 00       	ld.sh	r0,r0[0x0]
8000c24e:	8e 00       	ld.sh	r0,r7[0x0]
8000c250:	80 01       	ld.sh	r1,r0[0x0]
8000c252:	fc 54 d4 31 	cp.w	r4,-142287

8000c254 <decode_mcu_AC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
8000c254:	d4 31       	pushm	r0-r7,lr
8000c256:	20 8d       	sub	sp,32
8000c258:	18 92       	mov	r2,r12
8000c25a:	16 97       	mov	r7,r11
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
8000c25c:	f8 f3 01 bc 	ld.w	r3,r12[444]
  int Se = cinfo->Se;
8000c260:	f8 f1 01 94 	ld.w	r1,r12[404]
  int Al = cinfo->Al;
8000c264:	f8 f5 01 9c 	ld.w	r5,r12[412]
  JBLOCKROW block;
  BITREAD_STATE_VARS;
  d_derived_tbl * tbl;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
8000c268:	f8 f8 01 14 	ld.w	r8,r12[276]
8000c26c:	58 08       	cp.w	r8,0
8000c26e:	c0 80       	breq	8000c27e <decode_mcu_AC_first+0x2a>
    if (entropy->restarts_to_go == 0)
8000c270:	66 a8       	ld.w	r8,r3[0x28]
8000c272:	58 08       	cp.w	r8,0
8000c274:	c0 51       	brne	8000c27e <decode_mcu_AC_first+0x2a>
      if (! process_restart(cinfo))
8000c276:	f0 1f 00 59 	mcall	8000c3d8 <decode_mcu_AC_first+0x184>
8000c27a:	e0 80 00 ab 	breq	8000c3d0 <decode_mcu_AC_first+0x17c>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->pub.insufficient_data) {
8000c27e:	66 28       	ld.w	r8,r3[0x8]
8000c280:	58 08       	cp.w	r8,0
8000c282:	e0 81 00 a2 	brne	8000c3c6 <decode_mcu_AC_first+0x172>

    /* Load up working state.
     * We can avoid loading/saving bitread state if in an EOB run.
     */
    EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
8000c286:	66 5c       	ld.w	r12,r3[0x14]
8000c288:	50 0c       	stdsp	sp[0x0],r12

    /* There is always only one block per MCU */

    if (EOBRUN > 0)		/* if it's a band of zeroes... */
8000c28a:	58 0c       	cp.w	r12,0
8000c28c:	c0 40       	breq	8000c294 <decode_mcu_AC_first+0x40>
      EOBRUN--;			/* ...process it now (we do nothing) */
8000c28e:	20 1c       	sub	r12,1
8000c290:	50 0c       	stdsp	sp[0x0],r12
8000c292:	c9 88       	rjmp	8000c3c2 <decode_mcu_AC_first+0x16e>
    else {
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
8000c294:	50 72       	stdsp	sp[0x1c],r2
8000c296:	64 68       	ld.w	r8,r2[0x18]
8000c298:	70 09       	ld.w	r9,r8[0x0]
8000c29a:	50 39       	stdsp	sp[0xc],r9
8000c29c:	70 18       	ld.w	r8,r8[0x4]
8000c29e:	50 48       	stdsp	sp[0x10],r8
8000c2a0:	66 3b       	ld.w	r11,r3[0xc]
8000c2a2:	66 4a       	ld.w	r10,r3[0x10]
      block = MCU_data[0];
8000c2a4:	6e 0e       	ld.w	lr,r7[0x0]
      tbl = entropy->ac_derived_tbl;
8000c2a6:	66 f4       	ld.w	r4,r3[0x3c]

      for (k = cinfo->Ss; k <= Se; k++) {
8000c2a8:	e4 f6 01 90 	ld.w	r6,r2[400]
8000c2ac:	0c 31       	cp.w	r1,r6
8000c2ae:	e0 85 00 82 	brlt	8000c3b2 <decode_mcu_AC_first+0x15e>
	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
8000c2b2:	fa c0 ff f4 	sub	r0,sp,-12
	s &= 15;
	if (s) {
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  r = GET_BITS(s);
	  s = HUFF_EXTEND(r, s);
8000c2b6:	50 13       	stdsp	sp[0x4],r3
8000c2b8:	0a 93       	mov	r3,r5
8000c2ba:	50 22       	stdsp	sp[0x8],r2
8000c2bc:	1c 92       	mov	r2,lr
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
      block = MCU_data[0];
      tbl = entropy->ac_derived_tbl;

      for (k = cinfo->Ss; k <= Se; k++) {
	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
8000c2be:	58 7a       	cp.w	r10,7
8000c2c0:	e0 89 00 0d 	brgt	8000c2da <decode_mcu_AC_first+0x86>
8000c2c4:	30 09       	mov	r9,0
8000c2c6:	00 9c       	mov	r12,r0
8000c2c8:	f0 1f 00 45 	mcall	8000c3dc <decode_mcu_AC_first+0x188>
8000c2cc:	e0 80 00 82 	breq	8000c3d0 <decode_mcu_AC_first+0x17c>
8000c2d0:	40 5b       	lddsp	r11,sp[0x14]
8000c2d2:	40 6a       	lddsp	r10,sp[0x18]
8000c2d4:	58 7a       	cp.w	r10,7
8000c2d6:	e0 8a 00 16 	brle	8000c302 <decode_mcu_AC_first+0xae>
8000c2da:	f4 c8 00 08 	sub	r8,r10,8
8000c2de:	f6 08 08 48 	asr	r8,r11,r8
8000c2e2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000c2e6:	f0 c9 ff dc 	sub	r9,r8,-36
8000c2ea:	e8 09 03 29 	ld.w	r9,r4[r9<<0x2]
8000c2ee:	58 09       	cp.w	r9,0
8000c2f0:	c0 31       	brne	8000c2f6 <decode_mcu_AC_first+0xa2>
8000c2f2:	30 98       	mov	r8,9
8000c2f4:	c0 88       	rjmp	8000c304 <decode_mcu_AC_first+0xb0>
8000c2f6:	12 1a       	sub	r10,r9
8000c2f8:	e8 08 00 08 	add	r8,r4,r8
8000c2fc:	f1 3c 04 90 	ld.ub	r12,r8[1168]
8000c300:	c0 98       	rjmp	8000c312 <decode_mcu_AC_first+0xbe>
8000c302:	30 18       	mov	r8,1
8000c304:	08 99       	mov	r9,r4
8000c306:	00 9c       	mov	r12,r0
8000c308:	f0 1f 00 36 	mcall	8000c3e0 <decode_mcu_AC_first+0x18c>
8000c30c:	c6 25       	brlt	8000c3d0 <decode_mcu_AC_first+0x17c>
8000c30e:	40 5b       	lddsp	r11,sp[0x14]
8000c310:	40 6a       	lddsp	r10,sp[0x18]
	r = s >> 4;
8000c312:	f8 05 14 04 	asr	r5,r12,0x4
	s &= 15;
8000c316:	ef dc c0 04 	bfextu	r7,r12,0x0,0x4
	if (s) {
8000c31a:	c2 60       	breq	8000c366 <decode_mcu_AC_first+0x112>
	  k += r;
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
8000c31c:	0e 3a       	cp.w	r10,r7
8000c31e:	c0 84       	brge	8000c32e <decode_mcu_AC_first+0xda>
8000c320:	0e 99       	mov	r9,r7
8000c322:	00 9c       	mov	r12,r0
8000c324:	f0 1f 00 2e 	mcall	8000c3dc <decode_mcu_AC_first+0x188>
8000c328:	c5 40       	breq	8000c3d0 <decode_mcu_AC_first+0x17c>
8000c32a:	40 5b       	lddsp	r11,sp[0x14]
8000c32c:	40 6a       	lddsp	r10,sp[0x18]
	  r = GET_BITS(s);
8000c32e:	0e 1a       	sub	r10,r7
8000c330:	f6 0a 08 49 	asr	r9,r11,r10
8000c334:	30 1c       	mov	r12,1
8000c336:	f8 07 09 48 	lsl	r8,r12,r7
8000c33a:	20 18       	sub	r8,1
8000c33c:	f3 e8 00 08 	and	r8,r9,r8
	  s = HUFF_EXTEND(r, s);
8000c340:	4a 9c       	lddpc	r12,8000c3e4 <decode_mcu_AC_first+0x190>
8000c342:	f8 07 03 29 	ld.w	r9,r12[r7<<0x2]
8000c346:	12 38       	cp.w	r8,r9
8000c348:	c0 54       	brge	8000c352 <decode_mcu_AC_first+0xfe>
8000c34a:	4a 8c       	lddpc	r12,8000c3e8 <decode_mcu_AC_first+0x194>
8000c34c:	f8 07 03 29 	ld.w	r9,r12[r7<<0x2]
8000c350:	12 08       	add	r8,r9
      for (k = cinfo->Ss; k <= Se; k++) {
	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
	r = s >> 4;
	s &= 15;
	if (s) {
	  k += r;
8000c352:	ea 06 00 06 	add	r6,r5,r6
	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
	  r = GET_BITS(s);
	  s = HUFF_EXTEND(r, s);
	  /* Scale and output coefficient in natural (dezigzagged) order */
	  (*block)[jpeg_natural_order[k]] = (JCOEF) (s << Al);
8000c356:	4a 6c       	lddpc	r12,8000c3ec <decode_mcu_AC_first+0x198>
8000c358:	f8 06 03 29 	ld.w	r9,r12[r6<<0x2]
8000c35c:	f0 03 09 48 	lsl	r8,r8,r3
8000c360:	e4 09 0a 18 	st.h	r2[r9<<0x1],r8
8000c364:	c2 28       	rjmp	8000c3a8 <decode_mcu_AC_first+0x154>
	} else {
	  if (r == 15) {	/* ZRL */
8000c366:	58 f5       	cp.w	r5,15
8000c368:	c0 31       	brne	8000c36e <decode_mcu_AC_first+0x11a>
	    k += 15;		/* skip 15 zeroes in band */
8000c36a:	2f 16       	sub	r6,-15
8000c36c:	c1 e8       	rjmp	8000c3a8 <decode_mcu_AC_first+0x154>
8000c36e:	40 13       	lddsp	r3,sp[0x4]
8000c370:	40 22       	lddsp	r2,sp[0x8]
	  } else {		/* EOBr, run length is 2^r + appended bits */
	    EOBRUN = 1 << r;
8000c372:	30 16       	mov	r6,1
8000c374:	ec 05 09 46 	lsl	r6,r6,r5
8000c378:	0c 97       	mov	r7,r6
	    if (r) {		/* EOBr, r > 0 */
8000c37a:	58 05       	cp.w	r5,0
8000c37c:	c1 20       	breq	8000c3a0 <decode_mcu_AC_first+0x14c>
	      CHECK_BIT_BUFFER(br_state, r, return FALSE);
8000c37e:	14 35       	cp.w	r5,r10
8000c380:	e0 8a 00 0a 	brle	8000c394 <decode_mcu_AC_first+0x140>
8000c384:	0a 99       	mov	r9,r5
8000c386:	fa cc ff f4 	sub	r12,sp,-12
8000c38a:	f0 1f 00 15 	mcall	8000c3dc <decode_mcu_AC_first+0x188>
8000c38e:	c2 10       	breq	8000c3d0 <decode_mcu_AC_first+0x17c>
8000c390:	40 5b       	lddsp	r11,sp[0x14]
8000c392:	40 6a       	lddsp	r10,sp[0x18]
	      r = GET_BITS(r);
8000c394:	0a 1a       	sub	r10,r5
	      EOBRUN += r;
8000c396:	f6 0a 08 48 	asr	r8,r11,r10
8000c39a:	20 16       	sub	r6,1
8000c39c:	0c 68       	and	r8,r6
8000c39e:	10 07       	add	r7,r8
	    }
	    EOBRUN--;		/* this band is processed at this moment */
8000c3a0:	ee c8 00 01 	sub	r8,r7,1
8000c3a4:	50 08       	stdsp	sp[0x0],r8
	    break;		/* force end-of-band */
8000c3a6:	c0 68       	rjmp	8000c3b2 <decode_mcu_AC_first+0x15e>
    else {
      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
      block = MCU_data[0];
      tbl = entropy->ac_derived_tbl;

      for (k = cinfo->Ss; k <= Se; k++) {
8000c3a8:	2f f6       	sub	r6,-1
8000c3aa:	0c 31       	cp.w	r1,r6
8000c3ac:	c8 94       	brge	8000c2be <decode_mcu_AC_first+0x6a>
8000c3ae:	40 13       	lddsp	r3,sp[0x4]
8000c3b0:	40 22       	lddsp	r2,sp[0x8]
	    break;		/* force end-of-band */
	  }
	}
      }

      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
8000c3b2:	64 68       	ld.w	r8,r2[0x18]
8000c3b4:	40 39       	lddsp	r9,sp[0xc]
8000c3b6:	91 09       	st.w	r8[0x0],r9
8000c3b8:	64 68       	ld.w	r8,r2[0x18]
8000c3ba:	40 49       	lddsp	r9,sp[0x10]
8000c3bc:	91 19       	st.w	r8[0x4],r9
8000c3be:	87 3b       	st.w	r3[0xc],r11
8000c3c0:	87 4a       	st.w	r3[0x10],r10
    }

    /* Completed MCU, so update state */
    entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
8000c3c2:	40 0c       	lddsp	r12,sp[0x0]
8000c3c4:	87 5c       	st.w	r3[0x14],r12
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
8000c3c6:	66 a8       	ld.w	r8,r3[0x28]
8000c3c8:	20 18       	sub	r8,1
8000c3ca:	87 a8       	st.w	r3[0x28],r8
8000c3cc:	30 1c       	mov	r12,1

  return TRUE;
8000c3ce:	c0 28       	rjmp	8000c3d2 <decode_mcu_AC_first+0x17e>
8000c3d0:	30 0c       	mov	r12,0
}
8000c3d2:	2f 8d       	sub	sp,-32
8000c3d4:	d8 32       	popm	r0-r7,pc
8000c3d6:	00 00       	add	r0,r0
8000c3d8:	80 00       	ld.sh	r0,r0[0x0]
8000c3da:	bb c0       	cbr	r0,0x1a
8000c3dc:	80 00       	ld.sh	r0,r0[0x0]
8000c3de:	8d 50       	st.w	r6[0x14],r0
8000c3e0:	80 00       	ld.sh	r0,r0[0x0]
8000c3e2:	8e 00       	ld.sh	r0,r7[0x0]
8000c3e4:	80 01       	ld.sh	r1,r0[0x0]
8000c3e6:	e6 28 80 01 	sub	r8,425985
8000c3ea:	e6 68 80 01 	mov	r8,425985
8000c3ee:	fc 54 d4 31 	cp.w	r4,-142287

8000c3f0 <decode_mcu_DC_first>:
 * or first pass of successive approximation).
 */

METHODDEF(boolean)
decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
{
8000c3f0:	d4 31       	pushm	r0-r7,lr
8000c3f2:	20 bd       	sub	sp,44
8000c3f4:	18 96       	mov	r6,r12
8000c3f6:	16 95       	mov	r5,r11
  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
8000c3f8:	f8 f0 01 bc 	ld.w	r0,r12[444]
  int Al = cinfo->Al;
8000c3fc:	f8 fc 01 9c 	ld.w	r12,r12[412]
8000c400:	50 0c       	stdsp	sp[0x0],r12
  savable_state state;
  d_derived_tbl * tbl;
  jpeg_component_info * compptr;

  /* Process restart marker if needed; may have to suspend */
  if (cinfo->restart_interval) {
8000c402:	ec f8 01 14 	ld.w	r8,r6[276]
8000c406:	58 08       	cp.w	r8,0
8000c408:	c0 90       	breq	8000c41a <decode_mcu_DC_first+0x2a>
    if (entropy->restarts_to_go == 0)
8000c40a:	60 a8       	ld.w	r8,r0[0x28]
8000c40c:	58 08       	cp.w	r8,0
8000c40e:	c0 61       	brne	8000c41a <decode_mcu_DC_first+0x2a>
      if (! process_restart(cinfo))
8000c410:	0c 9c       	mov	r12,r6
8000c412:	f0 1f 00 59 	mcall	8000c574 <decode_mcu_DC_first+0x184>
8000c416:	e0 80 00 ac 	breq	8000c56e <decode_mcu_DC_first+0x17e>
  }

  /* If we've run out of data, just leave the MCU set to zeroes.
   * This way, we return uniform gray for the remainder of the segment.
   */
  if (! entropy->pub.insufficient_data) {
8000c41a:	60 28       	ld.w	r8,r0[0x8]
8000c41c:	58 08       	cp.w	r8,0
8000c41e:	e0 81 00 a3 	brne	8000c564 <decode_mcu_DC_first+0x174>

    /* Load up working state */
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
8000c422:	50 a6       	stdsp	sp[0x28],r6
8000c424:	6c 68       	ld.w	r8,r6[0x18]
8000c426:	70 09       	ld.w	r9,r8[0x0]
8000c428:	50 69       	stdsp	sp[0x18],r9
8000c42a:	70 18       	ld.w	r8,r8[0x4]
8000c42c:	50 78       	stdsp	sp[0x1c],r8
8000c42e:	60 3b       	ld.w	r11,r0[0xc]
8000c430:	60 4a       	ld.w	r10,r0[0x10]
    ASSIGN_STATE(state, entropy->saved);
8000c432:	fa c8 ff fc 	sub	r8,sp,-4
8000c436:	e0 c9 ff ec 	sub	r9,r0,-20
8000c43a:	f2 e2 00 00 	ld.d	r2,r9[0]
8000c43e:	f0 e3 00 00 	st.d	r8[0],r2
8000c442:	f2 e2 00 08 	ld.d	r2,r9[8]
8000c446:	f0 e3 00 08 	st.d	r8[8],r2
8000c44a:	72 49       	ld.w	r9,r9[0x10]
8000c44c:	91 49       	st.w	r8[0x10],r9

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
8000c44e:	ec f8 01 64 	ld.w	r8,r6[356]
8000c452:	58 08       	cp.w	r8,0
8000c454:	e0 8a 00 72 	brle	8000c538 <decode_mcu_DC_first+0x148>
8000c458:	ec c4 fe 98 	sub	r4,r6,-360
8000c45c:	30 02       	mov	r2,0
      block = MCU_data[blkn];
8000c45e:	6a 01       	ld.w	r1,r5[0x0]
      ci = cinfo->MCU_membership[blkn];
8000c460:	68 03       	ld.w	r3,r4[0x0]
      compptr = cinfo->cur_comp_info[ci];
      tbl = entropy->derived_tbls[compptr->dc_tbl_no];
8000c462:	e6 c8 ff ad 	sub	r8,r3,-83
8000c466:	ec 08 03 28 	ld.w	r8,r6[r8<<0x2]
8000c46a:	70 58       	ld.w	r8,r8[0x14]
8000c46c:	2f 58       	sub	r8,-11
8000c46e:	e0 08 03 27 	ld.w	r7,r0[r8<<0x2]

      /* Decode a single block's worth of coefficients */

      /* Section F.2.2.1: decode the DC coefficient difference */
      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
8000c472:	58 7a       	cp.w	r10,7
8000c474:	e0 89 00 0d 	brgt	8000c48e <decode_mcu_DC_first+0x9e>
8000c478:	30 09       	mov	r9,0
8000c47a:	fa cc ff e8 	sub	r12,sp,-24
8000c47e:	f0 1f 00 3f 	mcall	8000c578 <decode_mcu_DC_first+0x188>
8000c482:	c7 60       	breq	8000c56e <decode_mcu_DC_first+0x17e>
8000c484:	40 8b       	lddsp	r11,sp[0x20]
8000c486:	40 9a       	lddsp	r10,sp[0x24]
8000c488:	58 7a       	cp.w	r10,7
8000c48a:	e0 8a 00 15 	brle	8000c4b4 <decode_mcu_DC_first+0xc4>
8000c48e:	f4 c8 00 08 	sub	r8,r10,8
8000c492:	f6 08 08 48 	asr	r8,r11,r8
8000c496:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000c49a:	f0 c9 ff dc 	sub	r9,r8,-36
8000c49e:	ee 09 03 29 	ld.w	r9,r7[r9<<0x2]
8000c4a2:	58 09       	cp.w	r9,0
8000c4a4:	c0 31       	brne	8000c4aa <decode_mcu_DC_first+0xba>
8000c4a6:	30 98       	mov	r8,9
8000c4a8:	c0 78       	rjmp	8000c4b6 <decode_mcu_DC_first+0xc6>
8000c4aa:	12 1a       	sub	r10,r9
8000c4ac:	10 07       	add	r7,r8
8000c4ae:	ef 37 04 90 	ld.ub	r7,r7[1168]
8000c4b2:	c0 b8       	rjmp	8000c4c8 <decode_mcu_DC_first+0xd8>
8000c4b4:	30 18       	mov	r8,1
8000c4b6:	0e 99       	mov	r9,r7
8000c4b8:	fa cc ff e8 	sub	r12,sp,-24
8000c4bc:	f0 1f 00 30 	mcall	8000c57c <decode_mcu_DC_first+0x18c>
8000c4c0:	18 97       	mov	r7,r12
8000c4c2:	c5 65       	brlt	8000c56e <decode_mcu_DC_first+0x17e>
8000c4c4:	40 8b       	lddsp	r11,sp[0x20]
8000c4c6:	40 9a       	lddsp	r10,sp[0x24]
      if (s) {
8000c4c8:	58 07       	cp.w	r7,0
8000c4ca:	c2 10       	breq	8000c50c <decode_mcu_DC_first+0x11c>
	CHECK_BIT_BUFFER(br_state, s, return FALSE);
8000c4cc:	14 37       	cp.w	r7,r10
8000c4ce:	e0 8a 00 0a 	brle	8000c4e2 <decode_mcu_DC_first+0xf2>
8000c4d2:	0e 99       	mov	r9,r7
8000c4d4:	fa cc ff e8 	sub	r12,sp,-24
8000c4d8:	f0 1f 00 28 	mcall	8000c578 <decode_mcu_DC_first+0x188>
8000c4dc:	c4 90       	breq	8000c56e <decode_mcu_DC_first+0x17e>
8000c4de:	40 8b       	lddsp	r11,sp[0x20]
8000c4e0:	40 9a       	lddsp	r10,sp[0x24]
	r = GET_BITS(s);
8000c4e2:	0e 1a       	sub	r10,r7
8000c4e4:	f6 0a 08 49 	asr	r9,r11,r10
8000c4e8:	30 1c       	mov	r12,1
8000c4ea:	f8 07 09 48 	lsl	r8,r12,r7
8000c4ee:	20 18       	sub	r8,1
8000c4f0:	f3 e8 00 08 	and	r8,r9,r8
	s = HUFF_EXTEND(r, s);
8000c4f4:	4a 3c       	lddpc	r12,8000c580 <decode_mcu_DC_first+0x190>
8000c4f6:	f8 07 03 29 	ld.w	r9,r12[r7<<0x2]
8000c4fa:	12 38       	cp.w	r8,r9
8000c4fc:	c0 35       	brlt	8000c502 <decode_mcu_DC_first+0x112>
8000c4fe:	10 97       	mov	r7,r8
8000c500:	c0 68       	rjmp	8000c50c <decode_mcu_DC_first+0x11c>
8000c502:	4a 19       	lddpc	r9,8000c584 <decode_mcu_DC_first+0x194>
8000c504:	f2 07 03 27 	ld.w	r7,r9[r7<<0x2]
8000c508:	f0 07 00 07 	add	r7,r8,r7
      }

      /* Convert DC difference to actual value, update last_dc_val */
      s += state.last_dc_val[ci];
8000c50c:	2f f3       	sub	r3,-1
8000c50e:	fa c8 ff d4 	sub	r8,sp,-44
8000c512:	f0 03 00 23 	add	r3,r8,r3<<0x2
8000c516:	e6 f8 ff d8 	ld.w	r8,r3[-40]
8000c51a:	10 07       	add	r7,r8
      state.last_dc_val[ci] = s;
8000c51c:	e7 47 ff d8 	st.w	r3[-40],r7
      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
      (*block)[0] = (JCOEF) (s << Al);
8000c520:	40 0c       	lddsp	r12,sp[0x0]
8000c522:	ee 0c 09 47 	lsl	r7,r7,r12
8000c526:	a2 07       	st.h	r1[0x0],r7
    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
    ASSIGN_STATE(state, entropy->saved);

    /* Outer loop handles each block in the MCU */

    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
8000c528:	2f f2       	sub	r2,-1
8000c52a:	2f c5       	sub	r5,-4
8000c52c:	2f c4       	sub	r4,-4
8000c52e:	ec f8 01 64 	ld.w	r8,r6[356]
8000c532:	04 38       	cp.w	r8,r2
8000c534:	fe 99 ff 95 	brgt	8000c45e <decode_mcu_DC_first+0x6e>
      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
      (*block)[0] = (JCOEF) (s << Al);
    }

    /* Completed MCU, so update state */
    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
8000c538:	6c 68       	ld.w	r8,r6[0x18]
8000c53a:	40 69       	lddsp	r9,sp[0x18]
8000c53c:	91 09       	st.w	r8[0x0],r9
8000c53e:	6c 68       	ld.w	r8,r6[0x18]
8000c540:	40 79       	lddsp	r9,sp[0x1c]
8000c542:	91 19       	st.w	r8[0x4],r9
8000c544:	81 3b       	st.w	r0[0xc],r11
8000c546:	81 4a       	st.w	r0[0x10],r10
    ASSIGN_STATE(entropy->saved, state);
8000c548:	e0 c8 ff ec 	sub	r8,r0,-20
8000c54c:	fa c9 ff fc 	sub	r9,sp,-4
8000c550:	f2 ea 00 00 	ld.d	r10,r9[0]
8000c554:	f0 eb 00 00 	st.d	r8[0],r10
8000c558:	f2 ea 00 08 	ld.d	r10,r9[8]
8000c55c:	f0 eb 00 08 	st.d	r8[8],r10
8000c560:	72 49       	ld.w	r9,r9[0x10]
8000c562:	91 49       	st.w	r8[0x10],r9
  }

  /* Account for restart interval (no-op if not using restarts) */
  entropy->restarts_to_go--;
8000c564:	60 a8       	ld.w	r8,r0[0x28]
8000c566:	20 18       	sub	r8,1
8000c568:	81 a8       	st.w	r0[0x28],r8
8000c56a:	30 1c       	mov	r12,1

  return TRUE;
8000c56c:	c0 28       	rjmp	8000c570 <decode_mcu_DC_first+0x180>
8000c56e:	30 0c       	mov	r12,0
}
8000c570:	2f 5d       	sub	sp,-44
8000c572:	d8 32       	popm	r0-r7,pc
8000c574:	80 00       	ld.sh	r0,r0[0x0]
8000c576:	bb c0       	cbr	r0,0x1a
8000c578:	80 00       	ld.sh	r0,r0[0x0]
8000c57a:	8d 50       	st.w	r6[0x14],r0
8000c57c:	80 00       	ld.sh	r0,r0[0x0]
8000c57e:	8e 00       	ld.sh	r0,r7[0x0]
8000c580:	80 01       	ld.sh	r1,r0[0x0]
8000c582:	e6 28 80 01 	sub	r8,425985
8000c586:	e6 68 eb cd 	mov	r8,453581

8000c588 <start_pass_dpost>:
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
{
8000c588:	eb cd 40 c0 	pushm	r6-r7,lr
  my_post_ptr post = (my_post_ptr) cinfo->post;
8000c58c:	f8 f7 01 b0 	ld.w	r7,r12[432]

  switch (pass_mode) {
8000c590:	58 2b       	cp.w	r11,2
8000c592:	c2 70       	breq	8000c5e0 <start_pass_dpost+0x58>
8000c594:	58 3b       	cp.w	r11,3
8000c596:	c1 90       	breq	8000c5c8 <start_pass_dpost+0x40>
8000c598:	58 0b       	cp.w	r11,0
8000c59a:	c2 f1       	brne	8000c5f8 <start_pass_dpost+0x70>
  case JBUF_PASS_THRU:
    if (cinfo->quantize_colors) {
8000c59c:	79 58       	ld.w	r8,r12[0x54]
8000c59e:	58 08       	cp.w	r8,0
8000c5a0:	c0 f0       	breq	8000c5be <start_pass_dpost+0x36>
      /* Single-pass processing with color quantization. */
      post->pub.post_process_data = post_process_1pass;
8000c5a2:	49 c8       	lddpc	r8,8000c610 <start_pass_dpost+0x88>
8000c5a4:	8f 18       	st.w	r7[0x4],r8
      /* We could be doing buffered-image output before starting a 2-pass
       * color quantization; in that case, jinit_d_post_controller did not
       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
       */
      if (post->buffer == NULL) {
8000c5a6:	6e 38       	ld.w	r8,r7[0xc]
8000c5a8:	58 08       	cp.w	r8,0
8000c5aa:	c2 d1       	brne	8000c604 <start_pass_dpost+0x7c>
	post->buffer = (*cinfo->mem->access_virt_sarray)
8000c5ac:	78 18       	ld.w	r8,r12[0x4]
8000c5ae:	70 76       	ld.w	r6,r8[0x1c]
8000c5b0:	30 18       	mov	r8,1
8000c5b2:	6e 49       	ld.w	r9,r7[0x10]
8000c5b4:	30 0a       	mov	r10,0
8000c5b6:	6e 2b       	ld.w	r11,r7[0x8]
8000c5b8:	5d 16       	icall	r6
8000c5ba:	8f 3c       	st.w	r7[0xc],r12
8000c5bc:	c2 48       	rjmp	8000c604 <start_pass_dpost+0x7c>
      }
    } else {
      /* For single-pass processing without color quantization,
       * I have no work to do; just call the upsampler directly.
       */
      post->pub.post_process_data = cinfo->upsample->upsample;
8000c5be:	f8 f8 01 c4 	ld.w	r8,r12[452]
8000c5c2:	70 18       	ld.w	r8,r8[0x4]
8000c5c4:	8f 18       	st.w	r7[0x4],r8
8000c5c6:	c1 f8       	rjmp	8000c604 <start_pass_dpost+0x7c>
    }
    break;
#ifdef QUANT_2PASS_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    /* First pass of 2-pass quantization */
    if (post->whole_image == NULL)
8000c5c8:	6e 28       	ld.w	r8,r7[0x8]
8000c5ca:	58 08       	cp.w	r8,0
8000c5cc:	c0 71       	brne	8000c5da <start_pass_dpost+0x52>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
8000c5ce:	78 08       	ld.w	r8,r12[0x0]
8000c5d0:	30 49       	mov	r9,4
8000c5d2:	91 59       	st.w	r8[0x14],r9
8000c5d4:	78 08       	ld.w	r8,r12[0x0]
8000c5d6:	70 08       	ld.w	r8,r8[0x0]
8000c5d8:	5d 18       	icall	r8
    post->pub.post_process_data = post_process_prepass;
8000c5da:	48 f8       	lddpc	r8,8000c614 <start_pass_dpost+0x8c>
8000c5dc:	8f 18       	st.w	r7[0x4],r8
    break;
8000c5de:	c1 38       	rjmp	8000c604 <start_pass_dpost+0x7c>
  case JBUF_CRANK_DEST:
    /* Second pass of 2-pass quantization */
    if (post->whole_image == NULL)
8000c5e0:	6e 28       	ld.w	r8,r7[0x8]
8000c5e2:	58 08       	cp.w	r8,0
8000c5e4:	c0 71       	brne	8000c5f2 <start_pass_dpost+0x6a>
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
8000c5e6:	78 08       	ld.w	r8,r12[0x0]
8000c5e8:	30 49       	mov	r9,4
8000c5ea:	91 59       	st.w	r8[0x14],r9
8000c5ec:	78 08       	ld.w	r8,r12[0x0]
8000c5ee:	70 08       	ld.w	r8,r8[0x0]
8000c5f0:	5d 18       	icall	r8
    post->pub.post_process_data = post_process_2pass;
8000c5f2:	48 a8       	lddpc	r8,8000c618 <start_pass_dpost+0x90>
8000c5f4:	8f 18       	st.w	r7[0x4],r8
    break;
8000c5f6:	c0 78       	rjmp	8000c604 <start_pass_dpost+0x7c>
#endif /* QUANT_2PASS_SUPPORTED */
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
8000c5f8:	78 08       	ld.w	r8,r12[0x0]
8000c5fa:	30 49       	mov	r9,4
8000c5fc:	91 59       	st.w	r8[0x14],r9
8000c5fe:	78 08       	ld.w	r8,r12[0x0]
8000c600:	70 08       	ld.w	r8,r8[0x0]
8000c602:	5d 18       	icall	r8
    break;
  }
  post->starting_row = post->next_row = 0;
8000c604:	30 08       	mov	r8,0
8000c606:	8f 68       	st.w	r7[0x18],r8
8000c608:	8f 58       	st.w	r7[0x14],r8
}
8000c60a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000c60e:	00 00       	add	r0,r0
8000c610:	80 00       	ld.sh	r0,r0[0x0]
8000c612:	c6 1c       	rcall	8000c6d4 <post_process_prepass+0x5a>
8000c614:	80 00       	ld.sh	r0,r0[0x0]
8000c616:	c6 7a       	rjmp	8000c2e4 <decode_mcu_AC_first+0x90>
8000c618:	80 00       	ld.sh	r0,r0[0x0]
8000c61a:	c6 fa       	rjmp	8000c2f8 <decode_mcu_AC_first+0xa4>

8000c61c <post_process_1pass>:
post_process_1pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
8000c61c:	eb cd 40 f8 	pushm	r3-r7,lr
8000c620:	20 1d       	sub	sp,4
8000c622:	fa c4 ff e4 	sub	r4,sp,-28
8000c626:	18 95       	mov	r5,r12
8000c628:	10 93       	mov	r3,r8
8000c62a:	68 06       	ld.w	r6,r4[0x0]
8000c62c:	68 1e       	ld.w	lr,r4[0x4]
  my_post_ptr post = (my_post_ptr) cinfo->post;
8000c62e:	f8 f4 01 b0 	ld.w	r4,r12[432]
  JDIMENSION num_rows, max_rows;

  /* Fill the buffer, but not more than what we can dump out in one go. */
  /* Note we rely on the upsampler to detect bottom of image. */
  max_rows = out_rows_avail - *out_row_ctr;
8000c632:	6c 08       	ld.w	r8,r6[0x0]
8000c634:	10 1e       	sub	lr,r8
8000c636:	68 48       	ld.w	r8,r4[0x10]
8000c638:	10 3e       	cp.w	lr,r8
8000c63a:	f0 0e 17 b0 	movhi	lr,r8
  if (max_rows > post->strip_height)
    max_rows = post->strip_height;
  num_rows = 0;
8000c63e:	fa c7 ff fc 	sub	r7,sp,-4
8000c642:	30 08       	mov	r8,0
8000c644:	0e d8       	st.w	--r7,r8
  (*cinfo->upsample->upsample) (cinfo,
8000c646:	f8 f8 01 c4 	ld.w	r8,r12[452]
8000c64a:	1a de       	st.w	--sp,lr
8000c64c:	1a d7       	st.w	--sp,r7
8000c64e:	70 17       	ld.w	r7,r8[0x4]
8000c650:	68 38       	ld.w	r8,r4[0xc]
8000c652:	5d 17       	icall	r7
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &num_rows, max_rows);
  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
8000c654:	ea f8 01 cc 	ld.w	r8,r5[460]
8000c658:	6c 0a       	ld.w	r10,r6[0x0]
8000c65a:	70 18       	ld.w	r8,r8[0x4]
8000c65c:	40 29       	lddsp	r9,sp[0x8]
8000c65e:	e6 0a 00 2a 	add	r10,r3,r10<<0x2
8000c662:	68 3b       	ld.w	r11,r4[0xc]
8000c664:	0a 9c       	mov	r12,r5
8000c666:	5d 18       	icall	r8
		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
  *out_row_ctr += num_rows;
8000c668:	6c 09       	ld.w	r9,r6[0x0]
8000c66a:	40 28       	lddsp	r8,sp[0x8]
8000c66c:	f2 08 00 08 	add	r8,r9,r8
8000c670:	8d 08       	st.w	r6[0x0],r8
8000c672:	2f ed       	sub	sp,-8
}
8000c674:	2f fd       	sub	sp,-4
8000c676:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8000c67a <post_process_prepass>:
post_process_prepass (j_decompress_ptr cinfo,
		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		      JDIMENSION in_row_groups_avail,
		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		      JDIMENSION out_rows_avail)
{
8000c67a:	d4 31       	pushm	r0-r7,lr
8000c67c:	18 95       	mov	r5,r12
8000c67e:	16 92       	mov	r2,r11
8000c680:	14 93       	mov	r3,r10
8000c682:	12 94       	mov	r4,r9
8000c684:	40 90       	lddsp	r0,sp[0x24]
  my_post_ptr post = (my_post_ptr) cinfo->post;
8000c686:	f8 f7 01 b0 	ld.w	r7,r12[432]
  JDIMENSION old_next_row, num_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
8000c68a:	6e 68       	ld.w	r8,r7[0x18]
8000c68c:	58 08       	cp.w	r8,0
8000c68e:	c0 91       	brne	8000c6a0 <post_process_prepass+0x26>
    post->buffer = (*cinfo->mem->access_virt_sarray)
8000c690:	78 18       	ld.w	r8,r12[0x4]
8000c692:	70 76       	ld.w	r6,r8[0x1c]
8000c694:	30 18       	mov	r8,1
8000c696:	6e 49       	ld.w	r9,r7[0x10]
8000c698:	6e 5a       	ld.w	r10,r7[0x14]
8000c69a:	6e 2b       	ld.w	r11,r7[0x8]
8000c69c:	5d 16       	icall	r6
8000c69e:	8f 3c       	st.w	r7[0xc],r12
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, TRUE);
  }

  /* Upsample some data (up to a strip height's worth). */
  old_next_row = post->next_row;
8000c6a0:	6e 61       	ld.w	r1,r7[0x18]
  (*cinfo->upsample->upsample) (cinfo,
8000c6a2:	ea f8 01 c4 	ld.w	r8,r5[452]
8000c6a6:	6e 49       	ld.w	r9,r7[0x10]
8000c6a8:	1a d9       	st.w	--sp,r9
8000c6aa:	ee c9 ff e8 	sub	r9,r7,-24
8000c6ae:	1a d9       	st.w	--sp,r9
8000c6b0:	70 16       	ld.w	r6,r8[0x4]
8000c6b2:	6e 38       	ld.w	r8,r7[0xc]
8000c6b4:	08 99       	mov	r9,r4
8000c6b6:	06 9a       	mov	r10,r3
8000c6b8:	04 9b       	mov	r11,r2
8000c6ba:	0a 9c       	mov	r12,r5
8000c6bc:	5d 16       	icall	r6
		input_buf, in_row_group_ctr, in_row_groups_avail,
		post->buffer, &post->next_row, post->strip_height);

  /* Allow quantizer to scan new data.  No data is emitted, */
  /* but we advance out_row_ctr so outer loop can tell when we're done. */
  if (post->next_row > old_next_row) {
8000c6be:	6e 66       	ld.w	r6,r7[0x18]
8000c6c0:	2f ed       	sub	sp,-8
8000c6c2:	0c 31       	cp.w	r1,r6
8000c6c4:	c1 02       	brcc	8000c6e4 <post_process_prepass+0x6a>
    num_rows = post->next_row - old_next_row;
8000c6c6:	02 16       	sub	r6,r1
    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
8000c6c8:	ea f8 01 cc 	ld.w	r8,r5[460]
8000c6cc:	6e 3b       	ld.w	r11,r7[0xc]
8000c6ce:	70 18       	ld.w	r8,r8[0x4]
8000c6d0:	0c 99       	mov	r9,r6
8000c6d2:	30 0a       	mov	r10,0
8000c6d4:	f6 01 00 2b 	add	r11,r11,r1<<0x2
8000c6d8:	0a 9c       	mov	r12,r5
8000c6da:	5d 18       	icall	r8
					 (JSAMPARRAY) NULL, (int) num_rows);
    *out_row_ctr += num_rows;
8000c6dc:	60 08       	ld.w	r8,r0[0x0]
8000c6de:	f0 06 00 06 	add	r6,r8,r6
8000c6e2:	81 06       	st.w	r0[0x0],r6
  }

  /* Advance if we filled the strip. */
  if (post->next_row >= post->strip_height) {
8000c6e4:	6e 48       	ld.w	r8,r7[0x10]
8000c6e6:	6e 69       	ld.w	r9,r7[0x18]
8000c6e8:	10 39       	cp.w	r9,r8
8000c6ea:	c0 73       	brcs	8000c6f8 <post_process_prepass+0x7e>
    post->starting_row += post->strip_height;
8000c6ec:	6e 59       	ld.w	r9,r7[0x14]
8000c6ee:	f2 08 00 08 	add	r8,r9,r8
8000c6f2:	8f 58       	st.w	r7[0x14],r8
    post->next_row = 0;
8000c6f4:	30 08       	mov	r8,0
8000c6f6:	8f 68       	st.w	r7[0x18],r8
8000c6f8:	d8 32       	popm	r0-r7,pc

8000c6fa <post_process_2pass>:
post_process_2pass (j_decompress_ptr cinfo,
		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
		    JDIMENSION in_row_groups_avail,
		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
		    JDIMENSION out_rows_avail)
{
8000c6fa:	eb cd 40 fc 	pushm	r2-r7,lr
8000c6fe:	fa c4 ff e4 	sub	r4,sp,-28
8000c702:	18 95       	mov	r5,r12
8000c704:	10 92       	mov	r2,r8
8000c706:	68 03       	ld.w	r3,r4[0x0]
8000c708:	68 14       	ld.w	r4,r4[0x4]
  my_post_ptr post = (my_post_ptr) cinfo->post;
8000c70a:	f8 f7 01 b0 	ld.w	r7,r12[432]
  JDIMENSION num_rows, max_rows;

  /* Reposition virtual buffer if at start of strip. */
  if (post->next_row == 0) {
8000c70e:	6e 68       	ld.w	r8,r7[0x18]
8000c710:	58 08       	cp.w	r8,0
8000c712:	c0 91       	brne	8000c724 <post_process_2pass+0x2a>
    post->buffer = (*cinfo->mem->access_virt_sarray)
8000c714:	78 18       	ld.w	r8,r12[0x4]
8000c716:	70 76       	ld.w	r6,r8[0x1c]
8000c718:	30 08       	mov	r8,0
8000c71a:	6e 49       	ld.w	r9,r7[0x10]
8000c71c:	6e 5a       	ld.w	r10,r7[0x14]
8000c71e:	6e 2b       	ld.w	r11,r7[0x8]
8000c720:	5d 16       	icall	r6
8000c722:	8f 3c       	st.w	r7[0xc],r12
	((j_common_ptr) cinfo, post->whole_image,
	 post->starting_row, post->strip_height, FALSE);
  }

  /* Determine number of rows to emit. */
  num_rows = post->strip_height - post->next_row; /* available in strip */
8000c724:	6e 6b       	ld.w	r11,r7[0x18]
8000c726:	6e 48       	ld.w	r8,r7[0x10]
8000c728:	16 18       	sub	r8,r11
  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
8000c72a:	66 0a       	ld.w	r10,r3[0x0]
8000c72c:	6b d6       	ld.w	r6,r5[0x74]
8000c72e:	6e 59       	ld.w	r9,r7[0x14]
8000c730:	12 16       	sub	r6,r9
8000c732:	10 36       	cp.w	r6,r8
8000c734:	f0 06 17 b0 	movhi	r6,r8
8000c738:	14 14       	sub	r4,r10
8000c73a:	08 36       	cp.w	r6,r4
8000c73c:	e8 06 17 b0 	movhi	r6,r4
  max_rows = cinfo->output_height - post->starting_row;
  if (num_rows > max_rows)
    num_rows = max_rows;

  /* Quantize and emit data. */
  (*cinfo->cquantize->color_quantize) (cinfo,
8000c740:	ea f8 01 cc 	ld.w	r8,r5[460]
8000c744:	6e 3c       	ld.w	r12,r7[0xc]
8000c746:	70 18       	ld.w	r8,r8[0x4]
8000c748:	0c 99       	mov	r9,r6
8000c74a:	e4 0a 00 2a 	add	r10,r2,r10<<0x2
8000c74e:	f8 0b 00 2b 	add	r11,r12,r11<<0x2
8000c752:	0a 9c       	mov	r12,r5
8000c754:	5d 18       	icall	r8
		post->buffer + post->next_row, output_buf + *out_row_ctr,
		(int) num_rows);
  *out_row_ctr += num_rows;
8000c756:	66 08       	ld.w	r8,r3[0x0]
8000c758:	0c 08       	add	r8,r6
8000c75a:	87 08       	st.w	r3[0x0],r8

  /* Advance if we filled the strip. */
  post->next_row += num_rows;
8000c75c:	6e 68       	ld.w	r8,r7[0x18]
8000c75e:	10 06       	add	r6,r8
8000c760:	8f 66       	st.w	r7[0x18],r6
  if (post->next_row >= post->strip_height) {
8000c762:	6e 48       	ld.w	r8,r7[0x10]
8000c764:	10 36       	cp.w	r6,r8
8000c766:	c0 73       	brcs	8000c774 <post_process_2pass+0x7a>
    post->starting_row += post->strip_height;
8000c768:	6e 59       	ld.w	r9,r7[0x14]
8000c76a:	f2 08 00 08 	add	r8,r9,r8
8000c76e:	8f 58       	st.w	r7[0x14],r8
    post->next_row = 0;
8000c770:	30 08       	mov	r8,0
8000c772:	8f 68       	st.w	r7[0x18],r8
8000c774:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

8000c778 <jinit_d_post_controller>:
 * Initialize postprocessing controller.
 */

GLOBAL(void)
jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
{
8000c778:	eb cd 40 f8 	pushm	r3-r7,lr
8000c77c:	18 97       	mov	r7,r12
8000c77e:	16 95       	mov	r5,r11
  my_post_ptr post;

  post = (my_post_ptr)
8000c780:	18 94       	mov	r4,r12
8000c782:	78 18       	ld.w	r8,r12[0x4]
8000c784:	70 08       	ld.w	r8,r8[0x0]
8000c786:	31 ca       	mov	r10,28
8000c788:	30 1b       	mov	r11,1
8000c78a:	5d 18       	icall	r8
8000c78c:	18 96       	mov	r6,r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_post_controller));
  cinfo->post = (struct jpeg_d_post_controller *) post;
8000c78e:	ef 4c 01 b0 	st.w	r7[432],r12
  post->pub.start_pass = start_pass_dpost;
8000c792:	49 88       	lddpc	r8,8000c7f0 <jinit_d_post_controller+0x78>
8000c794:	99 08       	st.w	r12[0x0],r8
  post->whole_image = NULL;	/* flag for no virtual arrays */
8000c796:	30 08       	mov	r8,0
8000c798:	99 28       	st.w	r12[0x8],r8
  post->buffer = NULL;		/* flag for no strip buffer */
8000c79a:	99 38       	st.w	r12[0xc],r8

  /* Create the quantization buffer, if needed */
  if (cinfo->quantize_colors) {
8000c79c:	6f 58       	ld.w	r8,r7[0x54]
8000c79e:	58 08       	cp.w	r8,0
8000c7a0:	c2 50       	breq	8000c7ea <jinit_d_post_controller+0x72>
    /* The buffer strip height is max_v_samp_factor, which is typically
     * an efficient number of rows for upsampling to return.
     * (In the presence of output rescaling, we might want to be smarter?)
     */
    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
8000c7a2:	ee fb 01 38 	ld.w	r11,r7[312]
8000c7a6:	16 93       	mov	r3,r11
8000c7a8:	99 4b       	st.w	r12[0x10],r11
    if (need_full_buffer) {
8000c7aa:	58 05       	cp.w	r5,0
8000c7ac:	c1 40       	breq	8000c7d4 <jinit_d_post_controller+0x5c>
      /* Two-pass color quantization: need full-image storage. */
      /* We round up the number of rows to a multiple of the strip height. */
#ifdef QUANT_2PASS_SUPPORTED
      post->whole_image = (*cinfo->mem->request_virt_sarray)
8000c7ae:	6e 18       	ld.w	r8,r7[0x4]
8000c7b0:	70 45       	ld.w	r5,r8[0x10]
8000c7b2:	6f dc       	ld.w	r12,r7[0x74]
8000c7b4:	f0 1f 00 10 	mcall	8000c7f4 <jinit_d_post_controller+0x7c>
8000c7b8:	6f ea       	ld.w	r10,r7[0x78]
8000c7ba:	6f c9       	ld.w	r9,r7[0x70]
8000c7bc:	1a d3       	st.w	--sp,r3
8000c7be:	18 98       	mov	r8,r12
8000c7c0:	f4 09 02 49 	mul	r9,r10,r9
8000c7c4:	30 0a       	mov	r10,0
8000c7c6:	30 1b       	mov	r11,1
8000c7c8:	0e 9c       	mov	r12,r7
8000c7ca:	5d 15       	icall	r5
8000c7cc:	8d 2c       	st.w	r6[0x8],r12
8000c7ce:	2f fd       	sub	sp,-4
8000c7d0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
#else
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif /* QUANT_2PASS_SUPPORTED */
    } else {
      /* One-pass color quantization: just make a strip buffer. */
      post->buffer = (*cinfo->mem->alloc_sarray)
8000c7d4:	6e 18       	ld.w	r8,r7[0x4]
8000c7d6:	6f eb       	ld.w	r11,r7[0x78]
8000c7d8:	6f ca       	ld.w	r10,r7[0x70]
8000c7da:	70 28       	ld.w	r8,r8[0x8]
8000c7dc:	06 99       	mov	r9,r3
8000c7de:	f6 0a 02 4a 	mul	r10,r11,r10
8000c7e2:	30 1b       	mov	r11,1
8000c7e4:	0e 9c       	mov	r12,r7
8000c7e6:	5d 18       	icall	r8
8000c7e8:	8d 3c       	st.w	r6[0xc],r12
8000c7ea:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000c7ee:	00 00       	add	r0,r0
8000c7f0:	80 00       	ld.sh	r0,r0[0x0]
8000c7f2:	c5 88       	rjmp	8000c8a2 <sep_upsample+0x9a>
8000c7f4:	80 00       	ld.sh	r0,r0[0x0]
8000c7f6:	fd 0e f8 f8 	ld.sh	lr,lr[-1800]

8000c7f8 <start_pass_upsample>:
 */

METHODDEF(void)
start_pass_upsample (j_decompress_ptr cinfo)
{
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000c7f8:	f8 f8 01 c4 	ld.w	r8,r12[452]

  /* Mark the conversion buffer empty */
  upsample->next_row_out = cinfo->max_v_samp_factor;
8000c7fc:	f8 f9 01 38 	ld.w	r9,r12[312]
8000c800:	91 b9       	st.w	r8[0x2c],r9
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
8000c802:	79 d9       	ld.w	r9,r12[0x74]
8000c804:	91 c9       	st.w	r8[0x30],r9
}
8000c806:	5e fc       	retal	r12

8000c808 <sep_upsample>:
sep_upsample (j_decompress_ptr cinfo,
	      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
	      JDIMENSION in_row_groups_avail,
	      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
	      JDIMENSION out_rows_avail)
{
8000c808:	d4 31       	pushm	r0-r7,lr
8000c80a:	20 2d       	sub	sp,8
8000c80c:	fa c4 ff d4 	sub	r4,sp,-44
8000c810:	18 97       	mov	r7,r12
8000c812:	14 92       	mov	r2,r10
8000c814:	50 08       	stdsp	sp[0x0],r8
8000c816:	68 01       	ld.w	r1,r4[0x0]
8000c818:	68 14       	ld.w	r4,r4[0x4]
8000c81a:	50 14       	stdsp	sp[0x4],r4
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000c81c:	f8 f5 01 c4 	ld.w	r5,r12[452]
  int ci;
  jpeg_component_info * compptr;
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
8000c820:	6a b9       	ld.w	r9,r5[0x2c]
8000c822:	f8 f8 01 38 	ld.w	r8,r12[312]
8000c826:	10 39       	cp.w	r9,r8
8000c828:	c2 25       	brlt	8000c86c <sep_upsample+0x64>
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000c82a:	f8 f3 00 d8 	ld.w	r3,r12[216]
8000c82e:	78 98       	ld.w	r8,r12[0x24]
8000c830:	58 08       	cp.w	r8,0
8000c832:	e0 8a 00 1b 	brle	8000c868 <sep_upsample+0x60>
8000c836:	ea c6 ff e4 	sub	r6,r5,-28
8000c83a:	16 90       	mov	r0,r11
8000c83c:	30 04       	mov	r4,0
	 ci++, compptr++) {
      /* Invoke per-component upsample method.  Notice we pass a POINTER
       * to color_buf[ci], so that fullsize_upsample can change it.
       */
      (*upsample->methods[ci]) (cinfo, compptr,
8000c83e:	e8 c9 ff fd 	sub	r9,r4,-3
8000c842:	6c 6a       	ld.w	r10,r6[0x18]
8000c844:	a3 6a       	lsl	r10,0x2
8000c846:	64 08       	ld.w	r8,r2[0x0]
8000c848:	b1 3a       	mul	r10,r8
8000c84a:	01 0b       	ld.w	r11,r0++
8000c84c:	0d 08       	ld.w	r8,r6++
8000c84e:	ea 09 00 29 	add	r9,r5,r9<<0x2
8000c852:	f6 0a 00 0a 	add	r10,r11,r10
8000c856:	06 9b       	mov	r11,r3
8000c858:	0e 9c       	mov	r12,r7
8000c85a:	5d 18       	icall	r8
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
8000c85c:	2f f4       	sub	r4,-1
8000c85e:	2a c3       	sub	r3,-84
  jpeg_component_info * compptr;
  JDIMENSION num_rows;

  /* Fill the conversion buffer, if it's empty */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000c860:	6e 98       	ld.w	r8,r7[0x24]
8000c862:	08 38       	cp.w	r8,r4
8000c864:	fe 99 ff ed 	brgt	8000c83e <sep_upsample+0x36>
       */
      (*upsample->methods[ci]) (cinfo, compptr,
	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
	upsample->color_buf + ci);
    }
    upsample->next_row_out = 0;
8000c868:	30 08       	mov	r8,0
8000c86a:	8b b8       	st.w	r5[0x2c],r8
  }

  /* Color-convert and emit rows */

  /* How many we have in the buffer: */
  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
8000c86c:	6a ba       	ld.w	r10,r5[0x2c]
8000c86e:	ee f4 01 38 	ld.w	r4,r7[312]
8000c872:	14 14       	sub	r4,r10
8000c874:	6a c8       	ld.w	r8,r5[0x30]
8000c876:	10 34       	cp.w	r4,r8
8000c878:	f0 04 17 b0 	movhi	r4,r8
   * in case the image height is not a multiple of max_v_samp_factor:
   */
  if (num_rows > upsample->rows_to_go)
    num_rows = upsample->rows_to_go;
  /* And not more than what the client can accept: */
  out_rows_avail -= *out_row_ctr;
8000c87c:	62 09       	ld.w	r9,r1[0x0]
8000c87e:	40 18       	lddsp	r8,sp[0x4]
8000c880:	12 18       	sub	r8,r9
8000c882:	10 34       	cp.w	r4,r8
8000c884:	f0 04 17 b0 	movhi	r4,r8
  if (num_rows > out_rows_avail)
    num_rows = out_rows_avail;

  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
8000c888:	ee f8 01 c8 	ld.w	r8,r7[456]
8000c88c:	70 16       	ld.w	r6,r8[0x4]
8000c88e:	08 98       	mov	r8,r4
8000c890:	40 0b       	lddsp	r11,sp[0x0]
8000c892:	f6 09 00 29 	add	r9,r11,r9<<0x2
8000c896:	ea cb ff f4 	sub	r11,r5,-12
8000c89a:	0e 9c       	mov	r12,r7
8000c89c:	5d 16       	icall	r6
				     (JDIMENSION) upsample->next_row_out,
				     output_buf + *out_row_ctr,
				     (int) num_rows);

  /* Adjust counts */
  *out_row_ctr += num_rows;
8000c89e:	62 08       	ld.w	r8,r1[0x0]
8000c8a0:	08 08       	add	r8,r4
8000c8a2:	83 08       	st.w	r1[0x0],r8
  upsample->rows_to_go -= num_rows;
8000c8a4:	6a c8       	ld.w	r8,r5[0x30]
8000c8a6:	08 18       	sub	r8,r4
8000c8a8:	8b c8       	st.w	r5[0x30],r8
  upsample->next_row_out += num_rows;
8000c8aa:	6a b8       	ld.w	r8,r5[0x2c]
8000c8ac:	10 04       	add	r4,r8
8000c8ae:	8b b4       	st.w	r5[0x2c],r4
  /* When the buffer is emptied, declare this input row group consumed */
  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
8000c8b0:	ee f8 01 38 	ld.w	r8,r7[312]
    (*in_row_group_ctr)++;
8000c8b4:	10 34       	cp.w	r4,r8
8000c8b6:	e5 f8 40 00 	ld.wge	r8,r2[0x0]
8000c8ba:	f7 b8 04 ff 	subge	r8,-1
8000c8be:	e5 f8 4a 00 	st.wge	r2[0x0],r8
}
8000c8c2:	2f ed       	sub	sp,-8
8000c8c4:	d8 32       	popm	r0-r7,pc

8000c8c6 <fullsize_upsample>:

METHODDEF(void)
fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = input_data;
8000c8c6:	93 0a       	st.w	r9[0x0],r10
}
8000c8c8:	5e fc       	retal	r12

8000c8ca <noop_upsample>:

METHODDEF(void)
noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
  *output_data_ptr = NULL;	/* safety check */
8000c8ca:	30 08       	mov	r8,0
8000c8cc:	93 08       	st.w	r9[0x0],r8
}
8000c8ce:	5e fc       	retal	r12

8000c8d0 <h2v1_upsample>:
 */

METHODDEF(void)
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
8000c8d0:	eb cd 40 c0 	pushm	r6-r7,lr
  JSAMPARRAY output_data = *output_data_ptr;
8000c8d4:	72 06       	ld.w	r6,r9[0x0]
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
8000c8d6:	f8 f8 01 38 	ld.w	r8,r12[312]
8000c8da:	58 08       	cp.w	r8,0
8000c8dc:	e0 8a 00 18 	brle	8000c90c <h2v1_upsample+0x3c>
8000c8e0:	30 07       	mov	r7,0
    inptr = input_data[inrow];
8000c8e2:	74 0b       	ld.w	r11,r10[0x0]
    outptr = output_data[inrow];
8000c8e4:	6c 08       	ld.w	r8,r6[0x0]
    outend = outptr + cinfo->output_width;
8000c8e6:	79 ce       	ld.w	lr,r12[0x70]
8000c8e8:	f0 0e 00 0e 	add	lr,r8,lr
    while (outptr < outend) {
8000c8ec:	1c 38       	cp.w	r8,lr
8000c8ee:	c0 72       	brcc	8000c8fc <h2v1_upsample+0x2c>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
8000c8f0:	17 39       	ld.ub	r9,r11++
      *outptr++ = invalue;
8000c8f2:	b0 89       	st.b	r8[0x0],r9
      *outptr++ = invalue;
8000c8f4:	b0 99       	st.b	r8[0x1],r9
 * Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
 * It's still a box filter.
 */

METHODDEF(void)
h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000c8f6:	2f e8       	sub	r8,-2

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
8000c8f8:	1c 38       	cp.w	r8,lr
8000c8fa:	cf b3       	brcs	8000c8f0 <h2v1_upsample+0x20>
  register JSAMPROW inptr, outptr;
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
8000c8fc:	2f f7       	sub	r7,-1
8000c8fe:	2f ca       	sub	r10,-4
8000c900:	2f c6       	sub	r6,-4
8000c902:	f8 f8 01 38 	ld.w	r8,r12[312]
8000c906:	0e 38       	cp.w	r8,r7
8000c908:	fe 99 ff ed 	brgt	8000c8e2 <h2v1_upsample+0x12>
8000c90c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000c910 <h2v1_fancy_upsample>:
 */

METHODDEF(void)
h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
8000c910:	eb cd 40 fe 	pushm	r1-r7,lr
  JSAMPARRAY output_data = *output_data_ptr;
8000c914:	72 03       	ld.w	r3,r9[0x0]
  register JSAMPROW inptr, outptr;
  register int invalue;
  register JDIMENSION colctr;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
8000c916:	f8 f8 01 38 	ld.w	r8,r12[312]
8000c91a:	58 08       	cp.w	r8,0
8000c91c:	e0 8a 00 3d 	brle	8000c996 <h2v1_fancy_upsample+0x86>
8000c920:	30 04       	mov	r4,0
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    /* Special case for first column */
    invalue = GETJSAMPLE(*inptr++);
8000c922:	74 06       	ld.w	r6,r10[0x0]
8000c924:	0d 38       	ld.ub	r8,r6++
    *outptr++ = (JSAMPLE) invalue;
8000c926:	66 05       	ld.w	r5,r3[0x0]
8000c928:	0a c8       	st.b	r5++,r8
    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(*inptr) + 2) >> 2);
8000c92a:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000c92e:	0d 89       	ld.ub	r9,r6[0x0]
8000c930:	12 08       	add	r8,r9
8000c932:	f3 b8 03 e2 	satrnds	r8>>0x2,0x1f
8000c936:	0a c8       	st.b	r5++,r8

    for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
8000c938:	76 a2       	ld.w	r2,r11[0x28]
8000c93a:	e4 ce 00 02 	sub	lr,r2,2
8000c93e:	c1 90       	breq	8000c970 <h2v1_fancy_upsample+0x60>
8000c940:	0a 99       	mov	r9,r5
8000c942:	0c 98       	mov	r8,r6
      /* General case: 3/4 * nearer pixel + 1/4 * further pixel */
      invalue = GETJSAMPLE(*inptr++) * 3;
8000c944:	11 37       	ld.ub	r7,r8++
8000c946:	ee 07 00 17 	add	r7,r7,r7<<0x1
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
8000c94a:	f1 31 ff fe 	ld.ub	r1,r8[-2]
8000c94e:	2f f1       	sub	r1,-1
8000c950:	0e 01       	add	r1,r7
8000c952:	a3 41       	asr	r1,0x2
8000c954:	b2 81       	st.b	r9[0x0],r1
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(*inptr) + 2) >> 2);
8000c956:	11 81       	ld.ub	r1,r8[0x0]
8000c958:	2f e1       	sub	r1,-2
8000c95a:	e2 07 00 07 	add	r7,r1,r7
8000c95e:	a3 47       	asr	r7,0x2
8000c960:	b2 97       	st.b	r9[0x1],r7
 * Instead, this code is arranged so that 0.5 will be rounded up or down at
 * alternate pixel locations (a simple ordered dither pattern).
 */

METHODDEF(void)
h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000c962:	2f e9       	sub	r9,-2
    /* Special case for first column */
    invalue = GETJSAMPLE(*inptr++);
    *outptr++ = (JSAMPLE) invalue;
    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(*inptr) + 2) >> 2);

    for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
8000c964:	20 1e       	sub	lr,1
8000c966:	ce f1       	brne	8000c944 <h2v1_fancy_upsample+0x34>
 * Instead, this code is arranged so that 0.5 will be rounded up or down at
 * alternate pixel locations (a simple ordered dither pattern).
 */

METHODDEF(void)
h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000c968:	20 22       	sub	r2,2
8000c96a:	04 06       	add	r6,r2
8000c96c:	ea 02 00 15 	add	r5,r5,r2<<0x1
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(*inptr) + 2) >> 2);
    }

    /* Special case for last column */
    invalue = GETJSAMPLE(*inptr);
8000c970:	0d 88       	ld.ub	r8,r6[0x0]
    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(inptr[-1]) + 1) >> 2);
8000c972:	f0 08 00 1e 	add	lr,r8,r8<<0x1
8000c976:	ed 39 ff ff 	ld.ub	r9,r6[-1]
8000c97a:	fc 09 00 09 	add	r9,lr,r9
8000c97e:	2f f9       	sub	r9,-1
8000c980:	a3 49       	asr	r9,0x2
8000c982:	aa 89       	st.b	r5[0x0],r9
    *outptr++ = (JSAMPLE) invalue;
8000c984:	aa 98       	st.b	r5[0x1],r8
  register JSAMPROW inptr, outptr;
  register int invalue;
  register JDIMENSION colctr;
  int inrow;

  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
8000c986:	2f f4       	sub	r4,-1
8000c988:	2f ca       	sub	r10,-4
8000c98a:	2f c3       	sub	r3,-4
8000c98c:	f8 f8 01 38 	ld.w	r8,r12[312]
8000c990:	08 38       	cp.w	r8,r4
8000c992:	fe 99 ff c8 	brgt	8000c922 <h2v1_fancy_upsample+0x12>
8000c996:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc

8000c99a <h2v2_fancy_upsample>:
 */

METHODDEF(void)
h2v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
8000c99a:	d4 31       	pushm	r0-r7,lr
8000c99c:	20 3d       	sub	sp,12
8000c99e:	50 2c       	stdsp	sp[0x8],r12
8000c9a0:	50 1b       	stdsp	sp[0x4],r11
  JSAMPARRAY output_data = *output_data_ptr;
8000c9a2:	72 00       	ld.w	r0,r9[0x0]
#endif
  register JDIMENSION colctr;
  int inrow, outrow, v;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
8000c9a4:	f8 f8 01 38 	ld.w	r8,r12[312]
8000c9a8:	58 08       	cp.w	r8,0
8000c9aa:	e0 8a 00 66 	brle	8000ca76 <h2v2_fancy_upsample+0xdc>
8000c9ae:	f4 c2 00 04 	sub	r2,r10,4
8000c9b2:	30 09       	mov	r9,0
8000c9b4:	50 09       	stdsp	sp[0x0],r9
8000c9b6:	c5 d8       	rjmp	8000ca70 <h2v2_fancy_upsample+0xd6>
    for (v = 0; v < 2; v++) {
      /* inptr0 points to nearest input row, inptr1 points to next nearest */
      inptr0 = input_data[inrow];
8000c9b8:	64 16       	ld.w	r6,r2[0x4]
      if (v == 0)		/* next nearest is row above */
	inptr1 = input_data[inrow-1];
8000c9ba:	58 04       	cp.w	r4,0
8000c9bc:	e5 f7 00 00 	ld.weq	r7,r2[0x0]
      else			/* next nearest is row below */
	inptr1 = input_data[inrow+1];
8000c9c0:	e5 f7 10 02 	ld.wne	r7,r2[0x8]
      outptr = output_data[outrow++];

      /* Special case for first column */
      thiscolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
8000c9c4:	0f 3e       	ld.ub	lr,r7++
8000c9c6:	0d 38       	ld.ub	r8,r6++
8000c9c8:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000c9cc:	10 0e       	add	lr,r8
      nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
8000c9ce:	0f 88       	ld.ub	r8,r7[0x0]
8000c9d0:	0d 89       	ld.ub	r9,r6[0x0]
8000c9d2:	f2 09 00 19 	add	r9,r9,r9<<0x1
8000c9d6:	12 08       	add	r8,r9
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 8) >> 4);
8000c9d8:	fc c9 ff fe 	sub	r9,lr,-2
8000c9dc:	a3 89       	lsr	r9,0x2
8000c9de:	66 05       	ld.w	r5,r3[0x0]
8000c9e0:	0a c9       	st.b	r5++,r9
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
8000c9e2:	fc 0e 00 19 	add	r9,lr,lr<<0x1
8000c9e6:	f0 09 00 09 	add	r9,r8,r9
8000c9ea:	2f 99       	sub	r9,-7
8000c9ec:	a5 49       	asr	r9,0x4
8000c9ee:	0a c9       	st.b	r5++,r9
      lastcolsum = thiscolsum; thiscolsum = nextcolsum;

      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
8000c9f0:	40 19       	lddsp	r9,sp[0x4]
8000c9f2:	72 a1       	ld.w	r1,r9[0x28]
8000c9f4:	e2 ca 00 02 	sub	r10,r1,2
8000c9f8:	c0 41       	brne	8000ca00 <h2v2_fancy_upsample+0x66>
8000c9fa:	1c 9c       	mov	r12,lr
8000c9fc:	10 9b       	mov	r11,r8
8000c9fe:	c1 e8       	rjmp	8000ca3a <h2v2_fancy_upsample+0xa0>
	inptr1 = input_data[inrow+1];
      outptr = output_data[outrow++];

      /* Special case for first column */
      thiscolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
      nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
8000ca00:	2f f6       	sub	r6,-1
8000ca02:	2f f7       	sub	r7,-1
8000ca04:	0a 99       	mov	r9,r5
      lastcolsum = thiscolsum; thiscolsum = nextcolsum;

      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each */
	/* dimension, thus 9/16, 3/16, 3/16, 1/16 overall */
	nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
8000ca06:	0d 3b       	ld.ub	r11,r6++
8000ca08:	f6 0b 00 1b 	add	r11,r11,r11<<0x1
8000ca0c:	0f 3c       	ld.ub	r12,r7++
8000ca0e:	18 0b       	add	r11,r12
	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
8000ca10:	f0 08 00 1c 	add	r12,r8,r8<<0x1
8000ca14:	2f 8e       	sub	lr,-8
8000ca16:	18 0e       	add	lr,r12
8000ca18:	a5 4e       	asr	lr,0x4
8000ca1a:	b2 8e       	st.b	r9[0x0],lr
	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
8000ca1c:	f6 ce ff f9 	sub	lr,r11,-7
8000ca20:	fc 0c 00 0c 	add	r12,lr,r12
8000ca24:	a5 4c       	asr	r12,0x4
8000ca26:	b2 9c       	st.b	r9[0x1],r12
 * It is OK for us to reference the adjacent input rows because we demanded
 * context from the main buffer controller (see initialization code).
 */

METHODDEF(void)
h2v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000ca28:	2f e9       	sub	r9,-2
      nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 8) >> 4);
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
      lastcolsum = thiscolsum; thiscolsum = nextcolsum;

      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
8000ca2a:	20 1a       	sub	r10,1
8000ca2c:	10 9c       	mov	r12,r8
8000ca2e:	10 9e       	mov	lr,r8
8000ca30:	16 98       	mov	r8,r11
8000ca32:	ce a1       	brne	8000ca06 <h2v2_fancy_upsample+0x6c>
8000ca34:	20 21       	sub	r1,2
8000ca36:	ea 01 00 15 	add	r5,r5,r1<<0x1
	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
	lastcolsum = thiscolsum; thiscolsum = nextcolsum;
      }

      /* Special case for last column */
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
8000ca3a:	f8 c8 ff f8 	sub	r8,r12,-8
8000ca3e:	f6 0b 00 19 	add	r9,r11,r11<<0x1
8000ca42:	12 08       	add	r8,r9
8000ca44:	a5 48       	asr	r8,0x4
8000ca46:	aa 88       	st.b	r5[0x0],r8
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 7) >> 4);
8000ca48:	a3 6b       	lsl	r11,0x2
8000ca4a:	2f 9b       	sub	r11,-7
8000ca4c:	a5 4b       	asr	r11,0x4
8000ca4e:	aa 9b       	st.b	r5[0x1],r11
  register JDIMENSION colctr;
  int inrow, outrow, v;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    for (v = 0; v < 2; v++) {
8000ca50:	2f f4       	sub	r4,-1
8000ca52:	2f c3       	sub	r3,-4
8000ca54:	58 24       	cp.w	r4,2
8000ca56:	cb 11       	brne	8000c9b8 <h2v2_fancy_upsample+0x1e>
8000ca58:	40 08       	lddsp	r8,sp[0x0]
8000ca5a:	2f e8       	sub	r8,-2
8000ca5c:	50 08       	stdsp	sp[0x0],r8
8000ca5e:	2f c2       	sub	r2,-4
8000ca60:	2f 80       	sub	r0,-8
#endif
  register JDIMENSION colctr;
  int inrow, outrow, v;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
8000ca62:	40 29       	lddsp	r9,sp[0x8]
8000ca64:	f2 f8 01 38 	ld.w	r8,r9[312]
8000ca68:	40 09       	lddsp	r9,sp[0x0]
8000ca6a:	12 38       	cp.w	r8,r9
8000ca6c:	e0 8a 00 05 	brle	8000ca76 <h2v2_fancy_upsample+0xdc>
8000ca70:	00 93       	mov	r3,r0
8000ca72:	30 04       	mov	r4,0
8000ca74:	ca 2b       	rjmp	8000c9b8 <h2v2_fancy_upsample+0x1e>
      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 7) >> 4);
    }
    inrow++;
  }
}
8000ca76:	2f dd       	sub	sp,-12
8000ca78:	d8 32       	popm	r0-r7,pc
8000ca7a:	d7 03       	nop

8000ca7c <jinit_upsampler>:
 * Module initialization routine for upsampling.
 */

GLOBAL(void)
jinit_upsampler (j_decompress_ptr cinfo)
{
8000ca7c:	d4 31       	pushm	r0-r7,lr
8000ca7e:	20 3d       	sub	sp,12
8000ca80:	18 97       	mov	r7,r12
  int ci;
  jpeg_component_info * compptr;
  boolean need_buffer, do_fancy;
  int h_in_group, v_in_group, h_out_group, v_out_group;

  upsample = (my_upsample_ptr)
8000ca82:	50 1c       	stdsp	sp[0x4],r12
8000ca84:	78 18       	ld.w	r8,r12[0x4]
8000ca86:	70 08       	ld.w	r8,r8[0x0]
8000ca88:	34 ca       	mov	r10,76
8000ca8a:	30 1b       	mov	r11,1
8000ca8c:	5d 18       	icall	r8
8000ca8e:	50 0c       	stdsp	sp[0x0],r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *) upsample;
8000ca90:	ef 4c 01 c4 	st.w	r7[452],r12
  upsample->pub.start_pass = start_pass_upsample;
8000ca94:	4d 98       	lddpc	r8,8000cbf8 <jinit_upsampler+0x17c>
8000ca96:	40 0b       	lddsp	r11,sp[0x0]
8000ca98:	97 08       	st.w	r11[0x0],r8
  upsample->pub.upsample = sep_upsample;
8000ca9a:	4d 98       	lddpc	r8,8000cbfc <jinit_upsampler+0x180>
8000ca9c:	97 18       	st.w	r11[0x4],r8
  upsample->pub.need_context_rows = FALSE; /* until we find out differently */
8000ca9e:	30 08       	mov	r8,0
8000caa0:	97 28       	st.w	r11[0x8],r8

  if (cinfo->CCIR601_sampling)	/* this isn't supported */
8000caa2:	ee f8 01 2c 	ld.w	r8,r7[300]
8000caa6:	58 08       	cp.w	r8,0
8000caa8:	c0 80       	breq	8000cab8 <jinit_upsampler+0x3c>
    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);
8000caaa:	6e 08       	ld.w	r8,r7[0x0]
8000caac:	31 99       	mov	r9,25
8000caae:	91 59       	st.w	r8[0x14],r9
8000cab0:	6e 08       	ld.w	r8,r7[0x0]
8000cab2:	70 08       	ld.w	r8,r8[0x0]
8000cab4:	40 1c       	lddsp	r12,sp[0x4]
8000cab6:	5d 18       	icall	r8

  /* jdmainct.c doesn't support context rows when min_DCT_scaled_size = 1,
   * so don't ask for it.
   */
  do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;
8000cab8:	6f 38       	ld.w	r8,r7[0x4c]
8000caba:	58 08       	cp.w	r8,0
8000cabc:	c0 41       	brne	8000cac4 <jinit_upsampler+0x48>
8000cabe:	30 09       	mov	r9,0
8000cac0:	50 29       	stdsp	sp[0x8],r9
8000cac2:	c0 68       	rjmp	8000cace <jinit_upsampler+0x52>
8000cac4:	ee f8 01 3c 	ld.w	r8,r7[316]
8000cac8:	58 18       	cp.w	r8,1
8000caca:	5f 98       	srgt	r8
8000cacc:	50 28       	stdsp	sp[0x8],r8

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000cace:	ee f6 00 d8 	ld.w	r6,r7[216]
8000cad2:	6e 98       	ld.w	r8,r7[0x24]
8000cad4:	58 08       	cp.w	r8,0
8000cad6:	e0 8a 00 8e 	brle	8000cbf2 <jinit_upsampler+0x176>
8000cada:	40 05       	lddsp	r5,sp[0x0]
8000cadc:	0a 93       	mov	r3,r5
8000cade:	2e 43       	sub	r3,-28
8000cae0:	0a 92       	mov	r2,r5
8000cae2:	30 04       	mov	r4,0
       ci++, compptr++) {
    /* Compute size of an "input group" after IDCT scaling.  This many samples
     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
     */
    h_in_group = (compptr->h_samp_factor * compptr->DCT_scaled_size) /
8000cae4:	6c 20       	ld.w	r0,r6[0x8]
8000cae6:	6c 9b       	ld.w	r11,r6[0x24]
8000cae8:	ee fa 01 3c 	ld.w	r10,r7[316]
		 cinfo->min_DCT_scaled_size;
    v_in_group = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
8000caec:	6c 39       	ld.w	r9,r6[0xc]
8000caee:	f6 09 02 49 	mul	r9,r11,r9
8000caf2:	f2 0a 0c 08 	divs	r8,r9,r10
8000caf6:	10 91       	mov	r1,r8
		 cinfo->min_DCT_scaled_size;
    h_out_group = cinfo->max_h_samp_factor;
8000caf8:	ee fc 01 34 	ld.w	r12,r7[308]
    v_out_group = cinfo->max_v_samp_factor;
8000cafc:	ee fe 01 38 	ld.w	lr,r7[312]
    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
8000cb00:	8b d8       	st.w	r5[0x34],r8
    need_buffer = TRUE;
    if (! compptr->component_needed) {
8000cb02:	6c c8       	ld.w	r8,r6[0x30]
8000cb04:	58 08       	cp.w	r8,0
8000cb06:	c0 41       	brne	8000cb0e <jinit_upsampler+0x92>
      /* Don't bother to upsample an uninteresting component. */
      upsample->methods[ci] = noop_upsample;
8000cb08:	4b e8       	lddpc	r8,8000cc00 <jinit_upsampler+0x184>
8000cb0a:	87 08       	st.w	r3[0x0],r8
8000cb0c:	c5 98       	rjmp	8000cbbe <jinit_upsampler+0x142>
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Compute size of an "input group" after IDCT scaling.  This many samples
     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.
     */
    h_in_group = (compptr->h_samp_factor * compptr->DCT_scaled_size) /
8000cb0e:	a1 3b       	mul	r11,r0
8000cb10:	f6 0a 0c 0a 	divs	r10,r11,r10
8000cb14:	14 98       	mov	r8,r10
    need_buffer = TRUE;
    if (! compptr->component_needed) {
      /* Don't bother to upsample an uninteresting component. */
      upsample->methods[ci] = noop_upsample;
      need_buffer = FALSE;
    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {
8000cb16:	1c 31       	cp.w	r1,lr
8000cb18:	5f 09       	sreq	r9
8000cb1a:	18 3a       	cp.w	r10,r12
8000cb1c:	5f 0a       	sreq	r10
8000cb1e:	f3 ea 00 0a 	and	r10,r9,r10
8000cb22:	30 0b       	mov	r11,0
8000cb24:	f6 0a 18 00 	cp.b	r10,r11
8000cb28:	c0 40       	breq	8000cb30 <jinit_upsampler+0xb4>
      /* Fullsize components can be processed without any work. */
      upsample->methods[ci] = fullsize_upsample;
8000cb2a:	4b 79       	lddpc	r9,8000cc04 <jinit_upsampler+0x188>
8000cb2c:	87 09       	st.w	r3[0x0],r9
8000cb2e:	c4 88       	rjmp	8000cbbe <jinit_upsampler+0x142>
      need_buffer = FALSE;
    } else if (h_in_group * 2 == h_out_group &&
8000cb30:	f0 0a 15 01 	lsl	r10,r8,0x1
8000cb34:	18 3a       	cp.w	r10,r12
8000cb36:	5f 0a       	sreq	r10
8000cb38:	14 69       	and	r9,r10
8000cb3a:	30 0b       	mov	r11,0
8000cb3c:	f6 09 18 00 	cp.b	r9,r11
8000cb40:	c0 e0       	breq	8000cb5c <jinit_upsampler+0xe0>
	       v_in_group == v_out_group) {
      /* Special cases for 2h1v upsampling */
      if (do_fancy && compptr->downsampled_width > 2)
8000cb42:	40 29       	lddsp	r9,sp[0x8]
8000cb44:	58 09       	cp.w	r9,0
8000cb46:	c0 80       	breq	8000cb56 <jinit_upsampler+0xda>
8000cb48:	6c a8       	ld.w	r8,r6[0x28]
8000cb4a:	58 28       	cp.w	r8,2
8000cb4c:	e0 88 00 05 	brls	8000cb56 <jinit_upsampler+0xda>
	upsample->methods[ci] = h2v1_fancy_upsample;
8000cb50:	4a e8       	lddpc	r8,8000cc08 <jinit_upsampler+0x18c>
8000cb52:	87 08       	st.w	r3[0x0],r8
      upsample->methods[ci] = fullsize_upsample;
      need_buffer = FALSE;
    } else if (h_in_group * 2 == h_out_group &&
	       v_in_group == v_out_group) {
      /* Special cases for 2h1v upsampling */
      if (do_fancy && compptr->downsampled_width > 2)
8000cb54:	c3 f8       	rjmp	8000cbd2 <jinit_upsampler+0x156>
	upsample->methods[ci] = h2v1_fancy_upsample;
      else
	upsample->methods[ci] = h2v1_upsample;
8000cb56:	4a eb       	lddpc	r11,8000cc0c <jinit_upsampler+0x190>
8000cb58:	87 0b       	st.w	r3[0x0],r11
8000cb5a:	c3 c8       	rjmp	8000cbd2 <jinit_upsampler+0x156>
    } else if (h_in_group * 2 == h_out_group &&
8000cb5c:	58 0a       	cp.w	r10,0
8000cb5e:	c1 50       	breq	8000cb88 <jinit_upsampler+0x10c>
8000cb60:	e2 09 15 01 	lsl	r9,r1,0x1
8000cb64:	1c 39       	cp.w	r9,lr
8000cb66:	c1 11       	brne	8000cb88 <jinit_upsampler+0x10c>
	       v_in_group * 2 == v_out_group) {
      /* Special cases for 2h2v upsampling */
      if (do_fancy && compptr->downsampled_width > 2) {
8000cb68:	40 29       	lddsp	r9,sp[0x8]
8000cb6a:	58 09       	cp.w	r9,0
8000cb6c:	c0 b0       	breq	8000cb82 <jinit_upsampler+0x106>
8000cb6e:	6c a8       	ld.w	r8,r6[0x28]
8000cb70:	58 28       	cp.w	r8,2
8000cb72:	e0 88 00 08 	brls	8000cb82 <jinit_upsampler+0x106>
	upsample->methods[ci] = h2v2_fancy_upsample;
8000cb76:	4a 78       	lddpc	r8,8000cc10 <jinit_upsampler+0x194>
8000cb78:	87 08       	st.w	r3[0x0],r8
	upsample->pub.need_context_rows = TRUE;
8000cb7a:	30 19       	mov	r9,1
8000cb7c:	40 0b       	lddsp	r11,sp[0x0]
8000cb7e:	97 29       	st.w	r11[0x8],r9
      else
	upsample->methods[ci] = h2v1_upsample;
    } else if (h_in_group * 2 == h_out_group &&
	       v_in_group * 2 == v_out_group) {
      /* Special cases for 2h2v upsampling */
      if (do_fancy && compptr->downsampled_width > 2) {
8000cb80:	c2 98       	rjmp	8000cbd2 <jinit_upsampler+0x156>
	upsample->methods[ci] = h2v2_fancy_upsample;
	upsample->pub.need_context_rows = TRUE;
      } else
	upsample->methods[ci] = h2v2_upsample;
8000cb82:	4a 58       	lddpc	r8,8000cc14 <jinit_upsampler+0x198>
8000cb84:	87 08       	st.w	r3[0x0],r8
8000cb86:	c2 68       	rjmp	8000cbd2 <jinit_upsampler+0x156>
    } else if ((h_out_group % h_in_group) == 0 &&
8000cb88:	f8 08 0c 0a 	divs	r10,r12,r8
8000cb8c:	58 0b       	cp.w	r11,0
8000cb8e:	c1 01       	brne	8000cbae <jinit_upsampler+0x132>
8000cb90:	fc 01 0c 0a 	divs	r10,lr,r1
8000cb94:	58 0b       	cp.w	r11,0
8000cb96:	c0 c1       	brne	8000cbae <jinit_upsampler+0x132>
	       (v_out_group % v_in_group) == 0) {
      /* Generic integral-factors upsampling method */
      upsample->methods[ci] = int_upsample;
8000cb98:	4a 0b       	lddpc	r11,8000cc18 <jinit_upsampler+0x19c>
8000cb9a:	87 0b       	st.w	r3[0x0],r11
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
8000cb9c:	f8 08 0c 08 	divs	r8,r12,r8
8000cba0:	e5 68 00 44 	st.b	r2[68],r8
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
8000cba4:	fc 01 0c 00 	divs	r0,lr,r1
8000cba8:	e5 60 00 48 	st.b	r2[72],r0
      if (do_fancy && compptr->downsampled_width > 2) {
	upsample->methods[ci] = h2v2_fancy_upsample;
	upsample->pub.need_context_rows = TRUE;
      } else
	upsample->methods[ci] = h2v2_upsample;
    } else if ((h_out_group % h_in_group) == 0 &&
8000cbac:	c1 38       	rjmp	8000cbd2 <jinit_upsampler+0x156>
      /* Generic integral-factors upsampling method */
      upsample->methods[ci] = int_upsample;
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
8000cbae:	6e 08       	ld.w	r8,r7[0x0]
8000cbb0:	32 69       	mov	r9,38
8000cbb2:	91 59       	st.w	r8[0x14],r9
8000cbb4:	6e 08       	ld.w	r8,r7[0x0]
8000cbb6:	70 08       	ld.w	r8,r8[0x0]
8000cbb8:	40 1c       	lddsp	r12,sp[0x4]
8000cbba:	5d 18       	icall	r8
8000cbbc:	c0 b8       	rjmp	8000cbd2 <jinit_upsampler+0x156>

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
8000cbbe:	2f f4       	sub	r4,-1
8000cbc0:	2f c5       	sub	r5,-4
8000cbc2:	2f c3       	sub	r3,-4
8000cbc4:	2f f2       	sub	r2,-1
  do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;

  /* Verify we can handle the sampling factors, select per-component methods,
   * and create storage as needed.
   */
  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
8000cbc6:	6e 98       	ld.w	r8,r7[0x24]
8000cbc8:	08 38       	cp.w	r8,r4
8000cbca:	e0 8a 00 14 	brle	8000cbf2 <jinit_upsampler+0x176>
       ci++, compptr++) {
8000cbce:	2a c6       	sub	r6,-84
8000cbd0:	c8 ab       	rjmp	8000cae4 <jinit_upsampler+0x68>
      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
    } else
      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
    if (need_buffer) {
      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
8000cbd2:	6e 18       	ld.w	r8,r7[0x4]
8000cbd4:	70 20       	ld.w	r0,r8[0x8]
8000cbd6:	ee f1 01 38 	ld.w	r1,r7[312]
8000cbda:	ee fb 01 34 	ld.w	r11,r7[308]
8000cbde:	6f cc       	ld.w	r12,r7[0x70]
8000cbe0:	f0 1f 00 0f 	mcall	8000cc1c <jinit_upsampler+0x1a0>
8000cbe4:	02 99       	mov	r9,r1
8000cbe6:	18 9a       	mov	r10,r12
8000cbe8:	30 1b       	mov	r11,1
8000cbea:	40 1c       	lddsp	r12,sp[0x4]
8000cbec:	5d 10       	icall	r0
8000cbee:	8b 3c       	st.w	r5[0xc],r12
8000cbf0:	ce 7b       	rjmp	8000cbbe <jinit_upsampler+0x142>
	 (JDIMENSION) jround_up((long) cinfo->output_width,
				(long) cinfo->max_h_samp_factor),
	 (JDIMENSION) cinfo->max_v_samp_factor);
    }
  }
}
8000cbf2:	2f dd       	sub	sp,-12
8000cbf4:	d8 32       	popm	r0-r7,pc
8000cbf6:	00 00       	add	r0,r0
8000cbf8:	80 00       	ld.sh	r0,r0[0x0]
8000cbfa:	c7 f8       	rjmp	8000ccf8 <h2v2_upsample+0x38>
8000cbfc:	80 00       	ld.sh	r0,r0[0x0]
8000cbfe:	c8 08       	rjmp	8000ccfe <h2v2_upsample+0x3e>
8000cc00:	80 00       	ld.sh	r0,r0[0x0]
8000cc02:	c8 ca       	rjmp	8000c91a <h2v1_fancy_upsample+0xa>
8000cc04:	80 00       	ld.sh	r0,r0[0x0]
8000cc06:	c8 c6       	brmi	8000cb1e <jinit_upsampler+0xa2>
8000cc08:	80 00       	ld.sh	r0,r0[0x0]
8000cc0a:	c9 10       	breq	8000cb2c <jinit_upsampler+0xb0>
8000cc0c:	80 00       	ld.sh	r0,r0[0x0]
8000cc0e:	c8 d0       	breq	8000cb28 <jinit_upsampler+0xac>
8000cc10:	80 00       	ld.sh	r0,r0[0x0]
8000cc12:	c9 9a       	rjmp	8000c944 <h2v1_fancy_upsample+0x34>
8000cc14:	80 00       	ld.sh	r0,r0[0x0]
8000cc16:	cc c0       	breq	8000cbae <jinit_upsampler+0x132>
8000cc18:	80 00       	ld.sh	r0,r0[0x0]
8000cc1a:	cc 20       	breq	8000cb9e <jinit_upsampler+0x122>
8000cc1c:	80 00       	ld.sh	r0,r0[0x0]
8000cc1e:	fd 0e d4 31 	ld.sh	lr,lr[-11215]

8000cc20 <int_upsample>:
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
8000cc20:	d4 31       	pushm	r0-r7,lr
8000cc22:	20 4d       	sub	sp,16
8000cc24:	18 96       	mov	r6,r12
  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
8000cc26:	f8 f8 01 c4 	ld.w	r8,r12[452]
  JSAMPARRAY output_data = *output_data_ptr;
8000cc2a:	72 09       	ld.w	r9,r9[0x0]
8000cc2c:	50 09       	stdsp	sp[0x0],r9
  register int h;
  JSAMPROW outend;
  int h_expand, v_expand;
  int inrow, outrow;

  h_expand = upsample->h_expand[compptr->component_index];
8000cc2e:	76 19       	ld.w	r9,r11[0x4]
8000cc30:	12 08       	add	r8,r9
8000cc32:	f1 32 00 44 	ld.ub	r2,r8[68]
8000cc36:	04 97       	mov	r7,r2
  v_expand = upsample->v_expand[compptr->component_index];
8000cc38:	f1 30 00 48 	ld.ub	r0,r8[72]

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
8000cc3c:	f8 f8 01 38 	ld.w	r8,r12[312]
8000cc40:	58 08       	cp.w	r8,0
8000cc42:	e0 8a 00 3a 	brle	8000ccb6 <int_upsample+0x96>
8000cc46:	14 94       	mov	r4,r10
 * so if you are actually going to use 3:1 or 4:1 sampling ratios
 * you would be well advised to improve this code.
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000cc48:	50 10       	stdsp	sp[0x4],r0
8000cc4a:	e0 08 15 02 	lsl	r8,r0,0x2
8000cc4e:	50 28       	stdsp	sp[0x8],r8
8000cc50:	40 03       	lddsp	r3,sp[0x0]
8000cc52:	30 05       	mov	r5,0
8000cc54:	04 91       	mov	r1,r2
	*outptr++ = invalue;
      }
    }
    /* Generate any additional output rows by duplicating the first one */
    if (v_expand > 1) {
      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
8000cc56:	e0 c8 00 01 	sub	r8,r0,1
8000cc5a:	50 38       	stdsp	sp[0xc],r8
  v_expand = upsample->v_expand[compptr->component_index];

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    /* Generate one output row with proper horizontal expansion */
    inptr = input_data[inrow];
8000cc5c:	68 08       	ld.w	r8,r4[0x0]
    outptr = output_data[outrow];
8000cc5e:	66 09       	ld.w	r9,r3[0x0]
    outend = outptr + cinfo->output_width;
8000cc60:	6d ca       	ld.w	r10,r6[0x70]
8000cc62:	f2 0a 00 0a 	add	r10,r9,r10
    while (outptr < outend) {
8000cc66:	14 39       	cp.w	r9,r10
8000cc68:	c0 f2       	brcc	8000cc86 <int_upsample+0x66>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
8000cc6a:	11 3b       	ld.ub	r11,r8++
      for (h = h_expand; h > 0; h--) {
8000cc6c:	58 07       	cp.w	r7,0
8000cc6e:	e0 8a 00 09 	brle	8000cc80 <int_upsample+0x60>
 * so if you are actually going to use 3:1 or 4:1 sampling ratios
 * you would be well advised to improve this code.
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000cc72:	f2 02 00 0e 	add	lr,r9,r2
8000cc76:	12 9c       	mov	r12,r9
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      for (h = h_expand; h > 0; h--) {
	*outptr++ = invalue;
8000cc78:	18 cb       	st.b	r12++,r11
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      for (h = h_expand; h > 0; h--) {
8000cc7a:	1c 3c       	cp.w	r12,lr
8000cc7c:	cf e1       	brne	8000cc78 <int_upsample+0x58>
8000cc7e:	02 09       	add	r9,r1
  while (outrow < cinfo->max_v_samp_factor) {
    /* Generate one output row with proper horizontal expansion */
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
8000cc80:	12 3a       	cp.w	r10,r9
8000cc82:	fe 9b ff f4 	brhi	8000cc6a <int_upsample+0x4a>
      for (h = h_expand; h > 0; h--) {
	*outptr++ = invalue;
      }
    }
    /* Generate any additional output rows by duplicating the first one */
    if (v_expand > 1) {
8000cc86:	58 10       	cp.w	r0,1
8000cc88:	e0 8a 00 0d 	brle	8000cca2 <int_upsample+0x82>
      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
8000cc8c:	6d c8       	ld.w	r8,r6[0x70]
8000cc8e:	1a d8       	st.w	--sp,r8
8000cc90:	40 48       	lddsp	r8,sp[0x10]
8000cc92:	ea c9 ff ff 	sub	r9,r5,-1
8000cc96:	40 1a       	lddsp	r10,sp[0x4]
8000cc98:	0a 9b       	mov	r11,r5
8000cc9a:	14 9c       	mov	r12,r10
8000cc9c:	f0 1f 00 08 	mcall	8000ccbc <int_upsample+0x9c>
8000cca0:	2f fd       	sub	sp,-4
 * so if you are actually going to use 3:1 or 4:1 sampling ratios
 * you would be well advised to improve this code.
 */

METHODDEF(void)
int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000cca2:	40 18       	lddsp	r8,sp[0x4]
8000cca4:	10 05       	add	r5,r8
8000cca6:	2f c4       	sub	r4,-4
8000cca8:	40 28       	lddsp	r8,sp[0x8]
8000ccaa:	10 03       	add	r3,r8

  h_expand = upsample->h_expand[compptr->component_index];
  v_expand = upsample->v_expand[compptr->component_index];

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
8000ccac:	ec f8 01 38 	ld.w	r8,r6[312]
8000ccb0:	0a 38       	cp.w	r8,r5
8000ccb2:	fe 99 ff d5 	brgt	8000cc5c <int_upsample+0x3c>
			v_expand-1, cinfo->output_width);
    }
    inrow++;
    outrow += v_expand;
  }
}
8000ccb6:	2f cd       	sub	sp,-16
8000ccb8:	d8 32       	popm	r0-r7,pc
8000ccba:	00 00       	add	r0,r0
8000ccbc:	80 00       	ld.sh	r0,r0[0x0]
8000ccbe:	fd 44 eb cd 	st.w	lr[-5171],r4

8000ccc0 <h2v2_upsample>:
 */

METHODDEF(void)
h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
{
8000ccc0:	eb cd 40 fc 	pushm	r2-r7,lr
8000ccc4:	18 96       	mov	r6,r12
  JSAMPARRAY output_data = *output_data_ptr;
8000ccc6:	72 03       	ld.w	r3,r9[0x0]
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
8000ccc8:	f8 f8 01 38 	ld.w	r8,r12[312]
8000cccc:	58 08       	cp.w	r8,0
8000ccce:	e0 8a 00 27 	brle	8000cd1c <h2v2_upsample+0x5c>
8000ccd2:	14 95       	mov	r5,r10
8000ccd4:	06 94       	mov	r4,r3
8000ccd6:	30 07       	mov	r7,0
    while (outptr < outend) {
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      *outptr++ = invalue;
      *outptr++ = invalue;
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
8000ccd8:	30 12       	mov	r2,1
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    inptr = input_data[inrow];
8000ccda:	6a 0a       	ld.w	r10,r5[0x0]
    outptr = output_data[outrow];
8000ccdc:	68 08       	ld.w	r8,r4[0x0]
    outend = outptr + cinfo->output_width;
8000ccde:	6d cb       	ld.w	r11,r6[0x70]
8000cce0:	f0 0b 00 0b 	add	r11,r8,r11
    while (outptr < outend) {
8000cce4:	16 38       	cp.w	r8,r11
8000cce6:	c0 82       	brcc	8000ccf6 <h2v2_upsample+0x36>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
8000cce8:	15 39       	ld.ub	r9,r10++
      *outptr++ = invalue;
8000ccea:	b0 89       	st.b	r8[0x0],r9
      *outptr++ = invalue;
8000ccec:	b0 99       	st.b	r8[0x1],r9
 * Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
 * It's still a box filter.
 */

METHODDEF(void)
h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000ccee:	2f e8       	sub	r8,-2
  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while (outptr < outend) {
8000ccf0:	10 3b       	cp.w	r11,r8
8000ccf2:	fe 9b ff fb 	brhi	8000cce8 <h2v2_upsample+0x28>
      invalue = *inptr++;	/* don't need GETJSAMPLE() here */
      *outptr++ = invalue;
      *outptr++ = invalue;
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
8000ccf6:	6d c8       	ld.w	r8,r6[0x70]
8000ccf8:	1a d8       	st.w	--sp,r8
8000ccfa:	04 98       	mov	r8,r2
8000ccfc:	ee c9 ff ff 	sub	r9,r7,-1
8000cd00:	06 9a       	mov	r10,r3
8000cd02:	0e 9b       	mov	r11,r7
8000cd04:	06 9c       	mov	r12,r3
8000cd06:	f0 1f 00 07 	mcall	8000cd20 <h2v2_upsample+0x60>
		      1, cinfo->output_width);
    inrow++;
    outrow += 2;
8000cd0a:	2f e7       	sub	r7,-2
8000cd0c:	2f c5       	sub	r5,-4
8000cd0e:	2f 84       	sub	r4,-8
  register JSAMPLE invalue;
  JSAMPROW outend;
  int inrow, outrow;

  inrow = outrow = 0;
  while (outrow < cinfo->max_v_samp_factor) {
8000cd10:	2f fd       	sub	sp,-4
8000cd12:	ec f8 01 38 	ld.w	r8,r6[312]
8000cd16:	0e 38       	cp.w	r8,r7
8000cd18:	fe 99 ff e1 	brgt	8000ccda <h2v2_upsample+0x1a>
8000cd1c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000cd20:	80 00       	ld.sh	r0,r0[0x0]
8000cd22:	fd 44 d4 01 	st.w	lr[-11263],r4

8000cd24 <output_message>:
 * not just not use this routine.
 */

METHODDEF(void)
output_message (j_common_ptr cinfo)
{
8000cd24:	d4 01       	pushm	lr
8000cd26:	fa cd 00 c8 	sub	sp,sp,200
  char buffer[JMSG_LENGTH_MAX];

  /* Create the message */
  (*cinfo->err->format_message) (cinfo, buffer);
8000cd2a:	78 08       	ld.w	r8,r12[0x0]
8000cd2c:	70 38       	ld.w	r8,r8[0xc]
8000cd2e:	1a 9b       	mov	r11,sp
8000cd30:	5d 18       	icall	r8
	     MB_OK | MB_ICONERROR);
#else
  /* Send it to stderr, adding a newline */
  //fprintf(stderr, "%s\n", buffer);
#endif
}
8000cd32:	2c ed       	sub	sp,-200
8000cd34:	d8 02       	popm	pc

8000cd36 <emit_message>:
 * or change the policy about which messages to display.
 */

METHODDEF(void)
emit_message (j_common_ptr cinfo, int msg_level)
{
8000cd36:	eb cd 40 80 	pushm	r7,lr
  struct jpeg_error_mgr * err = cinfo->err;
8000cd3a:	78 07       	ld.w	r7,r12[0x0]

  if (msg_level < 0) {
8000cd3c:	58 0b       	cp.w	r11,0
8000cd3e:	c1 04       	brge	8000cd5e <emit_message+0x28>
    /* It's a warning message.  Since corrupt files may generate many warnings,
     * the policy implemented here is to show only the first warning,
     * unless trace_level >= 3.
     */
    if (err->num_warnings == 0 || err->trace_level >= 3)
8000cd40:	6f b8       	ld.w	r8,r7[0x6c]
8000cd42:	58 08       	cp.w	r8,0
8000cd44:	c0 50       	breq	8000cd4e <emit_message+0x18>
8000cd46:	6f a8       	ld.w	r8,r7[0x68]
8000cd48:	58 28       	cp.w	r8,2
8000cd4a:	e0 8a 00 04 	brle	8000cd52 <emit_message+0x1c>
      (*err->output_message) (cinfo);
8000cd4e:	6e 28       	ld.w	r8,r7[0x8]
8000cd50:	5d 18       	icall	r8
    /* Always count warnings in num_warnings. */
    err->num_warnings++;
8000cd52:	6f b8       	ld.w	r8,r7[0x6c]
8000cd54:	2f f8       	sub	r8,-1
8000cd56:	ef 48 00 6c 	st.w	r7[108],r8
8000cd5a:	e3 cd 80 80 	ldm	sp++,r7,pc
  } else {
    /* It's a trace message.  Show it if trace_level >= msg_level. */
    if (err->trace_level >= msg_level)
8000cd5e:	6f a8       	ld.w	r8,r7[0x68]
8000cd60:	10 3b       	cp.w	r11,r8
8000cd62:	e0 89 00 04 	brgt	8000cd6a <emit_message+0x34>
      (*err->output_message) (cinfo);
8000cd66:	6e 28       	ld.w	r8,r7[0x8]
8000cd68:	5d 18       	icall	r8
8000cd6a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000cd6e <reset_error_mgr>:
 */

METHODDEF(void)
reset_error_mgr (j_common_ptr cinfo)
{
  cinfo->err->num_warnings = 0;
8000cd6e:	78 09       	ld.w	r9,r12[0x0]
8000cd70:	30 08       	mov	r8,0
8000cd72:	f3 48 00 6c 	st.w	r9[108],r8
  /* trace_level is not reset since it is an application-supplied parameter */
  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
8000cd76:	78 09       	ld.w	r9,r12[0x0]
8000cd78:	93 58       	st.w	r9[0x14],r8
}
8000cd7a:	5e fc       	retal	r12

8000cd7c <jpeg_std_error>:
 */

GLOBAL(struct jpeg_error_mgr *)
jpeg_std_error (struct jpeg_error_mgr * err)
{
  err->error_exit = error_exit;
8000cd7c:	48 f9       	lddpc	r9,8000cdb8 <jpeg_std_error+0x3c>
8000cd7e:	99 09       	st.w	r12[0x0],r9
  err->emit_message = emit_message;
8000cd80:	48 f9       	lddpc	r9,8000cdbc <jpeg_std_error+0x40>
8000cd82:	99 19       	st.w	r12[0x4],r9
  err->output_message = output_message;
8000cd84:	48 f9       	lddpc	r9,8000cdc0 <jpeg_std_error+0x44>
8000cd86:	99 29       	st.w	r12[0x8],r9
  err->format_message = format_message;
8000cd88:	48 f9       	lddpc	r9,8000cdc4 <jpeg_std_error+0x48>
8000cd8a:	99 39       	st.w	r12[0xc],r9
  err->reset_error_mgr = reset_error_mgr;
8000cd8c:	48 f9       	lddpc	r9,8000cdc8 <jpeg_std_error+0x4c>
8000cd8e:	99 49       	st.w	r12[0x10],r9

  err->trace_level = 0;		/* default = no tracing */
8000cd90:	30 09       	mov	r9,0
8000cd92:	f9 49 00 68 	st.w	r12[104],r9
  err->num_warnings = 0;	/* no warnings emitted yet */
8000cd96:	f9 49 00 6c 	st.w	r12[108],r9
  err->msg_code = 0;		/* may be useful as a flag for "no error" */
8000cd9a:	99 59       	st.w	r12[0x14],r9

  /* Initialize message table pointers */
  err->jpeg_message_table = jpeg_std_message_table;
8000cd9c:	48 ca       	lddpc	r10,8000cdcc <jpeg_std_error+0x50>
8000cd9e:	f9 4a 00 70 	st.w	r12[112],r10
  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;
8000cda2:	37 ba       	mov	r10,123
8000cda4:	f9 4a 00 74 	st.w	r12[116],r10

  err->addon_message_table = NULL;
8000cda8:	f9 49 00 78 	st.w	r12[120],r9
  err->first_addon_message = 0;	/* for safety */
8000cdac:	f9 49 00 7c 	st.w	r12[124],r9
  err->last_addon_message = 0;
8000cdb0:	f9 49 00 80 	st.w	r12[128],r9

  return err;
}
8000cdb4:	5e fc       	retal	r12
8000cdb6:	00 00       	add	r0,r0
8000cdb8:	80 00       	ld.sh	r0,r0[0x0]
8000cdba:	ce 74       	brge	8000cd88 <jpeg_std_error+0xc>
8000cdbc:	80 00       	ld.sh	r0,r0[0x0]
8000cdbe:	cd 36       	brmi	8000cd64 <emit_message+0x2e>
8000cdc0:	80 00       	ld.sh	r0,r0[0x0]
8000cdc2:	cd 24       	brge	8000cd66 <emit_message+0x30>
8000cdc4:	80 00       	ld.sh	r0,r0[0x0]
8000cdc6:	cd d0       	breq	8000cd80 <jpeg_std_error+0x4>
8000cdc8:	80 00       	ld.sh	r0,r0[0x0]
8000cdca:	cd 6e       	rcall	8000cb76 <jinit_upsampler+0xfa>
8000cdcc:	80 01       	ld.sh	r1,r0[0x0]
8000cdce:	e6 a8       	*unknown*

8000cdd0 <format_message>:
 * Few applications should need to override this method.
 */

METHODDEF(void)
format_message (j_common_ptr cinfo, char * buffer)
{
8000cdd0:	d4 01       	pushm	lr
8000cdd2:	16 98       	mov	r8,r11
  struct jpeg_error_mgr * err = cinfo->err;
8000cdd4:	78 0c       	ld.w	r12,r12[0x0]
  int msg_code = err->msg_code;
8000cdd6:	78 59       	ld.w	r9,r12[0x14]
  const char * msgptr;
  char ch;
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
8000cdd8:	58 09       	cp.w	r9,0
8000cdda:	e0 8a 00 0a 	brle	8000cdee <format_message+0x1e>
8000cdde:	79 da       	ld.w	r10,r12[0x74]
8000cde0:	14 39       	cp.w	r9,r10
8000cde2:	e0 89 00 06 	brgt	8000cdee <format_message+0x1e>
    msgtext = err->jpeg_message_table[msg_code];
8000cde6:	79 ca       	ld.w	r10,r12[0x70]
8000cde8:	f4 09 03 2b 	ld.w	r11,r10[r9<<0x2]
  const char * msgptr;
  char ch;
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
8000cdec:	c1 08       	rjmp	8000ce0c <format_message+0x3c>
    msgtext = err->jpeg_message_table[msg_code];
  } else if (err->addon_message_table != NULL &&
8000cdee:	79 ea       	ld.w	r10,r12[0x78]
8000cdf0:	58 0a       	cp.w	r10,0
8000cdf2:	c0 f0       	breq	8000ce10 <format_message+0x40>
	     msg_code >= err->first_addon_message &&
8000cdf4:	79 fb       	ld.w	r11,r12[0x7c]
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
    msgtext = err->jpeg_message_table[msg_code];
  } else if (err->addon_message_table != NULL &&
8000cdf6:	16 39       	cp.w	r9,r11
8000cdf8:	c0 c5       	brlt	8000ce10 <format_message+0x40>
	     msg_code >= err->first_addon_message &&
	     msg_code <= err->last_addon_message) {
8000cdfa:	f8 fe 00 80 	ld.w	lr,r12[128]
8000cdfe:	1c 39       	cp.w	r9,lr
8000ce00:	e0 89 00 08 	brgt	8000ce10 <format_message+0x40>
    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
8000ce04:	f2 0b 01 0b 	sub	r11,r9,r11
8000ce08:	f4 0b 03 2b 	ld.w	r11,r10[r11<<0x2]
  }

  /* Defend against bogus message number */
  if (msgtext == NULL) {
8000ce0c:	58 0b       	cp.w	r11,0
8000ce0e:	c0 41       	brne	8000ce16 <format_message+0x46>
    err->msg_parm.i[0] = msg_code;
8000ce10:	99 69       	st.w	r12[0x18],r9
    msgtext = err->jpeg_message_table[0];
8000ce12:	79 c9       	ld.w	r9,r12[0x70]
8000ce14:	72 0b       	ld.w	r11,r9[0x0]
8000ce16:	16 99       	mov	r9,r11

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
  msgptr = msgtext;
  while ((ch = *msgptr++) != '\0') {
    if (ch == '%') {
8000ce18:	32 5e       	mov	lr,37
  }

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
  msgptr = msgtext;
  while ((ch = *msgptr++) != '\0') {
8000ce1a:	c0 b8       	rjmp	8000ce30 <format_message+0x60>
8000ce1c:	2f f9       	sub	r9,-1
    if (ch == '%') {
8000ce1e:	fc 0a 18 00 	cp.b	r10,lr
8000ce22:	c0 71       	brne	8000ce30 <format_message+0x60>
      if (*msgptr == 's') isstring = TRUE;
8000ce24:	13 8a       	ld.ub	r10,r9[0x0]
8000ce26:	37 39       	mov	r9,115
8000ce28:	f2 0a 18 00 	cp.b	r10,r9
8000ce2c:	c0 60       	breq	8000ce38 <format_message+0x68>
8000ce2e:	c0 c8       	rjmp	8000ce46 <format_message+0x76>
  }

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
  msgptr = msgtext;
  while ((ch = *msgptr++) != '\0') {
8000ce30:	13 8a       	ld.ub	r10,r9[0x0]
8000ce32:	58 0a       	cp.w	r10,0
8000ce34:	cf 41       	brne	8000ce1c <format_message+0x4c>
8000ce36:	c0 88       	rjmp	8000ce46 <format_message+0x76>
    }
  }

  /* Format the message into the passed buffer */
  if (isstring)
    sprintf(buffer, msgtext, err->msg_parm.s);
8000ce38:	2e 8c       	sub	r12,-24
8000ce3a:	1a dc       	st.w	--sp,r12
8000ce3c:	10 9c       	mov	r12,r8
8000ce3e:	f0 1f 00 0d 	mcall	8000ce70 <format_message+0xa0>
8000ce42:	2f fd       	sub	sp,-4
8000ce44:	d8 02       	popm	pc
  else
    sprintf(buffer, msgtext,
8000ce46:	78 d9       	ld.w	r9,r12[0x34]
8000ce48:	1a d9       	st.w	--sp,r9
8000ce4a:	78 c9       	ld.w	r9,r12[0x30]
8000ce4c:	1a d9       	st.w	--sp,r9
8000ce4e:	78 b9       	ld.w	r9,r12[0x2c]
8000ce50:	1a d9       	st.w	--sp,r9
8000ce52:	78 a9       	ld.w	r9,r12[0x28]
8000ce54:	1a d9       	st.w	--sp,r9
8000ce56:	78 99       	ld.w	r9,r12[0x24]
8000ce58:	1a d9       	st.w	--sp,r9
8000ce5a:	78 89       	ld.w	r9,r12[0x20]
8000ce5c:	1a d9       	st.w	--sp,r9
8000ce5e:	78 79       	ld.w	r9,r12[0x1c]
8000ce60:	1a d9       	st.w	--sp,r9
8000ce62:	78 69       	ld.w	r9,r12[0x18]
8000ce64:	1a d9       	st.w	--sp,r9
8000ce66:	10 9c       	mov	r12,r8
8000ce68:	f0 1f 00 02 	mcall	8000ce70 <format_message+0xa0>
8000ce6c:	2f 8d       	sub	sp,-32
8000ce6e:	d8 02       	popm	pc
8000ce70:	80 01       	ld.sh	r1,r0[0x0]
8000ce72:	56 44       	stdsp	sp[0x190],r4

8000ce74 <error_exit>:
 * or jpeg_destroy) at some point.
 */

METHODDEF(void)
error_exit (j_common_ptr cinfo)
{
8000ce74:	eb cd 40 80 	pushm	r7,lr
8000ce78:	18 97       	mov	r7,r12
  /* Always display the message */
  (*cinfo->err->output_message) (cinfo);
8000ce7a:	78 08       	ld.w	r8,r12[0x0]
8000ce7c:	70 28       	ld.w	r8,r8[0x8]
8000ce7e:	5d 18       	icall	r8

  /* Let the memory manager delete any temp files before we die */
  jpeg_destroy(cinfo);
8000ce80:	0e 9c       	mov	r12,r7
8000ce82:	f0 1f 00 03 	mcall	8000ce8c <error_exit+0x18>

  //exit(EXIT_FAILURE);
}
8000ce86:	e3 cd 80 80 	ldm	sp++,r7,pc
8000ce8a:	00 00       	add	r0,r0
8000ce8c:	80 00       	ld.sh	r0,r0[0x0]
8000ce8e:	74 7e       	ld.w	lr,r10[0x1c]

8000ce90 <jpeg_idct_ifast>:

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
8000ce90:	d4 31       	pushm	r0-r7,lr
8000ce92:	fa cd 01 2c 	sub	sp,sp,300
8000ce96:	50 89       	stdsp	sp[0x20],r9
8000ce98:	50 a8       	stdsp	sp[0x28],r8
  DCTELEM z5, z10, z11, z12, z13;
  JCOEFPTR inptr;
  IFAST_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
8000ce9a:	f8 f8 01 44 	ld.w	r8,r12[324]
8000ce9e:	28 08       	sub	r8,-128
8000cea0:	77 49       	ld.w	r9,r11[0x50]
8000cea2:	fa ce ff d4 	sub	lr,sp,-44
8000cea6:	50 7e       	stdsp	sp[0x1c],lr
8000cea8:	fa cc ff b4 	sub	r12,sp,-76
8000ceac:	50 6c       	stdsp	sp[0x18],r12
8000ceae:	fa c4 ff 94 	sub	r4,sp,-108
8000ceb2:	fa c5 ff 74 	sub	r5,sp,-140
8000ceb6:	fa c6 ff 54 	sub	r6,sp,-172
8000ceba:	18 97       	mov	r7,r12
8000cebc:	1c 9b       	mov	r11,lr
8000cebe:	30 83       	mov	r3,8
8000cec0:	50 23       	stdsp	sp[0x8],r3
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
8000cec2:	50 98       	stdsp	sp[0x24],r8
8000cec4:	f5 08 00 10 	ld.sh	r8,r10[16]
8000cec8:	58 08       	cp.w	r8,0
8000ceca:	c3 01       	brne	8000cf2a <jpeg_idct_ifast+0x9a>
8000cecc:	f5 0c 00 20 	ld.sh	r12,r10[32]
8000ced0:	30 02       	mov	r2,0
8000ced2:	e4 0c 19 00 	cp.h	r12,r2
8000ced6:	c2 a1       	brne	8000cf2a <jpeg_idct_ifast+0x9a>
8000ced8:	f5 0c 00 30 	ld.sh	r12,r10[48]
8000cedc:	e4 0c 19 00 	cp.h	r12,r2
8000cee0:	c2 51       	brne	8000cf2a <jpeg_idct_ifast+0x9a>
8000cee2:	f5 0c 00 40 	ld.sh	r12,r10[64]
8000cee6:	e4 0c 19 00 	cp.h	r12,r2
8000ceea:	c2 01       	brne	8000cf2a <jpeg_idct_ifast+0x9a>
8000ceec:	f5 0c 00 50 	ld.sh	r12,r10[80]
8000cef0:	e4 0c 19 00 	cp.h	r12,r2
8000cef4:	c1 b1       	brne	8000cf2a <jpeg_idct_ifast+0x9a>
8000cef6:	f5 0c 00 60 	ld.sh	r12,r10[96]
8000cefa:	e4 0c 19 00 	cp.h	r12,r2
8000cefe:	c1 61       	brne	8000cf2a <jpeg_idct_ifast+0x9a>
8000cf00:	f5 0c 00 70 	ld.sh	r12,r10[112]
8000cf04:	e4 0c 19 00 	cp.h	r12,r2
8000cf08:	c1 11       	brne	8000cf2a <jpeg_idct_ifast+0x9a>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
	inptr[DCTSIZE*7] == 0) {
      /* AC terms all zero */
      int dcval = (int) DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
8000cf0a:	94 0c       	ld.sh	r12,r10[0x0]
8000cf0c:	72 08       	ld.w	r8,r9[0x0]
8000cf0e:	f8 08 02 48 	mul	r8,r12,r8

      wsptr[DCTSIZE*0] = dcval;
8000cf12:	97 08       	st.w	r11[0x0],r8
      wsptr[DCTSIZE*1] = dcval;
8000cf14:	8f 08       	st.w	r7[0x0],r8
      wsptr[DCTSIZE*2] = dcval;
8000cf16:	89 08       	st.w	r4[0x0],r8
      wsptr[DCTSIZE*3] = dcval;
8000cf18:	8b 08       	st.w	r5[0x0],r8
      wsptr[DCTSIZE*4] = dcval;
8000cf1a:	8d 08       	st.w	r6[0x0],r8
      wsptr[DCTSIZE*5] = dcval;
8000cf1c:	f7 48 00 a0 	st.w	r11[160],r8
      wsptr[DCTSIZE*6] = dcval;
8000cf20:	f7 48 00 c0 	st.w	r11[192],r8
      wsptr[DCTSIZE*7] = dcval;
8000cf24:	f7 48 00 e0 	st.w	r11[224],r8

      inptr++;			/* advance pointers to next column */
      quantptr++;
      wsptr++;
      continue;
8000cf28:	c7 f8       	rjmp	8000d026 <jpeg_idct_ifast+0x196>
    }

    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
8000cf2a:	94 02       	ld.sh	r2,r10[0x0]
8000cf2c:	72 0c       	ld.w	r12,r9[0x0]
8000cf2e:	b9 32       	mul	r2,r12
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
8000cf30:	f5 0e 00 20 	ld.sh	lr,r10[32]
8000cf34:	73 0c       	ld.w	r12,r9[0x40]
8000cf36:	b9 3e       	mul	lr,r12
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
8000cf38:	f5 03 00 40 	ld.sh	r3,r10[64]
8000cf3c:	f2 fc 00 80 	ld.w	r12,r9[128]
8000cf40:	b9 33       	mul	r3,r12
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
8000cf42:	f5 01 00 60 	ld.sh	r1,r10[96]
8000cf46:	f2 fc 00 c0 	ld.w	r12,r9[192]
8000cf4a:	e2 0c 02 4c 	mul	r12,r1,r12

    tmp10 = tmp0 + tmp2;	/* phase 3 */
8000cf4e:	e6 02 00 01 	add	r1,r3,r2
    tmp11 = tmp0 - tmp2;
8000cf52:	e4 03 01 03 	sub	r3,r2,r3

    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
8000cf56:	f8 0e 00 02 	add	r2,r12,lr
    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
8000cf5a:	fc 0c 01 0c 	sub	r12,lr,r12
8000cf5e:	e0 60 01 6a 	mov	r0,362
8000cf62:	a1 3c       	mul	r12,r0
8000cf64:	a9 4c       	asr	r12,0x8
8000cf66:	04 1c       	sub	r12,r2

    tmp0 = tmp10 + tmp13;	/* phase 2 */
8000cf68:	e4 01 00 0e 	add	lr,r2,r1
8000cf6c:	50 0e       	stdsp	sp[0x0],lr
    tmp3 = tmp10 - tmp13;
8000cf6e:	04 11       	sub	r1,r2
8000cf70:	50 51       	stdsp	sp[0x14],r1
    tmp1 = tmp11 + tmp12;
8000cf72:	f8 03 00 02 	add	r2,r12,r3
8000cf76:	50 42       	stdsp	sp[0x10],r2
    tmp2 = tmp11 - tmp12;
8000cf78:	18 13       	sub	r3,r12
8000cf7a:	50 33       	stdsp	sp[0xc],r3

    /* Odd part */

    tmp4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
8000cf7c:	72 82       	ld.w	r2,r9[0x20]
8000cf7e:	f0 02 02 42 	mul	r2,r8,r2
    tmp5 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
8000cf82:	f5 03 00 30 	ld.sh	r3,r10[48]
8000cf86:	73 88       	ld.w	r8,r9[0x60]
8000cf88:	b1 33       	mul	r3,r8
    tmp6 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
8000cf8a:	f5 0c 00 50 	ld.sh	r12,r10[80]
8000cf8e:	f2 f8 00 a0 	ld.w	r8,r9[160]
8000cf92:	f8 08 02 48 	mul	r8,r12,r8
    tmp7 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
8000cf96:	f5 01 00 70 	ld.sh	r1,r10[112]
8000cf9a:	f2 fc 00 e0 	ld.w	r12,r9[224]
8000cf9e:	e2 0c 02 4c 	mul	r12,r1,r12

    z13 = tmp6 + tmp5;		/* phase 6 */
8000cfa2:	f0 03 00 01 	add	r1,r8,r3
    z10 = tmp6 - tmp5;
8000cfa6:	f0 03 01 03 	sub	r3,r8,r3
8000cfaa:	50 13       	stdsp	sp[0x4],r3
    z11 = tmp4 + tmp7;
8000cfac:	f8 02 00 00 	add	r0,r12,r2
    z12 = tmp4 - tmp7;
8000cfb0:	18 12       	sub	r2,r12

    tmp7 = z11 + z13;		/* phase 5 */
8000cfb2:	e0 01 00 0c 	add	r12,r0,r1
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
8000cfb6:	e4 03 00 08 	add	r8,r2,r3
8000cfba:	e0 6e 01 d9 	mov	lr,473
8000cfbe:	bd 38       	mul	r8,lr
8000cfc0:	f0 03 14 08 	asr	r3,r8,0x8
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;	/* phase 2 */
8000cfc4:	40 18       	lddsp	r8,sp[0x4]
8000cfc6:	fe 7e fd 63 	mov	lr,-669
8000cfca:	bd 38       	mul	r8,lr
8000cfcc:	50 18       	stdsp	sp[0x4],r8
8000cfce:	a9 48       	asr	r8,0x8
8000cfd0:	18 18       	sub	r8,r12
8000cfd2:	06 08       	add	r8,r3
    tmp5 = tmp11 - tmp6;
8000cfd4:	e0 01 01 01 	sub	r1,r0,r1
8000cfd8:	e0 60 01 6a 	mov	r0,362
8000cfdc:	a1 31       	mul	r1,r0
8000cfde:	a9 41       	asr	r1,0x8
8000cfe0:	10 11       	sub	r1,r8
    tmp4 = tmp10 + tmp5;
8000cfe2:	e0 6e 01 15 	mov	lr,277
8000cfe6:	bd 32       	mul	r2,lr
8000cfe8:	a9 42       	asr	r2,0x8
8000cfea:	e4 03 01 03 	sub	r3,r2,r3
8000cfee:	02 03       	add	r3,r1

    wsptr[DCTSIZE*0] = (int) (tmp0 + tmp7);
8000cff0:	40 00       	lddsp	r0,sp[0x0]
8000cff2:	f8 00 00 02 	add	r2,r12,r0
8000cff6:	97 02       	st.w	r11[0x0],r2
    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
8000cff8:	18 10       	sub	r0,r12
8000cffa:	f7 40 00 e0 	st.w	r11[224],r0
    wsptr[DCTSIZE*1] = (int) (tmp1 + tmp6);
8000cffe:	40 4c       	lddsp	r12,sp[0x10]
8000d000:	10 0c       	add	r12,r8
8000d002:	8f 0c       	st.w	r7[0x0],r12
    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
8000d004:	40 4e       	lddsp	lr,sp[0x10]
8000d006:	10 1e       	sub	lr,r8
8000d008:	f7 4e 00 c0 	st.w	r11[192],lr
    wsptr[DCTSIZE*2] = (int) (tmp2 + tmp5);
8000d00c:	40 3c       	lddsp	r12,sp[0xc]
8000d00e:	e2 0c 00 08 	add	r8,r1,r12
8000d012:	89 08       	st.w	r4[0x0],r8
    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
8000d014:	02 1c       	sub	r12,r1
8000d016:	f7 4c 00 a0 	st.w	r11[160],r12
    wsptr[DCTSIZE*4] = (int) (tmp3 + tmp4);
8000d01a:	40 52       	lddsp	r2,sp[0x14]
8000d01c:	e6 02 00 08 	add	r8,r3,r2
8000d020:	8d 08       	st.w	r6[0x0],r8
    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
8000d022:	06 12       	sub	r2,r3
8000d024:	8b 02       	st.w	r5[0x0],r2
  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
8000d026:	40 21       	lddsp	r1,sp[0x8]
8000d028:	20 11       	sub	r1,1
8000d02a:	50 21       	stdsp	sp[0x8],r1
8000d02c:	2f ea       	sub	r10,-2
8000d02e:	2f c9       	sub	r9,-4
8000d030:	2f cb       	sub	r11,-4
8000d032:	2f c7       	sub	r7,-4
8000d034:	2f c4       	sub	r4,-4
8000d036:	2f c5       	sub	r5,-4
8000d038:	2f c6       	sub	r6,-4
8000d03a:	58 01       	cp.w	r1,0
8000d03c:	fe 91 ff 44 	brne	8000cec4 <jpeg_idct_ifast+0x34>
8000d040:	40 98       	lddsp	r8,sp[0x24]
8000d042:	40 83       	lddsp	r3,sp[0x20]
8000d044:	fa c7 ff c4 	sub	r7,sp,-60
8000d048:	fa cc ff cc 	sub	r12,sp,-52
8000d04c:	fa c5 ff bc 	sub	r5,sp,-68
8000d050:	fa c6 ff c0 	sub	r6,sp,-64
8000d054:	fa ce ff c8 	sub	lr,sp,-56
8000d058:	fa c4 ff b8 	sub	r4,sp,-72
/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000d05c:	40 70       	lddsp	r0,sp[0x1c]
8000d05e:	e0 c0 fe e0 	sub	r0,r0,-288
8000d062:	50 90       	stdsp	sp[0x24],r0
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
    outptr = output_buf[ctr] + output_col;
8000d064:	66 09       	ld.w	r9,r3[0x0]
8000d066:	40 ab       	lddsp	r11,sp[0x28]
8000d068:	16 09       	add	r9,r11
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */

#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
8000d06a:	40 6a       	lddsp	r10,sp[0x18]
8000d06c:	f4 fb ff e4 	ld.w	r11,r10[-28]
8000d070:	58 0b       	cp.w	r11,0
8000d072:	c2 21       	brne	8000d0b6 <jpeg_idct_ifast+0x226>
8000d074:	78 0a       	ld.w	r10,r12[0x0]
8000d076:	58 0a       	cp.w	r10,0
8000d078:	c1 f1       	brne	8000d0b6 <jpeg_idct_ifast+0x226>
8000d07a:	7c 0a       	ld.w	r10,lr[0x0]
8000d07c:	58 0a       	cp.w	r10,0
8000d07e:	c1 c1       	brne	8000d0b6 <jpeg_idct_ifast+0x226>
8000d080:	6e 0a       	ld.w	r10,r7[0x0]
8000d082:	58 0a       	cp.w	r10,0
8000d084:	c1 91       	brne	8000d0b6 <jpeg_idct_ifast+0x226>
8000d086:	6c 0a       	ld.w	r10,r6[0x0]
8000d088:	58 0a       	cp.w	r10,0
8000d08a:	c1 61       	brne	8000d0b6 <jpeg_idct_ifast+0x226>
8000d08c:	6a 0a       	ld.w	r10,r5[0x0]
8000d08e:	58 0a       	cp.w	r10,0
8000d090:	c1 31       	brne	8000d0b6 <jpeg_idct_ifast+0x226>
8000d092:	68 0a       	ld.w	r10,r4[0x0]
8000d094:	58 0a       	cp.w	r10,0
8000d096:	c1 01       	brne	8000d0b6 <jpeg_idct_ifast+0x226>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
8000d098:	40 72       	lddsp	r2,sp[0x1c]
8000d09a:	64 0a       	ld.w	r10,r2[0x0]
8000d09c:	f5 da c0 aa 	bfextu	r10,r10,0x5,0xa
8000d0a0:	f0 0a 07 0a 	ld.ub	r10,r8[r10]

      outptr[0] = dcval;
8000d0a4:	b2 8a       	st.b	r9[0x0],r10
      outptr[1] = dcval;
8000d0a6:	b2 9a       	st.b	r9[0x1],r10
      outptr[2] = dcval;
8000d0a8:	b2 aa       	st.b	r9[0x2],r10
      outptr[3] = dcval;
8000d0aa:	b2 ba       	st.b	r9[0x3],r10
      outptr[4] = dcval;
8000d0ac:	b2 ca       	st.b	r9[0x4],r10
      outptr[5] = dcval;
8000d0ae:	b2 da       	st.b	r9[0x5],r10
      outptr[6] = dcval;
8000d0b0:	b2 ea       	st.b	r9[0x6],r10
      outptr[7] = dcval;
8000d0b2:	b2 fa       	st.b	r9[0x7],r10

      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
8000d0b4:	c8 98       	rjmp	8000d1c6 <jpeg_idct_ifast+0x336>
    }
#endif

    /* Even part */

    tmp10 = ((DCTELEM) wsptr[0] + (DCTELEM) wsptr[4]);
8000d0b6:	40 71       	lddsp	r1,sp[0x1c]
8000d0b8:	62 02       	ld.w	r2,r1[0x0]
8000d0ba:	6e 0a       	ld.w	r10,r7[0x0]
8000d0bc:	f4 02 00 01 	add	r1,r10,r2
    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);
8000d0c0:	14 12       	sub	r2,r10
8000d0c2:	50 22       	stdsp	sp[0x8],r2

    tmp13 = ((DCTELEM) wsptr[2] + (DCTELEM) wsptr[6]);
8000d0c4:	78 02       	ld.w	r2,r12[0x0]
8000d0c6:	6a 0a       	ld.w	r10,r5[0x0]
8000d0c8:	04 0a       	add	r10,r2
    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
8000d0ca:	6a 00       	ld.w	r0,r5[0x0]
8000d0cc:	00 12       	sub	r2,r0
8000d0ce:	e0 60 01 6a 	mov	r0,362
8000d0d2:	a1 32       	mul	r2,r0
8000d0d4:	e4 00 14 08 	asr	r0,r2,0x8
8000d0d8:	14 10       	sub	r0,r10
	    - tmp13;

    tmp0 = tmp10 + tmp13;
8000d0da:	f4 01 00 02 	add	r2,r10,r1
8000d0de:	50 82       	stdsp	sp[0x20],r2
    tmp3 = tmp10 - tmp13;
8000d0e0:	14 11       	sub	r1,r10
8000d0e2:	50 51       	stdsp	sp[0x14],r1
    tmp1 = tmp11 + tmp12;
8000d0e4:	40 21       	lddsp	r1,sp[0x8]
8000d0e6:	e0 01 00 01 	add	r1,r0,r1
8000d0ea:	50 41       	stdsp	sp[0x10],r1
    tmp2 = tmp11 - tmp12;
8000d0ec:	40 2a       	lddsp	r10,sp[0x8]
8000d0ee:	00 1a       	sub	r10,r0
8000d0f0:	50 3a       	stdsp	sp[0xc],r10

    /* Odd part */

    z13 = (DCTELEM) wsptr[5] + (DCTELEM) wsptr[3];
8000d0f2:	6c 02       	ld.w	r2,r6[0x0]
8000d0f4:	7c 0a       	ld.w	r10,lr[0x0]
8000d0f6:	f4 02 00 01 	add	r1,r10,r2
    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
8000d0fa:	14 12       	sub	r2,r10
8000d0fc:	50 02       	stdsp	sp[0x0],r2
    z11 = (DCTELEM) wsptr[1] + (DCTELEM) wsptr[7];
8000d0fe:	68 02       	ld.w	r2,r4[0x0]
8000d100:	e4 0b 00 00 	add	r0,r2,r11
    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];
8000d104:	04 1b       	sub	r11,r2
8000d106:	50 2b       	stdsp	sp[0x8],r11

    tmp7 = z11 + z13;		/* phase 5 */
8000d108:	e0 01 00 0b 	add	r11,r0,r1
    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */

    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */
8000d10c:	40 2a       	lddsp	r10,sp[0x8]
8000d10e:	40 02       	lddsp	r2,sp[0x0]
8000d110:	04 0a       	add	r10,r2
8000d112:	e0 62 01 d9 	mov	r2,473
8000d116:	a5 3a       	mul	r10,r2
8000d118:	a9 4a       	asr	r10,0x8
8000d11a:	50 1a       	stdsp	sp[0x4],r10
    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */

    tmp6 = tmp12 - tmp7;	/* phase 2 */
8000d11c:	40 02       	lddsp	r2,sp[0x0]
8000d11e:	fe 7a fd 63 	mov	r10,-669
8000d122:	b5 32       	mul	r2,r10
8000d124:	e4 0a 14 08 	asr	r10,r2,0x8
8000d128:	16 1a       	sub	r10,r11
8000d12a:	40 12       	lddsp	r2,sp[0x4]
8000d12c:	04 0a       	add	r10,r2
    tmp5 = tmp11 - tmp6;
8000d12e:	02 10       	sub	r0,r1
8000d130:	e0 61 01 6a 	mov	r1,362
8000d134:	a3 30       	mul	r0,r1
8000d136:	a9 40       	asr	r0,0x8
8000d138:	14 10       	sub	r0,r10
    tmp4 = tmp10 + tmp5;
8000d13a:	40 21       	lddsp	r1,sp[0x8]
8000d13c:	e0 62 01 15 	mov	r2,277
8000d140:	a5 31       	mul	r1,r2
8000d142:	a9 41       	asr	r1,0x8
8000d144:	40 12       	lddsp	r2,sp[0x4]
8000d146:	04 11       	sub	r1,r2
8000d148:	00 01       	add	r1,r0

    /* Final output stage: scale down by a factor of 8 and range-limit */

    outptr[0] = range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS+3)
8000d14a:	40 82       	lddsp	r2,sp[0x20]
8000d14c:	f6 02 00 02 	add	r2,r11,r2
8000d150:	e5 d2 c0 aa 	bfextu	r2,r2,0x5,0xa
8000d154:	50 22       	stdsp	sp[0x8],r2
8000d156:	f0 02 07 02 	ld.ub	r2,r8[r2]
8000d15a:	b2 82       	st.b	r9[0x0],r2
			    & RANGE_MASK];
    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
8000d15c:	40 82       	lddsp	r2,sp[0x20]
8000d15e:	e4 0b 01 0b 	sub	r11,r2,r11
8000d162:	f7 db c0 aa 	bfextu	r11,r11,0x5,0xa
8000d166:	f0 0b 07 0b 	ld.ub	r11,r8[r11]
8000d16a:	b2 fb       	st.b	r9[0x7],r11
			    & RANGE_MASK];
    outptr[1] = range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS+3)
8000d16c:	40 4b       	lddsp	r11,sp[0x10]
8000d16e:	14 0b       	add	r11,r10
8000d170:	f7 db c0 aa 	bfextu	r11,r11,0x5,0xa
8000d174:	f0 0b 07 0b 	ld.ub	r11,r8[r11]
8000d178:	b2 9b       	st.b	r9[0x1],r11
			    & RANGE_MASK];
    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
8000d17a:	40 4b       	lddsp	r11,sp[0x10]
8000d17c:	f6 0a 01 0a 	sub	r10,r11,r10
8000d180:	f5 da c0 aa 	bfextu	r10,r10,0x5,0xa
8000d184:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
8000d188:	b2 ea       	st.b	r9[0x6],r10
			    & RANGE_MASK];
    outptr[2] = range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS+3)
8000d18a:	40 32       	lddsp	r2,sp[0xc]
8000d18c:	e0 02 00 0a 	add	r10,r0,r2
8000d190:	f5 da c0 aa 	bfextu	r10,r10,0x5,0xa
8000d194:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
8000d198:	b2 aa       	st.b	r9[0x2],r10
			    & RANGE_MASK];
    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
8000d19a:	e4 00 01 00 	sub	r0,r2,r0
8000d19e:	e1 d0 c0 aa 	bfextu	r0,r0,0x5,0xa
8000d1a2:	f0 00 07 0a 	ld.ub	r10,r8[r0]
8000d1a6:	b2 da       	st.b	r9[0x5],r10
			    & RANGE_MASK];
    outptr[4] = range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS+3)
8000d1a8:	40 50       	lddsp	r0,sp[0x14]
8000d1aa:	e2 00 00 0a 	add	r10,r1,r0
8000d1ae:	f5 da c0 aa 	bfextu	r10,r10,0x5,0xa
8000d1b2:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
8000d1b6:	b2 ca       	st.b	r9[0x4],r10
			    & RANGE_MASK];
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
8000d1b8:	e0 01 01 01 	sub	r1,r0,r1
8000d1bc:	e3 d1 c0 aa 	bfextu	r1,r1,0x5,0xa
8000d1c0:	f0 01 07 0a 	ld.ub	r10,r8[r1]
8000d1c4:	b2 ba       	st.b	r9[0x3],r10
8000d1c6:	2f c3       	sub	r3,-4
8000d1c8:	40 7b       	lddsp	r11,sp[0x1c]
8000d1ca:	2e 0b       	sub	r11,-32
8000d1cc:	50 7b       	stdsp	sp[0x1c],r11
8000d1ce:	40 6a       	lddsp	r10,sp[0x18]
8000d1d0:	2e 0a       	sub	r10,-32
8000d1d2:	50 6a       	stdsp	sp[0x18],r10
8000d1d4:	2e 07       	sub	r7,-32
8000d1d6:	2e 0c       	sub	r12,-32
8000d1d8:	2e 05       	sub	r5,-32
8000d1da:	2e 06       	sub	r6,-32
8000d1dc:	2e 0e       	sub	lr,-32
8000d1de:	2e 04       	sub	r4,-32
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
8000d1e0:	40 99       	lddsp	r9,sp[0x24]
8000d1e2:	12 3a       	cp.w	r10,r9
8000d1e4:	fe 91 ff 40 	brne	8000d064 <jpeg_idct_ifast+0x1d4>
    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
			    & RANGE_MASK];

    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}
8000d1e8:	2b 5d       	sub	sp,-300
8000d1ea:	d8 32       	popm	r0-r7,pc

8000d1ec <jpeg_idct_islow>:

GLOBAL(void)
jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
		 JCOEFPTR coef_block,
		 JSAMPARRAY output_buf, JDIMENSION output_col)
{
8000d1ec:	d4 31       	pushm	r0-r7,lr
8000d1ee:	fa cd 01 38 	sub	sp,sp,312
8000d1f2:	50 a9       	stdsp	sp[0x28],r9
8000d1f4:	50 c8       	stdsp	sp[0x30],r8
  INT32 z1, z2, z3, z4, z5;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
8000d1f6:	f8 f8 01 44 	ld.w	r8,r12[324]
8000d1fa:	28 08       	sub	r8,-128
8000d1fc:	77 49       	ld.w	r9,r11[0x50]
8000d1fe:	fa cc ff c8 	sub	r12,sp,-56
8000d202:	50 9c       	stdsp	sp[0x24],r12
8000d204:	fa cb ff a8 	sub	r11,sp,-88
8000d208:	50 8b       	stdsp	sp[0x20],r11
8000d20a:	fa c4 ff 88 	sub	r4,sp,-120
8000d20e:	fa c5 ff 68 	sub	r5,sp,-152
8000d212:	fa c6 ff 48 	sub	r6,sp,-184
8000d216:	50 46       	stdsp	sp[0x10],r6
8000d218:	50 3b       	stdsp	sp[0xc],r11
8000d21a:	18 9b       	mov	r11,r12
8000d21c:	30 83       	mov	r3,8
8000d21e:	50 13       	stdsp	sp[0x4],r3
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */

    z3 += z5;
    z4 += z5;

    tmp0 += z1 + z3;
8000d220:	50 b8       	stdsp	sp[0x2c],r8
     * DC coefficient (with scale factor as needed).
     * With typical images and quantization tables, half or more of the
     * column DCT calculations can be simplified this way.
     */

    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
8000d222:	f5 08 00 10 	ld.sh	r8,r10[16]
8000d226:	58 08       	cp.w	r8,0
8000d228:	c3 31       	brne	8000d28e <jpeg_idct_islow+0xa2>
8000d22a:	f5 0e 00 20 	ld.sh	lr,r10[32]
8000d22e:	30 0c       	mov	r12,0
8000d230:	f8 0e 19 00 	cp.h	lr,r12
8000d234:	c2 d1       	brne	8000d28e <jpeg_idct_islow+0xa2>
8000d236:	f5 0e 00 30 	ld.sh	lr,r10[48]
8000d23a:	f8 0e 19 00 	cp.h	lr,r12
8000d23e:	c2 81       	brne	8000d28e <jpeg_idct_islow+0xa2>
8000d240:	f5 0e 00 40 	ld.sh	lr,r10[64]
8000d244:	f8 0e 19 00 	cp.h	lr,r12
8000d248:	c2 31       	brne	8000d28e <jpeg_idct_islow+0xa2>
8000d24a:	f5 0e 00 50 	ld.sh	lr,r10[80]
8000d24e:	f8 0e 19 00 	cp.h	lr,r12
8000d252:	c1 e1       	brne	8000d28e <jpeg_idct_islow+0xa2>
8000d254:	f5 0e 00 60 	ld.sh	lr,r10[96]
8000d258:	f8 0e 19 00 	cp.h	lr,r12
8000d25c:	c1 91       	brne	8000d28e <jpeg_idct_islow+0xa2>
8000d25e:	f5 0e 00 70 	ld.sh	lr,r10[112]
8000d262:	f8 0e 19 00 	cp.h	lr,r12
8000d266:	c1 41       	brne	8000d28e <jpeg_idct_islow+0xa2>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
	inptr[DCTSIZE*7] == 0) {
      /* AC terms all zero */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
8000d268:	94 0c       	ld.sh	r12,r10[0x0]
8000d26a:	72 08       	ld.w	r8,r9[0x0]
8000d26c:	f8 08 02 48 	mul	r8,r12,r8
8000d270:	a3 68       	lsl	r8,0x2

      wsptr[DCTSIZE*0] = dcval;
8000d272:	97 08       	st.w	r11[0x0],r8
      wsptr[DCTSIZE*1] = dcval;
8000d274:	40 32       	lddsp	r2,sp[0xc]
8000d276:	85 08       	st.w	r2[0x0],r8
      wsptr[DCTSIZE*2] = dcval;
8000d278:	89 08       	st.w	r4[0x0],r8
      wsptr[DCTSIZE*3] = dcval;
8000d27a:	8b 08       	st.w	r5[0x0],r8
      wsptr[DCTSIZE*4] = dcval;
8000d27c:	40 41       	lddsp	r1,sp[0x10]
8000d27e:	83 08       	st.w	r1[0x0],r8
      wsptr[DCTSIZE*5] = dcval;
8000d280:	f7 48 00 a0 	st.w	r11[160],r8
      wsptr[DCTSIZE*6] = dcval;
8000d284:	f7 48 00 c0 	st.w	r11[192],r8
      wsptr[DCTSIZE*7] = dcval;
8000d288:	f7 48 00 e0 	st.w	r11[224],r8

      inptr++;			/* advance pointers to next column */
      quantptr++;
      wsptr++;
      continue;
8000d28c:	cb 28       	rjmp	8000d3f0 <jpeg_idct_islow+0x204>
    }

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
8000d28e:	f5 0e 00 20 	ld.sh	lr,r10[32]
8000d292:	73 0c       	ld.w	r12,r9[0x40]
8000d294:	b9 3e       	mul	lr,r12
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
8000d296:	f5 07 00 60 	ld.sh	r7,r10[96]
8000d29a:	f2 fc 00 c0 	ld.w	r12,r9[192]
8000d29e:	b9 37       	mul	r7,r12

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
8000d2a0:	ee 0e 00 0c 	add	r12,r7,lr
8000d2a4:	e0 60 11 51 	mov	r0,4433
8000d2a8:	a1 3c       	mul	r12,r0
    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
8000d2aa:	fe 76 c4 df 	mov	r6,-15137
8000d2ae:	ad 37       	mul	r7,r6
8000d2b0:	f8 07 00 03 	add	r3,r12,r7
8000d2b4:	50 53       	stdsp	sp[0x14],r3
    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
8000d2b6:	e0 62 18 7e 	mov	r2,6270
8000d2ba:	a5 3e       	mul	lr,r2
8000d2bc:	f8 0e 00 0e 	add	lr,r12,lr
8000d2c0:	50 2e       	stdsp	sp[0x8],lr

    z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
8000d2c2:	94 0e       	ld.sh	lr,r10[0x0]
8000d2c4:	72 0c       	ld.w	r12,r9[0x0]
8000d2c6:	b9 3e       	mul	lr,r12
    z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
8000d2c8:	f5 07 00 40 	ld.sh	r7,r10[64]
8000d2cc:	f2 fc 00 80 	ld.w	r12,r9[128]
8000d2d0:	ee 0c 02 4c 	mul	r12,r7,r12

    tmp0 = (z2 + z3) << CONST_BITS;
8000d2d4:	f8 0e 00 07 	add	r7,r12,lr
8000d2d8:	ee 01 15 0d 	lsl	r1,r7,0xd
8000d2dc:	50 71       	stdsp	sp[0x1c],r1
    tmp1 = (z2 - z3) << CONST_BITS;
8000d2de:	fc 0c 01 0c 	sub	r12,lr,r12
8000d2e2:	ad 7c       	lsl	r12,0xd
8000d2e4:	50 6c       	stdsp	sp[0x18],r12

    /* Odd part per figure 8; the matrix is unitary and hence its
     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
     */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
8000d2e6:	f5 07 00 70 	ld.sh	r7,r10[112]
8000d2ea:	f2 fc 00 e0 	ld.w	r12,r9[224]
8000d2ee:	b9 37       	mul	r7,r12
    tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
8000d2f0:	f5 0e 00 50 	ld.sh	lr,r10[80]
8000d2f4:	f2 fc 00 a0 	ld.w	r12,r9[160]
8000d2f8:	b9 3e       	mul	lr,r12
    tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
8000d2fa:	f5 06 00 30 	ld.sh	r6,r10[48]
8000d2fe:	73 8c       	ld.w	r12,r9[0x60]
8000d300:	ec 0c 02 4c 	mul	r12,r6,r12
    tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
8000d304:	72 86       	ld.w	r6,r9[0x20]
8000d306:	ad 38       	mul	r8,r6

    z1 = tmp0 + tmp3;
8000d308:	f0 07 00 00 	add	r0,r8,r7
8000d30c:	50 d0       	stdsp	sp[0x34],r0
    z2 = tmp1 + tmp2;
8000d30e:	f8 0e 00 06 	add	r6,r12,lr
8000d312:	50 06       	stdsp	sp[0x0],r6
    z3 = tmp0 + tmp2;
8000d314:	f8 07 00 02 	add	r2,r12,r7
    z4 = tmp1 + tmp3;
8000d318:	f0 0e 00 06 	add	r6,r8,lr
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
8000d31c:	ec 02 00 00 	add	r0,r6,r2
8000d320:	e0 63 25 a1 	mov	r3,9633
8000d324:	a7 30       	mul	r0,r3

    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
8000d326:	40 d1       	lddsp	r1,sp[0x34]
8000d328:	fe 73 e3 33 	mov	r3,-7373
8000d32c:	a7 31       	mul	r1,r3
8000d32e:	50 d1       	stdsp	sp[0x34],r1
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
8000d330:	40 01       	lddsp	r1,sp[0x0]
8000d332:	fe 73 ad fd 	mov	r3,-20995
8000d336:	a7 31       	mul	r1,r3
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
8000d338:	fe 73 c1 3b 	mov	r3,-16069
8000d33c:	a7 32       	mul	r2,r3
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
8000d33e:	fe 73 f3 84 	mov	r3,-3196
8000d342:	a7 36       	mul	r6,r3

    z3 += z5;
8000d344:	e0 02 00 02 	add	r2,r0,r2
    z4 += z5;
8000d348:	e0 06 00 06 	add	r6,r0,r6

    tmp0 += z1 + z3;
8000d34c:	e0 60 09 8e 	mov	r0,2446
8000d350:	a1 37       	mul	r7,r0
8000d352:	40 d3       	lddsp	r3,sp[0x34]
8000d354:	e6 07 00 07 	add	r7,r3,r7
8000d358:	04 07       	add	r7,r2
    tmp1 += z2 + z4;
8000d35a:	e0 60 41 b3 	mov	r0,16819
8000d35e:	a1 3e       	mul	lr,r0
8000d360:	e2 0e 00 0e 	add	lr,r1,lr
8000d364:	0c 0e       	add	lr,r6
    tmp2 += z2 + z3;
8000d366:	e0 60 62 54 	mov	r0,25172
8000d36a:	a1 3c       	mul	r12,r0
8000d36c:	e2 0c 00 0c 	add	r12,r1,r12
8000d370:	f8 02 00 02 	add	r2,r12,r2
    tmp3 += z1 + z4;
8000d374:	e0 6c 30 0b 	mov	r12,12299
8000d378:	b9 38       	mul	r8,r12
8000d37a:	e6 08 00 08 	add	r8,r3,r8
8000d37e:	f0 06 00 06 	add	r6,r8,r6

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
8000d382:	40 23       	lddsp	r3,sp[0x8]
8000d384:	40 71       	lddsp	r1,sp[0x1c]
8000d386:	02 03       	add	r3,r1
8000d388:	e6 c3 fc 00 	sub	r3,r3,-1024
8000d38c:	e6 06 00 08 	add	r8,r3,r6
8000d390:	ab 58       	asr	r8,0xb
8000d392:	97 08       	st.w	r11[0x0],r8
    wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
8000d394:	e6 06 01 06 	sub	r6,r3,r6
8000d398:	ab 56       	asr	r6,0xb
8000d39a:	f7 46 00 e0 	st.w	r11[224],r6
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
8000d39e:	40 5c       	lddsp	r12,sp[0x14]
8000d3a0:	40 60       	lddsp	r0,sp[0x18]
8000d3a2:	00 0c       	add	r12,r0
8000d3a4:	f8 cc fc 00 	sub	r12,r12,-1024
8000d3a8:	f8 02 00 08 	add	r8,r12,r2
8000d3ac:	ab 58       	asr	r8,0xb
8000d3ae:	40 36       	lddsp	r6,sp[0xc]
8000d3b0:	8d 08       	st.w	r6[0x0],r8
    wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
8000d3b2:	f8 02 01 02 	sub	r2,r12,r2
8000d3b6:	ab 52       	asr	r2,0xb
8000d3b8:	f7 42 00 c0 	st.w	r11[192],r2
    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
8000d3bc:	00 98       	mov	r8,r0
8000d3be:	40 53       	lddsp	r3,sp[0x14]
8000d3c0:	06 18       	sub	r8,r3
8000d3c2:	f0 c8 fc 00 	sub	r8,r8,-1024
8000d3c6:	f0 0e 00 0c 	add	r12,r8,lr
8000d3ca:	ab 5c       	asr	r12,0xb
8000d3cc:	89 0c       	st.w	r4[0x0],r12
    wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
8000d3ce:	1c 18       	sub	r8,lr
8000d3d0:	ab 58       	asr	r8,0xb
8000d3d2:	f7 48 00 a0 	st.w	r11[160],r8
    wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
8000d3d6:	02 98       	mov	r8,r1
8000d3d8:	40 22       	lddsp	r2,sp[0x8]
8000d3da:	04 18       	sub	r8,r2
8000d3dc:	f0 c8 fc 00 	sub	r8,r8,-1024
8000d3e0:	f0 07 00 0c 	add	r12,r8,r7
8000d3e4:	ab 5c       	asr	r12,0xb
8000d3e6:	8b 0c       	st.w	r5[0x0],r12
    wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
8000d3e8:	0e 18       	sub	r8,r7
8000d3ea:	ab 58       	asr	r8,0xb
8000d3ec:	40 41       	lddsp	r1,sp[0x10]
8000d3ee:	83 08       	st.w	r1[0x0],r8
  /* furthermore, we scale the results by 2**PASS1_BITS. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; ctr--) {
8000d3f0:	40 10       	lddsp	r0,sp[0x4]
8000d3f2:	20 10       	sub	r0,1
8000d3f4:	50 10       	stdsp	sp[0x4],r0
8000d3f6:	2f ea       	sub	r10,-2
8000d3f8:	2f c9       	sub	r9,-4
8000d3fa:	2f cb       	sub	r11,-4
8000d3fc:	40 3c       	lddsp	r12,sp[0xc]
8000d3fe:	2f cc       	sub	r12,-4
8000d400:	50 3c       	stdsp	sp[0xc],r12
8000d402:	2f c4       	sub	r4,-4
8000d404:	2f c5       	sub	r5,-4
8000d406:	40 48       	lddsp	r8,sp[0x10]
8000d408:	2f c8       	sub	r8,-4
8000d40a:	50 48       	stdsp	sp[0x10],r8
8000d40c:	58 00       	cp.w	r0,0
8000d40e:	fe 91 ff 0a 	brne	8000d222 <jpeg_idct_islow+0x36>
8000d412:	40 b8       	lddsp	r8,sp[0x2c]
8000d414:	40 a3       	lddsp	r3,sp[0x28]
8000d416:	fa cc ff c0 	sub	r12,sp,-64
8000d41a:	fa c5 ff b0 	sub	r5,sp,-80
8000d41e:	fa c7 ff b8 	sub	r7,sp,-72
8000d422:	fa c4 ff ac 	sub	r4,sp,-84
8000d426:	fa c6 ff b4 	sub	r6,sp,-76
8000d42a:	fa ce ff bc 	sub	lr,sp,-68
/*
 * Perform dequantization and inverse DCT on one block of coefficients.
 */

GLOBAL(void)
jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000d42e:	40 92       	lddsp	r2,sp[0x24]
8000d430:	e4 c2 fe e0 	sub	r2,r2,-288
8000d434:	50 d2       	stdsp	sp[0x34],r2
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
    outptr = output_buf[ctr] + output_col;
8000d436:	66 09       	ld.w	r9,r3[0x0]
8000d438:	40 c1       	lddsp	r1,sp[0x30]
8000d43a:	02 09       	add	r9,r1
     * test takes more time than it's worth.  In that case this section
     * may be commented out.
     */

#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
8000d43c:	40 80       	lddsp	r0,sp[0x20]
8000d43e:	e0 fa ff e4 	ld.w	r10,r0[-28]
8000d442:	58 0a       	cp.w	r10,0
8000d444:	c2 31       	brne	8000d48a <jpeg_idct_islow+0x29e>
8000d446:	78 0b       	ld.w	r11,r12[0x0]
8000d448:	58 0b       	cp.w	r11,0
8000d44a:	c2 01       	brne	8000d48a <jpeg_idct_islow+0x29e>
8000d44c:	7c 0b       	ld.w	r11,lr[0x0]
8000d44e:	58 0b       	cp.w	r11,0
8000d450:	c1 d1       	brne	8000d48a <jpeg_idct_islow+0x29e>
8000d452:	6e 0b       	ld.w	r11,r7[0x0]
8000d454:	58 0b       	cp.w	r11,0
8000d456:	c1 a1       	brne	8000d48a <jpeg_idct_islow+0x29e>
8000d458:	6c 0b       	ld.w	r11,r6[0x0]
8000d45a:	58 0b       	cp.w	r11,0
8000d45c:	c1 71       	brne	8000d48a <jpeg_idct_islow+0x29e>
8000d45e:	6a 0b       	ld.w	r11,r5[0x0]
8000d460:	58 0b       	cp.w	r11,0
8000d462:	c1 41       	brne	8000d48a <jpeg_idct_islow+0x29e>
8000d464:	68 0b       	ld.w	r11,r4[0x0]
8000d466:	58 0b       	cp.w	r11,0
8000d468:	c1 11       	brne	8000d48a <jpeg_idct_islow+0x29e>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
8000d46a:	40 9b       	lddsp	r11,sp[0x24]
8000d46c:	76 0a       	ld.w	r10,r11[0x0]
8000d46e:	2f 0a       	sub	r10,-16
8000d470:	f5 da c0 aa 	bfextu	r10,r10,0x5,0xa
8000d474:	f0 0a 07 0a 	ld.ub	r10,r8[r10]

      outptr[0] = dcval;
8000d478:	b2 8a       	st.b	r9[0x0],r10
      outptr[1] = dcval;
8000d47a:	b2 9a       	st.b	r9[0x1],r10
      outptr[2] = dcval;
8000d47c:	b2 aa       	st.b	r9[0x2],r10
      outptr[3] = dcval;
8000d47e:	b2 ba       	st.b	r9[0x3],r10
      outptr[4] = dcval;
8000d480:	b2 ca       	st.b	r9[0x4],r10
      outptr[5] = dcval;
8000d482:	b2 da       	st.b	r9[0x5],r10
      outptr[6] = dcval;
8000d484:	b2 ea       	st.b	r9[0x6],r10
      outptr[7] = dcval;
8000d486:	b2 fa       	st.b	r9[0x7],r10

      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
8000d488:	cb 58       	rjmp	8000d5f2 <jpeg_idct_islow+0x406>
#endif

    /* Even part: reverse the even part of the forward DCT. */
    /* The rotator is sqrt(2)*c(-6). */

    z2 = (INT32) wsptr[2];
8000d48a:	78 02       	ld.w	r2,r12[0x0]
    z3 = (INT32) wsptr[6];
8000d48c:	6a 01       	ld.w	r1,r5[0x0]

    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
8000d48e:	e2 02 00 0b 	add	r11,r1,r2
8000d492:	e0 60 11 51 	mov	r0,4433
8000d496:	a1 3b       	mul	r11,r0
    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
8000d498:	fe 70 c4 df 	mov	r0,-15137
8000d49c:	a1 31       	mul	r1,r0
8000d49e:	f6 01 00 01 	add	r1,r11,r1
8000d4a2:	50 b1       	stdsp	sp[0x2c],r1
    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
8000d4a4:	e0 61 18 7e 	mov	r1,6270
8000d4a8:	a3 32       	mul	r2,r1
8000d4aa:	f6 02 00 02 	add	r2,r11,r2
8000d4ae:	50 a2       	stdsp	sp[0x28],r2

    tmp0 = ((INT32) wsptr[0] + (INT32) wsptr[4]) << CONST_BITS;
8000d4b0:	40 90       	lddsp	r0,sp[0x24]
8000d4b2:	60 02       	ld.w	r2,r0[0x0]
8000d4b4:	6e 0b       	ld.w	r11,r7[0x0]
8000d4b6:	f6 02 00 01 	add	r1,r11,r2
8000d4ba:	ad 71       	lsl	r1,0xd
8000d4bc:	50 71       	stdsp	sp[0x1c],r1
    tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
8000d4be:	e4 0b 01 0b 	sub	r11,r2,r11
8000d4c2:	ad 7b       	lsl	r11,0xd
8000d4c4:	50 6b       	stdsp	sp[0x18],r11
    tmp0 = (INT32) wsptr[7];
    tmp1 = (INT32) wsptr[5];
    tmp2 = (INT32) wsptr[3];
    tmp3 = (INT32) wsptr[1];

    z1 = tmp0 + tmp3;
8000d4c6:	68 0b       	ld.w	r11,r4[0x0]
8000d4c8:	14 0b       	add	r11,r10
8000d4ca:	50 2b       	stdsp	sp[0x8],r11
    z2 = tmp1 + tmp2;
8000d4cc:	7c 02       	ld.w	r2,lr[0x0]
8000d4ce:	6c 01       	ld.w	r1,r6[0x0]
8000d4d0:	02 02       	add	r2,r1
8000d4d2:	50 12       	stdsp	sp[0x4],r2
    z3 = tmp0 + tmp2;
8000d4d4:	7c 00       	ld.w	r0,lr[0x0]
8000d4d6:	68 0b       	ld.w	r11,r4[0x0]
8000d4d8:	16 00       	add	r0,r11
    z4 = tmp1 + tmp3;
8000d4da:	6c 01       	ld.w	r1,r6[0x0]
8000d4dc:	14 01       	add	r1,r10
    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
8000d4de:	e2 00 00 0b 	add	r11,r1,r0
8000d4e2:	e0 62 25 a1 	mov	r2,9633
8000d4e6:	a5 3b       	mul	r11,r2
8000d4e8:	50 3b       	stdsp	sp[0xc],r11

    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
8000d4ea:	40 2b       	lddsp	r11,sp[0x8]
8000d4ec:	fe 72 e3 33 	mov	r2,-7373
8000d4f0:	a5 3b       	mul	r11,r2
8000d4f2:	50 5b       	stdsp	sp[0x14],r11
    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
8000d4f4:	40 1b       	lddsp	r11,sp[0x4]
8000d4f6:	fe 72 ad fd 	mov	r2,-20995
8000d4fa:	a5 3b       	mul	r11,r2
8000d4fc:	50 2b       	stdsp	sp[0x8],r11
    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
8000d4fe:	fe 7b c1 3b 	mov	r11,-16069
8000d502:	b7 30       	mul	r0,r11
    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
8000d504:	fe 72 f3 84 	mov	r2,-3196
8000d508:	a5 31       	mul	r1,r2

    z3 += z5;
8000d50a:	40 3b       	lddsp	r11,sp[0xc]
8000d50c:	f6 00 00 00 	add	r0,r11,r0
    z4 += z5;
8000d510:	f6 01 00 01 	add	r1,r11,r1

    tmp0 += z1 + z3;
8000d514:	68 0b       	ld.w	r11,r4[0x0]
8000d516:	e0 62 09 8e 	mov	r2,2446
8000d51a:	a5 3b       	mul	r11,r2
8000d51c:	40 52       	lddsp	r2,sp[0x14]
8000d51e:	e4 0b 00 0b 	add	r11,r2,r11
8000d522:	00 0b       	add	r11,r0
8000d524:	50 1b       	stdsp	sp[0x4],r11
    tmp1 += z2 + z4;
8000d526:	e0 6b 41 b3 	mov	r11,16819
8000d52a:	6c 02       	ld.w	r2,r6[0x0]
8000d52c:	e4 0b 02 4b 	mul	r11,r2,r11
8000d530:	40 22       	lddsp	r2,sp[0x8]
8000d532:	e4 0b 00 0b 	add	r11,r2,r11
8000d536:	02 0b       	add	r11,r1
8000d538:	50 4b       	stdsp	sp[0x10],r11
    tmp2 += z2 + z3;
8000d53a:	7c 0b       	ld.w	r11,lr[0x0]
8000d53c:	e0 62 62 54 	mov	r2,25172
8000d540:	a5 3b       	mul	r11,r2
8000d542:	40 22       	lddsp	r2,sp[0x8]
8000d544:	16 02       	add	r2,r11
8000d546:	e4 00 00 00 	add	r0,r2,r0
    tmp3 += z1 + z4;
8000d54a:	e0 62 30 0b 	mov	r2,12299
8000d54e:	a5 3a       	mul	r10,r2
8000d550:	40 5b       	lddsp	r11,sp[0x14]
8000d552:	f6 0a 00 0a 	add	r10,r11,r10
8000d556:	f4 01 00 01 	add	r1,r10,r1

    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */

    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp3,
8000d55a:	40 a2       	lddsp	r2,sp[0x28]
8000d55c:	40 7a       	lddsp	r10,sp[0x1c]
8000d55e:	14 02       	add	r2,r10
8000d560:	fe 22 00 00 	sub	r2,-131072
8000d564:	e4 01 00 0a 	add	r10,r2,r1
8000d568:	f5 da c2 4a 	bfextu	r10,r10,0x12,0xa
8000d56c:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
8000d570:	b2 8a       	st.b	r9[0x0],r10
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
8000d572:	e4 01 01 01 	sub	r1,r2,r1
8000d576:	e3 d1 c2 4a 	bfextu	r1,r1,0x12,0xa
8000d57a:	f0 01 07 0a 	ld.ub	r10,r8[r1]
8000d57e:	b2 fa       	st.b	r9[0x7],r10
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp11 + tmp2,
8000d580:	40 b2       	lddsp	r2,sp[0x2c]
8000d582:	40 61       	lddsp	r1,sp[0x18]
8000d584:	02 02       	add	r2,r1
8000d586:	fe 22 00 00 	sub	r2,-131072
8000d58a:	e4 00 00 0a 	add	r10,r2,r0
8000d58e:	f5 da c2 4a 	bfextu	r10,r10,0x12,0xa
8000d592:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
8000d596:	b2 9a       	st.b	r9[0x1],r10
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
8000d598:	e4 00 01 00 	sub	r0,r2,r0
8000d59c:	e1 d0 c2 4a 	bfextu	r0,r0,0x12,0xa
8000d5a0:	f0 00 07 0a 	ld.ub	r10,r8[r0]
8000d5a4:	b2 ea       	st.b	r9[0x6],r10
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE(tmp12 + tmp1,
8000d5a6:	02 9a       	mov	r10,r1
8000d5a8:	40 b0       	lddsp	r0,sp[0x2c]
8000d5aa:	00 1a       	sub	r10,r0
8000d5ac:	fe 2a 00 00 	sub	r10,-131072
8000d5b0:	40 4b       	lddsp	r11,sp[0x10]
8000d5b2:	f4 0b 00 02 	add	r2,r10,r11
8000d5b6:	e5 d2 c2 4a 	bfextu	r2,r2,0x12,0xa
8000d5ba:	f0 02 07 02 	ld.ub	r2,r8[r2]
8000d5be:	b2 a2       	st.b	r9[0x2],r2
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
8000d5c0:	16 1a       	sub	r10,r11
8000d5c2:	f5 da c2 4a 	bfextu	r10,r10,0x12,0xa
8000d5c6:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
8000d5ca:	b2 da       	st.b	r9[0x5],r10
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE(tmp13 + tmp0,
8000d5cc:	40 7b       	lddsp	r11,sp[0x1c]
8000d5ce:	40 aa       	lddsp	r10,sp[0x28]
8000d5d0:	14 1b       	sub	r11,r10
8000d5d2:	fe 2b 00 00 	sub	r11,-131072
8000d5d6:	40 12       	lddsp	r2,sp[0x4]
8000d5d8:	f6 02 00 0a 	add	r10,r11,r2
8000d5dc:	f5 da c2 4a 	bfextu	r10,r10,0x12,0xa
8000d5e0:	f0 0a 07 0a 	ld.ub	r10,r8[r10]
8000d5e4:	b2 ba       	st.b	r9[0x3],r10
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];
    outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
8000d5e6:	04 1b       	sub	r11,r2
8000d5e8:	f7 db c2 4a 	bfextu	r11,r11,0x12,0xa
8000d5ec:	f0 0b 07 0a 	ld.ub	r10,r8[r11]
8000d5f0:	b2 ca       	st.b	r9[0x4],r10
8000d5f2:	2f c3       	sub	r3,-4
8000d5f4:	40 91       	lddsp	r1,sp[0x24]
8000d5f6:	2e 01       	sub	r1,-32
8000d5f8:	50 91       	stdsp	sp[0x24],r1
8000d5fa:	40 80       	lddsp	r0,sp[0x20]
8000d5fc:	2e 00       	sub	r0,-32
8000d5fe:	50 80       	stdsp	sp[0x20],r0
8000d600:	2e 0c       	sub	r12,-32
8000d602:	2e 05       	sub	r5,-32
8000d604:	2e 07       	sub	r7,-32
8000d606:	2e 04       	sub	r4,-32
8000d608:	2e 06       	sub	r6,-32
8000d60a:	2e 0e       	sub	lr,-32
  /* Pass 2: process rows from work array, store into output array. */
  /* Note that we must descale the results by a factor of 8 == 2**3, */
  /* and also undo the PASS1_BITS scaling. */

  wsptr = workspace;
  for (ctr = 0; ctr < DCTSIZE; ctr++) {
8000d60c:	40 db       	lddsp	r11,sp[0x34]
8000d60e:	16 30       	cp.w	r0,r11
8000d610:	fe 91 ff 13 	brne	8000d436 <jpeg_idct_islow+0x24a>
					  CONST_BITS+PASS1_BITS+3)
			    & RANGE_MASK];

    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}
8000d614:	2b 2d       	sub	sp,-312
8000d616:	d8 32       	popm	r0-r7,pc

8000d618 <jpeg_idct_4x4>:

GLOBAL(void)
jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
8000d618:	d4 31       	pushm	r0-r7,lr
8000d61a:	fa cd 00 94 	sub	sp,sp,148
8000d61e:	50 29       	stdsp	sp[0x8],r9
8000d620:	50 48       	stdsp	sp[0x10],r8
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
8000d622:	f8 f8 01 44 	ld.w	r8,r12[324]
8000d626:	28 08       	sub	r8,-128
8000d628:	50 18       	stdsp	sp[0x4],r8
8000d62a:	2f ea       	sub	r10,-2
8000d62c:	77 48       	ld.w	r8,r11[0x50]
8000d62e:	2f c8       	sub	r8,-4
8000d630:	fa c9 ff e8 	sub	r9,sp,-24
8000d634:	30 7b       	mov	r11,7
    tmp0 <<= (CONST_BITS+1);

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);
8000d636:	fe 70 e7 82 	mov	r0,-6270
8000d63a:	c0 58       	rjmp	8000d644 <jpeg_idct_4x4+0x2c>
  INT32 z1, z2, z3, z4;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
8000d63c:	2f ea       	sub	r10,-2
8000d63e:	2f c8       	sub	r8,-4
8000d640:	2f c9       	sub	r9,-4
8000d642:	20 1b       	sub	r11,1
  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process column 4, because second pass won't use it */
    if (ctr == DCTSIZE-4)
8000d644:	58 3b       	cp.w	r11,3
8000d646:	cf b0       	breq	8000d63c <jpeg_idct_4x4+0x24>
      continue;
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
8000d648:	94 76       	ld.sh	r6,r10[0xe]
8000d64a:	58 06       	cp.w	r6,0
8000d64c:	c2 91       	brne	8000d69e <jpeg_idct_4x4+0x86>
8000d64e:	f5 0e 00 1e 	ld.sh	lr,r10[30]
8000d652:	30 0c       	mov	r12,0
8000d654:	f8 0e 19 00 	cp.h	lr,r12
8000d658:	c2 31       	brne	8000d69e <jpeg_idct_4x4+0x86>
8000d65a:	f5 0e 00 2e 	ld.sh	lr,r10[46]
8000d65e:	f8 0e 19 00 	cp.h	lr,r12
8000d662:	c1 e1       	brne	8000d69e <jpeg_idct_4x4+0x86>
8000d664:	f5 0e 00 4e 	ld.sh	lr,r10[78]
8000d668:	f8 0e 19 00 	cp.h	lr,r12
8000d66c:	c1 91       	brne	8000d69e <jpeg_idct_4x4+0x86>
8000d66e:	f5 0e 00 5e 	ld.sh	lr,r10[94]
8000d672:	f8 0e 19 00 	cp.h	lr,r12
8000d676:	c1 41       	brne	8000d69e <jpeg_idct_4x4+0x86>
8000d678:	f5 0e 00 6e 	ld.sh	lr,r10[110]
8000d67c:	f8 0e 19 00 	cp.h	lr,r12
8000d680:	c0 f1       	brne	8000d69e <jpeg_idct_4x4+0x86>
	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*5] == 0 &&
	inptr[DCTSIZE*6] == 0 && inptr[DCTSIZE*7] == 0) {
      /* AC terms all zero; we need not examine term 4 for 4x4 output */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
8000d682:	f5 0e ff fe 	ld.sh	lr,r10[-2]
8000d686:	f0 fc ff fc 	ld.w	r12,r8[-4]
8000d68a:	fc 0c 02 4c 	mul	r12,lr,r12
8000d68e:	a3 6c       	lsl	r12,0x2

      wsptr[DCTSIZE*0] = dcval;
8000d690:	f3 4c ff fc 	st.w	r9[-4],r12
      wsptr[DCTSIZE*1] = dcval;
8000d694:	93 7c       	st.w	r9[0x1c],r12
      wsptr[DCTSIZE*2] = dcval;
8000d696:	93 fc       	st.w	r9[0x3c],r12
      wsptr[DCTSIZE*3] = dcval;
8000d698:	f3 4c 00 5c 	st.w	r9[92],r12

      continue;
8000d69c:	c6 78       	rjmp	8000d76a <jpeg_idct_4x4+0x152>
    }

    /* Even part */

    tmp0 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
8000d69e:	f5 0e ff fe 	ld.sh	lr,r10[-2]
8000d6a2:	f0 fc ff fc 	ld.w	r12,r8[-4]
8000d6a6:	b9 3e       	mul	lr,r12
    tmp0 <<= (CONST_BITS+1);
8000d6a8:	af 6e       	lsl	lr,0xe

    z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
    z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);

    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);
8000d6aa:	f0 f7 00 bc 	ld.w	r7,r8[188]
8000d6ae:	a1 37       	mul	r7,r0
8000d6b0:	f5 05 00 5e 	ld.sh	r5,r10[94]
8000d6b4:	ab 37       	mul	r7,r5
8000d6b6:	70 fc       	ld.w	r12,r8[0x3c]
8000d6b8:	e0 65 3b 21 	mov	r5,15137
8000d6bc:	ab 3c       	mul	r12,r5
8000d6be:	f5 05 00 1e 	ld.sh	r5,r10[30]
8000d6c2:	ab 3c       	mul	r12,r5
8000d6c4:	ee 0c 00 0c 	add	r12,r7,r12
    tmp10 = tmp0 + tmp2;
    tmp12 = tmp0 - tmp2;

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
8000d6c8:	f5 05 00 6e 	ld.sh	r5,r10[110]
8000d6cc:	f0 f7 00 dc 	ld.w	r7,r8[220]
8000d6d0:	af 35       	mul	r5,r7
    z2 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
8000d6d2:	f5 04 00 4e 	ld.sh	r4,r10[78]
8000d6d6:	f0 f7 00 9c 	ld.w	r7,r8[156]
8000d6da:	af 34       	mul	r4,r7
    z3 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
8000d6dc:	f5 03 00 2e 	ld.sh	r3,r10[46]
8000d6e0:	71 77       	ld.w	r7,r8[0x5c]
8000d6e2:	e6 07 02 47 	mul	r7,r3,r7
    z4 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
8000d6e6:	70 73       	ld.w	r3,r8[0x1c]
8000d6e8:	a7 36       	mul	r6,r3

    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
8000d6ea:	e0 63 2e 75 	mov	r3,11893
8000d6ee:	e8 03 02 42 	mul	r2,r4,r3
8000d6f2:	fe 71 f9 3e 	mov	r1,-1730
8000d6f6:	ea 01 02 43 	mul	r3,r5,r1
8000d6fa:	06 02       	add	r2,r3
8000d6fc:	e0 61 21 f9 	mov	r1,8697
8000d700:	ec 01 02 43 	mul	r3,r6,r1
8000d704:	06 02       	add	r2,r3
8000d706:	fe 71 ba 79 	mov	r1,-17799
8000d70a:	ee 01 02 43 	mul	r3,r7,r1
8000d70e:	e4 03 00 03 	add	r3,r2,r3
	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */

    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
8000d712:	fe 72 ec c2 	mov	r2,-4926
8000d716:	a5 34       	mul	r4,r2
8000d718:	fe 71 ef b0 	mov	r1,-4176
8000d71c:	a3 35       	mul	r5,r1
8000d71e:	0a 04       	add	r4,r5
8000d720:	e0 62 52 03 	mov	r2,20995
8000d724:	ec 02 02 45 	mul	r5,r6,r2
8000d728:	e8 05 00 05 	add	r5,r4,r5
8000d72c:	e0 66 1c cd 	mov	r6,7373
8000d730:	ad 37       	mul	r7,r6
8000d732:	ea 07 00 07 	add	r7,r5,r7
	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */

    /* Final output stage */

    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp2, CONST_BITS-PASS1_BITS+1);
8000d736:	f8 0e 00 06 	add	r6,r12,lr
8000d73a:	ec c6 f8 00 	sub	r6,r6,-2048
8000d73e:	ec 07 00 05 	add	r5,r6,r7
8000d742:	ad 45       	asr	r5,0xc
8000d744:	f3 45 ff fc 	st.w	r9[-4],r5
    wsptr[DCTSIZE*3] = (int) DESCALE(tmp10 - tmp2, CONST_BITS-PASS1_BITS+1);
8000d748:	ec 07 01 07 	sub	r7,r6,r7
8000d74c:	ad 47       	asr	r7,0xc
8000d74e:	f3 47 00 5c 	st.w	r9[92],r7
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp12 + tmp0, CONST_BITS-PASS1_BITS+1);
8000d752:	fc 0c 01 0c 	sub	r12,lr,r12
8000d756:	f8 cc f8 00 	sub	r12,r12,-2048
8000d75a:	f8 03 00 0e 	add	lr,r12,r3
8000d75e:	ad 4e       	asr	lr,0xc
8000d760:	93 7e       	st.w	r9[0x1c],lr
    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 - tmp0, CONST_BITS-PASS1_BITS+1);
8000d762:	f8 03 01 03 	sub	r3,r12,r3
8000d766:	ad 43       	asr	r3,0xc
8000d768:	93 f3       	st.w	r9[0x3c],r3
  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
8000d76a:	58 0b       	cp.w	r11,0
8000d76c:	fe 99 ff 68 	brgt	8000d63c <jpeg_idct_4x4+0x24>
8000d770:	40 26       	lddsp	r6,sp[0x8]
8000d772:	fa c5 ff ec 	sub	r5,sp,-20
8000d776:	fa c9 ff cc 	sub	r9,sp,-52
8000d77a:	fa ca ff e4 	sub	r10,sp,-28
8000d77e:	fa ce ff d4 	sub	lr,sp,-44
8000d782:	fa c7 ff d0 	sub	r7,sp,-48
8000d786:	fa cc ff d8 	sub	r12,sp,-40
8000d78a:	fa cb ff e0 	sub	r11,sp,-32
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 4x4 output block.
 */

GLOBAL(void)
jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000d78e:	fa c1 ff 4c 	sub	r1,sp,-180
8000d792:	50 01       	stdsp	sp[0x0],r1
    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */

    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
8000d794:	40 14       	lddsp	r4,sp[0x4]

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 4; ctr++) {
    outptr = output_buf[ctr] + output_col;
8000d796:	6c 08       	ld.w	r8,r6[0x0]
8000d798:	40 40       	lddsp	r0,sp[0x10]
8000d79a:	00 08       	add	r8,r0
    /* It's not clear whether a zero row test is worthwhile here ... */

#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 &&
8000d79c:	f2 f1 ff e4 	ld.w	r1,r9[-28]
8000d7a0:	58 01       	cp.w	r1,0
8000d7a2:	c1 b1       	brne	8000d7d8 <jpeg_idct_4x4+0x1c0>
8000d7a4:	74 03       	ld.w	r3,r10[0x0]
8000d7a6:	58 03       	cp.w	r3,0
8000d7a8:	c1 81       	brne	8000d7d8 <jpeg_idct_4x4+0x1c0>
8000d7aa:	76 03       	ld.w	r3,r11[0x0]
8000d7ac:	58 03       	cp.w	r3,0
8000d7ae:	c1 51       	brne	8000d7d8 <jpeg_idct_4x4+0x1c0>
8000d7b0:	78 03       	ld.w	r3,r12[0x0]
8000d7b2:	58 03       	cp.w	r3,0
8000d7b4:	c1 21       	brne	8000d7d8 <jpeg_idct_4x4+0x1c0>
8000d7b6:	7c 03       	ld.w	r3,lr[0x0]
8000d7b8:	58 03       	cp.w	r3,0
8000d7ba:	c0 f1       	brne	8000d7d8 <jpeg_idct_4x4+0x1c0>
8000d7bc:	6e 03       	ld.w	r3,r7[0x0]
8000d7be:	58 03       	cp.w	r3,0
8000d7c0:	c0 c1       	brne	8000d7d8 <jpeg_idct_4x4+0x1c0>
	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
8000d7c2:	6a 03       	ld.w	r3,r5[0x0]
8000d7c4:	2f 03       	sub	r3,-16
8000d7c6:	e7 d3 c0 aa 	bfextu	r3,r3,0x5,0xa
8000d7ca:	e8 03 07 03 	ld.ub	r3,r4[r3]

      outptr[0] = dcval;
8000d7ce:	b0 83       	st.b	r8[0x0],r3
      outptr[1] = dcval;
8000d7d0:	b0 93       	st.b	r8[0x1],r3
      outptr[2] = dcval;
8000d7d2:	b0 a3       	st.b	r8[0x2],r3
      outptr[3] = dcval;
8000d7d4:	b0 b3       	st.b	r8[0x3],r3

      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
8000d7d6:	c6 38       	rjmp	8000d89c <jpeg_idct_4x4+0x284>
    }
#endif

    /* Even part */

    tmp0 = ((INT32) wsptr[0]) << (CONST_BITS+1);
8000d7d8:	6a 03       	ld.w	r3,r5[0x0]
8000d7da:	af 63       	lsl	r3,0xe

    tmp2 = MULTIPLY((INT32) wsptr[2], FIX_1_847759065)
8000d7dc:	7c 00       	ld.w	r0,lr[0x0]
8000d7de:	fe 72 e7 82 	mov	r2,-6270
8000d7e2:	a5 30       	mul	r0,r2
8000d7e4:	50 20       	stdsp	sp[0x8],r0
8000d7e6:	74 00       	ld.w	r0,r10[0x0]
8000d7e8:	e0 62 3b 21 	mov	r2,15137
8000d7ec:	a5 30       	mul	r0,r2
8000d7ee:	40 22       	lddsp	r2,sp[0x8]
8000d7f0:	00 02       	add	r2,r0
8000d7f2:	50 32       	stdsp	sp[0xc],r2
    z1 = (INT32) wsptr[7];
    z2 = (INT32) wsptr[5];
    z3 = (INT32) wsptr[3];
    z4 = (INT32) wsptr[1];

    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
8000d7f4:	78 00       	ld.w	r0,r12[0x0]
8000d7f6:	e0 62 2e 75 	mov	r2,11893
8000d7fa:	a5 30       	mul	r0,r2
8000d7fc:	50 10       	stdsp	sp[0x4],r0
8000d7fe:	6e 02       	ld.w	r2,r7[0x0]
8000d800:	fe 70 f9 3e 	mov	r0,-1730
8000d804:	a1 32       	mul	r2,r0
8000d806:	40 10       	lddsp	r0,sp[0x4]
8000d808:	04 00       	add	r0,r2
8000d80a:	50 10       	stdsp	sp[0x4],r0
8000d80c:	e0 60 21 f9 	mov	r0,8697
8000d810:	e2 00 02 42 	mul	r2,r1,r0
8000d814:	40 10       	lddsp	r0,sp[0x4]
8000d816:	04 00       	add	r0,r2
8000d818:	50 10       	stdsp	sp[0x4],r0
8000d81a:	76 02       	ld.w	r2,r11[0x0]
8000d81c:	fe 70 ba 79 	mov	r0,-17799
8000d820:	a1 32       	mul	r2,r0
8000d822:	40 10       	lddsp	r0,sp[0x4]
8000d824:	04 00       	add	r0,r2
8000d826:	50 10       	stdsp	sp[0x4],r0
	 + MULTIPLY(z2, FIX_1_451774981) /* sqrt(2) * (c3+c7) */
	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
	 + MULTIPLY(z4, FIX_1_061594337); /* sqrt(2) * (c5+c7) */

    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
8000d828:	78 02       	ld.w	r2,r12[0x0]
8000d82a:	fe 70 ec c2 	mov	r0,-4926
8000d82e:	a1 32       	mul	r2,r0
8000d830:	50 22       	stdsp	sp[0x8],r2
8000d832:	6e 02       	ld.w	r2,r7[0x0]
8000d834:	fe 70 ef b0 	mov	r0,-4176
8000d838:	a1 32       	mul	r2,r0
8000d83a:	40 20       	lddsp	r0,sp[0x8]
8000d83c:	e0 02 00 02 	add	r2,r0,r2
8000d840:	e0 60 52 03 	mov	r0,20995
8000d844:	a1 31       	mul	r1,r0
8000d846:	02 02       	add	r2,r1
8000d848:	e0 61 1c cd 	mov	r1,7373
8000d84c:	76 00       	ld.w	r0,r11[0x0]
8000d84e:	e0 01 02 41 	mul	r1,r0,r1
8000d852:	02 02       	add	r2,r1
	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
	 + MULTIPLY(z4, FIX_2_562915447); /* sqrt(2) * (c1+c3) */

    /* Final output stage */

    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp2,
8000d854:	40 31       	lddsp	r1,sp[0xc]
8000d856:	06 01       	add	r1,r3
8000d858:	fc 21 00 00 	sub	r1,-262144
8000d85c:	e2 02 00 00 	add	r0,r1,r2
8000d860:	e1 d0 c2 6a 	bfextu	r0,r0,0x13,0xa
8000d864:	e8 00 07 00 	ld.ub	r0,r4[r0]
8000d868:	b0 80       	st.b	r8[0x0],r0
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[3] = range_limit[(int) DESCALE(tmp10 - tmp2,
8000d86a:	e2 02 01 02 	sub	r2,r1,r2
8000d86e:	e5 d2 c2 6a 	bfextu	r2,r2,0x13,0xa
8000d872:	e8 02 07 02 	ld.ub	r2,r4[r2]
8000d876:	b0 b2       	st.b	r8[0x3],r2
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp12 + tmp0,
8000d878:	40 32       	lddsp	r2,sp[0xc]
8000d87a:	04 13       	sub	r3,r2
8000d87c:	fc 23 00 00 	sub	r3,-262144
8000d880:	40 11       	lddsp	r1,sp[0x4]
8000d882:	e6 01 00 02 	add	r2,r3,r1
8000d886:	e5 d2 c2 6a 	bfextu	r2,r2,0x13,0xa
8000d88a:	e8 02 07 02 	ld.ub	r2,r4[r2]
8000d88e:	b0 92       	st.b	r8[0x1],r2
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];
    outptr[2] = range_limit[(int) DESCALE(tmp12 - tmp0,
8000d890:	02 13       	sub	r3,r1
8000d892:	e7 d3 c2 6a 	bfextu	r3,r3,0x13,0xa
8000d896:	e8 03 07 03 	ld.ub	r3,r4[r3]
8000d89a:	b0 a3       	st.b	r8[0x2],r3
8000d89c:	2f c6       	sub	r6,-4
8000d89e:	2e 05       	sub	r5,-32
8000d8a0:	2e 09       	sub	r9,-32
8000d8a2:	2e 0a       	sub	r10,-32
8000d8a4:	2e 0e       	sub	lr,-32
8000d8a6:	2e 07       	sub	r7,-32
8000d8a8:	2e 0c       	sub	r12,-32
8000d8aa:	2e 0b       	sub	r11,-32
  }

  /* Pass 2: process 4 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 4; ctr++) {
8000d8ac:	40 00       	lddsp	r0,sp[0x0]
8000d8ae:	00 39       	cp.w	r9,r0
8000d8b0:	fe 91 ff 73 	brne	8000d796 <jpeg_idct_4x4+0x17e>
					  CONST_BITS+PASS1_BITS+3+1)
			    & RANGE_MASK];

    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}
8000d8b4:	2d bd       	sub	sp,-148
8000d8b6:	d8 32       	popm	r0-r7,pc

8000d8b8 <jpeg_idct_2x2>:

GLOBAL(void)
jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
	       JCOEFPTR coef_block,
	       JSAMPARRAY output_buf, JDIMENSION output_col)
{
8000d8b8:	d4 31       	pushm	r0-r7,lr
8000d8ba:	21 3d       	sub	sp,76
8000d8bc:	50 29       	stdsp	sp[0x8],r9
8000d8be:	50 18       	stdsp	sp[0x4],r8
  INT32 tmp0, tmp10, z1;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
8000d8c0:	f8 f8 01 44 	ld.w	r8,r12[324]
8000d8c4:	28 08       	sub	r8,-128
8000d8c6:	50 08       	stdsp	sp[0x0],r8
8000d8c8:	2f ea       	sub	r10,-2
8000d8ca:	77 49       	ld.w	r9,r11[0x50]
8000d8cc:	2f c9       	sub	r9,-4
8000d8ce:	fa cc ff f0 	sub	r12,sp,-16
8000d8d2:	30 7b       	mov	r11,7
8000d8d4:	30 88       	mov	r8,8
  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process columns 2,4,6 */
    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
8000d8d6:	30 0e       	mov	lr,0
    tmp10 = z1 << (CONST_BITS+2);

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    tmp0 = MULTIPLY(z1, - FIX_0_720959822); /* sqrt(2) * (c7-c5+c3-c1) */
8000d8d8:	fe 71 e8 ee 	mov	r1,-5906
    z1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp0 += MULTIPLY(z1, FIX_0_850430095); /* sqrt(2) * (-c1+c3+c5+c7) */
8000d8dc:	e0 62 1b 37 	mov	r2,6967
    z1 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp0 += MULTIPLY(z1, - FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */
8000d8e0:	fe 73 d7 46 	mov	r3,-10426
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process columns 2,4,6 */
    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
      continue;
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*3] == 0 &&
8000d8e4:	30 00       	mov	r0,0
8000d8e6:	c0 68       	rjmp	8000d8f2 <jpeg_idct_2x2+0x3a>
  INT32 tmp0, tmp10, z1;
  JCOEFPTR inptr;
  ISLOW_MULT_TYPE * quantptr;
  int * wsptr;
  JSAMPROW outptr;
  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
8000d8e8:	20 18       	sub	r8,1
8000d8ea:	2f ea       	sub	r10,-2
8000d8ec:	2f c9       	sub	r9,-4
8000d8ee:	2f cc       	sub	r12,-4
8000d8f0:	20 1b       	sub	r11,1
  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
    /* Don't bother to process columns 2,4,6 */
    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
8000d8f2:	58 68       	cp.w	r8,6
8000d8f4:	5f 06       	sreq	r6
8000d8f6:	58 48       	cp.w	r8,4
8000d8f8:	5f 07       	sreq	r7
8000d8fa:	0e 46       	or	r6,r7
8000d8fc:	fc 06 18 00 	cp.b	r6,lr
8000d900:	c4 e1       	brne	8000d99c <jpeg_idct_2x2+0xe4>
8000d902:	58 28       	cp.w	r8,2
8000d904:	cf 20       	breq	8000d8e8 <jpeg_idct_2x2+0x30>
      continue;
    if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*3] == 0 &&
8000d906:	94 77       	ld.sh	r7,r10[0xe]
8000d908:	58 07       	cp.w	r7,0
8000d90a:	c1 b1       	brne	8000d940 <jpeg_idct_2x2+0x88>
8000d90c:	f5 06 00 2e 	ld.sh	r6,r10[46]
8000d910:	e0 06 19 00 	cp.h	r6,r0
8000d914:	c1 61       	brne	8000d940 <jpeg_idct_2x2+0x88>
8000d916:	f5 06 00 4e 	ld.sh	r6,r10[78]
8000d91a:	e0 06 19 00 	cp.h	r6,r0
8000d91e:	c1 11       	brne	8000d940 <jpeg_idct_2x2+0x88>
8000d920:	f5 06 00 6e 	ld.sh	r6,r10[110]
8000d924:	e0 06 19 00 	cp.h	r6,r0
8000d928:	c0 c1       	brne	8000d940 <jpeg_idct_2x2+0x88>
	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*7] == 0) {
      /* AC terms all zero; we need not examine terms 2,4,6 for 2x2 output */
      int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
8000d92a:	f5 06 ff fe 	ld.sh	r6,r10[-2]
8000d92e:	f2 f7 ff fc 	ld.w	r7,r9[-4]
8000d932:	ec 07 02 47 	mul	r7,r6,r7
8000d936:	a3 67       	lsl	r7,0x2

      wsptr[DCTSIZE*0] = dcval;
8000d938:	f9 47 ff fc 	st.w	r12[-4],r7
      wsptr[DCTSIZE*1] = dcval;
8000d93c:	99 77       	st.w	r12[0x1c],r7

      continue;
8000d93e:	c2 f8       	rjmp	8000d99c <jpeg_idct_2x2+0xe4>
    tmp10 = z1 << (CONST_BITS+2);

    /* Odd part */

    z1 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
    tmp0 = MULTIPLY(z1, - FIX_0_720959822); /* sqrt(2) * (c7-c5+c3-c1) */
8000d940:	f2 f5 00 dc 	ld.w	r5,r9[220]
8000d944:	a3 35       	mul	r5,r1
8000d946:	f5 04 00 6e 	ld.sh	r4,r10[110]
8000d94a:	a9 35       	mul	r5,r4
    z1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
    tmp0 += MULTIPLY(z1, FIX_0_850430095); /* sqrt(2) * (-c1+c3+c5+c7) */
8000d94c:	f2 f6 00 9c 	ld.w	r6,r9[156]
8000d950:	a5 36       	mul	r6,r2
8000d952:	f5 04 00 4e 	ld.sh	r4,r10[78]
8000d956:	a9 36       	mul	r6,r4
8000d958:	0a 06       	add	r6,r5
    z1 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
    tmp0 += MULTIPLY(z1, - FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */
8000d95a:	73 74       	ld.w	r4,r9[0x5c]
8000d95c:	a7 34       	mul	r4,r3
8000d95e:	f5 05 00 2e 	ld.sh	r5,r10[46]
8000d962:	e8 05 02 45 	mul	r5,r4,r5
8000d966:	0a 06       	add	r6,r5
    z1 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
    tmp0 += MULTIPLY(z1, FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */
8000d968:	72 75       	ld.w	r5,r9[0x1c]
8000d96a:	e0 64 73 fc 	mov	r4,29692
8000d96e:	a9 35       	mul	r5,r4
8000d970:	ea 07 02 47 	mul	r7,r5,r7
8000d974:	ec 07 00 07 	add	r7,r6,r7

    /* Final output stage */

    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp0, CONST_BITS-PASS1_BITS+2);
8000d978:	f5 05 ff fe 	ld.sh	r5,r10[-2]
8000d97c:	f2 f6 ff fc 	ld.w	r6,r9[-4]
8000d980:	ea 06 02 46 	mul	r6,r5,r6
8000d984:	af 76       	lsl	r6,0xf
8000d986:	ec c6 f0 00 	sub	r6,r6,-4096
8000d98a:	ec 07 00 05 	add	r5,r6,r7
8000d98e:	ad 55       	asr	r5,0xd
8000d990:	f9 45 ff fc 	st.w	r12[-4],r5
    wsptr[DCTSIZE*1] = (int) DESCALE(tmp10 - tmp0, CONST_BITS-PASS1_BITS+2);
8000d994:	ec 07 01 07 	sub	r7,r6,r7
8000d998:	ad 57       	asr	r7,0xd
8000d99a:	99 77       	st.w	r12[0x1c],r7
  /* Pass 1: process columns from input, store into work array. */

  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  wsptr = workspace;
  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
8000d99c:	58 0b       	cp.w	r11,0
8000d99e:	fe 99 ff a5 	brgt	8000d8e8 <jpeg_idct_2x2+0x30>
8000d9a2:	40 2c       	lddsp	r12,sp[0x8]
8000d9a4:	fa ce ff f4 	sub	lr,sp,-12
8000d9a8:	fa c8 ff d4 	sub	r8,sp,-44
8000d9ac:	fa cb ff d8 	sub	r11,sp,-40
8000d9b0:	fa ca ff e0 	sub	r10,sp,-32
8000d9b4:	fa c9 ff e8 	sub	r9,sp,-24
 * Perform dequantization and inverse DCT on one block of coefficients,
 * producing a reduced-size 2x2 output block.
 */

GLOBAL(void)
jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
8000d9b8:	fa c4 ff 94 	sub	r4,sp,-108

    tmp10 = ((INT32) wsptr[0]) << (CONST_BITS+2);

    /* Odd part */

    tmp0 = MULTIPLY((INT32) wsptr[7], - FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */
8000d9bc:	e0 61 1b 37 	mov	r1,6967
8000d9c0:	fe 72 e8 ee 	mov	r2,-5906

  /* Pass 2: process 2 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 2; ctr++) {
    outptr = output_buf[ctr] + output_col;
8000d9c4:	78 07       	ld.w	r7,r12[0x0]
8000d9c6:	40 13       	lddsp	r3,sp[0x4]
8000d9c8:	06 07       	add	r7,r3
    /* It's not clear whether a zero row test is worthwhile here ... */

#ifndef NO_ZERO_ROW_TEST
    if (wsptr[1] == 0 && wsptr[3] == 0 && wsptr[5] == 0 && wsptr[7] == 0) {
8000d9ca:	f0 f6 ff e4 	ld.w	r6,r8[-28]
8000d9ce:	58 06       	cp.w	r6,0
8000d9d0:	c1 41       	brne	8000d9f8 <jpeg_idct_2x2+0x140>
8000d9d2:	72 05       	ld.w	r5,r9[0x0]
8000d9d4:	58 05       	cp.w	r5,0
8000d9d6:	c1 11       	brne	8000d9f8 <jpeg_idct_2x2+0x140>
8000d9d8:	74 05       	ld.w	r5,r10[0x0]
8000d9da:	58 05       	cp.w	r5,0
8000d9dc:	c0 e1       	brne	8000d9f8 <jpeg_idct_2x2+0x140>
8000d9de:	76 05       	ld.w	r5,r11[0x0]
8000d9e0:	58 05       	cp.w	r5,0
8000d9e2:	c0 b1       	brne	8000d9f8 <jpeg_idct_2x2+0x140>
      /* AC terms all zero */
      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
				  & RANGE_MASK];
8000d9e4:	7c 06       	ld.w	r6,lr[0x0]
8000d9e6:	2f 06       	sub	r6,-16
8000d9e8:	ed d6 c0 aa 	bfextu	r6,r6,0x5,0xa
8000d9ec:	40 00       	lddsp	r0,sp[0x0]
8000d9ee:	e0 06 07 06 	ld.ub	r6,r0[r6]

      outptr[0] = dcval;
8000d9f2:	ae 86       	st.b	r7[0x0],r6
      outptr[1] = dcval;
8000d9f4:	ae 96       	st.b	r7[0x1],r6

      wsptr += DCTSIZE;		/* advance pointer to next row */
      continue;
8000d9f6:	c2 48       	rjmp	8000da3e <jpeg_idct_2x2+0x186>

    tmp10 = ((INT32) wsptr[0]) << (CONST_BITS+2);

    /* Odd part */

    tmp0 = MULTIPLY((INT32) wsptr[7], - FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */
8000d9f8:	74 00       	ld.w	r0,r10[0x0]
8000d9fa:	a3 30       	mul	r0,r1
8000d9fc:	76 05       	ld.w	r5,r11[0x0]
8000d9fe:	a5 35       	mul	r5,r2
8000da00:	e0 05 00 05 	add	r5,r0,r5
8000da04:	e0 63 73 fc 	mov	r3,29692
8000da08:	a7 36       	mul	r6,r3
8000da0a:	ea 06 00 06 	add	r6,r5,r6
8000da0e:	72 05       	ld.w	r5,r9[0x0]
8000da10:	fe 70 d7 46 	mov	r0,-10426
8000da14:	a1 35       	mul	r5,r0
8000da16:	0a 06       	add	r6,r5
	 + MULTIPLY((INT32) wsptr[3], - FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */
	 + MULTIPLY((INT32) wsptr[1], FIX_3_624509785); /* sqrt(2) * (c1+c3+c5+c7) */

    /* Final output stage */

    outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp0,
8000da18:	7c 05       	ld.w	r5,lr[0x0]
8000da1a:	af 75       	lsl	r5,0xf
8000da1c:	f8 25 00 00 	sub	r5,-524288
8000da20:	ea 06 00 00 	add	r0,r5,r6
8000da24:	e1 d0 c2 8a 	bfextu	r0,r0,0x14,0xa
8000da28:	40 03       	lddsp	r3,sp[0x0]
8000da2a:	e6 00 07 00 	ld.ub	r0,r3[r0]
8000da2e:	ae 80       	st.b	r7[0x0],r0
					  CONST_BITS+PASS1_BITS+3+2)
			    & RANGE_MASK];
    outptr[1] = range_limit[(int) DESCALE(tmp10 - tmp0,
8000da30:	ea 06 01 06 	sub	r6,r5,r6
8000da34:	ed d6 c2 8a 	bfextu	r6,r6,0x14,0xa
8000da38:	e6 06 07 06 	ld.ub	r6,r3[r6]
8000da3c:	ae 96       	st.b	r7[0x1],r6
8000da3e:	2f cc       	sub	r12,-4
8000da40:	2e 0e       	sub	lr,-32
8000da42:	2e 08       	sub	r8,-32
8000da44:	2e 0b       	sub	r11,-32
8000da46:	2e 0a       	sub	r10,-32
8000da48:	2e 09       	sub	r9,-32
  }

  /* Pass 2: process 2 rows from work array, store into output array. */

  wsptr = workspace;
  for (ctr = 0; ctr < 2; ctr++) {
8000da4a:	08 38       	cp.w	r8,r4
8000da4c:	cb c1       	brne	8000d9c4 <jpeg_idct_2x2+0x10c>
					  CONST_BITS+PASS1_BITS+3+2)
			    & RANGE_MASK];

    wsptr += DCTSIZE;		/* advance pointer to next row */
  }
}
8000da4e:	2e dd       	sub	sp,-76
8000da50:	d8 32       	popm	r0-r7,pc

8000da52 <jpeg_idct_1x1>:
  /* We hardly need an inverse DCT routine for this: just take the
   * average pixel value, which is one-eighth of the DC coefficient.
   */
  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);
  dcval = (int) DESCALE((INT32) dcval, 3);
8000da52:	94 0a       	ld.sh	r10,r10[0x0]
8000da54:	77 4b       	ld.w	r11,r11[0x50]
8000da56:	76 0b       	ld.w	r11,r11[0x0]
8000da58:	b7 3a       	mul	r10,r11
8000da5a:	2f ca       	sub	r10,-4

  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];
8000da5c:	72 09       	ld.w	r9,r9[0x0]
8000da5e:	f5 da c0 6a 	bfextu	r10,r10,0x3,0xa
8000da62:	f8 fb 01 44 	ld.w	r11,r12[324]
8000da66:	f6 0a 00 0a 	add	r10,r11,r10
8000da6a:	f5 3a 00 80 	ld.ub	r10,r10[128]
8000da6e:	f2 08 0b 0a 	st.b	r9[r8],r10
}
8000da72:	5e fc       	retal	r12

8000da74 <out_of_memory>:

LOCAL(void)
out_of_memory (j_common_ptr cinfo, int which)
/* Report an out-of-memory error and stop execution */
/* If we compiled MEM_STATS support, report alloc requests before dying */
{
8000da74:	d4 01       	pushm	lr
#ifdef MEM_STATS
  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
#endif
  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
8000da76:	78 09       	ld.w	r9,r12[0x0]
8000da78:	33 6a       	mov	r10,54
8000da7a:	93 5a       	st.w	r9[0x14],r10
8000da7c:	78 09       	ld.w	r9,r12[0x0]
8000da7e:	93 6b       	st.w	r9[0x18],r11
8000da80:	78 08       	ld.w	r8,r12[0x0]
8000da82:	70 08       	ld.w	r8,r8[0x0]
8000da84:	5d 18       	icall	r8
}
8000da86:	d8 02       	popm	pc

8000da88 <do_sarray_io>:


LOCAL(void)
do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual sample array */
{
8000da88:	d4 31       	pushm	r0-r7,lr
8000da8a:	20 1d       	sub	sp,4
8000da8c:	18 91       	mov	r1,r12
8000da8e:	16 97       	mov	r7,r11
8000da90:	14 92       	mov	r2,r10
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
8000da92:	76 23       	ld.w	r3,r11[0x8]
8000da94:	06 90       	mov	r0,r3
  file_offset = ptr->cur_start_row * bytesperrow;
8000da96:	76 69       	ld.w	r9,r11[0x18]
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
8000da98:	76 48       	ld.w	r8,r11[0x10]
8000da9a:	58 08       	cp.w	r8,0
8000da9c:	e0 8a 00 47 	brle	8000db2a <do_sarray_io+0xa2>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
8000daa0:	76 5a       	ld.w	r10,r11[0x14]
8000daa2:	f0 0a 0d 48 	min	r8,r8,r10
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
8000daa6:	76 7a       	ld.w	r10,r11[0x1c]
8000daa8:	12 1a       	sub	r10,r9
8000daaa:	f0 0a 0d 48 	min	r8,r8,r10
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
8000daae:	76 1a       	ld.w	r10,r11[0x4]
8000dab0:	12 1a       	sub	r10,r9
8000dab2:	f0 0a 0d 48 	min	r8,r8,r10
    if (rows <= 0)		/* this chunk might be past end of file! */
8000dab6:	58 08       	cp.w	r8,0
8000dab8:	e0 8a 00 39 	brle	8000db2a <do_sarray_io+0xa2>
/* Do backing store read or write of a virtual sample array */
{
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
  file_offset = ptr->cur_start_row * bytesperrow;
8000dabc:	f2 03 02 43 	mul	r3,r9,r3
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
    if (writing)
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
8000dac0:	f6 c9 ff d0 	sub	r9,r11,-48
8000dac4:	50 09       	stdsp	sp[0x0],r9
8000dac6:	30 05       	mov	r5,0
8000dac8:	c1 48       	rjmp	8000daf0 <do_sarray_io+0x68>
  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
8000daca:	0a 18       	sub	r8,r5
8000dacc:	f0 09 0d 48 	min	r8,r8,r9
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
8000dad0:	6e 69       	ld.w	r9,r7[0x18]
8000dad2:	ea 09 00 09 	add	r9,r5,r9
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
8000dad6:	6e 7a       	ld.w	r10,r7[0x1c]
8000dad8:	12 1a       	sub	r10,r9
8000dada:	f0 0a 0d 48 	min	r8,r8,r10
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
8000dade:	6e 1a       	ld.w	r10,r7[0x4]
8000dae0:	f4 09 01 09 	sub	r9,r10,r9
8000dae4:	f0 09 0d 48 	min	r8,r8,r9
    if (rows <= 0)		/* this chunk might be past end of file! */
8000dae8:	58 08       	cp.w	r8,0
8000daea:	e0 8a 00 20 	brle	8000db2a <do_sarray_io+0xa2>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
8000daee:	08 03       	add	r3,r4
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
8000daf0:	f0 00 02 44 	mul	r4,r8,r0
    if (writing)
8000daf4:	58 02       	cp.w	r2,0
8000daf6:	c0 b0       	breq	8000db0c <do_sarray_io+0x84>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
8000daf8:	6e 0a       	ld.w	r10,r7[0x0]
8000dafa:	6e d6       	ld.w	r6,r7[0x34]
8000dafc:	08 98       	mov	r8,r4
8000dafe:	06 99       	mov	r9,r3
8000db00:	f4 05 03 2a 	ld.w	r10,r10[r5<<0x2]
8000db04:	40 0b       	lddsp	r11,sp[0x0]
8000db06:	02 9c       	mov	r12,r1
8000db08:	5d 16       	icall	r6
8000db0a:	c0 a8       	rjmp	8000db1e <do_sarray_io+0x96>
					    (void FAR *) ptr->mem_buffer[i],
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
8000db0c:	6e 0a       	ld.w	r10,r7[0x0]
8000db0e:	6e c6       	ld.w	r6,r7[0x30]
8000db10:	08 98       	mov	r8,r4
8000db12:	06 99       	mov	r9,r3
8000db14:	f4 05 03 2a 	ld.w	r10,r10[r5<<0x2]
8000db18:	40 0b       	lddsp	r11,sp[0x0]
8000db1a:	02 9c       	mov	r12,r1
8000db1c:	5d 16       	icall	r6
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
8000db1e:	6e 59       	ld.w	r9,r7[0x14]
8000db20:	12 05       	add	r5,r9
8000db22:	6e 48       	ld.w	r8,r7[0x10]
8000db24:	0a 38       	cp.w	r8,r5
8000db26:	fe 99 ff d2 	brgt	8000daca <do_sarray_io+0x42>
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
  }
}
8000db2a:	2f fd       	sub	sp,-4
8000db2c:	d8 32       	popm	r0-r7,pc

8000db2e <do_barray_io>:


LOCAL(void)
do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
/* Do backing store read or write of a virtual coefficient-block array */
{
8000db2e:	d4 31       	pushm	r0-r7,lr
8000db30:	20 1d       	sub	sp,4
8000db32:	18 91       	mov	r1,r12
8000db34:	16 97       	mov	r7,r11
8000db36:	14 92       	mov	r2,r10
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
8000db38:	76 23       	ld.w	r3,r11[0x8]
8000db3a:	a7 73       	lsl	r3,0x7
8000db3c:	06 90       	mov	r0,r3
  file_offset = ptr->cur_start_row * bytesperrow;
8000db3e:	76 69       	ld.w	r9,r11[0x18]
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
8000db40:	76 48       	ld.w	r8,r11[0x10]
8000db42:	58 08       	cp.w	r8,0
8000db44:	e0 8a 00 46 	brle	8000dbd0 <do_barray_io+0xa2>
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
8000db48:	76 5a       	ld.w	r10,r11[0x14]
8000db4a:	f0 0a 0d 48 	min	r8,r8,r10
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
8000db4e:	76 7a       	ld.w	r10,r11[0x1c]
8000db50:	12 1a       	sub	r10,r9
8000db52:	f0 0a 0d 48 	min	r8,r8,r10
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
8000db56:	76 1a       	ld.w	r10,r11[0x4]
8000db58:	12 1a       	sub	r10,r9
8000db5a:	f0 0a 0d 48 	min	r8,r8,r10
    if (rows <= 0)		/* this chunk might be past end of file! */
8000db5e:	58 08       	cp.w	r8,0
8000db60:	e0 8a 00 38 	brle	8000dbd0 <do_barray_io+0xa2>
/* Do backing store read or write of a virtual coefficient-block array */
{
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
  file_offset = ptr->cur_start_row * bytesperrow;
8000db64:	b3 33       	mul	r3,r9
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
    if (writing)
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
8000db66:	f6 c9 ff d0 	sub	r9,r11,-48
8000db6a:	50 09       	stdsp	sp[0x0],r9
8000db6c:	30 05       	mov	r5,0
8000db6e:	c1 48       	rjmp	8000db96 <do_barray_io+0x68>
  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
    /* One chunk, but check for short chunk at end of buffer */
    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
8000db70:	0a 18       	sub	r8,r5
8000db72:	f0 09 0d 48 	min	r8,r8,r9
    /* Transfer no more than is currently defined */
    thisrow = (long) ptr->cur_start_row + i;
8000db76:	6e 69       	ld.w	r9,r7[0x18]
8000db78:	ea 09 00 09 	add	r9,r5,r9
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
8000db7c:	6e 7a       	ld.w	r10,r7[0x1c]
8000db7e:	12 1a       	sub	r10,r9
8000db80:	f0 0a 0d 48 	min	r8,r8,r10
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
8000db84:	6e 1a       	ld.w	r10,r7[0x4]
8000db86:	f4 09 01 09 	sub	r9,r10,r9
8000db8a:	f0 09 0d 48 	min	r8,r8,r9
    if (rows <= 0)		/* this chunk might be past end of file! */
8000db8e:	58 08       	cp.w	r8,0
8000db90:	e0 8a 00 20 	brle	8000dbd0 <do_barray_io+0xa2>
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
8000db94:	08 03       	add	r3,r4
    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
    /* Transfer no more than fits in file */
    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
    if (rows <= 0)		/* this chunk might be past end of file! */
      break;
    byte_count = rows * bytesperrow;
8000db96:	f0 00 02 44 	mul	r4,r8,r0
    if (writing)
8000db9a:	58 02       	cp.w	r2,0
8000db9c:	c0 b0       	breq	8000dbb2 <do_barray_io+0x84>
      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
8000db9e:	6e 0a       	ld.w	r10,r7[0x0]
8000dba0:	6e d6       	ld.w	r6,r7[0x34]
8000dba2:	08 98       	mov	r8,r4
8000dba4:	06 99       	mov	r9,r3
8000dba6:	f4 05 03 2a 	ld.w	r10,r10[r5<<0x2]
8000dbaa:	40 0b       	lddsp	r11,sp[0x0]
8000dbac:	02 9c       	mov	r12,r1
8000dbae:	5d 16       	icall	r6
8000dbb0:	c0 a8       	rjmp	8000dbc4 <do_barray_io+0x96>
					    (void FAR *) ptr->mem_buffer[i],
					    file_offset, byte_count);
    else
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
8000dbb2:	6e 0a       	ld.w	r10,r7[0x0]
8000dbb4:	6e c6       	ld.w	r6,r7[0x30]
8000dbb6:	08 98       	mov	r8,r4
8000dbb8:	06 99       	mov	r9,r3
8000dbba:	f4 05 03 2a 	ld.w	r10,r10[r5<<0x2]
8000dbbe:	40 0b       	lddsp	r11,sp[0x0]
8000dbc0:	02 9c       	mov	r12,r1
8000dbc2:	5d 16       	icall	r6
  long bytesperrow, file_offset, byte_count, rows, thisrow, i;

  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
  file_offset = ptr->cur_start_row * bytesperrow;
  /* Loop to read or write each allocation chunk in mem_buffer */
  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
8000dbc4:	6e 59       	ld.w	r9,r7[0x14]
8000dbc6:	12 05       	add	r5,r9
8000dbc8:	6e 48       	ld.w	r8,r7[0x10]
8000dbca:	0a 38       	cp.w	r8,r5
8000dbcc:	fe 99 ff d2 	brgt	8000db70 <do_barray_io+0x42>
      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
					   (void FAR *) ptr->mem_buffer[i],
					   file_offset, byte_count);
    file_offset += byte_count;
  }
}
8000dbd0:	2f fd       	sub	sp,-4
8000dbd2:	d8 32       	popm	r0-r7,pc

8000dbd4 <alloc_small>:


METHODDEF(void *)
alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "small" object */
{
8000dbd4:	d4 31       	pushm	r0-r7,lr
8000dbd6:	18 95       	mov	r5,r12
8000dbd8:	16 93       	mov	r3,r11
8000dbda:	14 97       	mov	r7,r10
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000dbdc:	78 11       	ld.w	r1,r12[0x4]
  small_pool_ptr hdr_ptr, prev_hdr_ptr;
  char * data_ptr;
  size_t odd_bytes, min_request, slop;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
8000dbde:	e0 68 c9 f4 	mov	r8,51700
8000dbe2:	ea 18 3b 9a 	orh	r8,0x3b9a
8000dbe6:	10 3a       	cp.w	r10,r8
8000dbe8:	e0 88 00 05 	brls	8000dbf2 <alloc_small+0x1e>
    out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
8000dbec:	30 1b       	mov	r11,1
8000dbee:	f0 1f 00 38 	mcall	8000dccc <alloc_small+0xf8>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
8000dbf2:	f1 d7 c0 03 	bfextu	r8,r7,0x0,0x3
  if (odd_bytes > 0)
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
8000dbf6:	f7 b7 01 f8 	subne	r7,-8
8000dbfa:	ef d8 e1 17 	subne	r7,r7,r8

  /* See if space is available in any existing pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
8000dbfe:	58 13       	cp.w	r3,1
8000dc00:	e0 88 00 0b 	brls	8000dc16 <alloc_small+0x42>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
8000dc04:	6a 08       	ld.w	r8,r5[0x0]
8000dc06:	30 e9       	mov	r9,14
8000dc08:	91 59       	st.w	r8[0x14],r9
8000dc0a:	6a 08       	ld.w	r8,r5[0x0]
8000dc0c:	91 63       	st.w	r8[0x18],r3
8000dc0e:	6a 08       	ld.w	r8,r5[0x0]
8000dc10:	70 08       	ld.w	r8,r8[0x0]
8000dc12:	0a 9c       	mov	r12,r5
8000dc14:	5d 18       	icall	r8
  prev_hdr_ptr = NULL;
  hdr_ptr = mem->small_list[pool_id];
8000dc16:	e6 c8 ff f3 	sub	r8,r3,-13
8000dc1a:	e2 08 03 2c 	ld.w	r12,r1[r8<<0x2]
  while (hdr_ptr != NULL) {
8000dc1e:	58 0c       	cp.w	r12,0
8000dc20:	c5 10       	breq	8000dcc2 <alloc_small+0xee>
    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
8000dc22:	78 28       	ld.w	r8,r12[0x8]
8000dc24:	10 37       	cp.w	r7,r8
8000dc26:	e0 8b 00 07 	brhi	8000dc34 <alloc_small+0x60>
8000dc2a:	c3 b8       	rjmp	8000dca0 <alloc_small+0xcc>
8000dc2c:	78 28       	ld.w	r8,r12[0x8]
8000dc2e:	10 37       	cp.w	r7,r8
8000dc30:	e0 88 00 38 	brls	8000dca0 <alloc_small+0xcc>
8000dc34:	18 90       	mov	r0,r12
      break;			/* found pool with enough space */
    prev_hdr_ptr = hdr_ptr;
    hdr_ptr = hdr_ptr->hdr.next;
8000dc36:	78 0c       	ld.w	r12,r12[0x0]
  /* See if space is available in any existing pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
  prev_hdr_ptr = NULL;
  hdr_ptr = mem->small_list[pool_id];
  while (hdr_ptr != NULL) {
8000dc38:	58 0c       	cp.w	r12,0
8000dc3a:	cf 91       	brne	8000dc2c <alloc_small+0x58>
8000dc3c:	c3 e8       	rjmp	8000dcb8 <alloc_small+0xe4>
  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
      slop = first_pool_slop[pool_id];
8000dc3e:	4a 58       	lddpc	r8,8000dcd0 <alloc_small+0xfc>
8000dc40:	f0 03 03 26 	ld.w	r6,r8[r3<<0x2]
8000dc44:	c0 48       	rjmp	8000dc4c <alloc_small+0x78>
    else
      slop = extra_pool_slop[pool_id];
8000dc46:	4a 48       	lddpc	r8,8000dcd4 <alloc_small+0x100>
8000dc48:	f0 03 03 26 	ld.w	r6,r8[r3<<0x2]
    /* Don't ask for more than MAX_ALLOC_CHUNK */
    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
8000dc4c:	e0 68 ca 00 	mov	r8,51712
8000dc50:	ea 18 3b 9a 	orh	r8,0x3b9a
8000dc54:	04 18       	sub	r8,r2
8000dc56:	10 36       	cp.w	r6,r8
8000dc58:	f0 06 17 b0 	movhi	r6,r8
      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
    /* Try to get space, if fail reduce slop and try again */
    for (;;) {
      hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
8000dc5c:	ec 02 00 04 	add	r4,r6,r2
8000dc60:	08 9b       	mov	r11,r4
8000dc62:	0a 9c       	mov	r12,r5
8000dc64:	f0 1f 00 1d 	mcall	8000dcd8 <alloc_small+0x104>
      if (hdr_ptr != NULL)
8000dc68:	c0 b1       	brne	8000dc7e <alloc_small+0xaa>
	break;
      slop /= 2;
8000dc6a:	a1 96       	lsr	r6,0x1
      if (slop < MIN_SLOP)	/* give up when it gets real small */
8000dc6c:	e0 46 00 31 	cp.w	r6,49
8000dc70:	fe 9b ff f6 	brhi	8000dc5c <alloc_small+0x88>
	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
8000dc74:	30 2b       	mov	r11,2
8000dc76:	0a 9c       	mov	r12,r5
8000dc78:	f0 1f 00 15 	mcall	8000dccc <alloc_small+0xf8>
8000dc7c:	cf 0b       	rjmp	8000dc5c <alloc_small+0x88>
    }
    mem->total_space_allocated += min_request + slop;
8000dc7e:	63 38       	ld.w	r8,r1[0x4c]
8000dc80:	f0 04 00 04 	add	r4,r8,r4
8000dc84:	e3 44 00 4c 	st.w	r1[76],r4
    /* Success, initialize the new pool header and add to end of list */
    hdr_ptr->hdr.next = NULL;
8000dc88:	30 08       	mov	r8,0
8000dc8a:	99 08       	st.w	r12[0x0],r8
    hdr_ptr->hdr.bytes_used = 0;
8000dc8c:	99 18       	st.w	r12[0x4],r8
    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
8000dc8e:	0e 06       	add	r6,r7
8000dc90:	99 26       	st.w	r12[0x8],r6
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
8000dc92:	58 00       	cp.w	r0,0
8000dc94:	c0 51       	brne	8000dc9e <alloc_small+0xca>
      mem->small_list[pool_id] = hdr_ptr;
8000dc96:	2f 33       	sub	r3,-13
8000dc98:	e2 03 09 2c 	st.w	r1[r3<<0x2],r12
8000dc9c:	c0 28       	rjmp	8000dca0 <alloc_small+0xcc>
    else
      prev_hdr_ptr->hdr.next = hdr_ptr;
8000dc9e:	81 0c       	st.w	r0[0x0],r12
  }

  /* OK, allocate the object from the current pool */
  data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
8000dca0:	f8 c9 ff f4 	sub	r9,r12,-12
  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
8000dca4:	78 18       	ld.w	r8,r12[0x4]
  hdr_ptr->hdr.bytes_used += sizeofobject;
8000dca6:	ee 08 00 0a 	add	r10,r7,r8
8000dcaa:	99 1a       	st.w	r12[0x4],r10
  hdr_ptr->hdr.bytes_left -= sizeofobject;
8000dcac:	78 2a       	ld.w	r10,r12[0x8]
8000dcae:	0e 1a       	sub	r10,r7
8000dcb0:	99 2a       	st.w	r12[0x8],r10

  return (void *) data_ptr;
}
8000dcb2:	f2 08 00 0c 	add	r12,r9,r8
8000dcb6:	d8 32       	popm	r0-r7,pc
  }

  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
8000dcb8:	ee c2 ff f4 	sub	r2,r7,-12
    if (prev_hdr_ptr == NULL)	/* first pool in class? */
8000dcbc:	58 00       	cp.w	r0,0
8000dcbe:	cc 41       	brne	8000dc46 <alloc_small+0x72>
8000dcc0:	cb fb       	rjmp	8000dc3e <alloc_small+0x6a>
  }

  /* Time to make a new pool? */
  if (hdr_ptr == NULL) {
    /* min_request is what we need now, slop is what will be leftover */
    min_request = sizeofobject + SIZEOF(small_pool_hdr);
8000dcc2:	ee c2 ff f4 	sub	r2,r7,-12
8000dcc6:	30 00       	mov	r0,0
8000dcc8:	cb bb       	rjmp	8000dc3e <alloc_small+0x6a>
8000dcca:	00 00       	add	r0,r0
8000dccc:	80 00       	ld.sh	r0,r0[0x0]
8000dcce:	da 74       	*unknown*
8000dcd0:	80 01       	ld.sh	r1,r0[0x0]
8000dcd2:	fb 40 80 01 	st.w	sp[-32767],r0
8000dcd6:	fb 38 80 00 	ld.ub	r8,sp[-32768]
8000dcda:	e5 48 eb cd 	st.w	r2[-5171],r8

8000dcdc <request_virt_barray>:
METHODDEF(jvirt_barray_ptr)
request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION blocksperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D coefficient-block array */
{
8000dcdc:	eb cd 40 fe 	pushm	r1-r7,lr
8000dce0:	18 97       	mov	r7,r12
8000dce2:	16 96       	mov	r6,r11
8000dce4:	14 91       	mov	r1,r10
8000dce6:	12 93       	mov	r3,r9
8000dce8:	10 94       	mov	r4,r8
8000dcea:	40 82       	lddsp	r2,sp[0x20]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000dcec:	78 15       	ld.w	r5,r12[0x4]
  jvirt_barray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
8000dcee:	58 1b       	cp.w	r11,1
8000dcf0:	c0 90       	breq	8000dd02 <request_virt_barray+0x26>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
8000dcf2:	78 08       	ld.w	r8,r12[0x0]
8000dcf4:	30 e9       	mov	r9,14
8000dcf6:	91 59       	st.w	r8[0x14],r9
8000dcf8:	78 08       	ld.w	r8,r12[0x0]
8000dcfa:	91 6b       	st.w	r8[0x18],r11
8000dcfc:	78 08       	ld.w	r8,r12[0x0]
8000dcfe:	70 08       	ld.w	r8,r8[0x0]
8000dd00:	5d 18       	icall	r8

  /* get control block */
  result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
8000dd02:	e0 6a 00 80 	mov	r10,128
8000dd06:	0c 9b       	mov	r11,r6
8000dd08:	0e 9c       	mov	r12,r7
8000dd0a:	f0 1f 00 08 	mcall	8000dd28 <request_virt_barray+0x4c>
					  SIZEOF(struct jvirt_barray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
8000dd0e:	30 09       	mov	r9,0
8000dd10:	99 09       	st.w	r12[0x0],r9
  result->rows_in_array = numrows;
8000dd12:	99 14       	st.w	r12[0x4],r4
  result->blocksperrow = blocksperrow;
8000dd14:	99 23       	st.w	r12[0x8],r3
  result->maxaccess = maxaccess;
8000dd16:	99 32       	st.w	r12[0xc],r2
  result->pre_zero = pre_zero;
8000dd18:	99 81       	st.w	r12[0x20],r1
  result->b_s_open = FALSE;	/* no associated backing-store object */
8000dd1a:	99 a9       	st.w	r12[0x28],r9
  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
8000dd1c:	6b 29       	ld.w	r9,r5[0x48]
8000dd1e:	99 b9       	st.w	r12[0x2c],r9
  mem->virt_barray_list = result;
8000dd20:	eb 4c 00 48 	st.w	r5[72],r12

  return result;
}
8000dd24:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000dd28:	80 00       	ld.sh	r0,r0[0x0]
8000dd2a:	db d4       	*unknown*

8000dd2c <request_virt_sarray>:
METHODDEF(jvirt_sarray_ptr)
request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
		     JDIMENSION samplesperrow, JDIMENSION numrows,
		     JDIMENSION maxaccess)
/* Request a virtual 2-D sample array */
{
8000dd2c:	eb cd 40 fe 	pushm	r1-r7,lr
8000dd30:	18 97       	mov	r7,r12
8000dd32:	16 96       	mov	r6,r11
8000dd34:	14 91       	mov	r1,r10
8000dd36:	12 93       	mov	r3,r9
8000dd38:	10 94       	mov	r4,r8
8000dd3a:	40 82       	lddsp	r2,sp[0x20]
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000dd3c:	78 15       	ld.w	r5,r12[0x4]
  jvirt_sarray_ptr result;

  /* Only IMAGE-lifetime virtual arrays are currently supported */
  if (pool_id != JPOOL_IMAGE)
8000dd3e:	58 1b       	cp.w	r11,1
8000dd40:	c0 90       	breq	8000dd52 <request_virt_sarray+0x26>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
8000dd42:	78 08       	ld.w	r8,r12[0x0]
8000dd44:	30 e9       	mov	r9,14
8000dd46:	91 59       	st.w	r8[0x14],r9
8000dd48:	78 08       	ld.w	r8,r12[0x0]
8000dd4a:	91 6b       	st.w	r8[0x18],r11
8000dd4c:	78 08       	ld.w	r8,r12[0x0]
8000dd4e:	70 08       	ld.w	r8,r8[0x0]
8000dd50:	5d 18       	icall	r8

  /* get control block */
  result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
8000dd52:	e0 6a 00 80 	mov	r10,128
8000dd56:	0c 9b       	mov	r11,r6
8000dd58:	0e 9c       	mov	r12,r7
8000dd5a:	f0 1f 00 08 	mcall	8000dd78 <request_virt_sarray+0x4c>
					  SIZEOF(struct jvirt_sarray_control));

  result->mem_buffer = NULL;	/* marks array not yet realized */
8000dd5e:	30 09       	mov	r9,0
8000dd60:	99 09       	st.w	r12[0x0],r9
  result->rows_in_array = numrows;
8000dd62:	99 14       	st.w	r12[0x4],r4
  result->samplesperrow = samplesperrow;
8000dd64:	99 23       	st.w	r12[0x8],r3
  result->maxaccess = maxaccess;
8000dd66:	99 32       	st.w	r12[0xc],r2
  result->pre_zero = pre_zero;
8000dd68:	99 81       	st.w	r12[0x20],r1
  result->b_s_open = FALSE;	/* no associated backing-store object */
8000dd6a:	99 a9       	st.w	r12[0x28],r9
  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
8000dd6c:	6b 19       	ld.w	r9,r5[0x44]
8000dd6e:	99 b9       	st.w	r12[0x2c],r9
  mem->virt_sarray_list = result;
8000dd70:	eb 4c 00 44 	st.w	r5[68],r12

  return result;
}
8000dd74:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000dd78:	80 00       	ld.sh	r0,r0[0x0]
8000dd7a:	db d4       	*unknown*

8000dd7c <jinit_memory_mgr>:
 * When this is called, only the error manager pointer is valid in cinfo!
 */

GLOBAL(void)
jinit_memory_mgr (j_common_ptr cinfo)
{
8000dd7c:	eb cd 40 c0 	pushm	r6-r7,lr
8000dd80:	20 2d       	sub	sp,8
8000dd82:	18 96       	mov	r6,r12
  my_mem_ptr mem;
  long max_to_use;
  int pool;
  size_t test_mac;

  cinfo->mem = NULL;		/* for safety if init fails */
8000dd84:	30 08       	mov	r8,0
8000dd86:	99 18       	st.w	r12[0x4],r8
  test_mac = (size_t) MAX_ALLOC_CHUNK;
  if ((long) test_mac != MAX_ALLOC_CHUNK ||
      (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);

  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
8000dd88:	f0 1f 00 38 	mcall	8000de68 <jinit_memory_mgr+0xec>
8000dd8c:	50 1c       	stdsp	sp[0x4],r12

  /* Attempt to allocate memory manager's control block */
  mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
8000dd8e:	35 4b       	mov	r11,84
8000dd90:	0c 9c       	mov	r12,r6
8000dd92:	f0 1f 00 37 	mcall	8000de6c <jinit_memory_mgr+0xf0>
8000dd96:	18 97       	mov	r7,r12

  if (mem == NULL) {
8000dd98:	c0 e1       	brne	8000ddb4 <jinit_memory_mgr+0x38>
    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
8000dd9a:	0c 9c       	mov	r12,r6
8000dd9c:	f0 1f 00 35 	mcall	8000de70 <jinit_memory_mgr+0xf4>
    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
8000dda0:	6c 08       	ld.w	r8,r6[0x0]
8000dda2:	33 69       	mov	r9,54
8000dda4:	91 59       	st.w	r8[0x14],r9
8000dda6:	6c 08       	ld.w	r8,r6[0x0]
8000dda8:	30 09       	mov	r9,0
8000ddaa:	91 69       	st.w	r8[0x18],r9
8000ddac:	6c 08       	ld.w	r8,r6[0x0]
8000ddae:	70 08       	ld.w	r8,r8[0x0]
8000ddb0:	0c 9c       	mov	r12,r6
8000ddb2:	5d 18       	icall	r8
  }

  /* OK, fill in the method pointers */
  mem->pub.alloc_small = alloc_small;
8000ddb4:	4b 08       	lddpc	r8,8000de74 <jinit_memory_mgr+0xf8>
8000ddb6:	8f 08       	st.w	r7[0x0],r8
  mem->pub.alloc_large = alloc_large;
8000ddb8:	4b 08       	lddpc	r8,8000de78 <jinit_memory_mgr+0xfc>
8000ddba:	8f 18       	st.w	r7[0x4],r8
  mem->pub.alloc_sarray = alloc_sarray;
8000ddbc:	4b 08       	lddpc	r8,8000de7c <jinit_memory_mgr+0x100>
8000ddbe:	8f 28       	st.w	r7[0x8],r8
  mem->pub.alloc_barray = alloc_barray;
8000ddc0:	4b 08       	lddpc	r8,8000de80 <jinit_memory_mgr+0x104>
8000ddc2:	8f 38       	st.w	r7[0xc],r8
  mem->pub.request_virt_sarray = request_virt_sarray;
8000ddc4:	4b 08       	lddpc	r8,8000de84 <jinit_memory_mgr+0x108>
8000ddc6:	8f 48       	st.w	r7[0x10],r8
  mem->pub.request_virt_barray = request_virt_barray;
8000ddc8:	4b 08       	lddpc	r8,8000de88 <jinit_memory_mgr+0x10c>
8000ddca:	8f 58       	st.w	r7[0x14],r8
  mem->pub.realize_virt_arrays = realize_virt_arrays;
8000ddcc:	4b 08       	lddpc	r8,8000de8c <jinit_memory_mgr+0x110>
8000ddce:	8f 68       	st.w	r7[0x18],r8
  mem->pub.access_virt_sarray = access_virt_sarray;
8000ddd0:	4b 08       	lddpc	r8,8000de90 <jinit_memory_mgr+0x114>
8000ddd2:	8f 78       	st.w	r7[0x1c],r8
  mem->pub.access_virt_barray = access_virt_barray;
8000ddd4:	4b 08       	lddpc	r8,8000de94 <jinit_memory_mgr+0x118>
8000ddd6:	8f 88       	st.w	r7[0x20],r8
  mem->pub.free_pool = free_pool;
8000ddd8:	4b 08       	lddpc	r8,8000de98 <jinit_memory_mgr+0x11c>
8000ddda:	8f 98       	st.w	r7[0x24],r8
  mem->pub.self_destruct = self_destruct;
8000dddc:	4b 08       	lddpc	r8,8000de9c <jinit_memory_mgr+0x120>
8000ddde:	8f a8       	st.w	r7[0x28],r8

  /* Make MAX_ALLOC_CHUNK accessible to other modules */
  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
8000dde0:	e0 68 ca 00 	mov	r8,51712
8000dde4:	ea 18 3b 9a 	orh	r8,0x3b9a
8000dde8:	8f c8       	st.w	r7[0x30],r8

  /* Initialize working state */
  mem->pub.max_memory_to_use = max_to_use;
8000ddea:	40 18       	lddsp	r8,sp[0x4]
8000ddec:	8f b8       	st.w	r7[0x2c],r8

  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
    mem->small_list[pool] = NULL;
8000ddee:	30 08       	mov	r8,0
8000ddf0:	8f e8       	st.w	r7[0x38],r8
    mem->large_list[pool] = NULL;
8000ddf2:	ef 48 00 40 	st.w	r7[64],r8

  /* Initialize working state */
  mem->pub.max_memory_to_use = max_to_use;

  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
    mem->small_list[pool] = NULL;
8000ddf6:	8f d8       	st.w	r7[0x34],r8
    mem->large_list[pool] = NULL;
8000ddf8:	8f f8       	st.w	r7[0x3c],r8
  }
  mem->virt_sarray_list = NULL;
8000ddfa:	ef 48 00 44 	st.w	r7[68],r8
  mem->virt_barray_list = NULL;
8000ddfe:	ef 48 00 48 	st.w	r7[72],r8

  mem->total_space_allocated = SIZEOF(my_memory_mgr);
8000de02:	35 48       	mov	r8,84
8000de04:	ef 48 00 4c 	st.w	r7[76],r8

  /* Declare ourselves open for business */
  cinfo->mem = & mem->pub;
8000de08:	8d 17       	st.w	r6[0x4],r7
   * this feature.
   */
#ifndef NO_GETENV
  { char * memenv;

    if ((memenv = getenv("JPEGMEM")) != NULL) {
8000de0a:	4a 6c       	lddpc	r12,8000dea0 <jinit_memory_mgr+0x124>
8000de0c:	f0 1f 00 26 	mcall	8000dea4 <jinit_memory_mgr+0x128>
8000de10:	c2 80       	breq	8000de60 <jinit_memory_mgr+0xe4>
      char ch = 'x';
8000de12:	37 88       	mov	r8,120
8000de14:	ba b8       	st.b	sp[0x3],r8

      if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
8000de16:	fa c8 ff fd 	sub	r8,sp,-3
8000de1a:	1a d8       	st.w	--sp,r8
8000de1c:	fa c8 ff f8 	sub	r8,sp,-8
8000de20:	1a d8       	st.w	--sp,r8
8000de22:	4a 2b       	lddpc	r11,8000dea8 <jinit_memory_mgr+0x12c>
8000de24:	f0 1f 00 22 	mcall	8000deac <jinit_memory_mgr+0x130>
8000de28:	2f ed       	sub	sp,-8
8000de2a:	58 0c       	cp.w	r12,0
8000de2c:	e0 8a 00 1a 	brle	8000de60 <jinit_memory_mgr+0xe4>
	if (ch == 'm' || ch == 'M')
8000de30:	1b b8       	ld.ub	r8,sp[0x3]
8000de32:	36 d9       	mov	r9,109
8000de34:	f2 08 18 00 	cp.b	r8,r9
8000de38:	5f 09       	sreq	r9
8000de3a:	34 da       	mov	r10,77
8000de3c:	f4 08 18 00 	cp.b	r8,r10
8000de40:	5f 08       	sreq	r8
8000de42:	f3 e8 10 08 	or	r8,r9,r8
8000de46:	c0 70       	breq	8000de54 <jinit_memory_mgr+0xd8>
	  max_to_use *= 1000L;
8000de48:	e0 68 03 e8 	mov	r8,1000
8000de4c:	40 19       	lddsp	r9,sp[0x4]
8000de4e:	f2 08 02 48 	mul	r8,r9,r8
8000de52:	50 18       	stdsp	sp[0x4],r8
	mem->pub.max_memory_to_use = max_to_use * 1000L;
8000de54:	e0 68 03 e8 	mov	r8,1000
8000de58:	40 19       	lddsp	r9,sp[0x4]
8000de5a:	f2 08 02 48 	mul	r8,r9,r8
8000de5e:	8f b8       	st.w	r7[0x2c],r8
      }
    }
  }
#endif

}
8000de60:	2f ed       	sub	sp,-8
8000de62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000de66:	00 00       	add	r0,r0
8000de68:	80 00       	ld.sh	r0,r0[0x0]
8000de6a:	e5 12 80 00 	ld.uh	r2,r2[-32768]
8000de6e:	e5 48 80 00 	st.w	r2[-32768],r8
8000de72:	e5 14 80 00 	ld.uh	r4,r2[-32768]
8000de76:	db d4       	*unknown*
8000de78:	80 00       	ld.sh	r0,r0[0x0]
8000de7a:	e2 0c       	*unknown*
8000de7c:	80 00       	ld.sh	r0,r0[0x0]
8000de7e:	e3 24 80 00 	ld.sb	r4,r1[-32768]
8000de82:	e2 94 80 00 	brge	8007de82 <_data_sdram_lma+0x5d2ba>
8000de86:	dd 2c       	*unknown*
8000de88:	80 00       	ld.sh	r0,r0[0x0]
8000de8a:	dc dc       	*unknown*
8000de8c:	80 00       	ld.sh	r0,r0[0x0]
8000de8e:	e3 b0       	*unknown*
8000de90:	80 00       	ld.sh	r0,r0[0x0]
8000de92:	e0 ec 80 00 	ld.d	r12,r0[-32768]
8000de96:	df cc       	*unknown*
8000de98:	80 00       	ld.sh	r0,r0[0x0]
8000de9a:	de b0       	acall	0xeb
8000de9c:	80 00       	ld.sh	r0,r0[0x0]
8000de9e:	df 94       	*unknown*
8000dea0:	80 01       	ld.sh	r1,r0[0x0]
8000dea2:	fb 28 80 01 	ld.sb	r8,sp[-32767]
8000dea6:	4f a8       	lddpc	r8,8000e08c <access_virt_barray+0xc0>
8000dea8:	80 01       	ld.sh	r1,r0[0x0]
8000deaa:	fb 30 80 01 	ld.ub	r0,sp[-32767]
8000deae:	56 84       	stdsp	sp[0x1a0],r4

8000deb0 <free_pool>:
 * Release all objects belonging to a specified pool.
 */

METHODDEF(void)
free_pool (j_common_ptr cinfo, int pool_id)
{
8000deb0:	eb cd 40 f8 	pushm	r3-r7,lr
8000deb4:	18 94       	mov	r4,r12
8000deb6:	16 93       	mov	r3,r11
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000deb8:	78 17       	ld.w	r7,r12[0x4]
  small_pool_ptr shdr_ptr;
  large_pool_ptr lhdr_ptr;
  size_t space_freed;

  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
8000deba:	58 1b       	cp.w	r11,1
8000debc:	e0 88 00 0a 	brls	8000ded0 <free_pool+0x20>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
8000dec0:	78 08       	ld.w	r8,r12[0x0]
8000dec2:	30 e9       	mov	r9,14
8000dec4:	91 59       	st.w	r8[0x14],r9
8000dec6:	78 08       	ld.w	r8,r12[0x0]
8000dec8:	91 6b       	st.w	r8[0x18],r11
8000deca:	78 08       	ld.w	r8,r12[0x0]
8000decc:	70 08       	ld.w	r8,r8[0x0]
8000dece:	5d 18       	icall	r8
  if (cinfo->err->trace_level > 1)
    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
#endif

  /* If freeing IMAGE pool, close any virtual arrays first */
  if (pool_id == JPOOL_IMAGE) {
8000ded0:	58 13       	cp.w	r3,1
8000ded2:	c2 71       	brne	8000df20 <free_pool+0x70>
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
8000ded4:	6f 16       	ld.w	r6,r7[0x44]
8000ded6:	58 06       	cp.w	r6,0
8000ded8:	c0 e0       	breq	8000def4 <free_pool+0x44>
      if (sptr->b_s_open) {	/* there may be no backing store */
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
8000deda:	30 05       	mov	r5,0
  if (pool_id == JPOOL_IMAGE) {
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
      if (sptr->b_s_open) {	/* there may be no backing store */
8000dedc:	6c a8       	ld.w	r8,r6[0x28]
8000dede:	58 08       	cp.w	r8,0
8000dee0:	c0 70       	breq	8000deee <free_pool+0x3e>
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
8000dee2:	8d a5       	st.w	r6[0x28],r5
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
8000dee4:	6c e8       	ld.w	r8,r6[0x38]
8000dee6:	ec cb ff d0 	sub	r11,r6,-48
8000deea:	08 9c       	mov	r12,r4
8000deec:	5d 18       	icall	r8
  /* If freeing IMAGE pool, close any virtual arrays first */
  if (pool_id == JPOOL_IMAGE) {
    jvirt_sarray_ptr sptr;
    jvirt_barray_ptr bptr;

    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
8000deee:	6c b6       	ld.w	r6,r6[0x2c]
8000def0:	58 06       	cp.w	r6,0
8000def2:	cf 51       	brne	8000dedc <free_pool+0x2c>
      if (sptr->b_s_open) {	/* there may be no backing store */
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
      }
    }
    mem->virt_sarray_list = NULL;
8000def4:	30 08       	mov	r8,0
8000def6:	ef 48 00 44 	st.w	r7[68],r8
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
8000defa:	6f 26       	ld.w	r6,r7[0x48]
8000defc:	58 06       	cp.w	r6,0
8000defe:	c0 e0       	breq	8000df1a <free_pool+0x6a>
      if (bptr->b_s_open) {	/* there may be no backing store */
	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
8000df00:	10 95       	mov	r5,r8
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
      }
    }
    mem->virt_sarray_list = NULL;
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
      if (bptr->b_s_open) {	/* there may be no backing store */
8000df02:	6c a8       	ld.w	r8,r6[0x28]
8000df04:	58 08       	cp.w	r8,0
8000df06:	c0 70       	breq	8000df14 <free_pool+0x64>
	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
8000df08:	8d a5       	st.w	r6[0x28],r5
	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
8000df0a:	6c e8       	ld.w	r8,r6[0x38]
8000df0c:	ec cb ff d0 	sub	r11,r6,-48
8000df10:	08 9c       	mov	r12,r4
8000df12:	5d 18       	icall	r8
	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
      }
    }
    mem->virt_sarray_list = NULL;
    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
8000df14:	6c b6       	ld.w	r6,r6[0x2c]
8000df16:	58 06       	cp.w	r6,0
8000df18:	cf 51       	brne	8000df02 <free_pool+0x52>
      if (bptr->b_s_open) {	/* there may be no backing store */
	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
      }
    }
    mem->virt_barray_list = NULL;
8000df1a:	30 08       	mov	r8,0
8000df1c:	ef 48 00 48 	st.w	r7[72],r8
  }

  /* Release large objects */
  lhdr_ptr = mem->large_list[pool_id];
8000df20:	e6 c8 ff f1 	sub	r8,r3,-15
8000df24:	ee 08 03 2b 	ld.w	r11,r7[r8<<0x2]
  mem->large_list[pool_id] = NULL;
8000df28:	30 09       	mov	r9,0
8000df2a:	ee 08 09 29 	st.w	r7[r8<<0x2],r9

  while (lhdr_ptr != NULL) {
8000df2e:	58 0b       	cp.w	r11,0
8000df30:	c1 20       	breq	8000df54 <free_pool+0xa4>
    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
8000df32:	76 05       	ld.w	r5,r11[0x0]
    space_freed = lhdr_ptr->hdr.bytes_used +
8000df34:	76 16       	ld.w	r6,r11[0x4]
8000df36:	76 28       	ld.w	r8,r11[0x8]
8000df38:	10 06       	add	r6,r8
8000df3a:	2f 46       	sub	r6,-12
		  lhdr_ptr->hdr.bytes_left +
		  SIZEOF(large_pool_hdr);
    jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
8000df3c:	0c 9a       	mov	r10,r6
8000df3e:	08 9c       	mov	r12,r4
8000df40:	f0 1f 00 13 	mcall	8000df8c <free_pool+0xdc>
    mem->total_space_allocated -= space_freed;
8000df44:	6f 38       	ld.w	r8,r7[0x4c]
8000df46:	0c 18       	sub	r8,r6
8000df48:	ef 48 00 4c 	st.w	r7[76],r8

  /* Release large objects */
  lhdr_ptr = mem->large_list[pool_id];
  mem->large_list[pool_id] = NULL;

  while (lhdr_ptr != NULL) {
8000df4c:	58 05       	cp.w	r5,0
8000df4e:	c0 30       	breq	8000df54 <free_pool+0xa4>
8000df50:	0a 9b       	mov	r11,r5
8000df52:	cf 0b       	rjmp	8000df32 <free_pool+0x82>
    mem->total_space_allocated -= space_freed;
    lhdr_ptr = next_lhdr_ptr;
  }

  /* Release small objects */
  shdr_ptr = mem->small_list[pool_id];
8000df54:	2f 33       	sub	r3,-13
8000df56:	ee 03 03 2b 	ld.w	r11,r7[r3<<0x2]
  mem->small_list[pool_id] = NULL;
8000df5a:	30 08       	mov	r8,0
8000df5c:	ee 03 09 28 	st.w	r7[r3<<0x2],r8

  while (shdr_ptr != NULL) {
8000df60:	58 0b       	cp.w	r11,0
8000df62:	c1 20       	breq	8000df86 <free_pool+0xd6>
    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
8000df64:	76 05       	ld.w	r5,r11[0x0]
    space_freed = shdr_ptr->hdr.bytes_used +
8000df66:	76 16       	ld.w	r6,r11[0x4]
8000df68:	76 28       	ld.w	r8,r11[0x8]
8000df6a:	10 06       	add	r6,r8
8000df6c:	2f 46       	sub	r6,-12
		  shdr_ptr->hdr.bytes_left +
		  SIZEOF(small_pool_hdr);
    jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
8000df6e:	0c 9a       	mov	r10,r6
8000df70:	08 9c       	mov	r12,r4
8000df72:	f0 1f 00 08 	mcall	8000df90 <free_pool+0xe0>
    mem->total_space_allocated -= space_freed;
8000df76:	6f 38       	ld.w	r8,r7[0x4c]
8000df78:	0c 18       	sub	r8,r6
8000df7a:	ef 48 00 4c 	st.w	r7[76],r8

  /* Release small objects */
  shdr_ptr = mem->small_list[pool_id];
  mem->small_list[pool_id] = NULL;

  while (shdr_ptr != NULL) {
8000df7e:	58 05       	cp.w	r5,0
8000df80:	c0 30       	breq	8000df86 <free_pool+0xd6>
8000df82:	0a 9b       	mov	r11,r5
8000df84:	cf 0b       	rjmp	8000df64 <free_pool+0xb4>
8000df86:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000df8a:	00 00       	add	r0,r0
8000df8c:	80 00       	ld.sh	r0,r0[0x0]
8000df8e:	e5 18 80 00 	ld.uh	r8,r2[-32768]
8000df92:	e5 28 eb cd 	ld.sb	r8,r2[-5171]

8000df94 <self_destruct>:
 * Note that this cannot be called unless cinfo->mem is non-NULL.
 */

METHODDEF(void)
self_destruct (j_common_ptr cinfo)
{
8000df94:	eb cd 40 80 	pushm	r7,lr
8000df98:	18 97       	mov	r7,r12
  /* Close all backing store, release all memory.
   * Releasing pools in reverse order might help avoid fragmentation
   * with some (brain-damaged) malloc libraries.
   */
  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
    free_pool(cinfo, pool);
8000df9a:	30 1b       	mov	r11,1
8000df9c:	f0 1f 00 09 	mcall	8000dfc0 <self_destruct+0x2c>
8000dfa0:	30 0b       	mov	r11,0
8000dfa2:	0e 9c       	mov	r12,r7
8000dfa4:	f0 1f 00 07 	mcall	8000dfc0 <self_destruct+0x2c>
  }

  /* Release the memory manager control block too. */
  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
8000dfa8:	35 4a       	mov	r10,84
8000dfaa:	6e 1b       	ld.w	r11,r7[0x4]
8000dfac:	0e 9c       	mov	r12,r7
8000dfae:	f0 1f 00 06 	mcall	8000dfc4 <self_destruct+0x30>
  cinfo->mem = NULL;		/* ensures I will be called only once */
8000dfb2:	30 08       	mov	r8,0
8000dfb4:	8f 18       	st.w	r7[0x4],r8

  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
8000dfb6:	0e 9c       	mov	r12,r7
8000dfb8:	f0 1f 00 04 	mcall	8000dfc8 <self_destruct+0x34>
}
8000dfbc:	e3 cd 80 80 	ldm	sp++,r7,pc
8000dfc0:	80 00       	ld.sh	r0,r0[0x0]
8000dfc2:	de b0       	acall	0xeb
8000dfc4:	80 00       	ld.sh	r0,r0[0x0]
8000dfc6:	e5 28 80 00 	ld.sb	r8,r2[-32768]
8000dfca:	e5 14 eb cd 	ld.uh	r4,r2[-5171]

8000dfcc <access_virt_barray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual block array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
8000dfcc:	eb cd 40 fe 	pushm	r1-r7,lr
8000dfd0:	18 95       	mov	r5,r12
8000dfd2:	16 97       	mov	r7,r11
8000dfd4:	14 94       	mov	r4,r10
8000dfd6:	10 91       	mov	r1,r8
  JDIMENSION end_row = start_row + num_rows;
8000dfd8:	f2 0a 00 03 	add	r3,r9,r10
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
8000dfdc:	76 18       	ld.w	r8,r11[0x4]
8000dfde:	10 33       	cp.w	r3,r8
8000dfe0:	e0 8b 00 09 	brhi	8000dff2 <access_virt_barray+0x26>
8000dfe4:	76 38       	ld.w	r8,r11[0xc]
8000dfe6:	10 39       	cp.w	r9,r8
8000dfe8:	e0 8b 00 05 	brhi	8000dff2 <access_virt_barray+0x26>
      ptr->mem_buffer == NULL)
8000dfec:	76 08       	ld.w	r8,r11[0x0]
8000dfee:	58 08       	cp.w	r8,0
8000dff0:	c0 81       	brne	8000e000 <access_virt_barray+0x34>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
8000dff2:	6a 08       	ld.w	r8,r5[0x0]
8000dff4:	31 69       	mov	r9,22
8000dff6:	91 59       	st.w	r8[0x14],r9
8000dff8:	6a 08       	ld.w	r8,r5[0x0]
8000dffa:	70 08       	ld.w	r8,r8[0x0]
8000dffc:	0a 9c       	mov	r12,r5
8000dffe:	5d 18       	icall	r8

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
8000e000:	6e 68       	ld.w	r8,r7[0x18]
8000e002:	10 34       	cp.w	r4,r8
8000e004:	c0 63       	brcs	8000e010 <access_virt_barray+0x44>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
8000e006:	6e 49       	ld.w	r9,r7[0x10]
8000e008:	12 08       	add	r8,r9
8000e00a:	10 33       	cp.w	r3,r8
8000e00c:	e0 88 00 28 	brls	8000e05c <access_virt_barray+0x90>
    if (! ptr->b_s_open)
8000e010:	6e a8       	ld.w	r8,r7[0x28]
8000e012:	58 08       	cp.w	r8,0
8000e014:	c0 81       	brne	8000e024 <access_virt_barray+0x58>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
8000e016:	6a 08       	ld.w	r8,r5[0x0]
8000e018:	34 59       	mov	r9,69
8000e01a:	91 59       	st.w	r8[0x14],r9
8000e01c:	6a 08       	ld.w	r8,r5[0x0]
8000e01e:	70 08       	ld.w	r8,r8[0x0]
8000e020:	0a 9c       	mov	r12,r5
8000e022:	5d 18       	icall	r8
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
8000e024:	6e 98       	ld.w	r8,r7[0x24]
8000e026:	58 08       	cp.w	r8,0
8000e028:	c0 80       	breq	8000e038 <access_virt_barray+0x6c>
      do_barray_io(cinfo, ptr, TRUE);
8000e02a:	30 1a       	mov	r10,1
8000e02c:	0e 9b       	mov	r11,r7
8000e02e:	0a 9c       	mov	r12,r5
8000e030:	f0 1f 00 2d 	mcall	8000e0e4 <access_virt_barray+0x118>
      ptr->dirty = FALSE;
8000e034:	30 08       	mov	r8,0
8000e036:	8f 98       	st.w	r7[0x24],r8
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
8000e038:	6e 68       	ld.w	r8,r7[0x18]
8000e03a:	10 34       	cp.w	r4,r8
8000e03c:	e0 88 00 04 	brls	8000e044 <access_virt_barray+0x78>
      ptr->cur_start_row = start_row;
8000e040:	8f 64       	st.w	r7[0x18],r4
8000e042:	c0 88       	rjmp	8000e052 <access_virt_barray+0x86>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
8000e044:	6e 48       	ld.w	r8,r7[0x10]
8000e046:	e6 08 01 08 	sub	r8,r3,r8
      if (ltemp < 0)
	ltemp = 0;		/* don't fall off front end of file */
      ptr->cur_start_row = (JDIMENSION) ltemp;
8000e04a:	30 09       	mov	r9,0
8000e04c:	f0 09 0c 48 	max	r8,r8,r9
8000e050:	8f 68       	st.w	r7[0x18],r8
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_barray_io(cinfo, ptr, FALSE);
8000e052:	30 0a       	mov	r10,0
8000e054:	0e 9b       	mov	r11,r7
8000e056:	0a 9c       	mov	r12,r5
8000e058:	f0 1f 00 23 	mcall	8000e0e4 <access_virt_barray+0x118>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
8000e05c:	6e 76       	ld.w	r6,r7[0x1c]
8000e05e:	0c 33       	cp.w	r3,r6
8000e060:	e0 88 00 37 	brls	8000e0ce <access_virt_barray+0x102>
    if (ptr->first_undef_row < start_row) {
8000e064:	0c 34       	cp.w	r4,r6
8000e066:	e0 88 00 0f 	brls	8000e084 <access_virt_barray+0xb8>
      if (writable)		/* writer skipped over a section of array */
8000e06a:	58 01       	cp.w	r1,0
8000e06c:	c0 31       	brne	8000e072 <access_virt_barray+0xa6>
8000e06e:	08 96       	mov	r6,r4
8000e070:	c0 d8       	rjmp	8000e08a <access_virt_barray+0xbe>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
8000e072:	6a 08       	ld.w	r8,r5[0x0]
8000e074:	31 69       	mov	r9,22
8000e076:	91 59       	st.w	r8[0x14],r9
8000e078:	6a 08       	ld.w	r8,r5[0x0]
8000e07a:	70 08       	ld.w	r8,r8[0x0]
8000e07c:	0a 9c       	mov	r12,r5
8000e07e:	5d 18       	icall	r8
8000e080:	08 96       	mov	r6,r4
8000e082:	c0 38       	rjmp	8000e088 <access_virt_barray+0xbc>
      undef_row = start_row;	/* but reader is allowed to read ahead */
    } else {
      undef_row = ptr->first_undef_row;
    }
    if (writable)
8000e084:	58 01       	cp.w	r1,0
8000e086:	c0 20       	breq	8000e08a <access_virt_barray+0xbe>
      ptr->first_undef_row = end_row;
8000e088:	8f 73       	st.w	r7[0x1c],r3
    if (ptr->pre_zero) {
8000e08a:	6e 88       	ld.w	r8,r7[0x20]
8000e08c:	58 08       	cp.w	r8,0
8000e08e:	c1 60       	breq	8000e0ba <access_virt_barray+0xee>
      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
8000e090:	6e 22       	ld.w	r2,r7[0x8]
8000e092:	a7 72       	lsl	r2,0x7
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
8000e094:	6e 68       	ld.w	r8,r7[0x18]
8000e096:	10 16       	sub	r6,r8
      end_row -= ptr->cur_start_row;
8000e098:	10 13       	sub	r3,r8
      while (undef_row < end_row) {
8000e09a:	06 36       	cp.w	r6,r3
8000e09c:	c1 92       	brcc	8000e0ce <access_virt_barray+0x102>
8000e09e:	ec 05 15 02 	lsl	r5,r6,0x2
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
8000e0a2:	6e 08       	ld.w	r8,r7[0x0]
8000e0a4:	04 9b       	mov	r11,r2
8000e0a6:	f0 05 03 0c 	ld.w	r12,r8[r5]
8000e0aa:	f0 1f 00 10 	mcall	8000e0e8 <access_virt_barray+0x11c>
	undef_row++;
8000e0ae:	2f f6       	sub	r6,-1
8000e0b0:	2f c5       	sub	r5,-4
      ptr->first_undef_row = end_row;
    if (ptr->pre_zero) {
      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
      end_row -= ptr->cur_start_row;
      while (undef_row < end_row) {
8000e0b2:	0c 33       	cp.w	r3,r6
8000e0b4:	fe 9b ff f7 	brhi	8000e0a2 <access_virt_barray+0xd6>
8000e0b8:	c0 b8       	rjmp	8000e0ce <access_virt_barray+0x102>
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
	undef_row++;
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
8000e0ba:	58 01       	cp.w	r1,0
8000e0bc:	c0 b1       	brne	8000e0d2 <access_virt_barray+0x106>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
8000e0be:	6a 08       	ld.w	r8,r5[0x0]
8000e0c0:	31 69       	mov	r9,22
8000e0c2:	91 59       	st.w	r8[0x14],r9
8000e0c4:	6a 08       	ld.w	r8,r5[0x0]
8000e0c6:	70 08       	ld.w	r8,r8[0x0]
8000e0c8:	0a 9c       	mov	r12,r5
8000e0ca:	5d 18       	icall	r8
8000e0cc:	c0 58       	rjmp	8000e0d6 <access_virt_barray+0x10a>
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
8000e0ce:	58 01       	cp.w	r1,0
8000e0d0:	c0 30       	breq	8000e0d6 <access_virt_barray+0x10a>
    ptr->dirty = TRUE;
8000e0d2:	30 18       	mov	r8,1
8000e0d4:	8f 98       	st.w	r7[0x24],r8
8000e0d6:	6e 68       	ld.w	r8,r7[0x18]
8000e0d8:	10 14       	sub	r4,r8
8000e0da:	6e 08       	ld.w	r8,r7[0x0]
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}
8000e0dc:	f0 04 00 2c 	add	r12,r8,r4<<0x2
8000e0e0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000e0e4:	80 00       	ld.sh	r0,r0[0x0]
8000e0e6:	db 2e       	*unknown*
8000e0e8:	80 00       	ld.sh	r0,r0[0x0]
8000e0ea:	fd 20 eb cd 	ld.sb	r0,lr[-5171]

8000e0ec <access_virt_sarray>:
		    JDIMENSION start_row, JDIMENSION num_rows,
		    boolean writable)
/* Access the part of a virtual sample array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
{
8000e0ec:	eb cd 40 fe 	pushm	r1-r7,lr
8000e0f0:	18 95       	mov	r5,r12
8000e0f2:	16 97       	mov	r7,r11
8000e0f4:	14 94       	mov	r4,r10
8000e0f6:	10 91       	mov	r1,r8
  JDIMENSION end_row = start_row + num_rows;
8000e0f8:	f2 0a 00 03 	add	r3,r9,r10
  JDIMENSION undef_row;

  /* debugging check */
  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
8000e0fc:	76 18       	ld.w	r8,r11[0x4]
8000e0fe:	10 33       	cp.w	r3,r8
8000e100:	e0 8b 00 09 	brhi	8000e112 <access_virt_sarray+0x26>
8000e104:	76 38       	ld.w	r8,r11[0xc]
8000e106:	10 39       	cp.w	r9,r8
8000e108:	e0 8b 00 05 	brhi	8000e112 <access_virt_sarray+0x26>
      ptr->mem_buffer == NULL)
8000e10c:	76 08       	ld.w	r8,r11[0x0]
8000e10e:	58 08       	cp.w	r8,0
8000e110:	c0 81       	brne	8000e120 <access_virt_sarray+0x34>
    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
8000e112:	6a 08       	ld.w	r8,r5[0x0]
8000e114:	31 69       	mov	r9,22
8000e116:	91 59       	st.w	r8[0x14],r9
8000e118:	6a 08       	ld.w	r8,r5[0x0]
8000e11a:	70 08       	ld.w	r8,r8[0x0]
8000e11c:	0a 9c       	mov	r12,r5
8000e11e:	5d 18       	icall	r8

  /* Make the desired part of the virtual array accessible */
  if (start_row < ptr->cur_start_row ||
8000e120:	6e 68       	ld.w	r8,r7[0x18]
8000e122:	10 34       	cp.w	r4,r8
8000e124:	c0 63       	brcs	8000e130 <access_virt_sarray+0x44>
      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
8000e126:	6e 49       	ld.w	r9,r7[0x10]
8000e128:	12 08       	add	r8,r9
8000e12a:	10 33       	cp.w	r3,r8
8000e12c:	e0 88 00 28 	brls	8000e17c <access_virt_sarray+0x90>
    if (! ptr->b_s_open)
8000e130:	6e a8       	ld.w	r8,r7[0x28]
8000e132:	58 08       	cp.w	r8,0
8000e134:	c0 81       	brne	8000e144 <access_virt_sarray+0x58>
      ERREXIT(cinfo, JERR_VIRTUAL_BUG);
8000e136:	6a 08       	ld.w	r8,r5[0x0]
8000e138:	34 59       	mov	r9,69
8000e13a:	91 59       	st.w	r8[0x14],r9
8000e13c:	6a 08       	ld.w	r8,r5[0x0]
8000e13e:	70 08       	ld.w	r8,r8[0x0]
8000e140:	0a 9c       	mov	r12,r5
8000e142:	5d 18       	icall	r8
    /* Flush old buffer contents if necessary */
    if (ptr->dirty) {
8000e144:	6e 98       	ld.w	r8,r7[0x24]
8000e146:	58 08       	cp.w	r8,0
8000e148:	c0 80       	breq	8000e158 <access_virt_sarray+0x6c>
      do_sarray_io(cinfo, ptr, TRUE);
8000e14a:	30 1a       	mov	r10,1
8000e14c:	0e 9b       	mov	r11,r7
8000e14e:	0a 9c       	mov	r12,r5
8000e150:	f0 1f 00 2d 	mcall	8000e204 <access_virt_sarray+0x118>
      ptr->dirty = FALSE;
8000e154:	30 08       	mov	r8,0
8000e156:	8f 98       	st.w	r7[0x24],r8
     * load starting at target address.  If target address < current window,
     * assume backward scan, load so that target area is top of window.
     * Note that when switching from forward write to forward read, will have
     * start_row = 0, so the limiting case applies and we load from 0 anyway.
     */
    if (start_row > ptr->cur_start_row) {
8000e158:	6e 68       	ld.w	r8,r7[0x18]
8000e15a:	10 34       	cp.w	r4,r8
8000e15c:	e0 88 00 04 	brls	8000e164 <access_virt_sarray+0x78>
      ptr->cur_start_row = start_row;
8000e160:	8f 64       	st.w	r7[0x18],r4
8000e162:	c0 88       	rjmp	8000e172 <access_virt_sarray+0x86>
    } else {
      /* use long arithmetic here to avoid overflow & unsigned problems */
      long ltemp;

      ltemp = (long) end_row - (long) ptr->rows_in_mem;
8000e164:	6e 48       	ld.w	r8,r7[0x10]
8000e166:	e6 08 01 08 	sub	r8,r3,r8
      if (ltemp < 0)
	ltemp = 0;		/* don't fall off front end of file */
      ptr->cur_start_row = (JDIMENSION) ltemp;
8000e16a:	30 09       	mov	r9,0
8000e16c:	f0 09 0c 48 	max	r8,r8,r9
8000e170:	8f 68       	st.w	r7[0x18],r8
    }
    /* Read in the selected part of the array.
     * During the initial write pass, we will do no actual read
     * because the selected part is all undefined.
     */
    do_sarray_io(cinfo, ptr, FALSE);
8000e172:	30 0a       	mov	r10,0
8000e174:	0e 9b       	mov	r11,r7
8000e176:	0a 9c       	mov	r12,r5
8000e178:	f0 1f 00 23 	mcall	8000e204 <access_virt_sarray+0x118>
  }
  /* Ensure the accessed part of the array is defined; prezero if needed.
   * To improve locality of access, we only prezero the part of the array
   * that the caller is about to access, not the entire in-memory array.
   */
  if (ptr->first_undef_row < end_row) {
8000e17c:	6e 76       	ld.w	r6,r7[0x1c]
8000e17e:	0c 33       	cp.w	r3,r6
8000e180:	e0 88 00 36 	brls	8000e1ec <access_virt_sarray+0x100>
    if (ptr->first_undef_row < start_row) {
8000e184:	0c 34       	cp.w	r4,r6
8000e186:	e0 88 00 0f 	brls	8000e1a4 <access_virt_sarray+0xb8>
      if (writable)		/* writer skipped over a section of array */
8000e18a:	58 01       	cp.w	r1,0
8000e18c:	c0 31       	brne	8000e192 <access_virt_sarray+0xa6>
8000e18e:	08 96       	mov	r6,r4
8000e190:	c0 d8       	rjmp	8000e1aa <access_virt_sarray+0xbe>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
8000e192:	6a 08       	ld.w	r8,r5[0x0]
8000e194:	31 69       	mov	r9,22
8000e196:	91 59       	st.w	r8[0x14],r9
8000e198:	6a 08       	ld.w	r8,r5[0x0]
8000e19a:	70 08       	ld.w	r8,r8[0x0]
8000e19c:	0a 9c       	mov	r12,r5
8000e19e:	5d 18       	icall	r8
8000e1a0:	08 96       	mov	r6,r4
8000e1a2:	c0 38       	rjmp	8000e1a8 <access_virt_sarray+0xbc>
      undef_row = start_row;	/* but reader is allowed to read ahead */
    } else {
      undef_row = ptr->first_undef_row;
    }
    if (writable)
8000e1a4:	58 01       	cp.w	r1,0
8000e1a6:	c0 20       	breq	8000e1aa <access_virt_sarray+0xbe>
      ptr->first_undef_row = end_row;
8000e1a8:	8f 73       	st.w	r7[0x1c],r3
    if (ptr->pre_zero) {
8000e1aa:	6e 88       	ld.w	r8,r7[0x20]
8000e1ac:	58 08       	cp.w	r8,0
8000e1ae:	c1 50       	breq	8000e1d8 <access_virt_sarray+0xec>
      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
8000e1b0:	6e 22       	ld.w	r2,r7[0x8]
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
8000e1b2:	6e 68       	ld.w	r8,r7[0x18]
8000e1b4:	10 16       	sub	r6,r8
      end_row -= ptr->cur_start_row;
8000e1b6:	10 13       	sub	r3,r8
      while (undef_row < end_row) {
8000e1b8:	06 36       	cp.w	r6,r3
8000e1ba:	c1 92       	brcc	8000e1ec <access_virt_sarray+0x100>
8000e1bc:	ec 05 15 02 	lsl	r5,r6,0x2
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
8000e1c0:	6e 08       	ld.w	r8,r7[0x0]
8000e1c2:	04 9b       	mov	r11,r2
8000e1c4:	f0 05 03 0c 	ld.w	r12,r8[r5]
8000e1c8:	f0 1f 00 10 	mcall	8000e208 <access_virt_sarray+0x11c>
	undef_row++;
8000e1cc:	2f f6       	sub	r6,-1
8000e1ce:	2f c5       	sub	r5,-4
      ptr->first_undef_row = end_row;
    if (ptr->pre_zero) {
      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
      end_row -= ptr->cur_start_row;
      while (undef_row < end_row) {
8000e1d0:	0c 33       	cp.w	r3,r6
8000e1d2:	fe 9b ff f7 	brhi	8000e1c0 <access_virt_sarray+0xd4>
8000e1d6:	c0 b8       	rjmp	8000e1ec <access_virt_sarray+0x100>
	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
	undef_row++;
      }
    } else {
      if (! writable)		/* reader looking at undefined data */
8000e1d8:	58 01       	cp.w	r1,0
8000e1da:	c0 b1       	brne	8000e1f0 <access_virt_sarray+0x104>
	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
8000e1dc:	6a 08       	ld.w	r8,r5[0x0]
8000e1de:	31 69       	mov	r9,22
8000e1e0:	91 59       	st.w	r8[0x14],r9
8000e1e2:	6a 08       	ld.w	r8,r5[0x0]
8000e1e4:	70 08       	ld.w	r8,r8[0x0]
8000e1e6:	0a 9c       	mov	r12,r5
8000e1e8:	5d 18       	icall	r8
8000e1ea:	c0 58       	rjmp	8000e1f4 <access_virt_sarray+0x108>
    }
  }
  /* Flag the buffer dirty if caller will write in it */
  if (writable)
8000e1ec:	58 01       	cp.w	r1,0
8000e1ee:	c0 30       	breq	8000e1f4 <access_virt_sarray+0x108>
    ptr->dirty = TRUE;
8000e1f0:	30 18       	mov	r8,1
8000e1f2:	8f 98       	st.w	r7[0x24],r8
8000e1f4:	6e 68       	ld.w	r8,r7[0x18]
8000e1f6:	10 14       	sub	r4,r8
8000e1f8:	6e 08       	ld.w	r8,r7[0x0]
  /* Return address of proper part of the buffer */
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}
8000e1fa:	f0 04 00 2c 	add	r12,r8,r4<<0x2
8000e1fe:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000e202:	00 00       	add	r0,r0
8000e204:	80 00       	ld.sh	r0,r0[0x0]
8000e206:	da 88       	*unknown*
8000e208:	80 00       	ld.sh	r0,r0[0x0]
8000e20a:	fd 20 eb cd 	ld.sb	r0,lr[-5171]

8000e20c <alloc_large>:
 */

METHODDEF(void FAR *)
alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
/* Allocate a "large" object */
{
8000e20c:	eb cd 40 f8 	pushm	r3-r7,lr
8000e210:	18 96       	mov	r6,r12
8000e212:	16 93       	mov	r3,r11
8000e214:	14 95       	mov	r5,r10
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000e216:	78 14       	ld.w	r4,r12[0x4]
  large_pool_ptr hdr_ptr;
  size_t odd_bytes;

  /* Check for unsatisfiable request (do now to ensure no overflow below) */
  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
8000e218:	e0 68 c9 f4 	mov	r8,51700
8000e21c:	ea 18 3b 9a 	orh	r8,0x3b9a
8000e220:	10 3a       	cp.w	r10,r8
8000e222:	e0 88 00 05 	brls	8000e22c <alloc_large+0x20>
    out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
8000e226:	30 3b       	mov	r11,3
8000e228:	f0 1f 00 19 	mcall	8000e28c <alloc_large+0x80>

  /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
  odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
8000e22c:	f1 d5 c0 03 	bfextu	r8,r5,0x0,0x3
  if (odd_bytes > 0)
    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
8000e230:	f7 b5 01 f8 	subne	r5,-8
8000e234:	eb d8 e1 15 	subne	r5,r5,r8

  /* Always make a new pool */
  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
8000e238:	58 13       	cp.w	r3,1
8000e23a:	e0 88 00 0b 	brls	8000e250 <alloc_large+0x44>
    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
8000e23e:	6c 08       	ld.w	r8,r6[0x0]
8000e240:	30 e9       	mov	r9,14
8000e242:	91 59       	st.w	r8[0x14],r9
8000e244:	6c 08       	ld.w	r8,r6[0x0]
8000e246:	91 63       	st.w	r8[0x18],r3
8000e248:	6c 08       	ld.w	r8,r6[0x0]
8000e24a:	70 08       	ld.w	r8,r8[0x0]
8000e24c:	0c 9c       	mov	r12,r6
8000e24e:	5d 18       	icall	r8

  hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
8000e250:	ea cb ff f4 	sub	r11,r5,-12
8000e254:	0c 9c       	mov	r12,r6
8000e256:	f0 1f 00 0f 	mcall	8000e290 <alloc_large+0x84>
8000e25a:	18 97       	mov	r7,r12
					    SIZEOF(large_pool_hdr));
  if (hdr_ptr == NULL)
8000e25c:	c0 51       	brne	8000e266 <alloc_large+0x5a>
    out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
8000e25e:	30 4b       	mov	r11,4
8000e260:	0c 9c       	mov	r12,r6
8000e262:	f0 1f 00 0b 	mcall	8000e28c <alloc_large+0x80>
  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
8000e266:	69 38       	ld.w	r8,r4[0x4c]
8000e268:	2f 48       	sub	r8,-12
8000e26a:	0a 08       	add	r8,r5
8000e26c:	e9 48 00 4c 	st.w	r4[76],r8

  /* Success, initialize the new pool header and add to list */
  hdr_ptr->hdr.next = mem->large_list[pool_id];
8000e270:	2f 13       	sub	r3,-15
8000e272:	e8 03 03 28 	ld.w	r8,r4[r3<<0x2]
8000e276:	8f 08       	st.w	r7[0x0],r8
  /* We maintain space counts in each pool header for statistical purposes,
   * even though they are not needed for allocation.
   */
  hdr_ptr->hdr.bytes_used = sizeofobject;
8000e278:	8f 15       	st.w	r7[0x4],r5
  hdr_ptr->hdr.bytes_left = 0;
8000e27a:	30 08       	mov	r8,0
8000e27c:	8f 28       	st.w	r7[0x8],r8
  mem->large_list[pool_id] = hdr_ptr;
8000e27e:	e8 03 09 27 	st.w	r4[r3<<0x2],r7

  return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
}
8000e282:	ee cc ff f4 	sub	r12,r7,-12
8000e286:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000e28a:	00 00       	add	r0,r0
8000e28c:	80 00       	ld.sh	r0,r0[0x0]
8000e28e:	da 74       	*unknown*
8000e290:	80 00       	ld.sh	r0,r0[0x0]
8000e292:	e5 38 eb cd 	ld.ub	r8,r2[-5171]

8000e294 <alloc_barray>:

METHODDEF(JBLOCKARRAY)
alloc_barray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION blocksperrow, JDIMENSION numrows)
/* Allocate a 2-D coefficient-block array */
{
8000e294:	eb cd 40 fe 	pushm	r1-r7,lr
8000e298:	18 94       	mov	r4,r12
8000e29a:	16 92       	mov	r2,r11
8000e29c:	12 96       	mov	r6,r9
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000e29e:	78 11       	ld.w	r1,r12[0x4]
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
	  ((long) blocksperrow * SIZEOF(JBLOCK));
8000e2a0:	f4 03 15 07 	lsl	r3,r10,0x7
  JBLOCKROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
8000e2a4:	e0 69 c9 f4 	mov	r9,51700
8000e2a8:	ea 19 3b 9a 	orh	r9,0x3b9a
8000e2ac:	f2 03 0d 08 	divu	r8,r9,r3
8000e2b0:	10 97       	mov	r7,r8
8000e2b2:	10 95       	mov	r5,r8
	  ((long) blocksperrow * SIZEOF(JBLOCK));
  if (ltemp <= 0)
8000e2b4:	58 08       	cp.w	r8,0
8000e2b6:	e0 89 00 08 	brgt	8000e2c6 <alloc_barray+0x32>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
8000e2ba:	78 08       	ld.w	r8,r12[0x0]
8000e2bc:	34 69       	mov	r9,70
8000e2be:	91 59       	st.w	r8[0x14],r9
8000e2c0:	78 08       	ld.w	r8,r12[0x0]
8000e2c2:	70 08       	ld.w	r8,r8[0x0]
8000e2c4:	5d 18       	icall	r8
  if (ltemp < (long) numrows)
8000e2c6:	0c 35       	cp.w	r5,r6
8000e2c8:	ec 07 17 40 	movge	r7,r6
    rowsperchunk = (JDIMENSION) ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;
8000e2cc:	e3 47 00 50 	st.w	r1[80],r7

  /* Get space for row pointers (small object) */
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
8000e2d0:	ec 0a 15 02 	lsl	r10,r6,0x2
8000e2d4:	04 9b       	mov	r11,r2
8000e2d6:	08 9c       	mov	r12,r4
8000e2d8:	f0 1f 00 11 	mcall	8000e31c <alloc_barray+0x88>
8000e2dc:	18 91       	mov	r1,r12
				     (size_t) (numrows * SIZEOF(JBLOCKROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
8000e2de:	58 06       	cp.w	r6,0
8000e2e0:	c1 a0       	breq	8000e314 <alloc_barray+0x80>
8000e2e2:	30 05       	mov	r5,0
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
8000e2e4:	ec 05 01 08 	sub	r8,r6,r5
8000e2e8:	10 37       	cp.w	r7,r8
8000e2ea:	f0 07 17 b0 	movhi	r7,r8
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
8000e2ee:	e6 07 02 4a 	mul	r10,r3,r7
8000e2f2:	04 9b       	mov	r11,r2
8000e2f4:	08 9c       	mov	r12,r4
8000e2f6:	f0 1f 00 0b 	mcall	8000e320 <alloc_barray+0x8c>
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
8000e2fa:	58 07       	cp.w	r7,0
8000e2fc:	c0 90       	breq	8000e30e <alloc_barray+0x7a>

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
8000e2fe:	e2 05 00 29 	add	r9,r1,r5<<0x2
8000e302:	0e 98       	mov	r8,r7
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
      result[currow++] = workspace;
8000e304:	12 ac       	st.w	r9++,r12
      workspace += blocksperrow;
8000e306:	06 0c       	add	r12,r3
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
		  * SIZEOF(JBLOCK)));
    for (i = rowsperchunk; i > 0; i--) {
8000e308:	20 18       	sub	r8,1
8000e30a:	cf d1       	brne	8000e304 <alloc_barray+0x70>
8000e30c:	0e 05       	add	r5,r7
  result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
				     (size_t) (numrows * SIZEOF(JBLOCKROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
8000e30e:	0a 36       	cp.w	r6,r5
8000e310:	fe 9b ff ea 	brhi	8000e2e4 <alloc_barray+0x50>
      workspace += blocksperrow;
    }
  }

  return result;
}
8000e314:	02 9c       	mov	r12,r1
8000e316:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000e31a:	00 00       	add	r0,r0
8000e31c:	80 00       	ld.sh	r0,r0[0x0]
8000e31e:	db d4       	*unknown*
8000e320:	80 00       	ld.sh	r0,r0[0x0]
8000e322:	e2 0c       	*unknown*

8000e324 <alloc_sarray>:

METHODDEF(JSAMPARRAY)
alloc_sarray (j_common_ptr cinfo, int pool_id,
	      JDIMENSION samplesperrow, JDIMENSION numrows)
/* Allocate a 2-D sample array */
{
8000e324:	eb cd 40 fe 	pushm	r1-r7,lr
8000e328:	18 93       	mov	r3,r12
8000e32a:	16 92       	mov	r2,r11
8000e32c:	14 94       	mov	r4,r10
8000e32e:	12 96       	mov	r6,r9
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000e330:	78 11       	ld.w	r1,r12[0x4]
  JSAMPROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Calculate max # of rows allowed in one allocation chunk */
  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
8000e332:	e0 69 c9 f4 	mov	r9,51700
8000e336:	ea 19 3b 9a 	orh	r9,0x3b9a
8000e33a:	f2 0a 0d 08 	divu	r8,r9,r10
8000e33e:	10 97       	mov	r7,r8
8000e340:	10 95       	mov	r5,r8
	  ((long) samplesperrow * SIZEOF(JSAMPLE));
  if (ltemp <= 0)
8000e342:	58 08       	cp.w	r8,0
8000e344:	e0 89 00 08 	brgt	8000e354 <alloc_sarray+0x30>
    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
8000e348:	78 08       	ld.w	r8,r12[0x0]
8000e34a:	34 69       	mov	r9,70
8000e34c:	91 59       	st.w	r8[0x14],r9
8000e34e:	78 08       	ld.w	r8,r12[0x0]
8000e350:	70 08       	ld.w	r8,r8[0x0]
8000e352:	5d 18       	icall	r8
  if (ltemp < (long) numrows)
8000e354:	0c 35       	cp.w	r5,r6
8000e356:	ec 07 17 40 	movge	r7,r6
    rowsperchunk = (JDIMENSION) ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;
8000e35a:	e3 47 00 50 	st.w	r1[80],r7

  /* Get space for row pointers (small object) */
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
8000e35e:	ec 0a 15 02 	lsl	r10,r6,0x2
8000e362:	04 9b       	mov	r11,r2
8000e364:	06 9c       	mov	r12,r3
8000e366:	f0 1f 00 11 	mcall	8000e3a8 <alloc_sarray+0x84>
8000e36a:	18 91       	mov	r1,r12
				    (size_t) (numrows * SIZEOF(JSAMPROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
8000e36c:	58 06       	cp.w	r6,0
8000e36e:	c1 a0       	breq	8000e3a2 <alloc_sarray+0x7e>
8000e370:	30 05       	mov	r5,0
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
8000e372:	ec 05 01 08 	sub	r8,r6,r5
8000e376:	10 37       	cp.w	r7,r8
8000e378:	f0 07 17 b0 	movhi	r7,r8
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
8000e37c:	ee 04 02 4a 	mul	r10,r7,r4
8000e380:	04 9b       	mov	r11,r2
8000e382:	06 9c       	mov	r12,r3
8000e384:	f0 1f 00 0a 	mcall	8000e3ac <alloc_sarray+0x88>
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
8000e388:	58 07       	cp.w	r7,0
8000e38a:	c0 90       	breq	8000e39c <alloc_sarray+0x78>

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
8000e38c:	e2 05 00 29 	add	r9,r1,r5<<0x2
8000e390:	0e 98       	mov	r8,r7
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
      result[currow++] = workspace;
8000e392:	12 ac       	st.w	r9++,r12
      workspace += samplesperrow;
8000e394:	08 0c       	add	r12,r4
  while (currow < numrows) {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
		  * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--) {
8000e396:	20 18       	sub	r8,1
8000e398:	cf d1       	brne	8000e392 <alloc_sarray+0x6e>
8000e39a:	0e 05       	add	r5,r7
  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
				    (size_t) (numrows * SIZEOF(JSAMPROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows) {
8000e39c:	0a 36       	cp.w	r6,r5
8000e39e:	fe 9b ff ea 	brhi	8000e372 <alloc_sarray+0x4e>
      workspace += samplesperrow;
    }
  }

  return result;
}
8000e3a2:	02 9c       	mov	r12,r1
8000e3a4:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000e3a8:	80 00       	ld.sh	r0,r0[0x0]
8000e3aa:	db d4       	*unknown*
8000e3ac:	80 00       	ld.sh	r0,r0[0x0]
8000e3ae:	e2 0c       	*unknown*

8000e3b0 <realize_virt_arrays>:


METHODDEF(void)
realize_virt_arrays (j_common_ptr cinfo)
/* Allocate the in-memory buffers for any unrealized virtual arrays */
{
8000e3b0:	eb cd 40 fc 	pushm	r2-r7,lr
8000e3b4:	18 94       	mov	r4,r12
  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
8000e3b6:	78 15       	ld.w	r5,r12[0x4]
   * and the maximum space needed (full image height in each buffer).
   * These may be of use to the system-dependent jpeg_mem_available routine.
   */
  space_per_minheight = 0;
  maximum_space = 0;
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
8000e3b8:	6b 18       	ld.w	r8,r5[0x44]
8000e3ba:	58 08       	cp.w	r8,0
8000e3bc:	c0 41       	brne	8000e3c4 <realize_virt_arrays+0x14>
8000e3be:	30 07       	mov	r7,0
8000e3c0:	0e 96       	mov	r6,r7
8000e3c2:	c1 08       	rjmp	8000e3e2 <realize_virt_arrays+0x32>
8000e3c4:	30 07       	mov	r7,0
8000e3c6:	0e 96       	mov	r6,r7
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
8000e3c8:	70 09       	ld.w	r9,r8[0x0]
8000e3ca:	58 09       	cp.w	r9,0
8000e3cc:	c0 81       	brne	8000e3dc <realize_virt_arrays+0x2c>
      space_per_minheight += (long) sptr->maxaccess *
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
8000e3ce:	70 29       	ld.w	r9,r8[0x8]
   */
  space_per_minheight = 0;
  maximum_space = 0;
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
      space_per_minheight += (long) sptr->maxaccess *
8000e3d0:	70 3a       	ld.w	r10,r8[0xc]
8000e3d2:	f2 0a 03 46 	mac	r6,r9,r10
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
      maximum_space += (long) sptr->rows_in_array *
8000e3d6:	70 1a       	ld.w	r10,r8[0x4]
8000e3d8:	f2 0a 03 47 	mac	r7,r9,r10
   * and the maximum space needed (full image height in each buffer).
   * These may be of use to the system-dependent jpeg_mem_available routine.
   */
  space_per_minheight = 0;
  maximum_space = 0;
  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
8000e3dc:	70 b8       	ld.w	r8,r8[0x2c]
8000e3de:	58 08       	cp.w	r8,0
8000e3e0:	cf 41       	brne	8000e3c8 <realize_virt_arrays+0x18>
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
      maximum_space += (long) sptr->rows_in_array *
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
8000e3e2:	6b 28       	ld.w	r8,r5[0x48]
8000e3e4:	58 08       	cp.w	r8,0
8000e3e6:	c1 10       	breq	8000e408 <realize_virt_arrays+0x58>
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
8000e3e8:	70 09       	ld.w	r9,r8[0x0]
8000e3ea:	58 09       	cp.w	r9,0
8000e3ec:	c0 b1       	brne	8000e402 <realize_virt_arrays+0x52>
      space_per_minheight += (long) bptr->maxaccess *
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
8000e3ee:	70 29       	ld.w	r9,r8[0x8]
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
      space_per_minheight += (long) bptr->maxaccess *
8000e3f0:	70 3a       	ld.w	r10,r8[0xc]
8000e3f2:	f2 0a 02 4a 	mul	r10,r9,r10
8000e3f6:	a7 7a       	lsl	r10,0x7
8000e3f8:	14 06       	add	r6,r10
			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
      maximum_space += (long) bptr->rows_in_array *
8000e3fa:	70 1a       	ld.w	r10,r8[0x4]
8000e3fc:	b5 39       	mul	r9,r10
8000e3fe:	a7 79       	lsl	r9,0x7
8000e400:	12 07       	add	r7,r9
			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
      maximum_space += (long) sptr->rows_in_array *
		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
    }
  }
  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
8000e402:	70 b8       	ld.w	r8,r8[0x2c]
8000e404:	58 08       	cp.w	r8,0
8000e406:	cf 11       	brne	8000e3e8 <realize_virt_arrays+0x38>
      maximum_space += (long) bptr->rows_in_array *
		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
    }
  }

  if (space_per_minheight <= 0)
8000e408:	58 06       	cp.w	r6,0
8000e40a:	e0 8a 00 71 	brle	8000e4ec <realize_virt_arrays+0x13c>
    return;			/* no unrealized arrays, no work */

  /* Determine amount of memory to actually use; this is system-dependent. */
  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
8000e40e:	6b 39       	ld.w	r9,r5[0x4c]
8000e410:	0e 9a       	mov	r10,r7
8000e412:	0c 9b       	mov	r11,r6
8000e414:	08 9c       	mov	r12,r4
8000e416:	f0 1f 00 37 	mcall	8000e4f0 <realize_virt_arrays+0x140>

  /* If the maximum space needed is available, make all the buffers full
   * height; otherwise parcel it out with the same number of minheights
   * in each buffer.
   */
  if (avail_mem >= maximum_space)
8000e41a:	0e 3c       	cp.w	r12,r7
8000e41c:	c0 65       	brlt	8000e428 <realize_virt_arrays+0x78>
8000e41e:	e0 63 ca 00 	mov	r3,51712
8000e422:	ea 13 3b 9a 	orh	r3,0x3b9a
8000e426:	c0 68       	rjmp	8000e432 <realize_virt_arrays+0x82>
    max_minheights = 1000000000L;
  else {
    max_minheights = avail_mem / space_per_minheight;
8000e428:	f8 06 0c 08 	divs	r8,r12,r6
    /* If there doesn't seem to be enough space, try to get the minimum
     * anyway.  This allows a "stub" implementation of jpeg_mem_available().
     */
    if (max_minheights <= 0)
8000e42c:	30 13       	mov	r3,1
8000e42e:	f0 03 0c 43 	max	r3,r8,r3
      max_minheights = 1;
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
8000e432:	6b 17       	ld.w	r7,r5[0x44]
8000e434:	58 07       	cp.w	r7,0
8000e436:	c2 c0       	breq	8000e48e <realize_virt_arrays+0xde>
				(long) sptr->rows_in_array *
				(long) sptr->samplesperrow *
				(long) SIZEOF(JSAMPLE));
	sptr->b_s_open = TRUE;
      }
      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
8000e438:	30 12       	mov	r2,1
				      sptr->samplesperrow, sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
      sptr->cur_start_row = 0;
8000e43a:	30 06       	mov	r6,0
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
    if (sptr->mem_buffer == NULL) { /* if not realized yet */
8000e43c:	6e 08       	ld.w	r8,r7[0x0]
8000e43e:	58 08       	cp.w	r8,0
8000e440:	c2 41       	brne	8000e488 <realize_virt_arrays+0xd8>
      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
8000e442:	6e 18       	ld.w	r8,r7[0x4]
8000e444:	6e 39       	ld.w	r9,r7[0xc]
      if (minheights <= max_minheights) {
8000e446:	f0 cb 00 01 	sub	r11,r8,1
8000e44a:	f6 09 0d 0a 	divu	r10,r11,r9
8000e44e:	2f fa       	sub	r10,-1
8000e450:	14 33       	cp.w	r3,r10
8000e452:	c0 35       	brlt	8000e458 <realize_virt_arrays+0xa8>
	/* This buffer fits in memory */
	sptr->rows_in_mem = sptr->rows_in_array;
8000e454:	8f 48       	st.w	r7[0x10],r8
8000e456:	c0 d8       	rjmp	8000e470 <realize_virt_arrays+0xc0>
      } else {
	/* It doesn't fit in memory, create backing store. */
	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
8000e458:	e6 09 02 49 	mul	r9,r3,r9
8000e45c:	8f 49       	st.w	r7[0x10],r9
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
8000e45e:	6e 2a       	ld.w	r10,r7[0x8]
8000e460:	6e 18       	ld.w	r8,r7[0x4]
8000e462:	b1 3a       	mul	r10,r8
8000e464:	ee cb ff d0 	sub	r11,r7,-48
8000e468:	08 9c       	mov	r12,r4
8000e46a:	f0 1f 00 23 	mcall	8000e4f4 <realize_virt_arrays+0x144>
				(long) sptr->rows_in_array *
				(long) sptr->samplesperrow *
				(long) SIZEOF(JSAMPLE));
	sptr->b_s_open = TRUE;
8000e46e:	8f a2       	st.w	r7[0x28],r2
      }
      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
8000e470:	6e 49       	ld.w	r9,r7[0x10]
8000e472:	6e 2a       	ld.w	r10,r7[0x8]
8000e474:	04 9b       	mov	r11,r2
8000e476:	08 9c       	mov	r12,r4
8000e478:	f0 1f 00 20 	mcall	8000e4f8 <realize_virt_arrays+0x148>
8000e47c:	8f 0c       	st.w	r7[0x0],r12
				      sptr->samplesperrow, sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
8000e47e:	6b 48       	ld.w	r8,r5[0x50]
8000e480:	8f 58       	st.w	r7[0x14],r8
      sptr->cur_start_row = 0;
8000e482:	8f 66       	st.w	r7[0x18],r6
      sptr->first_undef_row = 0;
8000e484:	8f 76       	st.w	r7[0x1c],r6
      sptr->dirty = FALSE;
8000e486:	8f 96       	st.w	r7[0x24],r6
      max_minheights = 1;
  }

  /* Allocate the in-memory buffers and initialize backing store as needed. */

  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
8000e488:	6e b7       	ld.w	r7,r7[0x2c]
8000e48a:	58 07       	cp.w	r7,0
8000e48c:	cd 81       	brne	8000e43c <realize_virt_arrays+0x8c>
      sptr->first_undef_row = 0;
      sptr->dirty = FALSE;
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
8000e48e:	6b 27       	ld.w	r7,r5[0x48]
8000e490:	58 07       	cp.w	r7,0
8000e492:	c2 d0       	breq	8000e4ec <realize_virt_arrays+0x13c>
				(long) bptr->rows_in_array *
				(long) bptr->blocksperrow *
				(long) SIZEOF(JBLOCK));
	bptr->b_s_open = TRUE;
      }
      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
8000e494:	30 12       	mov	r2,1
				      bptr->blocksperrow, bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
      bptr->cur_start_row = 0;
8000e496:	30 06       	mov	r6,0
      sptr->dirty = FALSE;
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
    if (bptr->mem_buffer == NULL) { /* if not realized yet */
8000e498:	6e 08       	ld.w	r8,r7[0x0]
8000e49a:	58 08       	cp.w	r8,0
8000e49c:	c2 51       	brne	8000e4e6 <realize_virt_arrays+0x136>
      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
8000e49e:	6e 18       	ld.w	r8,r7[0x4]
8000e4a0:	6e 39       	ld.w	r9,r7[0xc]
      if (minheights <= max_minheights) {
8000e4a2:	f0 cb 00 01 	sub	r11,r8,1
8000e4a6:	f6 09 0d 0a 	divu	r10,r11,r9
8000e4aa:	2f fa       	sub	r10,-1
8000e4ac:	14 33       	cp.w	r3,r10
8000e4ae:	c0 35       	brlt	8000e4b4 <realize_virt_arrays+0x104>
	/* This buffer fits in memory */
	bptr->rows_in_mem = bptr->rows_in_array;
8000e4b0:	8f 48       	st.w	r7[0x10],r8
8000e4b2:	c0 e8       	rjmp	8000e4ce <realize_virt_arrays+0x11e>
      } else {
	/* It doesn't fit in memory, create backing store. */
	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
8000e4b4:	e6 09 02 49 	mul	r9,r3,r9
8000e4b8:	8f 49       	st.w	r7[0x10],r9
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
8000e4ba:	6e 1a       	ld.w	r10,r7[0x4]
8000e4bc:	6e 28       	ld.w	r8,r7[0x8]
8000e4be:	b1 3a       	mul	r10,r8
8000e4c0:	a7 7a       	lsl	r10,0x7
8000e4c2:	ee cb ff d0 	sub	r11,r7,-48
8000e4c6:	08 9c       	mov	r12,r4
8000e4c8:	f0 1f 00 0b 	mcall	8000e4f4 <realize_virt_arrays+0x144>
				(long) bptr->rows_in_array *
				(long) bptr->blocksperrow *
				(long) SIZEOF(JBLOCK));
	bptr->b_s_open = TRUE;
8000e4cc:	8f a2       	st.w	r7[0x28],r2
      }
      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
8000e4ce:	6e 49       	ld.w	r9,r7[0x10]
8000e4d0:	6e 2a       	ld.w	r10,r7[0x8]
8000e4d2:	04 9b       	mov	r11,r2
8000e4d4:	08 9c       	mov	r12,r4
8000e4d6:	f0 1f 00 0a 	mcall	8000e4fc <realize_virt_arrays+0x14c>
8000e4da:	8f 0c       	st.w	r7[0x0],r12
				      bptr->blocksperrow, bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
8000e4dc:	6b 48       	ld.w	r8,r5[0x50]
8000e4de:	8f 58       	st.w	r7[0x14],r8
      bptr->cur_start_row = 0;
8000e4e0:	8f 66       	st.w	r7[0x18],r6
      bptr->first_undef_row = 0;
8000e4e2:	8f 76       	st.w	r7[0x1c],r6
      bptr->dirty = FALSE;
8000e4e4:	8f 96       	st.w	r7[0x24],r6
      sptr->first_undef_row = 0;
      sptr->dirty = FALSE;
    }
  }

  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
8000e4e6:	6e b7       	ld.w	r7,r7[0x2c]
8000e4e8:	58 07       	cp.w	r7,0
8000e4ea:	cd 71       	brne	8000e498 <realize_virt_arrays+0xe8>
8000e4ec:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000e4f0:	80 00       	ld.sh	r0,r0[0x0]
8000e4f2:	e5 00 80 00 	ld.sh	r0,r2[-32768]
8000e4f6:	e5 02 80 00 	ld.sh	r2,r2[-32768]
8000e4fa:	e3 24 80 00 	ld.sb	r4,r1[-32768]
8000e4fe:	e2 94 5e fa 	brge	8007a2f2 <_data_sdram_lma+0x5972a>

8000e500 <jpeg_mem_available>:
GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
		    long max_bytes_needed, long already_allocated)
{
  return max_bytes_needed;
}
8000e500:	5e fa       	retal	r10

8000e502 <jpeg_open_backing_store>:
 */

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
8000e502:	d4 01       	pushm	lr
  ERREXIT(cinfo, JERR_NO_BACKING_STORE);
8000e504:	78 09       	ld.w	r9,r12[0x0]
8000e506:	33 1a       	mov	r10,49
8000e508:	93 5a       	st.w	r9[0x14],r10
8000e50a:	78 08       	ld.w	r8,r12[0x0]
8000e50c:	70 08       	ld.w	r8,r8[0x0]
8000e50e:	5d 18       	icall	r8
}
8000e510:	d8 02       	popm	pc

8000e512 <jpeg_mem_init>:

GLOBAL(long)
jpeg_mem_init (j_common_ptr cinfo)
{
  return 0;			/* just set max_memory_to_use to 0 */
}
8000e512:	5e fd       	retal	0

8000e514 <jpeg_mem_term>:

GLOBAL(void)
jpeg_mem_term (j_common_ptr cinfo)
{
  /* no work */
}
8000e514:	5e fc       	retal	r12
8000e516:	d7 03       	nop

8000e518 <jpeg_free_large>:
  return (void FAR *) malloc(sizeofobject);
}

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
8000e518:	d4 01       	pushm	lr
  free(object);
8000e51a:	16 9c       	mov	r12,r11
8000e51c:	f0 1f 00 02 	mcall	8000e524 <jpeg_free_large+0xc>
}
8000e520:	d8 02       	popm	pc
8000e522:	00 00       	add	r0,r0
8000e524:	80 01       	ld.sh	r1,r0[0x0]
8000e526:	50 48       	stdsp	sp[0x10],r8

8000e528 <jpeg_free_small>:
  return (void *) malloc(sizeofobject);
}

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
8000e528:	d4 01       	pushm	lr
  free(object);
8000e52a:	16 9c       	mov	r12,r11
8000e52c:	f0 1f 00 02 	mcall	8000e534 <jpeg_free_small+0xc>
}
8000e530:	d8 02       	popm	pc
8000e532:	00 00       	add	r0,r0
8000e534:	80 01       	ld.sh	r1,r0[0x0]
8000e536:	50 48       	stdsp	sp[0x10],r8

8000e538 <jpeg_get_large>:
 * you probably won't be able to process useful-size images in only 64KB.
 */

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
8000e538:	d4 01       	pushm	lr
  return (void FAR *) malloc(sizeofobject);
8000e53a:	16 9c       	mov	r12,r11
8000e53c:	f0 1f 00 02 	mcall	8000e544 <jpeg_get_large+0xc>
}
8000e540:	d8 02       	popm	pc
8000e542:	00 00       	add	r0,r0
8000e544:	80 01       	ld.sh	r1,r0[0x0]
8000e546:	50 58       	stdsp	sp[0x14],r8

8000e548 <jpeg_get_small>:
 * routines malloc() and free().
 */

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
8000e548:	d4 01       	pushm	lr
  return (void *) malloc(sizeofobject);
8000e54a:	16 9c       	mov	r12,r11
8000e54c:	f0 1f 00 02 	mcall	8000e554 <jpeg_get_small+0xc>
}
8000e550:	d8 02       	popm	pc
8000e552:	00 00       	add	r0,r0
8000e554:	80 01       	ld.sh	r1,r0[0x0]
8000e556:	50 58       	stdsp	sp[0x14],r8

8000e558 <largest_input_value>:

LOCAL(int)
largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
/* Return largest input value that should map to j'th output value */
/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
{
8000e558:	f4 08 15 08 	lsl	r8,r10,0x8
8000e55c:	14 18       	sub	r8,r10
8000e55e:	f2 08 00 18 	add	r8,r9,r8<<0x1
8000e562:	f0 c8 ff 01 	sub	r8,r8,-255
8000e566:	a1 79       	lsl	r9,0x1
8000e568:	f0 09 0c 08 	divs	r8,r8,r9
  /* Breakpoints are halfway between values returned by output_value */
  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
}
8000e56c:	5e f8       	retal	r8
8000e56e:	d7 03       	nop

8000e570 <create_colorindex>:
 * Create the color index table.
 */

LOCAL(void)
create_colorindex (j_decompress_ptr cinfo)
{
8000e570:	d4 31       	pushm	r0-r7,lr
8000e572:	20 3d       	sub	sp,12
8000e574:	18 95       	mov	r5,r12
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000e576:	f8 f0 01 cc 	ld.w	r0,r12[460]
  /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
   * This is not necessary in the other dithering modes.  However, we
   * flag whether it was done in case user changes dithering mode.
   */
  if (cinfo->dither_mode == JDITHER_ORDERED) {
8000e57a:	79 68       	ld.w	r8,r12[0x58]
8000e57c:	58 18       	cp.w	r8,1
8000e57e:	c0 61       	brne	8000e58a <create_colorindex+0x1a>
    pad = MAXJSAMPLE*2;
    cquantize->is_padded = TRUE;
8000e580:	81 78       	st.w	r0[0x1c],r8
8000e582:	e0 6b 01 fe 	mov	r11,510
8000e586:	50 1b       	stdsp	sp[0x4],r11
8000e588:	c0 48       	rjmp	8000e590 <create_colorindex+0x20>
  } else {
    pad = 0;
    cquantize->is_padded = FALSE;
8000e58a:	30 08       	mov	r8,0
8000e58c:	81 78       	st.w	r0[0x1c],r8
8000e58e:	50 18       	stdsp	sp[0x4],r8
  }

  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
8000e590:	6a 18       	ld.w	r8,r5[0x4]
8000e592:	70 28       	ld.w	r8,r8[0x8]
8000e594:	6b e9       	ld.w	r9,r5[0x78]
8000e596:	40 1b       	lddsp	r11,sp[0x4]
8000e598:	f6 ca ff 00 	sub	r10,r11,-256
8000e59c:	30 1b       	mov	r11,1
8000e59e:	0a 9c       	mov	r12,r5
8000e5a0:	5d 18       	icall	r8
8000e5a2:	81 6c       	st.w	r0[0x18],r12
    ((j_common_ptr) cinfo, JPOOL_IMAGE,
     (JDIMENSION) (MAXJSAMPLE+1 + pad),
     (JDIMENSION) cinfo->out_color_components);

  /* blksize is number of adjacent repeated entries for a component */
  blksize = cquantize->sv_actual;
8000e5a4:	60 51       	ld.w	r1,r0[0x14]

  for (i = 0; i < cinfo->out_color_components; i++) {
8000e5a6:	6b e8       	ld.w	r8,r5[0x78]
8000e5a8:	58 08       	cp.w	r8,0
8000e5aa:	e0 8a 00 55 	brle	8000e654 <create_colorindex+0xe4>
8000e5ae:	e0 c9 ff e0 	sub	r9,r0,-32
8000e5b2:	50 29       	stdsp	sp[0x8],r9
8000e5b4:	30 08       	mov	r8,0
8000e5b6:	50 08       	stdsp	sp[0x0],r8
8000e5b8:	10 94       	mov	r4,r8
    /* fill in colorindex entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
8000e5ba:	40 2b       	lddsp	r11,sp[0x8]
8000e5bc:	76 03       	ld.w	r3,r11[0x0]
    blksize = blksize / nci;
8000e5be:	e2 03 0c 08 	divs	r8,r1,r3
8000e5c2:	10 91       	mov	r1,r8

    /* adjust colorindex pointers to provide padding at negative indexes. */
    if (pad)
8000e5c4:	40 19       	lddsp	r9,sp[0x4]
8000e5c6:	58 09       	cp.w	r9,0
8000e5c8:	c0 80       	breq	8000e5d8 <create_colorindex+0x68>
      cquantize->colorindex[i] += MAXJSAMPLE;
8000e5ca:	60 68       	ld.w	r8,r0[0x18]
8000e5cc:	40 0b       	lddsp	r11,sp[0x0]
8000e5ce:	16 08       	add	r8,r11
8000e5d0:	70 09       	ld.w	r9,r8[0x0]
8000e5d2:	f2 c9 ff 01 	sub	r9,r9,-255
8000e5d6:	91 09       	st.w	r8[0x0],r9

    /* in loop, val = index of current output value, */
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
8000e5d8:	60 68       	ld.w	r8,r0[0x18]
8000e5da:	40 09       	lddsp	r9,sp[0x0]
8000e5dc:	f0 09 03 02 	ld.w	r2,r8[r9]
    val = 0;
    k = largest_input_value(cinfo, i, 0, nci-1);
8000e5e0:	20 13       	sub	r3,1
8000e5e2:	06 99       	mov	r9,r3
8000e5e4:	30 0a       	mov	r10,0
8000e5e6:	08 9b       	mov	r11,r4
8000e5e8:	0a 9c       	mov	r12,r5
8000e5ea:	f0 1f 00 1c 	mcall	8000e658 <create_colorindex+0xe8>
8000e5ee:	30 06       	mov	r6,0
8000e5f0:	0c 97       	mov	r7,r6
8000e5f2:	c1 28       	rjmp	8000e616 <create_colorindex+0xa6>
    for (j = 0; j <= MAXJSAMPLE; j++) {
      while (j > k)		/* advance val if past boundary */
	k = largest_input_value(cinfo, i, ++val, nci-1);
8000e5f4:	2f f7       	sub	r7,-1
8000e5f6:	06 99       	mov	r9,r3
8000e5f8:	0e 9a       	mov	r10,r7
8000e5fa:	08 9b       	mov	r11,r4
8000e5fc:	0a 9c       	mov	r12,r5
8000e5fe:	f0 1f 00 17 	mcall	8000e658 <create_colorindex+0xe8>
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
    val = 0;
    k = largest_input_value(cinfo, i, 0, nci-1);
    for (j = 0; j <= MAXJSAMPLE; j++) {
      while (j > k)		/* advance val if past boundary */
8000e602:	0c 3c       	cp.w	r12,r6
8000e604:	cf 85       	brlt	8000e5f4 <create_colorindex+0x84>
	k = largest_input_value(cinfo, i, ++val, nci-1);
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
8000e606:	0e 98       	mov	r8,r7
8000e608:	a3 38       	mul	r8,r1
8000e60a:	e4 06 0b 08 	st.b	r2[r6],r8
    /* in loop, val = index of current output value, */
    /* and k = largest j that maps to current val */
    indexptr = cquantize->colorindex[i];
    val = 0;
    k = largest_input_value(cinfo, i, 0, nci-1);
    for (j = 0; j <= MAXJSAMPLE; j++) {
8000e60e:	2f f6       	sub	r6,-1
8000e610:	e0 46 01 00 	cp.w	r6,256
8000e614:	c0 40       	breq	8000e61c <create_colorindex+0xac>
      while (j > k)		/* advance val if past boundary */
8000e616:	0c 3c       	cp.w	r12,r6
8000e618:	ce e5       	brlt	8000e5f4 <create_colorindex+0x84>
8000e61a:	cf 6b       	rjmp	8000e606 <create_colorindex+0x96>
	k = largest_input_value(cinfo, i, ++val, nci-1);
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
    }
    /* Pad at both ends if necessary */
    if (pad)
8000e61c:	40 18       	lddsp	r8,sp[0x4]
8000e61e:	58 08       	cp.w	r8,0
8000e620:	c0 f0       	breq	8000e63e <create_colorindex+0xce>
8000e622:	e4 c8 00 01 	sub	r8,r2,1
8000e626:	e4 c9 ff 00 	sub	r9,r2,-256
/*
 * Create the color index table.
 */

LOCAL(void)
create_colorindex (j_decompress_ptr cinfo)
8000e62a:	e4 cb 01 00 	sub	r11,r2,256
      indexptr[j] = (JSAMPLE) (val * blksize);
    }
    /* Pad at both ends if necessary */
    if (pad)
      for (j = 1; j <= MAXJSAMPLE; j++) {
	indexptr[-j] = indexptr[0];
8000e62e:	05 8a       	ld.ub	r10,r2[0x0]
8000e630:	b0 8a       	st.b	r8[0x0],r10
	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
8000e632:	e5 3a 00 ff 	ld.ub	r10,r2[255]
8000e636:	12 ca       	st.b	r9++,r10
8000e638:	20 18       	sub	r8,1
      /* premultiply so that no multiplication needed in main processing */
      indexptr[j] = (JSAMPLE) (val * blksize);
    }
    /* Pad at both ends if necessary */
    if (pad)
      for (j = 1; j <= MAXJSAMPLE; j++) {
8000e63a:	16 38       	cp.w	r8,r11
8000e63c:	cf 91       	brne	8000e62e <create_colorindex+0xbe>
     (JDIMENSION) cinfo->out_color_components);

  /* blksize is number of adjacent repeated entries for a component */
  blksize = cquantize->sv_actual;

  for (i = 0; i < cinfo->out_color_components; i++) {
8000e63e:	2f f4       	sub	r4,-1
8000e640:	40 2b       	lddsp	r11,sp[0x8]
8000e642:	2f cb       	sub	r11,-4
8000e644:	50 2b       	stdsp	sp[0x8],r11
8000e646:	40 09       	lddsp	r9,sp[0x0]
8000e648:	2f c9       	sub	r9,-4
8000e64a:	50 09       	stdsp	sp[0x0],r9
8000e64c:	6b e8       	ld.w	r8,r5[0x78]
8000e64e:	08 38       	cp.w	r8,r4
8000e650:	fe 99 ff b5 	brgt	8000e5ba <create_colorindex+0x4a>
      for (j = 1; j <= MAXJSAMPLE; j++) {
	indexptr[-j] = indexptr[0];
	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
      }
  }
}
8000e654:	2f dd       	sub	sp,-12
8000e656:	d8 32       	popm	r0-r7,pc
8000e658:	80 00       	ld.sh	r0,r0[0x0]
8000e65a:	e5 58 d4 31 	st.h	r2[-11215],r8

8000e65c <color_quantize>:

METHODDEF(void)
color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		JSAMPARRAY output_buf, int num_rows)
/* General case, no dithering */
{
8000e65c:	d4 31       	pushm	r0-r7,lr
8000e65e:	20 3d       	sub	sp,12
8000e660:	50 29       	stdsp	sp[0x8],r9
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  JSAMPARRAY colorindex = cquantize->colorindex;
8000e662:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000e666:	70 61       	ld.w	r1,r8[0x18]
  register int pixcode, ci;
  register JSAMPROW ptrin, ptrout;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000e668:	79 c5       	ld.w	r5,r12[0x70]
  register int nc = cinfo->out_color_components;
8000e66a:	79 ee       	ld.w	lr,r12[0x78]

  for (row = 0; row < num_rows; row++) {
8000e66c:	58 09       	cp.w	r9,0
8000e66e:	e0 8a 00 31 	brle	8000e6d0 <color_quantize+0x74>
8000e672:	16 90       	mov	r0,r11
8000e674:	50 0a       	stdsp	sp[0x0],r10
8000e676:	30 09       	mov	r9,0
8000e678:	50 19       	stdsp	sp[0x4],r9
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
      pixcode = 0;
      for (ci = 0; ci < nc; ci++) {
8000e67a:	12 93       	mov	r3,r9
8000e67c:	12 92       	mov	r2,r9
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  register int nc = cinfo->out_color_components;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
8000e67e:	60 07       	ld.w	r7,r0[0x0]
    ptrout = output_buf[row];
8000e680:	40 08       	lddsp	r8,sp[0x0]
8000e682:	70 04       	ld.w	r4,r8[0x0]
    for (col = width; col > 0; col--) {
8000e684:	58 05       	cp.w	r5,0
8000e686:	c1 b0       	breq	8000e6bc <color_quantize+0x60>
8000e688:	30 06       	mov	r6,0
8000e68a:	c1 08       	rjmp	8000e6aa <color_quantize+0x4e>
      pixcode = 0;
      for (ci = 0; ci < nc; ci++) {
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
8000e68c:	ee 08 07 0b 	ld.ub	r11,r7[r8]
8000e690:	15 0c       	ld.w	r12,r10++
8000e692:	f8 0b 07 0b 	ld.ub	r11,r12[r11]
8000e696:	16 09       	add	r9,r11
  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
      pixcode = 0;
      for (ci = 0; ci < nc; ci++) {
8000e698:	2f f8       	sub	r8,-1
8000e69a:	1c 38       	cp.w	r8,lr
8000e69c:	cf 81       	brne	8000e68c <color_quantize+0x30>
8000e69e:	1c 07       	add	r7,lr
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
      }
      *ptrout++ = (JSAMPLE) pixcode;
8000e6a0:	e8 06 0b 09 	st.b	r4[r6],r9
8000e6a4:	2f f6       	sub	r6,-1
  register int nc = cinfo->out_color_components;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
8000e6a6:	0c 35       	cp.w	r5,r6
8000e6a8:	c0 a0       	breq	8000e6bc <color_quantize+0x60>
      pixcode = 0;
      for (ci = 0; ci < nc; ci++) {
8000e6aa:	58 0e       	cp.w	lr,0
8000e6ac:	e0 89 00 04 	brgt	8000e6b4 <color_quantize+0x58>
8000e6b0:	06 99       	mov	r9,r3
8000e6b2:	cf 7b       	rjmp	8000e6a0 <color_quantize+0x44>
8000e6b4:	02 9a       	mov	r10,r1
8000e6b6:	06 98       	mov	r8,r3
8000e6b8:	04 99       	mov	r9,r2
8000e6ba:	ce 9b       	rjmp	8000e68c <color_quantize+0x30>
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  register int nc = cinfo->out_color_components;

  for (row = 0; row < num_rows; row++) {
8000e6bc:	40 19       	lddsp	r9,sp[0x4]
8000e6be:	2f f9       	sub	r9,-1
8000e6c0:	50 19       	stdsp	sp[0x4],r9
8000e6c2:	2f c0       	sub	r0,-4
8000e6c4:	40 08       	lddsp	r8,sp[0x0]
8000e6c6:	2f c8       	sub	r8,-4
8000e6c8:	50 08       	stdsp	sp[0x0],r8
8000e6ca:	40 28       	lddsp	r8,sp[0x8]
8000e6cc:	10 39       	cp.w	r9,r8
8000e6ce:	cd 81       	brne	8000e67e <color_quantize+0x22>
	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
      }
      *ptrout++ = (JSAMPLE) pixcode;
    }
  }
}
8000e6d0:	2f dd       	sub	sp,-12
8000e6d2:	d8 32       	popm	r0-r7,pc

8000e6d4 <color_quantize3>:

METHODDEF(void)
color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		 JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, no dithering */
{
8000e6d4:	d4 31       	pushm	r0-r7,lr
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register int pixcode;
  register JSAMPROW ptrin, ptrout;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
8000e6d6:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000e6da:	70 68       	ld.w	r8,r8[0x18]
8000e6dc:	70 03       	ld.w	r3,r8[0x0]
  JSAMPROW colorindex1 = cquantize->colorindex[1];
8000e6de:	70 14       	ld.w	r4,r8[0x4]
  JSAMPROW colorindex2 = cquantize->colorindex[2];
8000e6e0:	70 25       	ld.w	r5,r8[0x8]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000e6e2:	79 c7       	ld.w	r7,r12[0x70]

  for (row = 0; row < num_rows; row++) {
8000e6e4:	58 09       	cp.w	r9,0
8000e6e6:	e0 8a 00 21 	brle	8000e728 <color_quantize3+0x54>
8000e6ea:	16 90       	mov	r0,r11
8000e6ec:	14 91       	mov	r1,r10
8000e6ee:	30 02       	mov	r2,0
    ptrin = input_buf[row];
8000e6f0:	60 08       	ld.w	r8,r0[0x0]
    ptrout = output_buf[row];
8000e6f2:	62 0e       	ld.w	lr,r1[0x0]
    for (col = width; col > 0; col--) {
8000e6f4:	58 07       	cp.w	r7,0
8000e6f6:	c1 40       	breq	8000e71e <color_quantize3+0x4a>
8000e6f8:	30 0a       	mov	r10,0
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
8000e6fa:	11 8b       	ld.ub	r11,r8[0x0]
8000e6fc:	e6 0b 07 0c 	ld.ub	r12,r3[r11]
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
8000e700:	11 9b       	ld.ub	r11,r8[0x1]
8000e702:	e8 0b 07 06 	ld.ub	r6,r4[r11]
8000e706:	11 ab       	ld.ub	r11,r8[0x2]
8000e708:	ea 0b 07 0b 	ld.ub	r11,r5[r11]
8000e70c:	ec 0b 00 0b 	add	r11,r6,r11
  }
}


METHODDEF(void)
color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
8000e710:	2f d8       	sub	r8,-3
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
      *ptrout++ = (JSAMPLE) pixcode;
8000e712:	18 0b       	add	r11,r12
8000e714:	fc 0a 0b 0b 	st.b	lr[r10],r11
8000e718:	2f fa       	sub	r10,-1
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for (col = width; col > 0; col--) {
8000e71a:	14 37       	cp.w	r7,r10
8000e71c:	ce f1       	brne	8000e6fa <color_quantize3+0x26>
  JSAMPROW colorindex2 = cquantize->colorindex[2];
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
8000e71e:	2f f2       	sub	r2,-1
8000e720:	2f c0       	sub	r0,-4
8000e722:	2f c1       	sub	r1,-4
8000e724:	12 32       	cp.w	r2,r9
8000e726:	ce 51       	brne	8000e6f0 <color_quantize3+0x1c>
8000e728:	d8 32       	popm	r0-r7,pc

8000e72a <quantize3_ord_dither>:

METHODDEF(void)
quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		      JSAMPARRAY output_buf, int num_rows)
/* Fast path for out_color_components==3, with ordered dithering */
{
8000e72a:	d4 31       	pushm	r0-r7,lr
8000e72c:	20 8d       	sub	sp,32
8000e72e:	50 69       	stdsp	sp[0x18],r9
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000e730:	f8 f9 01 cc 	ld.w	r9,r12[460]
8000e734:	50 19       	stdsp	sp[0x4],r9
  register int pixcode;
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex0 = cquantize->colorindex[0];
8000e736:	72 68       	ld.w	r8,r9[0x18]
8000e738:	70 00       	ld.w	r0,r8[0x0]
  JSAMPROW colorindex1 = cquantize->colorindex[1];
8000e73a:	70 11       	ld.w	r1,r8[0x4]
  JSAMPROW colorindex2 = cquantize->colorindex[2];
8000e73c:	70 28       	ld.w	r8,r8[0x8]
8000e73e:	50 08       	stdsp	sp[0x0],r8
  int * dither1;
  int * dither2;
  int row_index, col_index;	/* current indexes into dither matrix */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000e740:	79 c6       	ld.w	r6,r12[0x70]

  for (row = 0; row < num_rows; row++) {
8000e742:	40 68       	lddsp	r8,sp[0x18]
8000e744:	58 08       	cp.w	r8,0
8000e746:	e0 8a 00 50 	brle	8000e7e6 <quantize3_ord_dither+0xbc>
8000e74a:	50 3b       	stdsp	sp[0xc],r11
8000e74c:	50 2a       	stdsp	sp[0x8],r10
8000e74e:	30 07       	mov	r7,0
8000e750:	50 47       	stdsp	sp[0x10],r7
    dither0 = cquantize->odither[0][row_index];
    dither1 = cquantize->odither[1][row_index];
    dither2 = cquantize->odither[2][row_index];
    col_index = 0;

    for (col = width; col > 0; col--) {
8000e752:	50 77       	stdsp	sp[0x1c],r7
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    row_index = cquantize->row_index;
8000e754:	40 19       	lddsp	r9,sp[0x4]
8000e756:	72 c9       	ld.w	r9,r9[0x30]
8000e758:	50 59       	stdsp	sp[0x14],r9
    input_ptr = input_buf[row];
8000e75a:	40 37       	lddsp	r7,sp[0xc]
8000e75c:	6e 08       	ld.w	r8,r7[0x0]
    output_ptr = output_buf[row];
8000e75e:	40 2a       	lddsp	r10,sp[0x8]
8000e760:	74 02       	ld.w	r2,r10[0x0]
    dither0 = cquantize->odither[0][row_index];
8000e762:	a7 69       	lsl	r9,0x6
8000e764:	40 17       	lddsp	r7,sp[0x4]
8000e766:	6e d3       	ld.w	r3,r7[0x34]
8000e768:	12 03       	add	r3,r9
    dither1 = cquantize->odither[1][row_index];
8000e76a:	6e e4       	ld.w	r4,r7[0x38]
8000e76c:	12 04       	add	r4,r9
    dither2 = cquantize->odither[2][row_index];
8000e76e:	6e f5       	ld.w	r5,r7[0x3c]
8000e770:	12 05       	add	r5,r9
    col_index = 0;

    for (col = width; col > 0; col--) {
8000e772:	58 06       	cp.w	r6,0
8000e774:	c2 70       	breq	8000e7c2 <quantize3_ord_dither+0x98>
8000e776:	30 09       	mov	r9,0
8000e778:	40 7b       	lddsp	r11,sp[0x1c]
      pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
8000e77a:	f6 0a 15 02 	lsl	r10,r11,0x2
8000e77e:	11 8c       	ld.ub	r12,r8[0x0]
8000e780:	e6 0a 03 0e 	ld.w	lr,r3[r10]
8000e784:	e0 0e 00 0e 	add	lr,r0,lr
8000e788:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
					dither0[col_index]]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
8000e78c:	11 9e       	ld.ub	lr,r8[0x1]
8000e78e:	e8 0a 03 07 	ld.w	r7,r4[r10]
8000e792:	e2 07 00 07 	add	r7,r1,r7
8000e796:	ee 0e 07 0e 	ld.ub	lr,r7[lr]
8000e79a:	fc 0c 00 0c 	add	r12,lr,r12
					dither1[col_index]]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
8000e79e:	11 ae       	ld.ub	lr,r8[0x2]
8000e7a0:	ea 0a 03 0a 	ld.w	r10,r5[r10]
8000e7a4:	40 07       	lddsp	r7,sp[0x0]
8000e7a6:	ee 0a 00 0a 	add	r10,r7,r10
8000e7aa:	f4 0e 07 0a 	ld.ub	r10,r10[lr]
8000e7ae:	14 0c       	add	r12,r10
  }
}


METHODDEF(void)
quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
8000e7b0:	2f d8       	sub	r8,-3
					dither0[col_index]]);
      pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
					dither1[col_index]]);
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
					dither2[col_index]]);
      *output_ptr++ = (JSAMPLE) pixcode;
8000e7b2:	e4 09 0b 0c 	st.b	r2[r9],r12
      col_index = (col_index + 1) & ODITHER_MASK;
8000e7b6:	2f fb       	sub	r11,-1
8000e7b8:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
8000e7bc:	2f f9       	sub	r9,-1
    dither0 = cquantize->odither[0][row_index];
    dither1 = cquantize->odither[1][row_index];
    dither2 = cquantize->odither[2][row_index];
    col_index = 0;

    for (col = width; col > 0; col--) {
8000e7be:	12 36       	cp.w	r6,r9
8000e7c0:	cd d1       	brne	8000e77a <quantize3_ord_dither+0x50>
      pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
					dither2[col_index]]);
      *output_ptr++ = (JSAMPLE) pixcode;
      col_index = (col_index + 1) & ODITHER_MASK;
    }
    row_index = (row_index + 1) & ODITHER_MASK;
8000e7c2:	40 58       	lddsp	r8,sp[0x14]
8000e7c4:	2f f8       	sub	r8,-1
    cquantize->row_index = row_index;
8000e7c6:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000e7ca:	40 1a       	lddsp	r10,sp[0x4]
8000e7cc:	95 c8       	st.w	r10[0x30],r8
  int row_index, col_index;	/* current indexes into dither matrix */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
8000e7ce:	40 49       	lddsp	r9,sp[0x10]
8000e7d0:	2f f9       	sub	r9,-1
8000e7d2:	50 49       	stdsp	sp[0x10],r9
8000e7d4:	40 38       	lddsp	r8,sp[0xc]
8000e7d6:	2f c8       	sub	r8,-4
8000e7d8:	50 38       	stdsp	sp[0xc],r8
8000e7da:	40 27       	lddsp	r7,sp[0x8]
8000e7dc:	2f c7       	sub	r7,-4
8000e7de:	50 27       	stdsp	sp[0x8],r7
8000e7e0:	40 6a       	lddsp	r10,sp[0x18]
8000e7e2:	14 39       	cp.w	r9,r10
8000e7e4:	cb 81       	brne	8000e754 <quantize3_ord_dither+0x2a>
      col_index = (col_index + 1) & ODITHER_MASK;
    }
    row_index = (row_index + 1) & ODITHER_MASK;
    cquantize->row_index = row_index;
  }
}
8000e7e6:	2f 8d       	sub	sp,-32
8000e7e8:	d8 32       	popm	r0-r7,pc

8000e7ea <alloc_fs_workspace>:
 * Allocate workspace for Floyd-Steinberg errors.
 */

LOCAL(void)
alloc_fs_workspace (j_decompress_ptr cinfo)
{
8000e7ea:	eb cd 40 f8 	pushm	r3-r7,lr
8000e7ee:	18 97       	mov	r7,r12
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000e7f0:	f8 f5 01 cc 	ld.w	r5,r12[460]
  size_t arraysize;
  int i;

  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
8000e7f4:	79 c4       	ld.w	r4,r12[0x70]
8000e7f6:	2f e4       	sub	r4,-2
8000e7f8:	a1 74       	lsl	r4,0x1
  for (i = 0; i < cinfo->out_color_components; i++) {
8000e7fa:	79 e8       	ld.w	r8,r12[0x78]
8000e7fc:	58 08       	cp.w	r8,0
8000e7fe:	e0 8a 00 11 	brle	8000e820 <alloc_fs_workspace+0x36>
8000e802:	2b c5       	sub	r5,-68
8000e804:	30 06       	mov	r6,0
    cquantize->fserrors[i] = (FSERRPTR)
8000e806:	30 13       	mov	r3,1
8000e808:	6e 18       	ld.w	r8,r7[0x4]
8000e80a:	70 18       	ld.w	r8,r8[0x4]
8000e80c:	08 9a       	mov	r10,r4
8000e80e:	06 9b       	mov	r11,r3
8000e810:	0e 9c       	mov	r12,r7
8000e812:	5d 18       	icall	r8
8000e814:	0a ac       	st.w	r5++,r12
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  size_t arraysize;
  int i;

  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
  for (i = 0; i < cinfo->out_color_components; i++) {
8000e816:	2f f6       	sub	r6,-1
8000e818:	6f e8       	ld.w	r8,r7[0x78]
8000e81a:	0c 38       	cp.w	r8,r6
8000e81c:	fe 99 ff f6 	brgt	8000e808 <alloc_fs_workspace+0x1e>
8000e820:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8000e824 <finish_pass_1_quant>:

METHODDEF(void)
finish_pass_1_quant (j_decompress_ptr cinfo)
{
  /* no work in 1-pass case */
}
8000e824:	5e fc       	retal	r12

8000e826 <new_color_map_1_quant>:
 * Shouldn't get to this module!
 */

METHODDEF(void)
new_color_map_1_quant (j_decompress_ptr cinfo)
{
8000e826:	d4 01       	pushm	lr
  ERREXIT(cinfo, JERR_MODE_CHANGE);
8000e828:	78 09       	ld.w	r9,r12[0x0]
8000e82a:	32 ea       	mov	r10,46
8000e82c:	93 5a       	st.w	r9[0x14],r10
8000e82e:	78 08       	ld.w	r8,r12[0x0]
8000e830:	70 08       	ld.w	r8,r8[0x0]
8000e832:	5d 18       	icall	r8
}
8000e834:	d8 02       	popm	pc
8000e836:	d7 03       	nop

8000e838 <jinit_1pass_quantizer>:
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
{
8000e838:	d4 31       	pushm	r0-r7,lr
8000e83a:	20 ad       	sub	sp,40
8000e83c:	18 96       	mov	r6,r12
  my_cquantize_ptr cquantize;

  cquantize = (my_cquantize_ptr)
8000e83e:	18 93       	mov	r3,r12
8000e840:	78 18       	ld.w	r8,r12[0x4]
8000e842:	70 08       	ld.w	r8,r8[0x0]
8000e844:	35 8a       	mov	r10,88
8000e846:	30 1b       	mov	r11,1
8000e848:	5d 18       	icall	r8
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
8000e84a:	ed 4c 01 cc 	st.w	r6[460],r12
  cquantize->pub.start_pass = start_pass_1_quant;
8000e84e:	fe f8 02 2e 	ld.w	r8,pc[558]
8000e852:	99 08       	st.w	r12[0x0],r8
  cquantize->pub.finish_pass = finish_pass_1_quant;
8000e854:	fe f8 02 2c 	ld.w	r8,pc[556]
8000e858:	99 28       	st.w	r12[0x8],r8
  cquantize->pub.new_color_map = new_color_map_1_quant;
8000e85a:	fe f8 02 2a 	ld.w	r8,pc[554]
8000e85e:	99 38       	st.w	r12[0xc],r8
  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
8000e860:	30 08       	mov	r8,0
8000e862:	f9 48 00 44 	st.w	r12[68],r8
  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
8000e866:	99 d8       	st.w	r12[0x34],r8

  /* Make sure my internal arrays won't overflow */
  if (cinfo->out_color_components > MAX_Q_COMPS)
8000e868:	6d e8       	ld.w	r8,r6[0x78]
8000e86a:	58 48       	cp.w	r8,4
8000e86c:	e0 8a 00 0c 	brle	8000e884 <jinit_1pass_quantizer+0x4c>
    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
8000e870:	6c 08       	ld.w	r8,r6[0x0]
8000e872:	33 79       	mov	r9,55
8000e874:	91 59       	st.w	r8[0x14],r9
8000e876:	6c 08       	ld.w	r8,r6[0x0]
8000e878:	30 49       	mov	r9,4
8000e87a:	91 69       	st.w	r8[0x18],r9
8000e87c:	6c 08       	ld.w	r8,r6[0x0]
8000e87e:	70 08       	ld.w	r8,r8[0x0]
8000e880:	0c 9c       	mov	r12,r6
8000e882:	5d 18       	icall	r8
  /* Make sure colormap indexes can be represented by JSAMPLEs */
  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
8000e884:	6d 88       	ld.w	r8,r6[0x60]
8000e886:	e0 48 01 00 	cp.w	r8,256
8000e88a:	e0 8a 00 0d 	brle	8000e8a4 <jinit_1pass_quantizer+0x6c>
    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
8000e88e:	6c 08       	ld.w	r8,r6[0x0]
8000e890:	33 99       	mov	r9,57
8000e892:	91 59       	st.w	r8[0x14],r9
8000e894:	6c 08       	ld.w	r8,r6[0x0]
8000e896:	e0 69 01 00 	mov	r9,256
8000e89a:	91 69       	st.w	r8[0x18],r9
8000e89c:	6c 08       	ld.w	r8,r6[0x0]
8000e89e:	70 08       	ld.w	r8,r8[0x0]
8000e8a0:	06 9c       	mov	r12,r3
8000e8a2:	5d 18       	icall	r8
 */

LOCAL(void)
create_colormap (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000e8a4:	ec fe 01 cc 	ld.w	lr,r6[460]
8000e8a8:	50 4e       	stdsp	sp[0x10],lr
  JSAMPARRAY colormap;		/* Created colormap */
  int total_colors;		/* Number of distinct output colors */
  int i,j,k, nci, blksize, blkdist, ptr, val;

  /* Select number of colors for each component */
  total_colors = select_ncolors(cinfo, cquantize->Ncolors);
8000e8aa:	1c 92       	mov	r2,lr
8000e8ac:	2e 02       	sub	r2,-32
select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
/* Determine allocation of desired colors to components, */
/* and fill in Ncolors[] array to indicate choice. */
/* Return value is total number of colors (product of Ncolors[] values). */
{
  int nc = cinfo->out_color_components; /* number of color components */
8000e8ae:	6d e7       	ld.w	r7,r6[0x78]
  int max_colors = cinfo->desired_number_of_colors;
8000e8b0:	6d 81       	ld.w	r1,r6[0x60]
8000e8b2:	30 14       	mov	r4,1
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
  do {
    iroot++;
    temp = iroot;		/* set temp = iroot ** nc */
    for (i = 1; i < nc; i++)
8000e8b4:	08 9b       	mov	r11,r4

  /* We can allocate at least the nc'th root of max_colors per component. */
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
  do {
    iroot++;
8000e8b6:	e8 ca ff ff 	sub	r10,r4,-1
    temp = iroot;		/* set temp = iroot ** nc */
    for (i = 1; i < nc; i++)
8000e8ba:	58 17       	cp.w	r7,1
8000e8bc:	e0 89 00 04 	brgt	8000e8c4 <jinit_1pass_quantizer+0x8c>
8000e8c0:	14 99       	mov	r9,r10
8000e8c2:	c0 78       	rjmp	8000e8d0 <jinit_1pass_quantizer+0x98>
8000e8c4:	14 99       	mov	r9,r10
8000e8c6:	16 98       	mov	r8,r11
      temp *= iroot;
8000e8c8:	b5 39       	mul	r9,r10
  /* Compute floor(nc'th root of max_colors). */
  iroot = 1;
  do {
    iroot++;
    temp = iroot;		/* set temp = iroot ** nc */
    for (i = 1; i < nc; i++)
8000e8ca:	2f f8       	sub	r8,-1
8000e8cc:	0e 38       	cp.w	r8,r7
8000e8ce:	cf d1       	brne	8000e8c8 <jinit_1pass_quantizer+0x90>
      temp *= iroot;
  } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
8000e8d0:	12 31       	cp.w	r1,r9
8000e8d2:	c0 35       	brlt	8000e8d8 <jinit_1pass_quantizer+0xa0>
8000e8d4:	14 94       	mov	r4,r10
8000e8d6:	cf 0b       	rjmp	8000e8b6 <jinit_1pass_quantizer+0x7e>
  iroot--;			/* now iroot = floor(root) */

  /* Must have at least 2 color values per component */
  if (iroot < 2)
8000e8d8:	58 14       	cp.w	r4,1
8000e8da:	e0 89 00 0b 	brgt	8000e8f0 <jinit_1pass_quantizer+0xb8>
    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
8000e8de:	6c 08       	ld.w	r8,r6[0x0]
8000e8e0:	33 8a       	mov	r10,56
8000e8e2:	91 5a       	st.w	r8[0x14],r10
8000e8e4:	6c 08       	ld.w	r8,r6[0x0]
8000e8e6:	91 69       	st.w	r8[0x18],r9
8000e8e8:	6c 08       	ld.w	r8,r6[0x0]
8000e8ea:	70 08       	ld.w	r8,r8[0x0]
8000e8ec:	06 9c       	mov	r12,r3
8000e8ee:	5d 18       	icall	r8

  /* Initialize to iroot color values for each component */
  total_colors = 1;
  for (i = 0; i < nc; i++) {
8000e8f0:	58 07       	cp.w	r7,0
8000e8f2:	e0 89 00 04 	brgt	8000e8fa <jinit_1pass_quantizer+0xc2>
8000e8f6:	30 15       	mov	r5,1
8000e8f8:	c0 98       	rjmp	8000e90a <jinit_1pass_quantizer+0xd2>
8000e8fa:	04 99       	mov	r9,r2
8000e8fc:	30 15       	mov	r5,1
8000e8fe:	30 08       	mov	r8,0
    Ncolors[i] = iroot;
8000e900:	12 a4       	st.w	r9++,r4
    total_colors *= iroot;
8000e902:	a9 35       	mul	r5,r4
  if (iroot < 2)
    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);

  /* Initialize to iroot color values for each component */
  total_colors = 1;
  for (i = 0; i < nc; i++) {
8000e904:	2f f8       	sub	r8,-1
8000e906:	0e 38       	cp.w	r8,r7
8000e908:	cf c1       	brne	8000e900 <jinit_1pass_quantizer+0xc8>
8000e90a:	30 09       	mov	r9,0
8000e90c:	12 98       	mov	r8,r9
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
      total_colors = (int) temp;
      changed = TRUE;
    }
  } while (changed);
8000e90e:	12 9a       	mov	r10,r9
8000e910:	12 9b       	mov	r11,r9
8000e912:	50 21       	stdsp	sp[0x8],r1
8000e914:	c1 a8       	rjmp	8000e948 <jinit_1pass_quantizer+0x110>
   * In RGB colorspace, try to increment G first, then R, then B.
   */
  do {
    changed = FALSE;
    for (i = 0; i < nc; i++) {
      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
8000e916:	6c bc       	ld.w	r12,r6[0x2c]
8000e918:	58 2c       	cp.w	r12,2
8000e91a:	c0 30       	breq	8000e920 <jinit_1pass_quantizer+0xe8>
8000e91c:	10 9c       	mov	r12,r8
8000e91e:	c0 48       	rjmp	8000e926 <jinit_1pass_quantizer+0xee>
8000e920:	4d a1       	lddpc	r1,8000ea88 <jinit_1pass_quantizer+0x250>
8000e922:	e2 08 03 2c 	ld.w	r12,r1[r8<<0x2]
      /* calculate new total_colors if Ncolors[j] is incremented */
      temp = total_colors / Ncolors[j];
8000e926:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000e92a:	78 0e       	ld.w	lr,r12[0x0]
8000e92c:	ea 0e 0c 00 	divs	r0,r5,lr
8000e930:	fa e1 00 00 	st.d	sp[0],r0
      temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
8000e934:	2f fe       	sub	lr,-1
8000e936:	fc 00 02 44 	mul	r4,lr,r0
      if (temp > (long) max_colors)
8000e93a:	40 20       	lddsp	r0,sp[0x8]
8000e93c:	08 30       	cp.w	r0,r4
8000e93e:	c0 85       	brlt	8000e94e <jinit_1pass_quantizer+0x116>
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
8000e940:	99 0e       	st.w	r12[0x0],lr
   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
   * In RGB colorspace, try to increment G first, then R, then B.
   */
  do {
    changed = FALSE;
    for (i = 0; i < nc; i++) {
8000e942:	2f f8       	sub	r8,-1
8000e944:	30 19       	mov	r9,1
8000e946:	08 95       	mov	r5,r4
8000e948:	10 37       	cp.w	r7,r8
8000e94a:	fe 99 ff e6 	brgt	8000e916 <jinit_1pass_quantizer+0xde>
	break;			/* won't fit, done with this pass */
      Ncolors[j]++;		/* OK, apply the increment */
      total_colors = (int) temp;
      changed = TRUE;
    }
  } while (changed);
8000e94e:	58 09       	cp.w	r9,0
8000e950:	c0 50       	breq	8000e95a <jinit_1pass_quantizer+0x122>
8000e952:	0a 94       	mov	r4,r5
8000e954:	14 99       	mov	r9,r10
8000e956:	16 98       	mov	r8,r11
8000e958:	cf 7b       	rjmp	8000e946 <jinit_1pass_quantizer+0x10e>
8000e95a:	0a 97       	mov	r7,r5

  /* Select number of colors for each component */
  total_colors = select_ncolors(cinfo, cquantize->Ncolors);

  /* Report selected color counts */
  if (cinfo->out_color_components == 3)
8000e95c:	6d e8       	ld.w	r8,r6[0x78]
8000e95e:	58 38       	cp.w	r8,3
8000e960:	c1 51       	brne	8000e98a <jinit_1pass_quantizer+0x152>
    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
8000e962:	6c 09       	ld.w	r9,r6[0x0]
8000e964:	f2 c8 ff e8 	sub	r8,r9,-24
8000e968:	93 65       	st.w	r9[0x18],r5
8000e96a:	40 4e       	lddsp	lr,sp[0x10]
8000e96c:	7c 89       	ld.w	r9,lr[0x20]
8000e96e:	91 19       	st.w	r8[0x4],r9
8000e970:	7c 99       	ld.w	r9,lr[0x24]
8000e972:	91 29       	st.w	r8[0x8],r9
8000e974:	7c a9       	ld.w	r9,lr[0x28]
8000e976:	91 39       	st.w	r8[0xc],r9
8000e978:	6c 08       	ld.w	r8,r6[0x0]
8000e97a:	35 e9       	mov	r9,94
8000e97c:	91 59       	st.w	r8[0x14],r9
8000e97e:	6c 08       	ld.w	r8,r6[0x0]
8000e980:	70 18       	ld.w	r8,r8[0x4]
8000e982:	30 1b       	mov	r11,1
8000e984:	06 9c       	mov	r12,r3
8000e986:	5d 18       	icall	r8
8000e988:	c0 b8       	rjmp	8000e99e <jinit_1pass_quantizer+0x166>
	     total_colors, cquantize->Ncolors[0],
	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
  else
    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
8000e98a:	6c 08       	ld.w	r8,r6[0x0]
8000e98c:	35 f9       	mov	r9,95
8000e98e:	91 59       	st.w	r8[0x14],r9
8000e990:	6c 08       	ld.w	r8,r6[0x0]
8000e992:	91 65       	st.w	r8[0x18],r5
8000e994:	6c 08       	ld.w	r8,r6[0x0]
8000e996:	70 18       	ld.w	r8,r8[0x4]
8000e998:	30 1b       	mov	r11,1
8000e99a:	06 9c       	mov	r12,r3
8000e99c:	5d 18       	icall	r8

  /* Allocate and fill in the colormap. */
  /* The colors are ordered in the map in standard row-major order, */
  /* i.e. rightmost (highest-indexed) color changes most rapidly. */

  colormap = (*cinfo->mem->alloc_sarray)
8000e99e:	6c 18       	ld.w	r8,r6[0x4]
8000e9a0:	70 28       	ld.w	r8,r8[0x8]
8000e9a2:	6d e9       	ld.w	r9,r6[0x78]
8000e9a4:	0e 9a       	mov	r10,r7
8000e9a6:	30 1b       	mov	r11,1
8000e9a8:	06 9c       	mov	r12,r3
8000e9aa:	5d 18       	icall	r8
8000e9ac:	50 7c       	stdsp	sp[0x1c],r12

  /* blksize is number of adjacent repeated entries for a component */
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;

  for (i = 0; i < cinfo->out_color_components; i++) {
8000e9ae:	6d e8       	ld.w	r8,r6[0x78]
8000e9b0:	58 08       	cp.w	r8,0
8000e9b2:	e0 8a 00 55 	brle	8000ea5c <jinit_1pass_quantizer+0x224>
8000e9b6:	50 52       	stdsp	sp[0x14],r2
8000e9b8:	18 9e       	mov	lr,r12
8000e9ba:	30 0a       	mov	r10,0
8000e9bc:	50 6a       	stdsp	sp[0x18],r10
/*
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
8000e9be:	50 8a       	stdsp	sp[0x20],r10
8000e9c0:	14 92       	mov	r2,r10
8000e9c2:	50 96       	stdsp	sp[0x24],r6
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;

  for (i = 0; i < cinfo->out_color_components; i++) {
    /* fill in colormap entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
8000e9c4:	40 51       	lddsp	r1,sp[0x14]
8000e9c6:	62 08       	ld.w	r8,r1[0x0]
    blksize = blkdist / nci;
8000e9c8:	ea 08 0c 0a 	divs	r10,r5,r8
8000e9cc:	14 9b       	mov	r11,r10
    for (j = 0; j < nci; j++) {
8000e9ce:	58 08       	cp.w	r8,0
8000e9d0:	e0 8a 00 38 	brle	8000ea40 <jinit_1pass_quantizer+0x208>
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
8000e9d4:	f0 c0 00 01 	sub	r0,r8,1
  /* We always provide values 0 and MAXJSAMPLE for each component;
   * any additional values are equally spaced between these limits.
   * (Forcing the upper and lower values to the limits ensures that
   * dithering can't produce a color outside the selected gamut.)
   */
  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
8000e9d8:	e0 09 16 1f 	lsr	r9,r0,0x1f
8000e9dc:	00 09       	add	r9,r0
8000e9de:	a1 59       	asr	r9,0x1
8000e9e0:	50 39       	stdsp	sp[0xc],r9
/*
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
8000e9e2:	50 2a       	stdsp	sp[0x8],r10
8000e9e4:	f0 09 15 08 	lsl	r9,r8,0x8
8000e9e8:	10 19       	sub	r9,r8
8000e9ea:	50 09       	stdsp	sp[0x0],r9
8000e9ec:	30 03       	mov	r3,0
8000e9ee:	40 81       	lddsp	r1,sp[0x20]
8000e9f0:	0a 94       	mov	r4,r5
  /* We always provide values 0 and MAXJSAMPLE for each component;
   * any additional values are equally spaced between these limits.
   * (Forcing the upper and lower values to the limits ensures that
   * dithering can't produce a color outside the selected gamut.)
   */
  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
8000e9f2:	40 3a       	lddsp	r10,sp[0xc]
8000e9f4:	e2 0a 00 09 	add	r9,r1,r10
8000e9f8:	f2 00 0c 08 	divs	r8,r9,r0
8000e9fc:	10 9c       	mov	r12,r8
8000e9fe:	06 9a       	mov	r10,r3
    blksize = blkdist / nci;
    for (j = 0; j < nci; j++) {
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
8000ea00:	06 37       	cp.w	r7,r3
8000ea02:	e0 8a 00 18 	brle	8000ea32 <jinit_1pass_quantizer+0x1fa>
/*
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
8000ea06:	ea 03 00 06 	add	r6,r5,r3
8000ea0a:	c1 08       	rjmp	8000ea2a <jinit_1pass_quantizer+0x1f2>
8000ea0c:	04 98       	mov	r8,r2
      val = output_value(cinfo, i, j, nci-1);
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
	  colormap[i][ptr+k] = (JSAMPLE) val;
8000ea0e:	7c 09       	ld.w	r9,lr[0x0]
8000ea10:	10 09       	add	r9,r8
8000ea12:	f2 0a 0b 0c 	st.b	r9[r10],r12
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
8000ea16:	2f f8       	sub	r8,-1
8000ea18:	16 38       	cp.w	r8,r11
8000ea1a:	cf a1       	brne	8000ea0e <jinit_1pass_quantizer+0x1d6>
/*
 * Module initialization routine for 1-pass color quantization.
 */

GLOBAL(void)
jinit_1pass_quantizer (j_decompress_ptr cinfo)
8000ea1c:	08 0a       	add	r10,r4
8000ea1e:	08 06       	add	r6,r4
    blksize = blkdist / nci;
    for (j = 0; j < nci; j++) {
      /* Compute j'th output value (out of nci) for component */
      val = output_value(cinfo, i, j, nci-1);
      /* Fill in all colormap entries that have this value of this component */
      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
8000ea20:	ec 04 01 08 	sub	r8,r6,r4
8000ea24:	10 37       	cp.w	r7,r8
8000ea26:	e0 8a 00 06 	brle	8000ea32 <jinit_1pass_quantizer+0x1fa>
	/* fill in blksize entries beginning at ptr */
	for (k = 0; k < blksize; k++)
8000ea2a:	58 0b       	cp.w	r11,0
8000ea2c:	fe 99 ff f0 	brgt	8000ea0c <jinit_1pass_quantizer+0x1d4>
8000ea30:	cf 6b       	rjmp	8000ea1c <jinit_1pass_quantizer+0x1e4>
8000ea32:	e2 c1 ff 01 	sub	r1,r1,-255
8000ea36:	40 29       	lddsp	r9,sp[0x8]
8000ea38:	12 03       	add	r3,r9

  for (i = 0; i < cinfo->out_color_components; i++) {
    /* fill in colormap entries for i'th color component */
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    blksize = blkdist / nci;
    for (j = 0; j < nci; j++) {
8000ea3a:	40 08       	lddsp	r8,sp[0x0]
8000ea3c:	10 31       	cp.w	r1,r8
8000ea3e:	cd a1       	brne	8000e9f2 <jinit_1pass_quantizer+0x1ba>

  /* blksize is number of adjacent repeated entries for a component */
  /* blkdist is distance between groups of identical entries for a component */
  blkdist = total_colors;

  for (i = 0; i < cinfo->out_color_components; i++) {
8000ea40:	40 61       	lddsp	r1,sp[0x18]
8000ea42:	2f f1       	sub	r1,-1
8000ea44:	50 61       	stdsp	sp[0x18],r1
8000ea46:	40 50       	lddsp	r0,sp[0x14]
8000ea48:	2f c0       	sub	r0,-4
8000ea4a:	50 50       	stdsp	sp[0x14],r0
8000ea4c:	2f ce       	sub	lr,-4
8000ea4e:	40 9a       	lddsp	r10,sp[0x24]
8000ea50:	75 e8       	ld.w	r8,r10[0x78]
8000ea52:	10 31       	cp.w	r1,r8
8000ea54:	c0 34       	brge	8000ea5a <jinit_1pass_quantizer+0x222>
8000ea56:	16 95       	mov	r5,r11
8000ea58:	cb 6b       	rjmp	8000e9c4 <jinit_1pass_quantizer+0x18c>
8000ea5a:	40 96       	lddsp	r6,sp[0x24]
  }

  /* Save the colormap in private storage,
   * where it will survive color quantization mode changes.
   */
  cquantize->sv_colormap = colormap;
8000ea5c:	40 78       	lddsp	r8,sp[0x1c]
8000ea5e:	40 49       	lddsp	r9,sp[0x10]
8000ea60:	93 48       	st.w	r9[0x10],r8
  cquantize->sv_actual = total_colors;
8000ea62:	93 57       	st.w	r9[0x14],r7
  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);

  /* Create the colormap and color index table. */
  create_colormap(cinfo);
  create_colorindex(cinfo);
8000ea64:	0c 9c       	mov	r12,r6
8000ea66:	f0 1f 00 0a 	mcall	8000ea8c <jinit_1pass_quantizer+0x254>
   * We do this now since it is FAR storage and may affect the memory
   * manager's space calculations.  If the user changes to FS dither
   * mode in a later pass, we will allocate the space then, and will
   * possibly overrun the max_memory_to_use setting.
   */
  if (cinfo->dither_mode == JDITHER_FS)
8000ea6a:	6d 68       	ld.w	r8,r6[0x58]
8000ea6c:	58 28       	cp.w	r8,2
8000ea6e:	c0 41       	brne	8000ea76 <jinit_1pass_quantizer+0x23e>
    alloc_fs_workspace(cinfo);
8000ea70:	0c 9c       	mov	r12,r6
8000ea72:	f0 1f 00 08 	mcall	8000ea90 <jinit_1pass_quantizer+0x258>
}
8000ea76:	2f 6d       	sub	sp,-40
8000ea78:	d8 32       	popm	r0-r7,pc
8000ea7a:	00 00       	add	r0,r0
8000ea7c:	80 00       	ld.sh	r0,r0[0x0]
8000ea7e:	ea 94 80 00 	brge	8017ea7e <_data_sdram_lma+0x15deb6>
8000ea82:	e8 24 80 00 	sub	r4,557056
8000ea86:	e8 26 80 01 	sub	r6,557057
8000ea8a:	fc 48 80 00 	cp.w	r8,-229376
8000ea8e:	e5 70 80 00 	stcond	r2[-32768],r0
8000ea92:	e7 ea d4 31 	sthh.w	r1[0x10c],r3:b,r10:t

8000ea94 <start_pass_1_quant>:
 * Initialize for one-pass color quantization.
 */

METHODDEF(void)
start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
8000ea94:	d4 31       	pushm	r0-r7,lr
8000ea96:	20 2d       	sub	sp,8
8000ea98:	18 97       	mov	r7,r12
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000ea9a:	f8 f5 01 cc 	ld.w	r5,r12[460]
  size_t arraysize;
  int i;

  /* Install my colormap. */
  cinfo->colormap = cquantize->sv_colormap;
8000ea9e:	6a 48       	ld.w	r8,r5[0x10]
8000eaa0:	f9 48 00 88 	st.w	r12[136],r8
  cinfo->actual_number_of_colors = cquantize->sv_actual;
8000eaa4:	6a 58       	ld.w	r8,r5[0x14]
8000eaa6:	f9 48 00 84 	st.w	r12[132],r8

  /* Initialize for desired dithering mode. */
  switch (cinfo->dither_mode) {
8000eaaa:	79 68       	ld.w	r8,r12[0x58]
8000eaac:	58 18       	cp.w	r8,1
8000eaae:	c0 f0       	breq	8000eacc <start_pass_1_quant+0x38>
8000eab0:	c0 53       	brcs	8000eaba <start_pass_1_quant+0x26>
8000eab2:	58 28       	cp.w	r8,2
8000eab4:	e0 81 00 96 	brne	8000ebe0 <start_pass_1_quant+0x14c>
8000eab8:	c7 78       	rjmp	8000eba6 <start_pass_1_quant+0x112>
  case JDITHER_NONE:
    if (cinfo->out_color_components == 3)
8000eaba:	79 e8       	ld.w	r8,r12[0x78]
8000eabc:	58 38       	cp.w	r8,3
8000eabe:	c0 41       	brne	8000eac6 <start_pass_1_quant+0x32>
      cquantize->pub.color_quantize = color_quantize3;
8000eac0:	4c c8       	lddpc	r8,8000ebf0 <start_pass_1_quant+0x15c>
8000eac2:	8b 18       	st.w	r5[0x4],r8
8000eac4:	c9 48       	rjmp	8000ebec <start_pass_1_quant+0x158>
    else
      cquantize->pub.color_quantize = color_quantize;
8000eac6:	4c c8       	lddpc	r8,8000ebf4 <start_pass_1_quant+0x160>
8000eac8:	8b 18       	st.w	r5[0x4],r8
8000eaca:	c9 18       	rjmp	8000ebec <start_pass_1_quant+0x158>
    break;
  case JDITHER_ORDERED:
    if (cinfo->out_color_components == 3)
8000eacc:	79 e8       	ld.w	r8,r12[0x78]
8000eace:	58 38       	cp.w	r8,3
8000ead0:	c0 41       	brne	8000ead8 <start_pass_1_quant+0x44>
      cquantize->pub.color_quantize = quantize3_ord_dither;
8000ead2:	4c a8       	lddpc	r8,8000ebf8 <start_pass_1_quant+0x164>
8000ead4:	8b 18       	st.w	r5[0x4],r8
8000ead6:	c0 38       	rjmp	8000eadc <start_pass_1_quant+0x48>
    else
      cquantize->pub.color_quantize = quantize_ord_dither;
8000ead8:	4c 98       	lddpc	r8,8000ebfc <start_pass_1_quant+0x168>
8000eada:	8b 18       	st.w	r5[0x4],r8
    cquantize->row_index = 0;	/* initialize state for ordered dither */
8000eadc:	30 08       	mov	r8,0
8000eade:	8b c8       	st.w	r5[0x30],r8
    /* If user changed to ordered dither from another mode,
     * we must recreate the color index table with padding.
     * This will cost extra space, but probably isn't very likely.
     */
    if (! cquantize->is_padded)
8000eae0:	6a 78       	ld.w	r8,r5[0x1c]
8000eae2:	58 08       	cp.w	r8,0
8000eae4:	c0 41       	brne	8000eaec <start_pass_1_quant+0x58>
      create_colorindex(cinfo);
8000eae6:	0e 9c       	mov	r12,r7
8000eae8:	f0 1f 00 46 	mcall	8000ec00 <start_pass_1_quant+0x16c>
    /* Create ordered-dither tables if we didn't already. */
    if (cquantize->odither[0] == NULL)
8000eaec:	6a d8       	ld.w	r8,r5[0x34]
8000eaee:	58 08       	cp.w	r8,0
8000eaf0:	c7 e1       	brne	8000ebec <start_pass_1_quant+0x158>
 */

LOCAL(void)
create_odither_tables (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000eaf2:	ee f2 01 cc 	ld.w	r2,r7[460]
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
8000eaf6:	6f e8       	ld.w	r8,r7[0x78]
8000eaf8:	58 08       	cp.w	r8,0
8000eafa:	e0 8a 00 79 	brle	8000ebec <start_pass_1_quant+0x158>
8000eafe:	e4 c3 ff e0 	sub	r3,r2,-32
8000eb02:	30 05       	mov	r5,0
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
  for (j = 0; j < ODITHER_SIZE; j++) {
    for (k = 0; k < ODITHER_SIZE; k++) {
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
8000eb04:	fe 76 fe 02 	mov	r6,-510
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
  for (j = 0; j < ODITHER_SIZE; j++) {
8000eb08:	50 05       	stdsp	sp[0x0],r5
8000eb0a:	0e 94       	mov	r4,r7
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
8000eb0c:	66 07       	ld.w	r7,r3[0x0]
    odither = NULL;		/* search for matching prior component */
    for (j = 0; j < i; j++) {
8000eb0e:	58 05       	cp.w	r5,0
8000eb10:	e0 8a 00 16 	brle	8000eb3c <start_pass_1_quant+0xa8>
      if (nci == cquantize->Ncolors[j]) {
8000eb14:	64 88       	ld.w	r8,r2[0x20]
8000eb16:	10 37       	cp.w	r7,r8
8000eb18:	c0 c1       	brne	8000eb30 <start_pass_1_quant+0x9c>
8000eb1a:	30 08       	mov	r8,0
8000eb1c:	c0 48       	rjmp	8000eb24 <start_pass_1_quant+0x90>
8000eb1e:	13 0a       	ld.w	r10,r9++
8000eb20:	14 37       	cp.w	r7,r10
8000eb22:	c0 a1       	brne	8000eb36 <start_pass_1_quant+0xa2>
	odither = cquantize->odither[j];
8000eb24:	2f 38       	sub	r8,-13
8000eb26:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
	break;
      }
    }
    if (odither == NULL)	/* need a new table? */
8000eb2a:	58 0c       	cp.w	r12,0
8000eb2c:	c3 61       	brne	8000eb98 <start_pass_1_quant+0x104>
8000eb2e:	c0 78       	rjmp	8000eb3c <start_pass_1_quant+0xa8>
8000eb30:	e4 c9 ff dc 	sub	r9,r2,-36
8000eb34:	30 08       	mov	r8,0
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
    odither = NULL;		/* search for matching prior component */
    for (j = 0; j < i; j++) {
8000eb36:	2f f8       	sub	r8,-1
8000eb38:	0a 38       	cp.w	r8,r5
8000eb3a:	cf 25       	brlt	8000eb1e <start_pass_1_quant+0x8a>
{
  ODITHER_MATRIX_PTR odither;
  int j,k;
  INT32 num,den;

  odither = (ODITHER_MATRIX_PTR)
8000eb3c:	68 18       	ld.w	r8,r4[0x4]
8000eb3e:	70 08       	ld.w	r8,r8[0x0]
8000eb40:	e0 6a 04 00 	mov	r10,1024
8000eb44:	30 1b       	mov	r11,1
8000eb46:	08 9c       	mov	r12,r4
8000eb48:	5d 18       	icall	r8
  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
8000eb4a:	20 17       	sub	r7,1
8000eb4c:	a9 77       	lsl	r7,0x9
8000eb4e:	18 90       	mov	r0,r12
8000eb50:	30 01       	mov	r1,0
8000eb52:	50 13       	stdsp	sp[0x4],r3
8000eb54:	40 03       	lddsp	r3,sp[0x0]
8000eb56:	c1 88       	rjmp	8000eb86 <start_pass_1_quant+0xf2>
  for (j = 0; j < ODITHER_SIZE; j++) {
    for (k = 0; k < ODITHER_SIZE; k++) {
      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
8000eb58:	13 8b       	ld.ub	r11,r9[0x0]
8000eb5a:	ad 3b       	mul	r11,r6
8000eb5c:	fe 3b 01 ff 	sub	r11,-65025
	    * MAXJSAMPLE;
      /* Ensure round towards zero despite C's lack of consistency
       * about rounding negative values in integer division...
       */
      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
8000eb60:	c0 67       	brpl	8000eb6c <start_pass_1_quant+0xd8>
8000eb62:	5c 3b       	neg	r11
8000eb64:	f6 07 0c 0a 	divs	r10,r11,r7
8000eb68:	5c 3a       	neg	r10
8000eb6a:	c0 38       	rjmp	8000eb70 <start_pass_1_quant+0xdc>
8000eb6c:	f6 07 0c 0a 	divs	r10,r11,r7
8000eb70:	fc 08 09 0a 	st.w	lr[r8],r10
8000eb74:	2f f9       	sub	r9,-1
8000eb76:	2f c8       	sub	r8,-4
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
  for (j = 0; j < ODITHER_SIZE; j++) {
    for (k = 0; k < ODITHER_SIZE; k++) {
8000eb78:	e0 48 00 40 	cp.w	r8,64
8000eb7c:	ce e1       	brne	8000eb58 <start_pass_1_quant+0xc4>
   * Hence the dither value for the matrix cell with fill order f
   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
   * On 16-bit-int machine, be careful to avoid overflow.
   */
  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
  for (j = 0; j < ODITHER_SIZE; j++) {
8000eb7e:	2f f1       	sub	r1,-1
8000eb80:	2c 00       	sub	r0,-64
8000eb82:	59 01       	cp.w	r1,16
8000eb84:	c0 90       	breq	8000eb96 <start_pass_1_quant+0x102>
8000eb86:	00 9e       	mov	lr,r0
8000eb88:	e2 09 15 04 	lsl	r9,r1,0x4
8000eb8c:	49 e8       	lddpc	r8,8000ec04 <start_pass_1_quant+0x170>
8000eb8e:	f0 09 00 09 	add	r9,r8,r9
8000eb92:	06 98       	mov	r8,r3
8000eb94:	ce 2b       	rjmp	8000eb58 <start_pass_1_quant+0xc4>
8000eb96:	40 13       	lddsp	r3,sp[0x4]
	break;
      }
    }
    if (odither == NULL)	/* need a new table? */
      odither = make_odither_array(cinfo, nci);
    cquantize->odither[i] = odither;
8000eb98:	87 5c       	st.w	r3[0x14],r12
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  ODITHER_MATRIX_PTR odither;
  int i, j, nci;

  for (i = 0; i < cinfo->out_color_components; i++) {
8000eb9a:	2f f5       	sub	r5,-1
8000eb9c:	2f c3       	sub	r3,-4
8000eb9e:	69 e8       	ld.w	r8,r4[0x78]
8000eba0:	10 35       	cp.w	r5,r8
8000eba2:	cb 55       	brlt	8000eb0c <start_pass_1_quant+0x78>
8000eba4:	c2 48       	rjmp	8000ebec <start_pass_1_quant+0x158>
    /* Create ordered-dither tables if we didn't already. */
    if (cquantize->odither[0] == NULL)
      create_odither_tables(cinfo);
    break;
  case JDITHER_FS:
    cquantize->pub.color_quantize = quantize_fs_dither;
8000eba6:	49 98       	lddpc	r8,8000ec08 <start_pass_1_quant+0x174>
8000eba8:	8b 18       	st.w	r5[0x4],r8
    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
8000ebaa:	30 08       	mov	r8,0
8000ebac:	eb 48 00 54 	st.w	r5[84],r8
    /* Allocate Floyd-Steinberg workspace if didn't already. */
    if (cquantize->fserrors[0] == NULL)
8000ebb0:	6b 18       	ld.w	r8,r5[0x44]
8000ebb2:	58 08       	cp.w	r8,0
8000ebb4:	c0 31       	brne	8000ebba <start_pass_1_quant+0x126>
      alloc_fs_workspace(cinfo);
8000ebb6:	f0 1f 00 16 	mcall	8000ec0c <start_pass_1_quant+0x178>
    /* Initialize the propagated errors to zero. */
    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
8000ebba:	6f c4       	ld.w	r4,r7[0x70]
8000ebbc:	2f e4       	sub	r4,-2
8000ebbe:	a1 74       	lsl	r4,0x1
    for (i = 0; i < cinfo->out_color_components; i++)
8000ebc0:	6f e8       	ld.w	r8,r7[0x78]
8000ebc2:	58 08       	cp.w	r8,0
8000ebc4:	e0 8a 00 14 	brle	8000ebec <start_pass_1_quant+0x158>
8000ebc8:	2b c5       	sub	r5,-68
8000ebca:	30 06       	mov	r6,0
      jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
8000ebcc:	08 9b       	mov	r11,r4
8000ebce:	0b 0c       	ld.w	r12,r5++
8000ebd0:	f0 1f 00 10 	mcall	8000ec10 <start_pass_1_quant+0x17c>
    /* Allocate Floyd-Steinberg workspace if didn't already. */
    if (cquantize->fserrors[0] == NULL)
      alloc_fs_workspace(cinfo);
    /* Initialize the propagated errors to zero. */
    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
    for (i = 0; i < cinfo->out_color_components; i++)
8000ebd4:	2f f6       	sub	r6,-1
8000ebd6:	6f e8       	ld.w	r8,r7[0x78]
8000ebd8:	0c 38       	cp.w	r8,r6
8000ebda:	fe 99 ff f9 	brgt	8000ebcc <start_pass_1_quant+0x138>
8000ebde:	c0 78       	rjmp	8000ebec <start_pass_1_quant+0x158>
      jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
    break;
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
8000ebe0:	78 08       	ld.w	r8,r12[0x0]
8000ebe2:	33 09       	mov	r9,48
8000ebe4:	91 59       	st.w	r8[0x14],r9
8000ebe6:	78 08       	ld.w	r8,r12[0x0]
8000ebe8:	70 08       	ld.w	r8,r8[0x0]
8000ebea:	5d 18       	icall	r8
    break;
  }
}
8000ebec:	2f ed       	sub	sp,-8
8000ebee:	d8 32       	popm	r0-r7,pc
8000ebf0:	80 00       	ld.sh	r0,r0[0x0]
8000ebf2:	e6 d4 80 00 	satsub.w	r4,r3,-32768
8000ebf6:	e6 5c 80 00 	cp.w	r12,491520
8000ebfa:	e7 2a 80 00 	ld.sb	r10,r3[-32768]
8000ebfe:	ed 7c 80 00 	stcond	r6[-32768],r12
8000ec02:	e5 70 80 01 	stcond	r2[-32767],r0
8000ec06:	fb 48 80 00 	st.w	sp[-32768],r8
8000ec0a:	ec 14 80 00 	eorl	r4,0x8000
8000ec0e:	e7 ea 80 00 	sthh.w	r0[r0],r3:b,r10:b
8000ec12:	fd 20 d4 31 	ld.sb	r0,lr[-11215]

8000ec14 <quantize_fs_dither>:

METHODDEF(void)
quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		    JSAMPARRAY output_buf, int num_rows)
/* General case, with Floyd-Steinberg dithering */
{
8000ec14:	d4 31       	pushm	r0-r7,lr
8000ec16:	21 4d       	sub	sp,80
8000ec18:	51 39       	stdsp	sp[0x4c],r9
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000ec1a:	f8 f9 01 cc 	ld.w	r9,r12[460]
8000ec1e:	50 49       	stdsp	sp[0x10],r9
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  JSAMPROW colormap_ci;
  int pixcode;
  int nc = cinfo->out_color_components;
8000ec20:	79 e8       	ld.w	r8,r12[0x78]
8000ec22:	50 a8       	stdsp	sp[0x28],r8
  int dir;			/* 1 for left-to-right, -1 for right-to-left */
  int dirnc;			/* dir * nc */
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000ec24:	79 c9       	ld.w	r9,r12[0x70]
8000ec26:	50 69       	stdsp	sp[0x18],r9
  JSAMPLE *range_limit = cinfo->sample_range_limit;
8000ec28:	f8 fc 01 44 	ld.w	r12,r12[324]
8000ec2c:	50 1c       	stdsp	sp[0x4],r12
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
8000ec2e:	41 38       	lddsp	r8,sp[0x4c]
8000ec30:	58 08       	cp.w	r8,0
8000ec32:	e0 8a 00 a0 	brle	8000ed72 <quantize_fs_dither+0x15e>
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      if (cquantize->on_odd_row) {
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
8000ec36:	12 98       	mov	r8,r9
8000ec38:	20 18       	sub	r8,1
8000ec3a:	40 ac       	lddsp	r12,sp[0x28]
8000ec3c:	b1 3c       	mul	r12,r8
8000ec3e:	51 0c       	stdsp	sp[0x40],r12
	output_ptr += width-1;
	dir = -1;
	dirnc = -nc;
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
8000ec40:	2f e8       	sub	r8,-2
8000ec42:	a1 78       	lsl	r8,0x1
8000ec44:	50 f8       	stdsp	sp[0x3c],r8
8000ec46:	50 8a       	stdsp	sp[0x20],r10
8000ec48:	50 9b       	stdsp	sp[0x24],r11
8000ec4a:	30 0a       	mov	r10,0
8000ec4c:	50 da       	stdsp	sp[0x34],r10
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      if (cquantize->on_odd_row) {
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
	output_ptr += width-1;
8000ec4e:	20 19       	sub	r9,1
8000ec50:	51 19       	stdsp	sp[0x44],r9
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
8000ec52:	50 ca       	stdsp	sp[0x30],r10
8000ec54:	50 7a       	stdsp	sp[0x1c],r10
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
      } else {
	/* work left to right in this row */
	dir = 1;
	dirnc = nc;
	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
8000ec56:	40 a8       	lddsp	r8,sp[0x28]
8000ec58:	51 28       	stdsp	sp[0x48],r8
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
8000ec5a:	40 6b       	lddsp	r11,sp[0x18]
8000ec5c:	40 8a       	lddsp	r10,sp[0x20]
8000ec5e:	74 0c       	ld.w	r12,r10[0x0]
8000ec60:	f0 1f 00 46 	mcall	8000ed78 <quantize_fs_dither+0x164>
	      (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
8000ec64:	40 a9       	lddsp	r9,sp[0x28]
8000ec66:	58 09       	cp.w	r9,0
8000ec68:	e0 8a 00 72 	brle	8000ed4c <quantize_fs_dither+0x138>
8000ec6c:	40 48       	lddsp	r8,sp[0x10]
8000ec6e:	2b c8       	sub	r8,-68
8000ec70:	50 58       	stdsp	sp[0x14],r8
8000ec72:	30 0c       	mov	r12,0
8000ec74:	50 2c       	stdsp	sp[0x8],r12
      if (cquantize->on_odd_row) {
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
	output_ptr += width-1;
	dir = -1;
	dirnc = -nc;
8000ec76:	5c 39       	neg	r9
8000ec78:	50 e9       	stdsp	sp[0x38],r9
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
8000ec7a:	40 6a       	lddsp	r10,sp[0x18]
8000ec7c:	50 ba       	stdsp	sp[0x2c],r10

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
8000ec7e:	40 29       	lddsp	r9,sp[0x8]
      input_ptr = input_buf[row] + ci;
8000ec80:	40 98       	lddsp	r8,sp[0x24]
8000ec82:	70 0b       	ld.w	r11,r8[0x0]
8000ec84:	12 0b       	add	r11,r9
      output_ptr = output_buf[row];
8000ec86:	40 8c       	lddsp	r12,sp[0x20]
8000ec88:	78 08       	ld.w	r8,r12[0x0]
      if (cquantize->on_odd_row) {
8000ec8a:	40 4c       	lddsp	r12,sp[0x10]
8000ec8c:	79 5a       	ld.w	r10,r12[0x54]
8000ec8e:	58 0a       	cp.w	r10,0
8000ec90:	c0 e0       	breq	8000ecac <quantize_fs_dither+0x98>
	/* work right to left in this row */
	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
8000ec92:	41 0a       	lddsp	r10,sp[0x40]
8000ec94:	14 0b       	add	r11,r10
	output_ptr += width-1;
8000ec96:	41 1c       	lddsp	r12,sp[0x44]
8000ec98:	18 08       	add	r8,r12
	dir = -1;
	dirnc = -nc;
8000ec9a:	40 ea       	lddsp	r10,sp[0x38]
8000ec9c:	50 0a       	stdsp	sp[0x0],r10
	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
8000ec9e:	40 5c       	lddsp	r12,sp[0x14]
8000eca0:	78 0a       	ld.w	r10,r12[0x0]
8000eca2:	40 fc       	lddsp	r12,sp[0x3c]
8000eca4:	18 0a       	add	r10,r12
8000eca6:	50 3a       	stdsp	sp[0xc],r10
8000eca8:	3f f2       	mov	r2,-1
8000ecaa:	c0 78       	rjmp	8000ecb8 <quantize_fs_dither+0xa4>
      } else {
	/* work left to right in this row */
	dir = 1;
	dirnc = nc;
	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
8000ecac:	40 5a       	lddsp	r10,sp[0x14]
8000ecae:	74 0a       	ld.w	r10,r10[0x0]
8000ecb0:	50 3a       	stdsp	sp[0xc],r10
8000ecb2:	41 2c       	lddsp	r12,sp[0x48]
8000ecb4:	50 0c       	stdsp	sp[0x0],r12
8000ecb6:	30 12       	mov	r2,1
8000ecb8:	a3 69       	lsl	r9,0x2
      }
      colorindex_ci = cquantize->colorindex[ci];
8000ecba:	40 4c       	lddsp	r12,sp[0x10]
8000ecbc:	78 6a       	ld.w	r10,r12[0x18]
8000ecbe:	f4 09 03 00 	ld.w	r0,r10[r9]
      colormap_ci = cquantize->sv_colormap[ci];
8000ecc2:	78 4a       	ld.w	r10,r12[0x10]
8000ecc4:	f4 09 03 01 	ld.w	r1,r10[r9]
      /* Preset error values: no error propagated to first pixel from left */
      cur = 0;
      /* and no error propagated to row below yet */
      belowerr = bpreverr = 0;

      for (col = width; col > 0; col--) {
8000ecc8:	40 6a       	lddsp	r10,sp[0x18]
8000ecca:	58 0a       	cp.w	r10,0
8000eccc:	c0 31       	brne	8000ecd2 <quantize_fs_dither+0xbe>
8000ecce:	40 c5       	lddsp	r5,sp[0x30]
8000ecd0:	c3 38       	rjmp	8000ed36 <quantize_fs_dither+0x122>
	 * round the error term (which is expressed * 16) to an integer.
	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
	 * for either sign of the error value.
	 * Note: errorptr points to *previous* column's array entry.
	 */
	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
8000ecd2:	e4 03 15 01 	lsl	r3,r2,0x1
8000ecd6:	40 be       	lddsp	lr,sp[0x2c]
8000ecd8:	40 3c       	lddsp	r12,sp[0xc]
8000ecda:	40 c5       	lddsp	r5,sp[0x30]
8000ecdc:	40 74       	lddsp	r4,sp[0x1c]
8000ecde:	08 96       	mov	r6,r4
8000ece0:	f8 03 00 07 	add	r7,r12,r3
8000ece4:	2f 86       	sub	r6,-8
8000ece6:	8e 09       	ld.sh	r9,r7[0x0]
8000ece8:	12 06       	add	r6,r9
8000ecea:	a5 46       	asr	r6,0x4
	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
	 * The maximum error is +- MAXJSAMPLE; this sets the required size
	 * of the range_limit array.
	 */
	cur += GETJSAMPLE(*input_ptr);
	cur = GETJSAMPLE(range_limit[cur]);
8000ecec:	17 89       	ld.ub	r9,r11[0x0]
8000ecee:	40 1a       	lddsp	r10,sp[0x4]
8000ecf0:	f4 06 00 06 	add	r6,r10,r6
8000ecf4:	ec 09 07 09 	ld.ub	r9,r6[r9]
	/* Select output value, accumulate into output code for this pixel */
	pixcode = GETJSAMPLE(colorindex_ci[cur]);
8000ecf8:	e0 09 07 0a 	ld.ub	r10,r0[r9]
	*output_ptr += (JSAMPLE) pixcode;
8000ecfc:	11 86       	ld.ub	r6,r8[0x0]
8000ecfe:	14 06       	add	r6,r10
8000ed00:	b0 86       	st.b	r8[0x0],r6
	/* Compute actual representation error at this pixel */
	/* Note: we can do this even though we don't have the final */
	/* pixel code, because the colormap is orthogonal. */
	cur -= GETJSAMPLE(colormap_ci[pixcode]);
8000ed02:	e2 0a 07 0a 	ld.ub	r10,r1[r10]
8000ed06:	14 19       	sub	r9,r10
	/* Compute error fractions to be propagated to adjacent pixels.
	 * Add these into the running sums, and simultaneously shift the
	 * next-line error sums left by 1 column.
	 */
	bnexterr = cur;
	delta = cur * 2;
8000ed08:	f2 0a 15 01 	lsl	r10,r9,0x1
	cur += delta;		/* form error * 3 */
8000ed0c:	f4 09 00 06 	add	r6,r10,r9
	errorptr[0] = (FSERROR) (bpreverr + cur);
8000ed10:	ec 05 00 05 	add	r5,r6,r5
8000ed14:	b8 05       	st.h	r12[0x0],r5
	cur += delta;		/* form error * 5 */
8000ed16:	14 06       	add	r6,r10
	bpreverr = belowerr + cur;
8000ed18:	ec 04 00 05 	add	r5,r6,r4
	belowerr = bnexterr;
	cur += delta;		/* form error * 7 */
8000ed1c:	14 06       	add	r6,r10
  }
}


METHODDEF(void)
quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
8000ed1e:	40 0c       	lddsp	r12,sp[0x0]
8000ed20:	18 0b       	add	r11,r12
	/* At this point cur contains the 7/16 error value to be propagated
	 * to the next pixel on the current line, and all the errors for the
	 * next line have been shifted over. We are therefore ready to move on.
	 */
	input_ptr += dirnc;	/* advance input ptr to next column */
	output_ptr += dir;	/* advance output ptr to next column */
8000ed22:	04 08       	add	r8,r2
      /* Preset error values: no error propagated to first pixel from left */
      cur = 0;
      /* and no error propagated to row below yet */
      belowerr = bpreverr = 0;

      for (col = width; col > 0; col--) {
8000ed24:	20 1e       	sub	lr,1
8000ed26:	0e 9c       	mov	r12,r7
8000ed28:	12 94       	mov	r4,r9
8000ed2a:	cd b1       	brne	8000ece0 <quantize_fs_dither+0xcc>
8000ed2c:	40 3a       	lddsp	r10,sp[0xc]
8000ed2e:	40 69       	lddsp	r9,sp[0x18]
8000ed30:	e6 09 03 4a 	mac	r10,r3,r9
8000ed34:	50 3a       	stdsp	sp[0xc],r10
      }
      /* Post-loop cleanup: we must unload the final error value into the
       * final fserrors[] entry.  Note we need not unload belowerr because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
8000ed36:	40 38       	lddsp	r8,sp[0xc]
8000ed38:	b0 05       	st.h	r8[0x0],r5

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    for (ci = 0; ci < nc; ci++) {
8000ed3a:	40 2c       	lddsp	r12,sp[0x8]
8000ed3c:	2f fc       	sub	r12,-1
8000ed3e:	50 2c       	stdsp	sp[0x8],r12
8000ed40:	40 5a       	lddsp	r10,sp[0x14]
8000ed42:	2f ca       	sub	r10,-4
8000ed44:	50 5a       	stdsp	sp[0x14],r10
8000ed46:	40 a9       	lddsp	r9,sp[0x28]
8000ed48:	12 3c       	cp.w	r12,r9
8000ed4a:	c9 a1       	brne	8000ec7e <quantize_fs_dither+0x6a>
       * final fserrors[] entry.  Note we need not unload belowerr because
       * it is for the dummy column before or after the actual array.
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
    }
    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
8000ed4c:	40 4c       	lddsp	r12,sp[0x10]
8000ed4e:	79 58       	ld.w	r8,r12[0x54]
8000ed50:	58 08       	cp.w	r8,0
8000ed52:	5f 08       	sreq	r8
8000ed54:	f9 48 00 54 	st.w	r12[84],r8
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
  JSAMPLE *range_limit = cinfo->sample_range_limit;
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
8000ed58:	40 da       	lddsp	r10,sp[0x34]
8000ed5a:	2f fa       	sub	r10,-1
8000ed5c:	50 da       	stdsp	sp[0x34],r10
8000ed5e:	40 89       	lddsp	r9,sp[0x20]
8000ed60:	2f c9       	sub	r9,-4
8000ed62:	50 89       	stdsp	sp[0x20],r9
8000ed64:	40 98       	lddsp	r8,sp[0x24]
8000ed66:	2f c8       	sub	r8,-4
8000ed68:	50 98       	stdsp	sp[0x24],r8
8000ed6a:	41 3c       	lddsp	r12,sp[0x4c]
8000ed6c:	14 3c       	cp.w	r12,r10
8000ed6e:	fe 99 ff 76 	brgt	8000ec5a <quantize_fs_dither+0x46>
       */
      errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
    }
    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
  }
}
8000ed72:	2e cd       	sub	sp,-80
8000ed74:	d8 32       	popm	r0-r7,pc
8000ed76:	00 00       	add	r0,r0
8000ed78:	80 00       	ld.sh	r0,r0[0x0]
8000ed7a:	fd 20 d4 31 	ld.sb	r0,lr[-11215]

8000ed7c <quantize_ord_dither>:

METHODDEF(void)
quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		     JSAMPARRAY output_buf, int num_rows)
/* General case, with ordered dithering */
{
8000ed7c:	d4 31       	pushm	r0-r7,lr
8000ed7e:	20 ad       	sub	sp,40
8000ed80:	50 79       	stdsp	sp[0x1c],r9
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000ed82:	f8 f6 01 cc 	ld.w	r6,r12[460]
  register JSAMPROW input_ptr;
  register JSAMPROW output_ptr;
  JSAMPROW colorindex_ci;
  int * dither;			/* points to active row of dither matrix */
  int row_index, col_index;	/* current indexes into dither matrix */
  int nc = cinfo->out_color_components;
8000ed86:	79 e7       	ld.w	r7,r12[0x78]
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000ed88:	79 cc       	ld.w	r12,r12[0x70]
8000ed8a:	50 2c       	stdsp	sp[0x8],r12

  for (row = 0; row < num_rows; row++) {
8000ed8c:	58 09       	cp.w	r9,0
8000ed8e:	e0 8a 00 4c 	brle	8000ee26 <quantize_ord_dither+0xaa>
8000ed92:	14 95       	mov	r5,r10
8000ed94:	50 0b       	stdsp	sp[0x0],r11
8000ed96:	30 0a       	mov	r10,0
8000ed98:	50 5a       	stdsp	sp[0x14],r10
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
8000ed9a:	50 8c       	stdsp	sp[0x20],r12
    row_index = cquantize->row_index;
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      colorindex_ci = cquantize->colorindex[ci];
      dither = cquantize->odither[ci][row_index];
8000ed9c:	ec c9 ff cc 	sub	r9,r6,-52
8000eda0:	50 99       	stdsp	sp[0x24],r9
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
8000eda2:	50 3c       	stdsp	sp[0xc],r12
8000eda4:	50 4a       	stdsp	sp[0x10],r10
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
8000eda6:	40 8b       	lddsp	r11,sp[0x20]
8000eda8:	6a 0c       	ld.w	r12,r5[0x0]
8000edaa:	f0 1f 00 21 	mcall	8000ee2c <quantize_ord_dither+0xb0>
	      (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
8000edae:	6c ca       	ld.w	r10,r6[0x30]
8000edb0:	50 6a       	stdsp	sp[0x18],r10
    for (ci = 0; ci < nc; ci++) {
8000edb2:	58 07       	cp.w	r7,0
8000edb4:	e0 8a 00 29 	brle	8000ee06 <quantize_ord_dither+0x8a>
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      colorindex_ci = cquantize->colorindex[ci];
      dither = cquantize->odither[ci][row_index];
8000edb8:	a7 6a       	lsl	r10,0x6
8000edba:	50 1a       	stdsp	sp[0x4],r10
8000edbc:	40 90       	lddsp	r0,sp[0x24]
8000edbe:	30 01       	mov	r1,0
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
8000edc0:	40 09       	lddsp	r9,sp[0x0]
8000edc2:	72 0b       	ld.w	r11,r9[0x0]
      output_ptr = output_buf[row];
8000edc4:	6a 08       	ld.w	r8,r5[0x0]
      colorindex_ci = cquantize->colorindex[ci];
8000edc6:	6c 6a       	ld.w	r10,r6[0x18]
8000edc8:	f4 01 03 22 	ld.w	r2,r10[r1<<0x2]
      dither = cquantize->odither[ci][row_index];
8000edcc:	60 03       	ld.w	r3,r0[0x0]
8000edce:	40 1a       	lddsp	r10,sp[0x4]
8000edd0:	14 03       	add	r3,r10
      col_index = 0;

      for (col = width; col > 0; col--) {
8000edd2:	40 2a       	lddsp	r10,sp[0x8]
8000edd4:	58 0a       	cp.w	r10,0
8000edd6:	c1 40       	breq	8000edfe <quantize_ord_dither+0x82>
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
    for (ci = 0; ci < nc; ci++) {
      input_ptr = input_buf[row] + ci;
8000edd8:	02 0b       	add	r11,r1
8000edda:	40 3a       	lddsp	r10,sp[0xc]
8000eddc:	40 49       	lddsp	r9,sp[0x10]
	 * Range-limiting need not be done explicitly, as we have extended
	 * the colorindex table to produce the right answers for out-of-range
	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
	 * required amount of padding.
	 */
	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
8000edde:	17 8e       	ld.ub	lr,r11[0x0]
8000ede0:	e6 09 03 24 	ld.w	r4,r3[r9<<0x2]
8000ede4:	e4 04 00 04 	add	r4,r2,r4
8000ede8:	11 8c       	ld.ub	r12,r8[0x0]
8000edea:	e8 0e 07 0e 	ld.ub	lr,r4[lr]
8000edee:	1c 0c       	add	r12,lr
8000edf0:	10 cc       	st.b	r8++,r12
  }
}


METHODDEF(void)
quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
8000edf2:	0e 0b       	add	r11,r7
	 * required amount of padding.
	 */
	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
	input_ptr += nc;
	output_ptr++;
	col_index = (col_index + 1) & ODITHER_MASK;
8000edf4:	2f f9       	sub	r9,-1
8000edf6:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
      output_ptr = output_buf[row];
      colorindex_ci = cquantize->colorindex[ci];
      dither = cquantize->odither[ci][row_index];
      col_index = 0;

      for (col = width; col > 0; col--) {
8000edfa:	20 1a       	sub	r10,1
8000edfc:	cf 11       	brne	8000edde <quantize_ord_dither+0x62>
  for (row = 0; row < num_rows; row++) {
    /* Initialize output values to 0 so can process components separately */
    jzero_far((void FAR *) output_buf[row],
	      (size_t) (width * SIZEOF(JSAMPLE)));
    row_index = cquantize->row_index;
    for (ci = 0; ci < nc; ci++) {
8000edfe:	2f f1       	sub	r1,-1
8000ee00:	2f c0       	sub	r0,-4
8000ee02:	0e 31       	cp.w	r1,r7
8000ee04:	cd e1       	brne	8000edc0 <quantize_ord_dither+0x44>
	output_ptr++;
	col_index = (col_index + 1) & ODITHER_MASK;
      }
    }
    /* Advance row index for next row */
    row_index = (row_index + 1) & ODITHER_MASK;
8000ee06:	40 68       	lddsp	r8,sp[0x18]
8000ee08:	2f f8       	sub	r8,-1
    cquantize->row_index = row_index;
8000ee0a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000ee0e:	8d c8       	st.w	r6[0x30],r8
  int ci;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
8000ee10:	40 59       	lddsp	r9,sp[0x14]
8000ee12:	2f f9       	sub	r9,-1
8000ee14:	50 59       	stdsp	sp[0x14],r9
8000ee16:	2f c5       	sub	r5,-4
8000ee18:	40 08       	lddsp	r8,sp[0x0]
8000ee1a:	2f c8       	sub	r8,-4
8000ee1c:	50 08       	stdsp	sp[0x0],r8
8000ee1e:	40 7a       	lddsp	r10,sp[0x1c]
8000ee20:	12 3a       	cp.w	r10,r9
8000ee22:	fe 99 ff c2 	brgt	8000eda6 <quantize_ord_dither+0x2a>
    }
    /* Advance row index for next row */
    row_index = (row_index + 1) & ODITHER_MASK;
    cquantize->row_index = row_index;
  }
}
8000ee26:	2f 6d       	sub	sp,-40
8000ee28:	d8 32       	popm	r0-r7,pc
8000ee2a:	00 00       	add	r0,r0
8000ee2c:	80 00       	ld.sh	r0,r0[0x0]
8000ee2e:	fd 20 eb cd 	ld.sb	r0,lr[-5171]

8000ee30 <prescan_quantize>:
 */

METHODDEF(void)
prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
		  JSAMPARRAY output_buf, int num_rows)
{
8000ee30:	eb cd 40 f8 	pushm	r3-r7,lr
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  register JSAMPROW ptr;
  register histptr histp;
  register hist3d histogram = cquantize->histogram;
8000ee34:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000ee38:	70 66       	ld.w	r6,r8[0x18]
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000ee3a:	79 c4       	ld.w	r4,r12[0x70]

  for (row = 0; row < num_rows; row++) {
8000ee3c:	58 09       	cp.w	r9,0
8000ee3e:	e0 8a 00 24 	brle	8000ee86 <prescan_quantize+0x56>
8000ee42:	30 05       	mov	r5,0
    ptr = input_buf[row];
    for (col = width; col > 0; col--) {
8000ee44:	08 93       	mov	r3,r4
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptr = input_buf[row];
8000ee46:	76 08       	ld.w	r8,r11[0x0]
    for (col = width; col > 0; col--) {
8000ee48:	58 04       	cp.w	r4,0
8000ee4a:	c1 a0       	breq	8000ee7e <prescan_quantize+0x4e>
8000ee4c:	06 9c       	mov	r12,r3
      /* get pixel value and index into the histogram */
      histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
8000ee4e:	11 8a       	ld.ub	r10,r8[0x0]
8000ee50:	a3 9a       	lsr	r10,0x3
8000ee52:	11 97       	ld.ub	r7,r8[0x1]
8000ee54:	a3 87       	lsr	r7,0x2
8000ee56:	a5 77       	lsl	r7,0x5
8000ee58:	11 ae       	ld.ub	lr,r8[0x2]
8000ee5a:	a3 9e       	lsr	lr,0x3
8000ee5c:	ee 0e 00 0e 	add	lr,r7,lr
8000ee60:	ec 0a 03 2a 	ld.w	r10,r6[r10<<0x2]
8000ee64:	f4 0e 00 1e 	add	lr,r10,lr<<0x1
			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
      /* increment, check for overflow and undo increment if so. */
      if (++(*histp) <= 0)
8000ee68:	9c 0a       	ld.sh	r10,lr[0x0]
8000ee6a:	f4 c7 ff ff 	sub	r7,r10,-1
8000ee6e:	5c 87       	casts.h	r7
8000ee70:	c0 20       	breq	8000ee74 <prescan_quantize+0x44>
8000ee72:	0e 9a       	mov	r10,r7
8000ee74:	bc 0a       	st.h	lr[0x0],r10
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    ptr = input_buf[row];
    for (col = width; col > 0; col--) {
8000ee76:	20 1c       	sub	r12,1
8000ee78:	c0 30       	breq	8000ee7e <prescan_quantize+0x4e>
			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
      /* increment, check for overflow and undo increment if so. */
      if (++(*histp) <= 0)
	(*histp)--;
      ptr += 3;
8000ee7a:	2f d8       	sub	r8,-3
8000ee7c:	ce 9b       	rjmp	8000ee4e <prescan_quantize+0x1e>
  register hist3d histogram = cquantize->histogram;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
8000ee7e:	2f f5       	sub	r5,-1
8000ee80:	2f cb       	sub	r11,-4
8000ee82:	12 35       	cp.w	r5,r9
8000ee84:	ce 11       	brne	8000ee46 <prescan_quantize+0x16>
8000ee86:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8000ee8a <update_box>:

LOCAL(void)
update_box (j_decompress_ptr cinfo, boxptr boxp)
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
{
8000ee8a:	d4 31       	pushm	r0-r7,lr
8000ee8c:	20 8d       	sub	sp,32
8000ee8e:	50 3b       	stdsp	sp[0xc],r11
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
8000ee90:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000ee94:	70 60       	ld.w	r0,r8[0x18]
  int c0,c1,c2;
  int c0min,c0max,c1min,c1max,c2min,c2max;
  INT32 dist0,dist1,dist2;
  long ccount;

  c0min = boxp->c0min;  c0max = boxp->c0max;
8000ee96:	76 01       	ld.w	r1,r11[0x0]
8000ee98:	76 19       	ld.w	r9,r11[0x4]
8000ee9a:	50 19       	stdsp	sp[0x4],r9
  c1min = boxp->c1min;  c1max = boxp->c1max;
8000ee9c:	76 22       	ld.w	r2,r11[0x8]
8000ee9e:	76 35       	ld.w	r5,r11[0xc]
  c2min = boxp->c2min;  c2max = boxp->c2max;
8000eea0:	76 44       	ld.w	r4,r11[0x10]
8000eea2:	76 5b       	ld.w	r11,r11[0x14]

  if (c0max > c0min)
8000eea4:	12 31       	cp.w	r1,r9
8000eea6:	c6 94       	brge	8000ef78 <update_box+0xee>
8000eea8:	e0 01 00 23 	add	r3,r0,r1<<0x2
8000eeac:	02 9e       	mov	lr,r1
    for (c0 = c0min; c0 <= c0max; c0++)
8000eeae:	e4 08 15 05 	lsl	r8,r2,0x5
8000eeb2:	08 08       	add	r8,r4
8000eeb4:	a1 78       	lsl	r8,0x1
8000eeb6:	50 08       	stdsp	sp[0x0],r8
8000eeb8:	50 48       	stdsp	sp[0x10],r8
8000eeba:	50 52       	stdsp	sp[0x14],r2
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000eebc:	30 0c       	mov	r12,0
8000eebe:	50 64       	stdsp	sp[0x18],r4
8000eec0:	c2 78       	rjmp	8000ef0e <update_box+0x84>
  c2min = boxp->c2min;  c2max = boxp->c2max;

  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
8000eec2:	66 09       	ld.w	r9,r3[0x0]
	for (c2 = c2min; c2 <= c2max; c2++)
8000eec4:	16 34       	cp.w	r4,r11
8000eec6:	e0 89 00 1a 	brgt	8000eefa <update_box+0x70>
  c2min = boxp->c2min;  c2max = boxp->c2max;

  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
8000eeca:	0c 09       	add	r9,r6
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000eecc:	92 08       	ld.sh	r8,r9[0x0]
8000eece:	f8 08 19 00 	cp.h	r8,r12
8000eed2:	c0 f0       	breq	8000eef0 <update_box+0x66>
8000eed4:	c0 78       	rjmp	8000eee2 <update_box+0x58>
8000eed6:	92 0a       	ld.sh	r10,r9[0x0]
8000eed8:	f8 0a 19 00 	cp.h	r10,r12
8000eedc:	c0 31       	brne	8000eee2 <update_box+0x58>
8000eede:	2f e9       	sub	r9,-2
8000eee0:	c0 a8       	rjmp	8000eef4 <update_box+0x6a>
	    boxp->c0min = c0min = c0;
8000eee2:	40 38       	lddsp	r8,sp[0xc]
8000eee4:	91 0e       	st.w	r8[0x0],lr
	    goto have_c0min;
	  }
      }
 have_c0min:
  if (c0max > c0min)
8000eee6:	40 19       	lddsp	r9,sp[0x4]
8000eee8:	1c 39       	cp.w	r9,lr
8000eeea:	e0 89 00 17 	brgt	8000ef18 <update_box+0x8e>
8000eeee:	c4 48       	rjmp	8000ef76 <update_box+0xec>
  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000eef0:	2f e9       	sub	r9,-2
8000eef2:	40 68       	lddsp	r8,sp[0x18]

  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
8000eef4:	2f f8       	sub	r8,-1
8000eef6:	10 3b       	cp.w	r11,r8
8000eef8:	ce f4       	brge	8000eed6 <update_box+0x4c>
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;

  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
      for (c1 = c1min; c1 <= c1max; c1++) {
8000eefa:	2f f7       	sub	r7,-1
8000eefc:	2c 06       	sub	r6,-64
8000eefe:	0a 37       	cp.w	r7,r5
8000ef00:	fe 9a ff e1 	brle	8000eec2 <update_box+0x38>
  c0min = boxp->c0min;  c0max = boxp->c0max;
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;

  if (c0max > c0min)
    for (c0 = c0min; c0 <= c0max; c0++)
8000ef04:	2f fe       	sub	lr,-1
8000ef06:	2f c3       	sub	r3,-4
8000ef08:	40 18       	lddsp	r8,sp[0x4]
8000ef0a:	1c 38       	cp.w	r8,lr
8000ef0c:	c0 75       	brlt	8000ef1a <update_box+0x90>
8000ef0e:	40 09       	lddsp	r9,sp[0x0]
8000ef10:	50 29       	stdsp	sp[0x8],r9
8000ef12:	40 46       	lddsp	r6,sp[0x10]
8000ef14:	40 57       	lddsp	r7,sp[0x14]
8000ef16:	cf 4b       	rjmp	8000eefe <update_box+0x74>
	    boxp->c0min = c0min = c0;
	    goto have_c0min;
	  }
      }
 have_c0min:
  if (c0max > c0min)
8000ef18:	1c 91       	mov	r1,lr
8000ef1a:	40 18       	lddsp	r8,sp[0x4]
8000ef1c:	e0 08 00 23 	add	r3,r0,r8<<0x2
8000ef20:	10 9e       	mov	lr,r8
    for (c0 = c0max; c0 >= c0min; c0--)
8000ef22:	50 02       	stdsp	sp[0x0],r2
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000ef24:	30 0c       	mov	r12,0
8000ef26:	50 44       	stdsp	sp[0x10],r4
8000ef28:	c2 48       	rjmp	8000ef70 <update_box+0xe6>
      }
 have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
8000ef2a:	66 09       	ld.w	r9,r3[0x0]
	for (c2 = c2min; c2 <= c2max; c2++)
8000ef2c:	16 34       	cp.w	r4,r11
8000ef2e:	e0 89 00 17 	brgt	8000ef5c <update_box+0xd2>
      }
 have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
8000ef32:	0c 09       	add	r9,r6
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000ef34:	92 08       	ld.sh	r8,r9[0x0]
8000ef36:	f8 08 19 00 	cp.h	r8,r12
8000ef3a:	c0 c0       	breq	8000ef52 <update_box+0xc8>
8000ef3c:	c0 78       	rjmp	8000ef4a <update_box+0xc0>
8000ef3e:	92 0a       	ld.sh	r10,r9[0x0]
8000ef40:	f8 0a 19 00 	cp.h	r10,r12
8000ef44:	c0 31       	brne	8000ef4a <update_box+0xc0>
8000ef46:	2f e9       	sub	r9,-2
8000ef48:	c0 78       	rjmp	8000ef56 <update_box+0xcc>
	    boxp->c0max = c0max = c0;
8000ef4a:	40 38       	lddsp	r8,sp[0xc]
8000ef4c:	91 1e       	st.w	r8[0x4],lr
8000ef4e:	50 1e       	stdsp	sp[0x4],lr
	    goto have_c0max;
8000ef50:	c1 48       	rjmp	8000ef78 <update_box+0xee>
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000ef52:	2f e9       	sub	r9,-2
8000ef54:	40 48       	lddsp	r8,sp[0x10]
 have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
8000ef56:	2f f8       	sub	r8,-1
8000ef58:	10 3b       	cp.w	r11,r8
8000ef5a:	cf 24       	brge	8000ef3e <update_box+0xb4>
	  }
      }
 have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
      for (c1 = c1min; c1 <= c1max; c1++) {
8000ef5c:	2f f7       	sub	r7,-1
8000ef5e:	2c 06       	sub	r6,-64
8000ef60:	0a 37       	cp.w	r7,r5
8000ef62:	fe 9a ff e4 	brle	8000ef2a <update_box+0xa0>
	    goto have_c0min;
	  }
      }
 have_c0min:
  if (c0max > c0min)
    for (c0 = c0max; c0 >= c0min; c0--)
8000ef66:	20 1e       	sub	lr,1
8000ef68:	20 43       	sub	r3,4
8000ef6a:	1c 31       	cp.w	r1,lr
8000ef6c:	e0 89 00 06 	brgt	8000ef78 <update_box+0xee>
8000ef70:	40 26       	lddsp	r6,sp[0x8]
8000ef72:	40 07       	lddsp	r7,sp[0x0]
8000ef74:	cf 6b       	rjmp	8000ef60 <update_box+0xd6>
8000ef76:	1c 91       	mov	r1,lr
	    boxp->c0max = c0max = c0;
	    goto have_c0max;
	  }
      }
 have_c0max:
  if (c1max > c1min)
8000ef78:	0a 32       	cp.w	r2,r5
8000ef7a:	c6 a4       	brge	8000f04e <update_box+0x1c4>
  return which;
}


LOCAL(void)
update_box (j_decompress_ptr cinfo, boxptr boxp)
8000ef7c:	50 44       	stdsp	sp[0x10],r4
8000ef7e:	e4 03 15 05 	lsl	r3,r2,0x5
8000ef82:	08 03       	add	r3,r4
8000ef84:	a1 73       	lsl	r3,0x1
8000ef86:	04 9e       	mov	lr,r2
	    goto have_c0max;
	  }
      }
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
8000ef88:	e0 01 00 29 	add	r9,r0,r1<<0x2
8000ef8c:	50 09       	stdsp	sp[0x0],r9
8000ef8e:	50 59       	stdsp	sp[0x14],r9
8000ef90:	50 61       	stdsp	sp[0x18],r1
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000ef92:	30 0c       	mov	r12,0
8000ef94:	50 74       	stdsp	sp[0x1c],r4
8000ef96:	c2 58       	rjmp	8000efe0 <update_box+0x156>
      }
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
8000ef98:	6c 09       	ld.w	r9,r6[0x0]
	for (c2 = c2min; c2 <= c2max; c2++)
8000ef9a:	16 34       	cp.w	r4,r11
8000ef9c:	e0 89 00 18 	brgt	8000efcc <update_box+0x142>
      }
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
8000efa0:	06 09       	add	r9,r3
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000efa2:	92 08       	ld.sh	r8,r9[0x0]
8000efa4:	f8 08 19 00 	cp.h	r8,r12
8000efa8:	c0 d0       	breq	8000efc2 <update_box+0x138>
8000efaa:	c0 78       	rjmp	8000efb8 <update_box+0x12e>
8000efac:	92 0a       	ld.sh	r10,r9[0x0]
8000efae:	f8 0a 19 00 	cp.h	r10,r12
8000efb2:	c0 31       	brne	8000efb8 <update_box+0x12e>
8000efb4:	2f e9       	sub	r9,-2
8000efb6:	c0 88       	rjmp	8000efc6 <update_box+0x13c>
	    boxp->c1min = c1min = c1;
8000efb8:	40 38       	lddsp	r8,sp[0xc]
8000efba:	91 2e       	st.w	r8[0x8],lr
	    goto have_c1min;
	  }
      }
 have_c1min:
  if (c1max > c1min)
8000efbc:	0a 3e       	cp.w	lr,r5
8000efbe:	c1 65       	brlt	8000efea <update_box+0x160>
8000efc0:	c4 68       	rjmp	8000f04c <update_box+0x1c2>
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000efc2:	2f e9       	sub	r9,-2
8000efc4:	40 78       	lddsp	r8,sp[0x1c]
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
8000efc6:	2f f8       	sub	r8,-1
8000efc8:	10 3b       	cp.w	r11,r8
8000efca:	cf 14       	brge	8000efac <update_box+0x122>
	  }
      }
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
      for (c0 = c0min; c0 <= c0max; c0++) {
8000efcc:	2f f7       	sub	r7,-1
8000efce:	2f c6       	sub	r6,-4
8000efd0:	40 19       	lddsp	r9,sp[0x4]
8000efd2:	12 37       	cp.w	r7,r9
8000efd4:	fe 9a ff e2 	brle	8000ef98 <update_box+0x10e>
	    goto have_c0max;
	  }
      }
 have_c0max:
  if (c1max > c1min)
    for (c1 = c1min; c1 <= c1max; c1++)
8000efd8:	2f fe       	sub	lr,-1
8000efda:	2c 03       	sub	r3,-64
8000efdc:	1c 35       	cp.w	r5,lr
8000efde:	c0 75       	brlt	8000efec <update_box+0x162>
8000efe0:	40 08       	lddsp	r8,sp[0x0]
8000efe2:	50 28       	stdsp	sp[0x8],r8
8000efe4:	40 56       	lddsp	r6,sp[0x14]
8000efe6:	40 67       	lddsp	r7,sp[0x18]
8000efe8:	cf 4b       	rjmp	8000efd0 <update_box+0x146>
	    boxp->c1min = c1min = c1;
	    goto have_c1min;
	  }
      }
 have_c1min:
  if (c1max > c1min)
8000efea:	1c 92       	mov	r2,lr
8000efec:	ea 03 15 05 	lsl	r3,r5,0x5
8000eff0:	40 49       	lddsp	r9,sp[0x10]
8000eff2:	12 03       	add	r3,r9
8000eff4:	a1 73       	lsl	r3,0x1
8000eff6:	0a 9e       	mov	lr,r5
    for (c1 = c1max; c1 >= c1min; c1--)
8000eff8:	50 01       	stdsp	sp[0x0],r1
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000effa:	30 0c       	mov	r12,0
8000effc:	50 44       	stdsp	sp[0x10],r4
8000effe:	c2 48       	rjmp	8000f046 <update_box+0x1bc>
      }
 have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
8000f000:	6c 09       	ld.w	r9,r6[0x0]
	for (c2 = c2min; c2 <= c2max; c2++)
8000f002:	16 34       	cp.w	r4,r11
8000f004:	e0 89 00 17 	brgt	8000f032 <update_box+0x1a8>
      }
 have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
8000f008:	06 09       	add	r9,r3
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000f00a:	92 08       	ld.sh	r8,r9[0x0]
8000f00c:	f8 08 19 00 	cp.h	r8,r12
8000f010:	c0 c0       	breq	8000f028 <update_box+0x19e>
8000f012:	c0 78       	rjmp	8000f020 <update_box+0x196>
8000f014:	92 0a       	ld.sh	r10,r9[0x0]
8000f016:	f8 0a 19 00 	cp.h	r10,r12
8000f01a:	c0 31       	brne	8000f020 <update_box+0x196>
8000f01c:	2f e9       	sub	r9,-2
8000f01e:	c0 78       	rjmp	8000f02c <update_box+0x1a2>
	    boxp->c1max = c1max = c1;
8000f020:	40 39       	lddsp	r9,sp[0xc]
8000f022:	93 3e       	st.w	r9[0xc],lr
8000f024:	1c 95       	mov	r5,lr
	    goto have_c1max;
8000f026:	c1 48       	rjmp	8000f04e <update_box+0x1c4>
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
	  if (*histp++ != 0) {
8000f028:	2f e9       	sub	r9,-2
8000f02a:	40 48       	lddsp	r8,sp[0x10]
 have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1][c2min];
	for (c2 = c2min; c2 <= c2max; c2++)
8000f02c:	2f f8       	sub	r8,-1
8000f02e:	10 3b       	cp.w	r11,r8
8000f030:	cf 24       	brge	8000f014 <update_box+0x18a>
	  }
      }
 have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
      for (c0 = c0min; c0 <= c0max; c0++) {
8000f032:	2f f7       	sub	r7,-1
8000f034:	2f c6       	sub	r6,-4
8000f036:	40 18       	lddsp	r8,sp[0x4]
8000f038:	10 37       	cp.w	r7,r8
8000f03a:	fe 9a ff e3 	brle	8000f000 <update_box+0x176>
	    goto have_c1min;
	  }
      }
 have_c1min:
  if (c1max > c1min)
    for (c1 = c1max; c1 >= c1min; c1--)
8000f03e:	20 1e       	sub	lr,1
8000f040:	24 03       	sub	r3,64
8000f042:	04 3e       	cp.w	lr,r2
8000f044:	c0 55       	brlt	8000f04e <update_box+0x1c4>
8000f046:	40 26       	lddsp	r6,sp[0x8]
8000f048:	40 07       	lddsp	r7,sp[0x0]
8000f04a:	cf 6b       	rjmp	8000f036 <update_box+0x1ac>
8000f04c:	1c 92       	mov	r2,lr
	    boxp->c1max = c1max = c1;
	    goto have_c1max;
	  }
      }
 have_c1max:
  if (c2max > c2min)
8000f04e:	16 34       	cp.w	r4,r11
8000f050:	c6 54       	brge	8000f11a <update_box+0x290>
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
8000f052:	e4 09 15 05 	lsl	r9,r2,0x5
8000f056:	50 09       	stdsp	sp[0x0],r9
8000f058:	12 93       	mov	r3,r9
8000f05a:	08 03       	add	r3,r4
8000f05c:	a1 73       	lsl	r3,0x1
8000f05e:	08 9e       	mov	lr,r4
	    goto have_c1max;
	  }
      }
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
8000f060:	e0 01 00 28 	add	r8,r0,r1<<0x2
8000f064:	50 48       	stdsp	sp[0x10],r8
8000f066:	50 58       	stdsp	sp[0x14],r8
8000f068:	50 61       	stdsp	sp[0x18],r1
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
8000f06a:	30 0c       	mov	r12,0
	    boxp->c2min = c2min = c2;
	    goto have_c2min;
8000f06c:	50 72       	stdsp	sp[0x1c],r2
8000f06e:	c2 38       	rjmp	8000f0b4 <update_box+0x22a>
      }
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
8000f070:	6c 08       	ld.w	r8,r6[0x0]
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
8000f072:	04 35       	cp.w	r5,r2
8000f074:	c1 65       	brlt	8000f0a0 <update_box+0x216>
      }
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
8000f076:	06 08       	add	r8,r3
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
8000f078:	90 09       	ld.sh	r9,r8[0x0]
8000f07a:	f8 09 19 00 	cp.h	r9,r12
8000f07e:	c0 d0       	breq	8000f098 <update_box+0x20e>
8000f080:	c0 68       	rjmp	8000f08c <update_box+0x202>
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
8000f082:	2c 08       	sub	r8,-64
	  if (*histp != 0) {
8000f084:	90 0a       	ld.sh	r10,r8[0x0]
8000f086:	f8 0a 19 00 	cp.h	r10,r12
8000f08a:	c0 80       	breq	8000f09a <update_box+0x210>
	    boxp->c2min = c2min = c2;
8000f08c:	40 39       	lddsp	r9,sp[0xc]
8000f08e:	93 4e       	st.w	r9[0x10],lr
	    goto have_c2min;
	  }
      }
 have_c2min:
  if (c2max > c2min)
8000f090:	1c 3b       	cp.w	r11,lr
8000f092:	e0 89 00 16 	brgt	8000f0be <update_box+0x234>
8000f096:	c4 18       	rjmp	8000f118 <update_box+0x28e>
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
	    boxp->c2min = c2min = c2;
	    goto have_c2min;
8000f098:	40 79       	lddsp	r9,sp[0x1c]
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
8000f09a:	2f f9       	sub	r9,-1
8000f09c:	12 35       	cp.w	r5,r9
8000f09e:	cf 24       	brge	8000f082 <update_box+0x1f8>
	  }
      }
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
      for (c0 = c0min; c0 <= c0max; c0++) {
8000f0a0:	2f f7       	sub	r7,-1
8000f0a2:	2f c6       	sub	r6,-4
8000f0a4:	40 18       	lddsp	r8,sp[0x4]
8000f0a6:	10 37       	cp.w	r7,r8
8000f0a8:	fe 9a ff e4 	brle	8000f070 <update_box+0x1e6>
	    goto have_c1max;
	  }
      }
 have_c1max:
  if (c2max > c2min)
    for (c2 = c2min; c2 <= c2max; c2++)
8000f0ac:	2f fe       	sub	lr,-1
8000f0ae:	2f e3       	sub	r3,-2
8000f0b0:	1c 3b       	cp.w	r11,lr
8000f0b2:	c0 75       	brlt	8000f0c0 <update_box+0x236>
8000f0b4:	40 49       	lddsp	r9,sp[0x10]
8000f0b6:	50 29       	stdsp	sp[0x8],r9
8000f0b8:	40 56       	lddsp	r6,sp[0x14]
8000f0ba:	40 67       	lddsp	r7,sp[0x18]
8000f0bc:	cf 4b       	rjmp	8000f0a4 <update_box+0x21a>
	    boxp->c2min = c2min = c2;
	    goto have_c2min;
	  }
      }
 have_c2min:
  if (c2max > c2min)
8000f0be:	1c 94       	mov	r4,lr
8000f0c0:	40 03       	lddsp	r3,sp[0x0]
8000f0c2:	16 03       	add	r3,r11
8000f0c4:	a1 73       	lsl	r3,0x1
8000f0c6:	16 9e       	mov	lr,r11
    for (c2 = c2max; c2 >= c2min; c2--)
8000f0c8:	50 01       	stdsp	sp[0x0],r1
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
8000f0ca:	30 0c       	mov	r12,0
	    boxp->c2max = c2max = c2;
	    goto have_c2max;
8000f0cc:	50 42       	stdsp	sp[0x10],r2
8000f0ce:	c2 28       	rjmp	8000f112 <update_box+0x288>
      }
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
8000f0d0:	6c 08       	ld.w	r8,r6[0x0]
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
8000f0d2:	04 35       	cp.w	r5,r2
8000f0d4:	c1 45       	brlt	8000f0fc <update_box+0x272>
      }
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
8000f0d6:	06 08       	add	r8,r3
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
	  if (*histp != 0) {
8000f0d8:	90 09       	ld.sh	r9,r8[0x0]
8000f0da:	f8 09 19 00 	cp.h	r9,r12
8000f0de:	c0 b0       	breq	8000f0f4 <update_box+0x26a>
8000f0e0:	c0 68       	rjmp	8000f0ec <update_box+0x262>
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
8000f0e2:	2c 08       	sub	r8,-64
	  if (*histp != 0) {
8000f0e4:	90 0a       	ld.sh	r10,r8[0x0]
8000f0e6:	f8 0a 19 00 	cp.h	r10,r12
8000f0ea:	c0 60       	breq	8000f0f6 <update_box+0x26c>
	    boxp->c2max = c2max = c2;
8000f0ec:	40 39       	lddsp	r9,sp[0xc]
8000f0ee:	93 5e       	st.w	r9[0x14],lr
8000f0f0:	1c 9b       	mov	r11,lr
	    goto have_c2max;
8000f0f2:	c1 48       	rjmp	8000f11a <update_box+0x290>
8000f0f4:	40 49       	lddsp	r9,sp[0x10]
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++) {
	histp = & histogram[c0][c1min][c2];
	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
8000f0f6:	2f f9       	sub	r9,-1
8000f0f8:	12 35       	cp.w	r5,r9
8000f0fa:	cf 44       	brge	8000f0e2 <update_box+0x258>
	  }
      }
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
      for (c0 = c0min; c0 <= c0max; c0++) {
8000f0fc:	2f f7       	sub	r7,-1
8000f0fe:	2f c6       	sub	r6,-4
8000f100:	40 18       	lddsp	r8,sp[0x4]
8000f102:	10 37       	cp.w	r7,r8
8000f104:	fe 9a ff e6 	brle	8000f0d0 <update_box+0x246>
	    goto have_c2min;
	  }
      }
 have_c2min:
  if (c2max > c2min)
    for (c2 = c2max; c2 >= c2min; c2--)
8000f108:	20 1e       	sub	lr,1
8000f10a:	20 23       	sub	r3,2
8000f10c:	1c 34       	cp.w	r4,lr
8000f10e:	e0 89 00 06 	brgt	8000f11a <update_box+0x290>
8000f112:	40 26       	lddsp	r6,sp[0x8]
8000f114:	40 07       	lddsp	r7,sp[0x0]
8000f116:	cf 5b       	rjmp	8000f100 <update_box+0x276>
8000f118:	1c 94       	mov	r4,lr
   * a box is splittable iff norm > 0.
   * Since the differences are expressed in histogram-cell units,
   * we have to shift back to JSAMPLE units to get consistent distances;
   * after which, we scale according to the selected distance scale factors.
   */
  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
8000f11a:	40 19       	lddsp	r9,sp[0x4]
8000f11c:	02 19       	sub	r9,r1
8000f11e:	a3 79       	lsl	r9,0x3
  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
8000f120:	ea 02 01 08 	sub	r8,r5,r2
8000f124:	f0 0a 15 03 	lsl	r10,r8,0x3
8000f128:	f4 08 00 2a 	add	r10,r10,r8<<0x2
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
8000f12c:	f6 04 01 08 	sub	r8,r11,r4
8000f130:	a5 68       	lsl	r8,0x4
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
8000f132:	b5 3a       	mul	r10,r10
8000f134:	b3 39       	mul	r9,r9
8000f136:	f4 09 00 09 	add	r9,r10,r9
8000f13a:	b1 38       	mul	r8,r8
8000f13c:	f2 08 00 08 	add	r8,r9,r8
8000f140:	40 39       	lddsp	r9,sp[0xc]
8000f142:	93 68       	st.w	r9[0x18],r8

  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
8000f144:	40 18       	lddsp	r8,sp[0x4]
8000f146:	10 31       	cp.w	r1,r8
8000f148:	e0 89 00 2e 	brgt	8000f1a4 <update_box+0x31a>
8000f14c:	e0 01 00 20 	add	r0,r0,r1<<0x2
8000f150:	30 0c       	mov	r12,0
    for (c1 = c1min; c1 <= c1max; c1++) {
8000f152:	e4 08 15 05 	lsl	r8,r2,0x5
8000f156:	e8 08 00 08 	add	r8,r4,r8
8000f15a:	a1 78       	lsl	r8,0x1
8000f15c:	50 28       	stdsp	sp[0x8],r8
8000f15e:	50 02       	stdsp	sp[0x0],r2
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
	if (*histp != 0) {
8000f160:	30 0e       	mov	lr,0
  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
8000f162:	08 93       	mov	r3,r4
8000f164:	c1 98       	rjmp	8000f196 <update_box+0x30c>
8000f166:	16 34       	cp.w	r4,r11
8000f168:	e0 89 00 0e 	brgt	8000f184 <update_box+0x2fa>
8000f16c:	0c 99       	mov	r9,r6
8000f16e:	06 98       	mov	r8,r3
	if (*histp != 0) {
8000f170:	92 0a       	ld.sh	r10,r9[0x0]
	  ccount++;
8000f172:	fc 0a 19 00 	cp.h	r10,lr
8000f176:	f7 bc 01 ff 	subne	r12,-1
  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
8000f17a:	2f f8       	sub	r8,-1
8000f17c:	10 3b       	cp.w	r11,r8
8000f17e:	c0 35       	brlt	8000f184 <update_box+0x2fa>
8000f180:	2f e9       	sub	r9,-2
8000f182:	cf 7b       	rjmp	8000f170 <update_box+0x2e6>
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;

  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
8000f184:	2f f7       	sub	r7,-1
8000f186:	2c 06       	sub	r6,-64
8000f188:	0e 35       	cp.w	r5,r7
8000f18a:	ce e4       	brge	8000f166 <update_box+0x2dc>
  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;

  /* Now scan remaining volume of box and compute population */
  ccount = 0;
  for (c0 = c0min; c0 <= c0max; c0++)
8000f18c:	2f f1       	sub	r1,-1
8000f18e:	2f c0       	sub	r0,-4
8000f190:	40 19       	lddsp	r9,sp[0x4]
8000f192:	02 39       	cp.w	r9,r1
8000f194:	c0 95       	brlt	8000f1a6 <update_box+0x31c>
    for (c1 = c1min; c1 <= c1max; c1++) {
8000f196:	04 35       	cp.w	r5,r2
8000f198:	cf a5       	brlt	8000f18c <update_box+0x302>
8000f19a:	60 06       	ld.w	r6,r0[0x0]
8000f19c:	40 28       	lddsp	r8,sp[0x8]
8000f19e:	10 06       	add	r6,r8
8000f1a0:	40 07       	lddsp	r7,sp[0x0]
8000f1a2:	ce 2b       	rjmp	8000f166 <update_box+0x2dc>
8000f1a4:	30 0c       	mov	r12,0
      for (c2 = c2min; c2 <= c2max; c2++, histp++)
	if (*histp != 0) {
	  ccount++;
	}
    }
  boxp->colorcount = ccount;
8000f1a6:	40 39       	lddsp	r9,sp[0xc]
8000f1a8:	93 7c       	st.w	r9[0x1c],r12
}
8000f1aa:	2f 8d       	sub	sp,-32
8000f1ac:	d8 32       	popm	r0-r7,pc

8000f1ae <fill_inverse_cmap>:
LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
{
8000f1ae:	d4 31       	pushm	r0-r7,lr
8000f1b0:	fa cd 05 bc 	sub	sp,sp,1468
8000f1b4:	50 6c       	stdsp	sp[0x18],r12
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
8000f1b6:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000f1ba:	70 68       	ld.w	r8,r8[0x18]
8000f1bc:	50 e8       	stdsp	sp[0x38],r8
  int numcolors;		/* number of candidate colors */
  /* This array holds the actually closest colormap index for each cell. */
  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Convert cell coordinates to update box ID */
  c0 >>= BOX_C0_LOG;
8000f1be:	a3 4b       	asr	r11,0x2
8000f1c0:	50 db       	stdsp	sp[0x34],r11
  c1 >>= BOX_C1_LOG;
8000f1c2:	a3 5a       	asr	r10,0x3
8000f1c4:	50 ca       	stdsp	sp[0x30],r10
  c2 >>= BOX_C2_LOG;
8000f1c6:	a3 49       	asr	r9,0x2
8000f1c8:	50 b9       	stdsp	sp[0x2c],r9

  /* Compute true coordinates of update box's origin corner.
   * Actually we compute the coordinates of the center of the corner
   * histogram cell, which are the lower bounds of the volume we care about.
   */
  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
8000f1ca:	16 96       	mov	r6,r11
8000f1cc:	a5 76       	lsl	r6,0x5
8000f1ce:	ec c0 ff fc 	sub	r0,r6,-4
  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
8000f1d2:	14 95       	mov	r5,r10
8000f1d4:	a5 75       	lsl	r5,0x5
8000f1d6:	ea cc ff fe 	sub	r12,r5,-2
8000f1da:	50 8c       	stdsp	sp[0x20],r12
  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
8000f1dc:	12 94       	mov	r4,r9
8000f1de:	a5 74       	lsl	r4,0x5
8000f1e0:	e8 c9 ff fc 	sub	r9,r4,-4
8000f1e4:	50 79       	stdsp	sp[0x1c],r9
 * placed in colorlist[].
 * This routine uses Heckbert's "locally sorted search" criterion to select
 * the colors that need further consideration.
 */
{
  int numcolors = cinfo->actual_number_of_colors;
8000f1e6:	40 68       	lddsp	r8,sp[0x18]
8000f1e8:	f0 fe 00 84 	ld.w	lr,r8[132]
   * Actually we compute the coordinates of the center of the upper-corner
   * histogram cell, which are the upper bounds of the volume we care about.
   * Note that since ">>" rounds down, the "center" values may be closer to
   * min than to max; hence comparisons to them must be "<=", not "<".
   */
  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
8000f1ec:	2e 46       	sub	r6,-28
  centerc0 = (minc0 + maxc0) >> 1;
8000f1ee:	ec 00 00 08 	add	r8,r6,r0
8000f1f2:	a1 58       	asr	r8,0x1
8000f1f4:	50 38       	stdsp	sp[0xc],r8
  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
8000f1f6:	2e 25       	sub	r5,-30
  centerc1 = (minc1 + maxc1) >> 1;
8000f1f8:	ea 0c 00 08 	add	r8,r5,r12
8000f1fc:	a1 58       	asr	r8,0x1
8000f1fe:	50 48       	stdsp	sp[0x10],r8
  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
8000f200:	2e 44       	sub	r4,-28
  centerc2 = (minc2 + maxc2) >> 1;
8000f202:	e8 09 00 08 	add	r8,r4,r9
8000f206:	a1 58       	asr	r8,0x1
8000f208:	50 58       	stdsp	sp[0x14],r8
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;

  for (i = 0; i < numcolors; i++) {
8000f20a:	58 0e       	cp.w	lr,0
8000f20c:	e0 89 00 04 	brgt	8000f214 <fill_inverse_cmap+0x66>
8000f210:	30 0b       	mov	r11,0
8000f212:	ca 88       	rjmp	8000f362 <fill_inverse_cmap+0x1b4>
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
8000f214:	40 67       	lddsp	r7,sp[0x18]
8000f216:	ee f8 00 88 	ld.w	r8,r7[136]
8000f21a:	70 02       	ld.w	r2,r8[0x0]
	tdist = (x - minc0) * C0_SCALE;
	max_dist = tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
8000f21c:	70 11       	ld.w	r1,r8[0x4]
	tdist = (x - minc1) * C1_SCALE;
	max_dist += tdist*tdist;
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
8000f21e:	70 28       	ld.w	r8,r8[0x8]
8000f220:	50 08       	stdsp	sp[0x0],r8
8000f222:	e0 6c ff ff 	mov	r12,65535
8000f226:	ea 1c 7f ff 	orh	r12,0x7fff
8000f22a:	30 08       	mov	r8,0
	tdist = (x - minc2) * C2_SCALE;
	max_dist += tdist*tdist;
      }
    }

    mindist[i] = min_dist;	/* save away the results */
8000f22c:	50 12       	stdsp	sp[0x4],r2
8000f22e:	50 21       	stdsp	sp[0x8],r1
8000f230:	40 73       	lddsp	r3,sp[0x1c]
8000f232:	40 82       	lddsp	r2,sp[0x20]
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
8000f234:	10 9b       	mov	r11,r8
   */
  minmaxdist = 0x7FFFFFFFL;

  for (i = 0; i < numcolors; i++) {
    /* We compute the squared-c0-distance term, then add in the other two. */
    x = GETJSAMPLE(cinfo->colormap[0][i]);
8000f236:	40 19       	lddsp	r9,sp[0x4]
8000f238:	f2 08 07 01 	ld.ub	r1,r9[r8]
    if (x < minc0) {
8000f23c:	02 30       	cp.w	r0,r1
8000f23e:	e0 8a 00 08 	brle	8000f24e <fill_inverse_cmap+0xa0>
      tdist = (x - minc0) * C0_SCALE;
8000f242:	e2 00 01 09 	sub	r9,r1,r0
      min_dist = tdist*tdist;
8000f246:	b3 39       	mul	r9,r9
      tdist = (x - maxc0) * C0_SCALE;
8000f248:	0c 11       	sub	r1,r6
      max_dist = tdist*tdist;
8000f24a:	a3 31       	mul	r1,r1
8000f24c:	c1 38       	rjmp	8000f272 <fill_inverse_cmap+0xc4>
    } else if (x > maxc0) {
8000f24e:	02 36       	cp.w	r6,r1
8000f250:	c0 74       	brge	8000f25e <fill_inverse_cmap+0xb0>
      tdist = (x - maxc0) * C0_SCALE;
8000f252:	e2 06 01 09 	sub	r9,r1,r6
      min_dist = tdist*tdist;
8000f256:	b3 39       	mul	r9,r9
      tdist = (x - minc0) * C0_SCALE;
8000f258:	00 11       	sub	r1,r0
      max_dist = tdist*tdist;
8000f25a:	a3 31       	mul	r1,r1
8000f25c:	c0 b8       	rjmp	8000f272 <fill_inverse_cmap+0xc4>
    } else {
      /* within cell range so no contribution to min_dist */
      min_dist = 0;
      if (x <= centerc0) {
8000f25e:	40 37       	lddsp	r7,sp[0xc]
8000f260:	02 37       	cp.w	r7,r1
8000f262:	c0 55       	brlt	8000f26c <fill_inverse_cmap+0xbe>
	tdist = (x - maxc0) * C0_SCALE;
8000f264:	0c 11       	sub	r1,r6
	max_dist = tdist*tdist;
8000f266:	a3 31       	mul	r1,r1
8000f268:	30 09       	mov	r9,0
8000f26a:	c0 48       	rjmp	8000f272 <fill_inverse_cmap+0xc4>
      } else {
	tdist = (x - minc0) * C0_SCALE;
8000f26c:	00 11       	sub	r1,r0
	max_dist = tdist*tdist;
8000f26e:	a3 31       	mul	r1,r1
8000f270:	30 09       	mov	r9,0
      }
    }

    x = GETJSAMPLE(cinfo->colormap[1][i]);
8000f272:	40 27       	lddsp	r7,sp[0x8]
8000f274:	ee 0b 07 0a 	ld.ub	r10,r7[r11]
    if (x < minc1) {
8000f278:	14 32       	cp.w	r2,r10
8000f27a:	e0 8a 00 0f 	brle	8000f298 <fill_inverse_cmap+0xea>
      tdist = (x - minc1) * C1_SCALE;
8000f27e:	f4 02 01 07 	sub	r7,r10,r2
8000f282:	ee 07 00 17 	add	r7,r7,r7<<0x1
      min_dist += tdist*tdist;
8000f286:	ee 07 03 49 	mac	r9,r7,r7
      tdist = (x - maxc1) * C1_SCALE;
8000f28a:	0a 1a       	sub	r10,r5
8000f28c:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
      max_dist += tdist*tdist;
8000f290:	b5 3a       	mul	r10,r10
8000f292:	e2 0a 00 07 	add	r7,r1,r10
8000f296:	c2 08       	rjmp	8000f2d6 <fill_inverse_cmap+0x128>
    } else if (x > maxc1) {
8000f298:	14 35       	cp.w	r5,r10
8000f29a:	c0 e4       	brge	8000f2b6 <fill_inverse_cmap+0x108>
      tdist = (x - maxc1) * C1_SCALE;
8000f29c:	f4 05 01 07 	sub	r7,r10,r5
8000f2a0:	ee 07 00 17 	add	r7,r7,r7<<0x1
      min_dist += tdist*tdist;
8000f2a4:	ee 07 03 49 	mac	r9,r7,r7
      tdist = (x - minc1) * C1_SCALE;
8000f2a8:	04 1a       	sub	r10,r2
8000f2aa:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
      max_dist += tdist*tdist;
8000f2ae:	b5 3a       	mul	r10,r10
8000f2b0:	e2 0a 00 07 	add	r7,r1,r10
8000f2b4:	c1 18       	rjmp	8000f2d6 <fill_inverse_cmap+0x128>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc1) {
8000f2b6:	40 47       	lddsp	r7,sp[0x10]
8000f2b8:	14 37       	cp.w	r7,r10
8000f2ba:	c0 85       	brlt	8000f2ca <fill_inverse_cmap+0x11c>
	tdist = (x - maxc1) * C1_SCALE;
8000f2bc:	0a 1a       	sub	r10,r5
8000f2be:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
	max_dist += tdist*tdist;
8000f2c2:	b5 3a       	mul	r10,r10
8000f2c4:	e2 0a 00 07 	add	r7,r1,r10
8000f2c8:	c0 78       	rjmp	8000f2d6 <fill_inverse_cmap+0x128>
      } else {
	tdist = (x - minc1) * C1_SCALE;
8000f2ca:	04 1a       	sub	r10,r2
8000f2cc:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
	max_dist += tdist*tdist;
8000f2d0:	b5 3a       	mul	r10,r10
8000f2d2:	e2 0a 00 07 	add	r7,r1,r10
      }
    }

    x = GETJSAMPLE(cinfo->colormap[2][i]);
8000f2d6:	40 01       	lddsp	r1,sp[0x0]
8000f2d8:	e2 0b 07 0a 	ld.ub	r10,r1[r11]
    if (x < minc2) {
8000f2dc:	14 33       	cp.w	r3,r10
8000f2de:	e0 8a 00 0d 	brle	8000f2f8 <fill_inverse_cmap+0x14a>
      tdist = (x - minc2) * C2_SCALE;
8000f2e2:	f4 03 01 01 	sub	r1,r10,r3
8000f2e6:	a1 71       	lsl	r1,0x1
      min_dist += tdist*tdist;
8000f2e8:	e2 01 03 49 	mac	r9,r1,r1
      tdist = (x - maxc2) * C2_SCALE;
8000f2ec:	08 1a       	sub	r10,r4
8000f2ee:	a1 7a       	lsl	r10,0x1
      max_dist += tdist*tdist;
8000f2f0:	b5 3a       	mul	r10,r10
8000f2f2:	ee 0a 00 0a 	add	r10,r7,r10
8000f2f6:	c1 c8       	rjmp	8000f32e <fill_inverse_cmap+0x180>
    } else if (x > maxc2) {
8000f2f8:	14 34       	cp.w	r4,r10
8000f2fa:	c0 c4       	brge	8000f312 <fill_inverse_cmap+0x164>
      tdist = (x - maxc2) * C2_SCALE;
8000f2fc:	f4 04 01 01 	sub	r1,r10,r4
8000f300:	a1 71       	lsl	r1,0x1
      min_dist += tdist*tdist;
8000f302:	e2 01 03 49 	mac	r9,r1,r1
      tdist = (x - minc2) * C2_SCALE;
8000f306:	06 1a       	sub	r10,r3
8000f308:	a1 7a       	lsl	r10,0x1
      max_dist += tdist*tdist;
8000f30a:	b5 3a       	mul	r10,r10
8000f30c:	ee 0a 00 0a 	add	r10,r7,r10
8000f310:	c0 f8       	rjmp	8000f32e <fill_inverse_cmap+0x180>
    } else {
      /* within cell range so no contribution to min_dist */
      if (x <= centerc2) {
8000f312:	40 51       	lddsp	r1,sp[0x14]
8000f314:	14 31       	cp.w	r1,r10
8000f316:	c0 75       	brlt	8000f324 <fill_inverse_cmap+0x176>
	tdist = (x - maxc2) * C2_SCALE;
8000f318:	08 1a       	sub	r10,r4
8000f31a:	a1 7a       	lsl	r10,0x1
	max_dist += tdist*tdist;
8000f31c:	b5 3a       	mul	r10,r10
8000f31e:	ee 0a 00 0a 	add	r10,r7,r10
8000f322:	c0 68       	rjmp	8000f32e <fill_inverse_cmap+0x180>
      } else {
	tdist = (x - minc2) * C2_SCALE;
8000f324:	06 1a       	sub	r10,r3
8000f326:	a1 7a       	lsl	r10,0x1
	max_dist += tdist*tdist;
8000f328:	b5 3a       	mul	r10,r10
8000f32a:	ee 0a 00 0a 	add	r10,r7,r10
      }
    }

    mindist[i] = min_dist;	/* save away the results */
8000f32e:	fa c7 ff c4 	sub	r7,sp,-60
8000f332:	ee 0b 09 29 	st.w	r7[r11<<0x2],r9
8000f336:	f8 0a 0d 4c 	min	r12,r12,r10
   * We save the minimum distance for each color in mindist[];
   * only the smallest maximum distance is of interest.
   */
  minmaxdist = 0x7FFFFFFFL;

  for (i = 0; i < numcolors; i++) {
8000f33a:	2f f8       	sub	r8,-1
8000f33c:	1c 38       	cp.w	r8,lr
8000f33e:	fe 91 ff 7b 	brne	8000f234 <fill_inverse_cmap+0x86>
8000f342:	0e 99       	mov	r9,r7
8000f344:	30 0b       	mov	r11,0
8000f346:	16 98       	mov	r8,r11
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
  for (i = 0; i < numcolors; i++) {
    if (mindist[i] <= minmaxdist)
      colorlist[ncolors++] = (JSAMPLE) i;
8000f348:	fa c7 fb 44 	sub	r7,sp,-1212
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
  for (i = 0; i < numcolors; i++) {
    if (mindist[i] <= minmaxdist)
8000f34c:	72 0a       	ld.w	r10,r9[0x0]
8000f34e:	18 3a       	cp.w	r10,r12
8000f350:	e0 89 00 05 	brgt	8000f35a <fill_inverse_cmap+0x1ac>
      colorlist[ncolors++] = (JSAMPLE) i;
8000f354:	ee 0b 0b 08 	st.b	r7[r11],r8
8000f358:	2f fb       	sub	r11,-1
  /* Now we know that no cell in the update box is more than minmaxdist
   * away from some colormap entry.  Therefore, only colors that are
   * within minmaxdist of some part of the box need be considered.
   */
  ncolors = 0;
  for (i = 0; i < numcolors; i++) {
8000f35a:	2f f8       	sub	r8,-1
8000f35c:	2f c9       	sub	r9,-4
8000f35e:	1c 38       	cp.w	r8,lr
8000f360:	cf 61       	brne	8000f34c <fill_inverse_cmap+0x19e>
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
8000f362:	fa ca fd c4 	sub	r10,sp,-572
8000f366:	fa c8 ff c4 	sub	r8,sp,-60
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
    *bptr++ = 0x7FFFFFFFL;
8000f36a:	e0 69 ff ff 	mov	r9,65535
8000f36e:	ea 19 7f ff 	orh	r9,0x7fff
8000f372:	10 a9       	st.w	r8++,r9
  /* This array holds the distance to the nearest-so-far color for each cell */
  INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];

  /* Initialize best-distance for each cell of the update box */
  bptr = bestdist;
  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
8000f374:	14 38       	cp.w	r8,r10
8000f376:	cf e1       	brne	8000f372 <fill_inverse_cmap+0x1c4>
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)

  for (i = 0; i < numcolors; i++) {
8000f378:	58 0b       	cp.w	r11,0
8000f37a:	e0 8a 00 7b 	brle	8000f470 <fill_inverse_cmap+0x2c2>
8000f37e:	fa cc fb 44 	sub	r12,sp,-1212
8000f382:	50 5c       	stdsp	sp[0x14],r12
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
8000f384:	18 0b       	add	r11,r12
8000f386:	50 9b       	stdsp	sp[0x24],r11
8000f388:	50 a0       	stdsp	sp[0x28],r0
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)

  for (i = 0; i < numcolors; i++) {
    icolor = GETJSAMPLE(colorlist[i]);
8000f38a:	40 59       	lddsp	r9,sp[0x14]
8000f38c:	13 84       	ld.ub	r4,r9[0x0]
    /* Compute (square of) distance from minc0/c1/c2 to this color */
    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
8000f38e:	40 68       	lddsp	r8,sp[0x18]
8000f390:	f0 f9 00 88 	ld.w	r9,r8[136]
8000f394:	72 08       	ld.w	r8,r9[0x0]
8000f396:	f0 04 07 0b 	ld.ub	r11,r8[r4]
8000f39a:	40 a7       	lddsp	r7,sp[0x28]
8000f39c:	ee 0b 01 0b 	sub	r11,r7,r11
    dist0 = inc0*inc0;
8000f3a0:	f6 0b 02 4a 	mul	r10,r11,r11
    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
8000f3a4:	72 18       	ld.w	r8,r9[0x4]
8000f3a6:	f0 04 07 08 	ld.ub	r8,r8[r4]
8000f3aa:	40 81       	lddsp	r1,sp[0x20]
8000f3ac:	e2 08 01 08 	sub	r8,r1,r8
8000f3b0:	f0 08 00 18 	add	r8,r8,r8<<0x1
    dist0 += inc1*inc1;
    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
8000f3b4:	72 29       	ld.w	r9,r9[0x8]
8000f3b6:	f2 04 07 09 	ld.ub	r9,r9[r4]
8000f3ba:	40 7c       	lddsp	r12,sp[0x1c]
8000f3bc:	f8 09 01 09 	sub	r9,r12,r9
8000f3c0:	a1 79       	lsl	r9,0x1
    dist0 += inc2*inc2;
8000f3c2:	f0 08 02 4c 	mul	r12,r8,r8
8000f3c6:	14 0c       	add	r12,r10
8000f3c8:	f2 09 02 4a 	mul	r10,r9,r9
8000f3cc:	f8 0a 00 0a 	add	r10,r12,r10
    /* Form the initial difference increments */
    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
8000f3d0:	2f cb       	sub	r11,-4
8000f3d2:	f6 00 15 04 	lsl	r0,r11,0x4
    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
8000f3d6:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000f3da:	a3 78       	lsl	r8,0x3
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
8000f3dc:	2f 89       	sub	r9,-8
8000f3de:	f2 02 15 05 	lsl	r2,r9,0x5
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
8000f3e2:	e0 c9 fe 80 	sub	r9,r0,-384
8000f3e6:	50 39       	stdsp	sp[0xc],r9
8000f3e8:	50 2a       	stdsp	sp[0x8],r10
8000f3ea:	fa c7 fb c4 	sub	r7,sp,-1084
8000f3ee:	50 17       	stdsp	sp[0x4],r7
8000f3f0:	fa c1 ff c4 	sub	r1,sp,-60
8000f3f4:	50 01       	stdsp	sp[0x0],r1
8000f3f6:	f0 c1 f7 90 	sub	r1,r8,-2160
8000f3fa:	f0 c8 ff 70 	sub	r8,r8,-144
8000f3fe:	50 48       	stdsp	sp[0x10],r8
8000f400:	e4 ce fa 00 	sub	lr,r2,-1536
8000f404:	c2 b8       	rjmp	8000f45a <fill_inverse_cmap+0x2ac>
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
	  if (dist2 < *bptr) {
	    *bptr = dist2;
	    *cptr = (JSAMPLE) icolor;
	  }
	  dist2 += xx2;
8000f406:	12 0a       	add	r10,r9
	  xx2 += 2 * STEP_C2 * STEP_C2;
8000f408:	f2 c9 fe 00 	sub	r9,r9,-512
      xx1 = inc1;
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
	dist2 = dist1;
	xx2 = inc2;
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
	  if (dist2 < *bptr) {
8000f40c:	70 0c       	ld.w	r12,r8[0x0]
	    *bptr = dist2;
8000f40e:	14 3c       	cp.w	r12,r10
8000f410:	f1 fa 9a 00 	st.wgt	r8[0x0],r10
	    *cptr = (JSAMPLE) icolor;
8000f414:	e8 0c 17 90 	movgt	r12,r4
8000f418:	f7 fc 9e 00 	st.bgt	r11[0x0],r12
	  }
	  dist2 += xx2;
	  xx2 += 2 * STEP_C2 * STEP_C2;
	  bptr++;
8000f41c:	2f c8       	sub	r8,-4
	  cptr++;
8000f41e:	2f fb       	sub	r11,-1
      dist1 = dist0;
      xx1 = inc1;
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
	dist2 = dist1;
	xx2 = inc2;
	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
8000f420:	1c 39       	cp.w	r9,lr
8000f422:	cf 21       	brne	8000f406 <fill_inverse_cmap+0x258>
8000f424:	2f 06       	sub	r6,-16
8000f426:	2f c5       	sub	r5,-4
    cptr = bestcolor;
    xx0 = inc0;
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
      dist1 = dist0;
      xx1 = inc1;
      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
8000f428:	02 37       	cp.w	r7,r1
8000f42a:	c0 a0       	breq	8000f43e <fill_inverse_cmap+0x290>
	  dist2 += xx2;
	  xx2 += 2 * STEP_C2 * STEP_C2;
	  bptr++;
	  cptr++;
	}
	dist1 += xx1;
8000f42c:	ee 03 00 0a 	add	r10,r7,r3
	xx1 += 2 * STEP_C1 * STEP_C1;
8000f430:	ee c7 fe e0 	sub	r7,r7,-288
8000f434:	14 93       	mov	r3,r10
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
8000f436:	04 99       	mov	r9,r2
8000f438:	0a 9b       	mov	r11,r5
8000f43a:	0c 98       	mov	r8,r6
8000f43c:	ce 8b       	rjmp	8000f40c <fill_inverse_cmap+0x25e>
8000f43e:	40 09       	lddsp	r9,sp[0x0]
8000f440:	28 09       	sub	r9,-128
8000f442:	50 09       	stdsp	sp[0x0],r9
8000f444:	40 18       	lddsp	r8,sp[0x4]
8000f446:	2e 08       	sub	r8,-32
8000f448:	50 18       	stdsp	sp[0x4],r8
    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
    /* Now loop over all cells in box, updating distance per Thomas method */
    bptr = bestdist;
    cptr = bestcolor;
    xx0 = inc0;
    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
8000f44a:	40 37       	lddsp	r7,sp[0xc]
8000f44c:	0e 30       	cp.w	r0,r7
8000f44e:	c0 b0       	breq	8000f464 <fill_inverse_cmap+0x2b6>
	  cptr++;
	}
	dist1 += xx1;
	xx1 += 2 * STEP_C1 * STEP_C1;
      }
      dist0 += xx0;
8000f450:	40 2c       	lddsp	r12,sp[0x8]
8000f452:	e0 0c 00 0a 	add	r10,r0,r12
      xx0 += 2 * STEP_C0 * STEP_C0;
8000f456:	28 00       	sub	r0,-128
8000f458:	50 2a       	stdsp	sp[0x8],r10
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
8000f45a:	40 47       	lddsp	r7,sp[0x10]
8000f45c:	14 93       	mov	r3,r10
8000f45e:	40 15       	lddsp	r5,sp[0x4]
8000f460:	40 06       	lddsp	r6,sp[0x0]
8000f462:	ce ab       	rjmp	8000f436 <fill_inverse_cmap+0x288>
8000f464:	40 59       	lddsp	r9,sp[0x14]
8000f466:	2f f9       	sub	r9,-1
8000f468:	50 59       	stdsp	sp[0x14],r9
  /* Nominal steps between cell centers ("x" in Thomas article) */
#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)

  for (i = 0; i < numcolors; i++) {
8000f46a:	40 98       	lddsp	r8,sp[0x24]
8000f46c:	10 39       	cp.w	r9,r8
8000f46e:	c8 e1       	brne	8000f38a <fill_inverse_cmap+0x1dc>
		   bestcolor);

  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
8000f470:	40 de       	lddsp	lr,sp[0x34]
8000f472:	a5 6e       	lsl	lr,0x4
8000f474:	40 e7       	lddsp	r7,sp[0x38]
8000f476:	ee 0e 00 0e 	add	lr,r7,lr
  }
}


LOCAL(void)
fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
8000f47a:	fa c4 fb 44 	sub	r4,sp,-1212
8000f47e:	fa c5 fb c4 	sub	r5,sp,-1084
  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
8000f482:	40 c3       	lddsp	r3,sp[0x30]
8000f484:	a9 63       	lsl	r3,0x8
8000f486:	40 b1       	lddsp	r1,sp[0x2c]
8000f488:	e6 01 00 23 	add	r3,r3,r1<<0x2
8000f48c:	a1 73       	lsl	r3,0x1
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
      cachep = & histogram[c0+ic0][c1+ic1][c2];
8000f48e:	30 06       	mov	r6,0
8000f490:	c1 38       	rjmp	8000f4b6 <fill_inverse_cmap+0x308>
8000f492:	7c 09       	ld.w	r9,lr[0x0]
8000f494:	18 09       	add	r9,r12
8000f496:	0c 98       	mov	r8,r6
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
8000f498:	f6 08 07 0a 	ld.ub	r10,r11[r8]
8000f49c:	2f fa       	sub	r10,-1
8000f49e:	12 ba       	st.h	r9++,r10
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
      cachep = & histogram[c0+ic0][c1+ic1][c2];
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
8000f4a0:	2f f8       	sub	r8,-1
8000f4a2:	58 48       	cp.w	r8,4
8000f4a4:	cf a1       	brne	8000f498 <fill_inverse_cmap+0x2ea>
8000f4a6:	2f cb       	sub	r11,-4
8000f4a8:	2c 0c       	sub	r12,-64
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
8000f4aa:	0e 3b       	cp.w	r11,r7
8000f4ac:	cf 31       	brne	8000f492 <fill_inverse_cmap+0x2e4>
8000f4ae:	2e 05       	sub	r5,-32
8000f4b0:	2f ce       	sub	lr,-4
  /* Save the best color numbers (plus 1) in the main cache array */
  c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
  c1 <<= BOX_C1_LOG;
  c2 <<= BOX_C2_LOG;
  cptr = bestcolor;
  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
8000f4b2:	08 35       	cp.w	r5,r4
8000f4b4:	c0 60       	breq	8000f4c0 <fill_inverse_cmap+0x312>
8000f4b6:	06 9c       	mov	r12,r3
8000f4b8:	ea c7 ff e0 	sub	r7,r5,-32
8000f4bc:	0a 9b       	mov	r11,r5
8000f4be:	ce ab       	rjmp	8000f492 <fill_inverse_cmap+0x2e4>
      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
      }
    }
  }
}
8000f4c0:	fe 3d fa 44 	sub	sp,-1468
8000f4c4:	d8 32       	popm	r0-r7,pc
8000f4c6:	d7 03       	nop

8000f4c8 <pass2_no_dither>:

METHODDEF(void)
pass2_no_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs no dithering */
{
8000f4c8:	d4 31       	pushm	r0-r7,lr
8000f4ca:	20 4d       	sub	sp,16
8000f4cc:	18 90       	mov	r0,r12
8000f4ce:	50 39       	stdsp	sp[0xc],r9
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
8000f4d0:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000f4d4:	70 64       	ld.w	r4,r8[0x18]
  register JSAMPROW inptr, outptr;
  register histptr cachep;
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000f4d6:	79 c2       	ld.w	r2,r12[0x70]

  for (row = 0; row < num_rows; row++) {
8000f4d8:	58 09       	cp.w	r9,0
8000f4da:	e0 8a 00 38 	brle	8000f54a <pass2_no_dither+0x82>
8000f4de:	50 1b       	stdsp	sp[0x4],r11
8000f4e0:	50 0a       	stdsp	sp[0x0],r10
8000f4e2:	30 09       	mov	r9,0
8000f4e4:	50 29       	stdsp	sp[0x8],r9
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
      cachep = & histogram[c0][c1][c2];
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
8000f4e6:	30 03       	mov	r3,0
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
8000f4e8:	40 18       	lddsp	r8,sp[0x4]
8000f4ea:	70 07       	ld.w	r7,r8[0x0]
    outptr = output_buf[row];
8000f4ec:	40 09       	lddsp	r9,sp[0x0]
8000f4ee:	72 01       	ld.w	r1,r9[0x0]
    for (col = width; col > 0; col--) {
8000f4f0:	58 02       	cp.w	r2,0
8000f4f2:	c1 e0       	breq	8000f52e <pass2_no_dither+0x66>
8000f4f4:	30 06       	mov	r6,0
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
8000f4f6:	0f 8b       	ld.ub	r11,r7[0x0]
8000f4f8:	a3 9b       	lsr	r11,0x3
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
8000f4fa:	0f 9a       	ld.ub	r10,r7[0x1]
8000f4fc:	a3 8a       	lsr	r10,0x2
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
8000f4fe:	0f a9       	ld.ub	r9,r7[0x2]
8000f500:	a3 99       	lsr	r9,0x3
/*
 * Map some rows of pixels to the output colormapped representation.
 */

METHODDEF(void)
pass2_no_dither (j_decompress_ptr cinfo,
8000f502:	2f d7       	sub	r7,-3
    for (col = width; col > 0; col--) {
      /* get pixel value and index into the cache */
      c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
      c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
      c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
      cachep = & histogram[c0][c1][c2];
8000f504:	f4 05 15 05 	lsl	r5,r10,0x5
8000f508:	12 05       	add	r5,r9
8000f50a:	e8 0b 03 28 	ld.w	r8,r4[r11<<0x2]
8000f50e:	f0 05 00 15 	add	r5,r8,r5<<0x1
      /* If we have not seen this color before, find nearest colormap entry */
      /* and update the cache */
      if (*cachep == 0)
8000f512:	8a 08       	ld.sh	r8,r5[0x0]
8000f514:	e6 08 19 00 	cp.h	r8,r3
8000f518:	c0 41       	brne	8000f520 <pass2_no_dither+0x58>
	fill_inverse_cmap(cinfo, c0,c1,c2);
8000f51a:	00 9c       	mov	r12,r0
8000f51c:	f0 1f 00 0d 	mcall	8000f550 <pass2_no_dither+0x88>
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
8000f520:	8a 08       	ld.sh	r8,r5[0x0]
8000f522:	20 18       	sub	r8,1
8000f524:	e2 06 0b 08 	st.b	r1[r6],r8
8000f528:	2f f6       	sub	r6,-1
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
    outptr = output_buf[row];
    for (col = width; col > 0; col--) {
8000f52a:	0c 32       	cp.w	r2,r6
8000f52c:	ce 51       	brne	8000f4f6 <pass2_no_dither+0x2e>
  register int c0, c1, c2;
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;

  for (row = 0; row < num_rows; row++) {
8000f52e:	40 28       	lddsp	r8,sp[0x8]
8000f530:	2f f8       	sub	r8,-1
8000f532:	50 28       	stdsp	sp[0x8],r8
8000f534:	40 19       	lddsp	r9,sp[0x4]
8000f536:	2f c9       	sub	r9,-4
8000f538:	50 19       	stdsp	sp[0x4],r9
8000f53a:	40 08       	lddsp	r8,sp[0x0]
8000f53c:	2f c8       	sub	r8,-4
8000f53e:	50 08       	stdsp	sp[0x0],r8
8000f540:	40 39       	lddsp	r9,sp[0xc]
8000f542:	40 28       	lddsp	r8,sp[0x8]
8000f544:	10 39       	cp.w	r9,r8
8000f546:	fe 99 ff d1 	brgt	8000f4e8 <pass2_no_dither+0x20>
	fill_inverse_cmap(cinfo, c0,c1,c2);
      /* Now emit the colormap index for this cell */
      *outptr++ = (JSAMPLE) (*cachep - 1);
    }
  }
}
8000f54a:	2f cd       	sub	sp,-16
8000f54c:	d8 32       	popm	r0-r7,pc
8000f54e:	00 00       	add	r0,r0
8000f550:	80 00       	ld.sh	r0,r0[0x0]
8000f552:	f1 ae d4 31 	ldc0.w	cr4,lr[0x34c4]

8000f554 <pass2_fs_dither>:

METHODDEF(void)
pass2_fs_dither (j_decompress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
/* This version performs Floyd-Steinberg dithering */
{
8000f554:	d4 31       	pushm	r0-r7,lr
8000f556:	fa cd 00 88 	sub	sp,sp,136
8000f55a:	51 7c       	stdsp	sp[0x5c],r12
8000f55c:	51 d9       	stdsp	sp[0x74],r9
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000f55e:	f8 fe 01 cc 	ld.w	lr,r12[460]
8000f562:	51 8e       	stdsp	sp[0x60],lr
  hist3d histogram = cquantize->histogram;
8000f564:	7c 6c       	ld.w	r12,lr[0x18]
8000f566:	51 4c       	stdsp	sp[0x50],r12
  histptr cachep;
  int dir;			/* +1 or -1 depending on direction */
  int dir3;			/* 3*dir, for advancing inptr & errorptr */
  int row;
  JDIMENSION col;
  JDIMENSION width = cinfo->output_width;
8000f568:	41 79       	lddsp	r9,sp[0x5c]
8000f56a:	73 c9       	ld.w	r9,r9[0x70]
8000f56c:	51 c9       	stdsp	sp[0x70],r9
  JSAMPLE *range_limit = cinfo->sample_range_limit;
8000f56e:	41 78       	lddsp	r8,sp[0x5c]
8000f570:	f0 f8 01 44 	ld.w	r8,r8[324]
8000f574:	50 58       	stdsp	sp[0x14],r8
  int *error_limit = cquantize->error_limiter;
8000f576:	7c a5       	ld.w	r5,lr[0x28]
8000f578:	50 45       	stdsp	sp[0x10],r5
  JSAMPROW colormap0 = cinfo->colormap[0];
8000f57a:	41 7e       	lddsp	lr,sp[0x5c]
8000f57c:	fc f8 00 88 	ld.w	r8,lr[136]
8000f580:	70 0c       	ld.w	r12,r8[0x0]
8000f582:	51 2c       	stdsp	sp[0x48],r12
  JSAMPROW colormap1 = cinfo->colormap[1];
8000f584:	70 19       	ld.w	r9,r8[0x4]
8000f586:	51 19       	stdsp	sp[0x44],r9
  JSAMPROW colormap2 = cinfo->colormap[2];
8000f588:	70 28       	ld.w	r8,r8[0x8]
8000f58a:	51 08       	stdsp	sp[0x40],r8
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
8000f58c:	41 d8       	lddsp	r8,sp[0x74]
8000f58e:	58 08       	cp.w	r8,0
8000f590:	e0 8a 01 0b 	brle	8000f7a6 <pass2_fs_dither+0x252>
    inptr = input_buf[row];
    outptr = output_buf[row];
    if (cquantize->on_odd_row) {
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
8000f594:	41 c5       	lddsp	r5,sp[0x70]
8000f596:	20 15       	sub	r5,1
8000f598:	51 e5       	stdsp	sp[0x78],r5
8000f59a:	ea 05 00 1e 	add	lr,r5,r5<<0x1
8000f59e:	52 0e       	stdsp	sp[0x80],lr
      outptr += width-1;
      dir = -1;
      dir3 = -3;
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
8000f5a0:	41 c8       	lddsp	r8,sp[0x70]
8000f5a2:	2f f8       	sub	r8,-1
8000f5a4:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000f5a8:	a1 78       	lsl	r8,0x1
8000f5aa:	51 f8       	stdsp	sp[0x7c],r8
8000f5ac:	51 ab       	stdsp	sp[0x68],r11
8000f5ae:	51 9a       	stdsp	sp[0x64],r10
8000f5b0:	30 0c       	mov	r12,0
8000f5b2:	51 bc       	stdsp	sp[0x6c],r12
    } else {
      /* work left to right in this row */
      dir = 1;
      dir3 = 3;
      errorptr = cquantize->fserrors; /* => entry before first real column */
      cquantize->on_odd_row = TRUE; /* flip for next time */
8000f5b4:	30 1b       	mov	r11,1
8000f5b6:	52 1b       	stdsp	sp[0x84],r11
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
8000f5b8:	51 6c       	stdsp	sp[0x58],r12
  JSAMPROW colormap1 = cinfo->colormap[1];
  JSAMPROW colormap2 = cinfo->colormap[2];
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
    inptr = input_buf[row];
8000f5ba:	41 a9       	lddsp	r9,sp[0x68]
8000f5bc:	72 07       	ld.w	r7,r9[0x0]
    outptr = output_buf[row];
8000f5be:	41 98       	lddsp	r8,sp[0x64]
8000f5c0:	70 08       	ld.w	r8,r8[0x0]
8000f5c2:	50 38       	stdsp	sp[0xc],r8
    if (cquantize->on_odd_row) {
8000f5c4:	41 85       	lddsp	r5,sp[0x60]
8000f5c6:	6a 98       	ld.w	r8,r5[0x24]
8000f5c8:	58 08       	cp.w	r8,0
8000f5ca:	c1 10       	breq	8000f5ec <pass2_fs_dither+0x98>
      /* work right to left in this row */
      inptr += (width-1) * 3;	/* so point to rightmost pixel */
8000f5cc:	42 0e       	lddsp	lr,sp[0x80]
8000f5ce:	1c 07       	add	r7,lr
      outptr += width-1;
8000f5d0:	40 3c       	lddsp	r12,sp[0xc]
8000f5d2:	41 eb       	lddsp	r11,sp[0x78]
8000f5d4:	16 0c       	add	r12,r11
8000f5d6:	50 3c       	stdsp	sp[0xc],r12
      dir = -1;
      dir3 = -3;
      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
8000f5d8:	6a 88       	ld.w	r8,r5[0x20]
8000f5da:	41 fa       	lddsp	r10,sp[0x7c]
8000f5dc:	14 08       	add	r8,r10
8000f5de:	51 58       	stdsp	sp[0x54],r8
      cquantize->on_odd_row = FALSE; /* flip for next time */
8000f5e0:	30 09       	mov	r9,0
8000f5e2:	8b 99       	st.w	r5[0x24],r9
8000f5e4:	3f d8       	mov	r8,-3
8000f5e6:	3f f5       	mov	r5,-1
8000f5e8:	51 35       	stdsp	sp[0x4c],r5
8000f5ea:	c0 a8       	rjmp	8000f5fe <pass2_fs_dither+0xaa>
    } else {
      /* work left to right in this row */
      dir = 1;
      dir3 = 3;
      errorptr = cquantize->fserrors; /* => entry before first real column */
8000f5ec:	41 8e       	lddsp	lr,sp[0x60]
8000f5ee:	7c 8e       	ld.w	lr,lr[0x20]
8000f5f0:	51 5e       	stdsp	sp[0x54],lr
      cquantize->on_odd_row = TRUE; /* flip for next time */
8000f5f2:	30 1b       	mov	r11,1
8000f5f4:	41 8c       	lddsp	r12,sp[0x60]
8000f5f6:	99 9b       	st.w	r12[0x24],r11
8000f5f8:	30 38       	mov	r8,3
8000f5fa:	42 1a       	lddsp	r10,sp[0x84]
8000f5fc:	51 3a       	stdsp	sp[0x4c],r10
    cur0 = cur1 = cur2 = 0;
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
    bpreverr0 = bpreverr1 = bpreverr2 = 0;

    for (col = width; col > 0; col--) {
8000f5fe:	41 c9       	lddsp	r9,sp[0x70]
8000f600:	58 09       	cp.w	r9,0
8000f602:	c0 71       	brne	8000f610 <pass2_fs_dither+0xbc>
8000f604:	30 08       	mov	r8,0
8000f606:	50 78       	stdsp	sp[0x1c],r8
8000f608:	41 65       	lddsp	r5,sp[0x58]
8000f60a:	50 85       	stdsp	sp[0x20],r5
8000f60c:	50 95       	stdsp	sp[0x24],r5
8000f60e:	cb 88       	rjmp	8000f77e <pass2_fs_dither+0x22a>
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
8000f610:	50 d8       	stdsp	sp[0x34],r8
8000f612:	10 94       	mov	r4,r8
8000f614:	a1 74       	lsl	r4,0x1
8000f616:	10 93       	mov	r3,r8
8000f618:	2f f3       	sub	r3,-1
8000f61a:	41 5e       	lddsp	lr,sp[0x54]
8000f61c:	fc 03 00 13 	add	r3,lr,r3<<0x1
8000f620:	2f e8       	sub	r8,-2
8000f622:	fc 08 00 18 	add	r8,lr,r8<<0x1
8000f626:	50 18       	stdsp	sp[0x4],r8
8000f628:	41 cc       	lddsp	r12,sp[0x70]
8000f62a:	50 2c       	stdsp	sp[0x8],r12
8000f62c:	50 6e       	stdsp	sp[0x18],lr
8000f62e:	30 0b       	mov	r11,0
8000f630:	50 7b       	stdsp	sp[0x1c],r11
8000f632:	41 6a       	lddsp	r10,sp[0x58]
8000f634:	50 8a       	stdsp	sp[0x20],r10
8000f636:	50 9a       	stdsp	sp[0x24],r10
8000f638:	50 aa       	stdsp	sp[0x28],r10
8000f63a:	50 ba       	stdsp	sp[0x2c],r10
8000f63c:	50 ca       	stdsp	sp[0x30],r10
8000f63e:	14 9b       	mov	r11,r10
8000f640:	14 99       	mov	r9,r10
	belowerr0 = bnexterr;
	cur0 += delta;		/* form error * 7 */
	bnexterr = cur1;	/* Process component 1 */
	delta = cur1 * 2;
	cur1 += delta;		/* form error * 3 */
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
8000f642:	e8 08 11 02 	rsub	r8,r4,2
8000f646:	50 e8       	stdsp	sp[0x38],r8
	belowerr1 = bnexterr;
	cur1 += delta;		/* form error * 7 */
	bnexterr = cur2;	/* Process component 2 */
	delta = cur2 * 2;
	cur2 += delta;		/* form error * 3 */
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
8000f648:	e8 05 11 04 	rsub	r5,r4,4
8000f64c:	50 f5       	stdsp	sp[0x3c],r5
       * round the error term (which is expressed * 16) to an integer.
       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
       * for either sign of the error value.
       * Note: errorptr points to *previous* column's array entry.
       */
      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
8000f64e:	40 66       	lddsp	r6,sp[0x18]
8000f650:	08 06       	add	r6,r4
8000f652:	2f 8a       	sub	r10,-8
8000f654:	8c 08       	ld.sh	r8,r6[0x0]
8000f656:	10 0a       	add	r10,r8
      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
8000f658:	2f 89       	sub	r9,-8
8000f65a:	86 08       	ld.sh	r8,r3[0x0]
8000f65c:	10 09       	add	r9,r8
      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
8000f65e:	2f 8b       	sub	r11,-8
8000f660:	40 1e       	lddsp	lr,sp[0x4]
8000f662:	9c 0c       	ld.sh	r12,lr[0x0]
8000f664:	18 0b       	add	r11,r12
      /* Limit the error using transfer function set by init_error_limit.
       * See comments with init_error_limit for rationale.
       */
      cur0 = error_limit[cur0];
8000f666:	a5 4a       	asr	r10,0x4
8000f668:	40 4c       	lddsp	r12,sp[0x10]
8000f66a:	f8 0a 03 2a 	ld.w	r10,r12[r10<<0x2]
      cur1 = error_limit[cur1];
8000f66e:	a5 49       	asr	r9,0x4
8000f670:	f8 09 03 29 	ld.w	r9,r12[r9<<0x2]
      cur2 = error_limit[cur2];
8000f674:	a5 4b       	asr	r11,0x4
8000f676:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
       * this sets the required size of the range_limit array.
       */
      cur0 += GETJSAMPLE(inptr[0]);
      cur1 += GETJSAMPLE(inptr[1]);
      cur2 += GETJSAMPLE(inptr[2]);
      cur0 = GETJSAMPLE(range_limit[cur0]);
8000f67a:	0f 8b       	ld.ub	r11,r7[0x0]
8000f67c:	40 55       	lddsp	r5,sp[0x14]
8000f67e:	ea 0a 00 0a 	add	r10,r5,r10
8000f682:	f4 0b 07 02 	ld.ub	r2,r10[r11]
      cur1 = GETJSAMPLE(range_limit[cur1]);
8000f686:	0f 9a       	ld.ub	r10,r7[0x1]
8000f688:	ea 09 00 09 	add	r9,r5,r9
8000f68c:	f2 0a 07 01 	ld.ub	r1,r9[r10]
      cur2 = GETJSAMPLE(range_limit[cur2]);
8000f690:	0f a9       	ld.ub	r9,r7[0x2]
8000f692:	ea 08 00 08 	add	r8,r5,r8
8000f696:	f0 09 07 00 	ld.ub	r0,r8[r9]
      /* Index into the cache with adjusted pixel value */
      cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
8000f69a:	e4 0b 14 03 	asr	r11,r2,0x3
8000f69e:	e2 0a 14 02 	asr	r10,r1,0x2
8000f6a2:	e0 09 14 03 	asr	r9,r0,0x3
8000f6a6:	f4 05 15 05 	lsl	r5,r10,0x5
8000f6aa:	12 05       	add	r5,r9
8000f6ac:	41 4e       	lddsp	lr,sp[0x50]
8000f6ae:	fc 0b 03 28 	ld.w	r8,lr[r11<<0x2]
8000f6b2:	f0 05 00 15 	add	r5,r8,r5<<0x1
      /* If we have not seen this color before, find nearest colormap */
      /* entry and update the cache */
      if (*cachep == 0)
8000f6b6:	8a 08       	ld.sh	r8,r5[0x0]
8000f6b8:	30 0c       	mov	r12,0
8000f6ba:	f8 08 19 00 	cp.h	r8,r12
8000f6be:	c0 41       	brne	8000f6c6 <pass2_fs_dither+0x172>
	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
8000f6c0:	41 7c       	lddsp	r12,sp[0x5c]
8000f6c2:	f0 1f 00 3b 	mcall	8000f7ac <pass2_fs_dither+0x258>
      /* Now emit the colormap index for this cell */
      { register int pixcode = *cachep - 1;
8000f6c6:	8a 88       	ld.uh	r8,r5[0x0]
8000f6c8:	20 18       	sub	r8,1
	*outptr = (JSAMPLE) pixcode;
8000f6ca:	40 3b       	lddsp	r11,sp[0xc]
8000f6cc:	b6 88       	st.b	r11[0x0],r8
	/* Compute representation error for this pixel */
	cur0 -= GETJSAMPLE(colormap0[pixcode]);
8000f6ce:	41 2a       	lddsp	r10,sp[0x48]
8000f6d0:	f4 08 07 09 	ld.ub	r9,r10[r8]
8000f6d4:	12 12       	sub	r2,r9
	cur1 -= GETJSAMPLE(colormap1[pixcode]);
8000f6d6:	41 15       	lddsp	r5,sp[0x44]
8000f6d8:	ea 08 07 09 	ld.ub	r9,r5[r8]
8000f6dc:	12 11       	sub	r1,r9
	cur2 -= GETJSAMPLE(colormap2[pixcode]);
8000f6de:	41 0e       	lddsp	lr,sp[0x40]
8000f6e0:	fc 08 07 08 	ld.ub	r8,lr[r8]
8000f6e4:	10 10       	sub	r0,r8
       * next-line error sums left by 1 column.
       */
      { register LOCFSERROR bnexterr, delta;

	bnexterr = cur0;	/* Process component 0 */
	delta = cur0 * 2;
8000f6e6:	e4 0a 15 01 	lsl	r10,r2,0x1
	cur0 += delta;		/* form error * 3 */
8000f6ea:	f4 02 00 0e 	add	lr,r10,r2
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
8000f6ee:	40 9c       	lddsp	r12,sp[0x24]
8000f6f0:	fc 0c 00 08 	add	r8,lr,r12
8000f6f4:	40 6b       	lddsp	r11,sp[0x18]
8000f6f6:	b6 08       	st.h	r11[0x0],r8
	cur0 += delta;		/* form error * 5 */
8000f6f8:	14 0e       	add	lr,r10
8000f6fa:	50 6e       	stdsp	sp[0x18],lr
	bpreverr0 = belowerr0 + cur0;
8000f6fc:	40 c9       	lddsp	r9,sp[0x30]
8000f6fe:	12 0e       	add	lr,r9
8000f700:	50 9e       	stdsp	sp[0x24],lr
	belowerr0 = bnexterr;
	cur0 += delta;		/* form error * 7 */
	bnexterr = cur1;	/* Process component 1 */
	delta = cur1 * 2;
8000f702:	e2 09 15 01 	lsl	r9,r1,0x1
	cur1 += delta;		/* form error * 3 */
8000f706:	f2 01 00 0c 	add	r12,r9,r1
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
8000f70a:	40 85       	lddsp	r5,sp[0x20]
8000f70c:	f8 05 00 08 	add	r8,r12,r5
8000f710:	40 ee       	lddsp	lr,sp[0x38]
8000f712:	fc 06 0a 08 	st.h	lr[r6],r8
	cur1 += delta;		/* form error * 5 */
8000f716:	12 0c       	add	r12,r9
	bpreverr1 = belowerr1 + cur1;
8000f718:	40 bb       	lddsp	r11,sp[0x2c]
8000f71a:	f8 0b 00 0b 	add	r11,r12,r11
8000f71e:	50 8b       	stdsp	sp[0x20],r11
	belowerr1 = bnexterr;
	cur1 += delta;		/* form error * 7 */
	bnexterr = cur2;	/* Process component 2 */
	delta = cur2 * 2;
8000f720:	e0 08 15 01 	lsl	r8,r0,0x1
	cur2 += delta;		/* form error * 3 */
8000f724:	f0 00 00 0b 	add	r11,r8,r0
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
8000f728:	40 75       	lddsp	r5,sp[0x1c]
8000f72a:	f6 05 00 05 	add	r5,r11,r5
8000f72e:	ba 15       	st.h	sp[0x2],r5
8000f730:	40 fe       	lddsp	lr,sp[0x3c]
8000f732:	ec 0e 0a 05 	st.h	r6[lr],r5
	cur2 += delta;		/* form error * 5 */
8000f736:	10 0b       	add	r11,r8
	bpreverr2 = belowerr2 + cur2;
8000f738:	40 a5       	lddsp	r5,sp[0x28]
8000f73a:	f6 05 00 05 	add	r5,r11,r5
8000f73e:	50 75       	stdsp	sp[0x1c],r5
    cur0 = cur1 = cur2 = 0;
    /* and no error propagated to row below yet */
    belowerr0 = belowerr1 = belowerr2 = 0;
    bpreverr0 = bpreverr1 = bpreverr2 = 0;

    for (col = width; col > 0; col--) {
8000f740:	40 2e       	lddsp	lr,sp[0x8]
8000f742:	20 1e       	sub	lr,1
8000f744:	50 2e       	stdsp	sp[0x8],lr
8000f746:	08 03       	add	r3,r4
8000f748:	40 15       	lddsp	r5,sp[0x4]
8000f74a:	08 05       	add	r5,r4
8000f74c:	50 15       	stdsp	sp[0x4],r5
8000f74e:	58 0e       	cp.w	lr,0
8000f750:	c1 20       	breq	8000f774 <pass2_fs_dither+0x220>
	cur0 += delta;		/* form error * 3 */
	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
	cur0 += delta;		/* form error * 5 */
	bpreverr0 = belowerr0 + cur0;
	belowerr0 = bnexterr;
	cur0 += delta;		/* form error * 7 */
8000f752:	40 6e       	lddsp	lr,sp[0x18]
8000f754:	fc 0a 00 0a 	add	r10,lr,r10
	cur1 += delta;		/* form error * 3 */
	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
	cur1 += delta;		/* form error * 5 */
	bpreverr1 = belowerr1 + cur1;
	belowerr1 = bnexterr;
	cur1 += delta;		/* form error * 7 */
8000f758:	f8 09 00 09 	add	r9,r12,r9
	cur2 += delta;		/* form error * 3 */
	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
	cur2 += delta;		/* form error * 5 */
	bpreverr2 = belowerr2 + cur2;
	belowerr2 = bnexterr;
	cur2 += delta;		/* form error * 7 */
8000f75c:	10 0b       	add	r11,r8
      }
      /* At this point curN contains the 7/16 error value to be propagated
       * to the next pixel on the current line, and all the errors for the
       * next line have been shifted over.  We are therefore ready to move on.
       */
      inptr += dir3;		/* Advance pixel pointers to next column */
8000f75e:	40 dc       	lddsp	r12,sp[0x34]
8000f760:	18 07       	add	r7,r12
  }
}


METHODDEF(void)
pass2_fs_dither (j_decompress_ptr cinfo,
8000f762:	40 38       	lddsp	r8,sp[0xc]
8000f764:	41 35       	lddsp	r5,sp[0x4c]
8000f766:	0a 08       	add	r8,r5
8000f768:	50 38       	stdsp	sp[0xc],r8
8000f76a:	50 c2       	stdsp	sp[0x30],r2
8000f76c:	50 b1       	stdsp	sp[0x2c],r1
8000f76e:	50 a0       	stdsp	sp[0x28],r0
8000f770:	50 66       	stdsp	sp[0x18],r6
8000f772:	c6 eb       	rjmp	8000f64e <pass2_fs_dither+0xfa>
8000f774:	41 5e       	lddsp	lr,sp[0x54]
8000f776:	41 cc       	lddsp	r12,sp[0x70]
8000f778:	e8 0c 03 4e 	mac	lr,r4,r12
8000f77c:	51 5e       	stdsp	sp[0x54],lr
    }
    /* Post-loop cleanup: we must unload the final error values into the
     * final fserrors[] entry.  Note we need not unload belowerrN because
     * it is for the dummy column before or after the actual array.
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
8000f77e:	40 9a       	lddsp	r10,sp[0x24]
8000f780:	41 5b       	lddsp	r11,sp[0x54]
8000f782:	b6 0a       	st.h	r11[0x0],r10
    errorptr[1] = (FSERROR) bpreverr1;
8000f784:	40 89       	lddsp	r9,sp[0x20]
8000f786:	b6 19       	st.h	r11[0x2],r9
    errorptr[2] = (FSERROR) bpreverr2;
8000f788:	40 78       	lddsp	r8,sp[0x1c]
8000f78a:	b6 28       	st.h	r11[0x4],r8
  JSAMPROW colormap0 = cinfo->colormap[0];
  JSAMPROW colormap1 = cinfo->colormap[1];
  JSAMPROW colormap2 = cinfo->colormap[2];
  SHIFT_TEMPS

  for (row = 0; row < num_rows; row++) {
8000f78c:	41 b5       	lddsp	r5,sp[0x6c]
8000f78e:	2f f5       	sub	r5,-1
8000f790:	51 b5       	stdsp	sp[0x6c],r5
8000f792:	41 ae       	lddsp	lr,sp[0x68]
8000f794:	2f ce       	sub	lr,-4
8000f796:	51 ae       	stdsp	sp[0x68],lr
8000f798:	41 9c       	lddsp	r12,sp[0x64]
8000f79a:	2f cc       	sub	r12,-4
8000f79c:	51 9c       	stdsp	sp[0x64],r12
8000f79e:	41 db       	lddsp	r11,sp[0x74]
8000f7a0:	0a 3b       	cp.w	r11,r5
8000f7a2:	fe 99 ff 0c 	brgt	8000f5ba <pass2_fs_dither+0x66>
     */
    errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
    errorptr[1] = (FSERROR) bpreverr1;
    errorptr[2] = (FSERROR) bpreverr2;
  }
}
8000f7a6:	2d ed       	sub	sp,-136
8000f7a8:	d8 32       	popm	r0-r7,pc
8000f7aa:	00 00       	add	r0,r0
8000f7ac:	80 00       	ld.sh	r0,r0[0x0]
8000f7ae:	f1 ae eb cd 	ldc0.w	cr11,lr[0x3b34]

8000f7b0 <init_error_limit>:
 */

LOCAL(void)
init_error_limit (j_decompress_ptr cinfo)
/* Allocate and fill in the error_limiter table */
{
8000f7b0:	eb cd 40 80 	pushm	r7,lr
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000f7b4:	f8 f7 01 cc 	ld.w	r7,r12[460]
  int * table;
  int in, out;

  table = (int *) (*cinfo->mem->alloc_small)
8000f7b8:	78 18       	ld.w	r8,r12[0x4]
8000f7ba:	70 08       	ld.w	r8,r8[0x0]
8000f7bc:	e0 6a 07 fc 	mov	r10,2044
8000f7c0:	30 1b       	mov	r11,1
8000f7c2:	5d 18       	icall	r8
8000f7c4:	18 9e       	mov	lr,r12
    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
8000f7c6:	f8 c9 fc 04 	sub	r9,r12,-1020
  cquantize->error_limiter = table;
8000f7ca:	8f a9       	st.w	r7[0x28],r9
8000f7cc:	12 9a       	mov	r10,r9
8000f7ce:	30 08       	mov	r8,0

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++) {
    table[in] = out; table[-in] = -out;
8000f7d0:	14 a8       	st.w	r10++,r8
8000f7d2:	f0 0b 11 00 	rsub	r11,r8,0
8000f7d6:	93 0b       	st.w	r9[0x0],r11
  cquantize->error_limiter = table;

#define STEPSIZE ((MAXJSAMPLE+1)/16)
  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++) {
8000f7d8:	2f f8       	sub	r8,-1
8000f7da:	20 49       	sub	r9,4
8000f7dc:	59 08       	cp.w	r8,16
8000f7de:	cf 91       	brne	8000f7d0 <init_error_limit+0x20>
8000f7e0:	fc cb fb c4 	sub	r11,lr,-1084
8000f7e4:	fc ca fc 44 	sub	r10,lr,-956
8000f7e8:	31 09       	mov	r9,16
    table[in] = out; table[-in] = -out;
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
    table[in] = out; table[-in] = -out;
8000f7ea:	16 a9       	st.w	r11++,r9
8000f7ec:	f2 07 11 00 	rsub	r7,r9,0
8000f7f0:	95 07       	st.w	r10[0x0],r7
  out = 0;
  for (in = 0; in < STEPSIZE; in++, out++) {
    table[in] = out; table[-in] = -out;
  }
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
8000f7f2:	2f f8       	sub	r8,-1
8000f7f4:	10 97       	mov	r7,r8
8000f7f6:	ec 17 00 01 	eorl	r7,0x1
8000f7fa:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
8000f7fe:	0e 09       	add	r9,r7
8000f800:	20 4a       	sub	r10,4
8000f802:	e0 48 00 30 	cp.w	r8,48
8000f806:	cf 21       	brne	8000f7ea <init_error_limit+0x3a>
8000f808:	fc ca fb 44 	sub	r10,lr,-1212
8000f80c:	fc c8 fc c4 	sub	r8,lr,-828
 * well, but the smoother transfer function used below is even better.  Thanks
 * to Aaron Giles for this idea.
 */

LOCAL(void)
init_error_limit (j_decompress_ptr cinfo)
8000f810:	f8 cc f8 04 	sub	r12,r12,-2044
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
    table[in] = out; table[-in] = -out;
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
    table[in] = out; table[-in] = -out;
8000f814:	f2 0b 11 00 	rsub	r11,r9,0
8000f818:	14 a9       	st.w	r10++,r9
8000f81a:	91 0b       	st.w	r8[0x0],r11
8000f81c:	20 48       	sub	r8,4
  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
  for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
    table[in] = out; table[-in] = -out;
  }
  /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
  for (; in <= MAXJSAMPLE; in++) {
8000f81e:	18 3a       	cp.w	r10,r12
8000f820:	cf c1       	brne	8000f818 <init_error_limit+0x68>
    table[in] = out; table[-in] = -out;
  }
#undef STEPSIZE
}
8000f822:	e3 cd 80 80 	ldm	sp++,r7,pc
8000f826:	d7 03       	nop

8000f828 <finish_pass1>:
 * Finish up at the end of each pass.
 */

METHODDEF(void)
finish_pass1 (j_decompress_ptr cinfo)
{
8000f828:	d4 31       	pushm	r0-r7,lr
8000f82a:	21 0d       	sub	sp,64
8000f82c:	50 4c       	stdsp	sp[0x10],r12
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000f82e:	f8 fa 01 cc 	ld.w	r10,r12[460]
8000f832:	50 ea       	stdsp	sp[0x38],r10

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
8000f834:	74 48       	ld.w	r8,r10[0x10]
8000f836:	f9 48 00 88 	st.w	r12[136],r8
  select_colors(cinfo, cquantize->desired);
8000f83a:	74 54       	ld.w	r4,r10[0x14]
  boxptr boxlist;
  int numboxes;
  int i;

  /* Allocate workspace for box list */
  boxlist = (boxptr) (*cinfo->mem->alloc_small)
8000f83c:	40 49       	lddsp	r9,sp[0x10]
8000f83e:	50 f9       	stdsp	sp[0x3c],r9
8000f840:	72 18       	ld.w	r8,r9[0x4]
8000f842:	70 08       	ld.w	r8,r8[0x0]
8000f844:	e8 0a 15 05 	lsl	r10,r4,0x5
8000f848:	30 1b       	mov	r11,1
8000f84a:	5d 18       	icall	r8
8000f84c:	18 96       	mov	r6,r12
8000f84e:	18 93       	mov	r3,r12
    ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
  /* Initialize one box containing whole space */
  numboxes = 1;
  boxlist[0].c0min = 0;
8000f850:	30 08       	mov	r8,0
8000f852:	99 08       	st.w	r12[0x0],r8
  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
8000f854:	31 f9       	mov	r9,31
8000f856:	99 19       	st.w	r12[0x4],r9
  boxlist[0].c1min = 0;
8000f858:	99 28       	st.w	r12[0x8],r8
  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
8000f85a:	33 fa       	mov	r10,63
8000f85c:	99 3a       	st.w	r12[0xc],r10
  boxlist[0].c2min = 0;
8000f85e:	99 48       	st.w	r12[0x10],r8
  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
8000f860:	99 59       	st.w	r12[0x14],r9
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
8000f862:	18 9b       	mov	r11,r12
8000f864:	40 4c       	lddsp	r12,sp[0x10]
8000f866:	f0 1f 00 a5 	mcall	8000faf8 <finish_pass1+0x2d0>
{
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
8000f86a:	58 14       	cp.w	r4,1
8000f86c:	e0 89 00 09 	brgt	8000f87e <finish_pass1+0x56>
8000f870:	30 18       	mov	r8,1
8000f872:	50 a8       	stdsp	sp[0x28],r8
8000f874:	50 76       	stdsp	sp[0x1c],r6
8000f876:	30 07       	mov	r7,0
8000f878:	50 c7       	stdsp	sp[0x30],r7
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
	if ((count = *histp++) != 0) {
	  total += count;
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
8000f87a:	50 b7       	stdsp	sp[0x2c],r7
8000f87c:	ca 18       	rjmp	8000f9be <finish_pass1+0x196>
{
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
8000f87e:	ec c7 ff e0 	sub	r7,r6,-32
8000f882:	30 10       	mov	r0,1
8000f884:	50 a0       	stdsp	sp[0x28],r0
  register boxptr boxp;
  register int i;
  register long maxc = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
8000f886:	30 05       	mov	r5,0
8000f888:	50 26       	stdsp	sp[0x8],r6
8000f88a:	0a 93       	mov	r3,r5
    cmax = c1; n = 1;
    if (c0 > cmax) { cmax = c0; n = 0; }
    if (c2 > cmax) { n = 2; }
#else
    cmax = c1; n = 1;
    if (c2 > cmax) { cmax = c2; n = 2; }
8000f88c:	0c 92       	mov	r2,r6
8000f88e:	00 96       	mov	r6,r0

  while (numboxes < desired_colors) {
    /* Select box to split.
     * Current algorithm: by population for first half, then by volume.
     */
    if (numboxes*2 <= desired_colors) {
8000f890:	ec 08 15 01 	lsl	r8,r6,0x1
8000f894:	10 34       	cp.w	r4,r8
8000f896:	c0 54       	brge	8000f8a0 <finish_pass1+0x78>
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
8000f898:	58 06       	cp.w	r6,0
8000f89a:	e0 89 00 1d 	brgt	8000f8d4 <finish_pass1+0xac>
8000f89e:	c2 b8       	rjmp	8000f8f4 <finish_pass1+0xcc>
  register boxptr boxp;
  register int i;
  register long maxc = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
8000f8a0:	58 06       	cp.w	r6,0
8000f8a2:	e0 8a 00 17 	brle	8000f8d0 <finish_pass1+0xa8>
8000f8a6:	40 28       	lddsp	r8,sp[0x8]
8000f8a8:	0a 9b       	mov	r11,r5
8000f8aa:	06 9a       	mov	r10,r3
8000f8ac:	06 9c       	mov	r12,r3
    if (boxp->colorcount > maxc && boxp->volume > 0) {
8000f8ae:	70 79       	ld.w	r9,r8[0x1c]
8000f8b0:	18 39       	cp.w	r9,r12
8000f8b2:	e0 8a 00 08 	brle	8000f8c2 <finish_pass1+0x9a>
8000f8b6:	70 6e       	ld.w	lr,r8[0x18]
8000f8b8:	58 0e       	cp.w	lr,0
8000f8ba:	e0 8a 00 04 	brle	8000f8c2 <finish_pass1+0x9a>
8000f8be:	10 9b       	mov	r11,r8
8000f8c0:	c0 28       	rjmp	8000f8c4 <finish_pass1+0x9c>
8000f8c2:	18 99       	mov	r9,r12
  register boxptr boxp;
  register int i;
  register long maxc = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
8000f8c4:	2f fa       	sub	r10,-1
8000f8c6:	0c 3a       	cp.w	r10,r6
8000f8c8:	c1 70       	breq	8000f8f6 <finish_pass1+0xce>
8000f8ca:	2e 08       	sub	r8,-32
8000f8cc:	12 9c       	mov	r12,r9
8000f8ce:	cf 0b       	rjmp	8000f8ae <finish_pass1+0x86>
8000f8d0:	0a 9b       	mov	r11,r5
8000f8d2:	c1 28       	rjmp	8000f8f6 <finish_pass1+0xce>
8000f8d4:	40 28       	lddsp	r8,sp[0x8]
8000f8d6:	0a 9b       	mov	r11,r5
8000f8d8:	06 9a       	mov	r10,r3
8000f8da:	06 9c       	mov	r12,r3
  register int i;
  register INT32 maxv = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
    if (boxp->volume > maxv) {
8000f8dc:	70 69       	ld.w	r9,r8[0x18]
8000f8de:	18 39       	cp.w	r9,r12
8000f8e0:	f0 0b 17 90 	movgt	r11,r8
8000f8e4:	f8 09 17 a0 	movle	r9,r12
  register boxptr boxp;
  register int i;
  register INT32 maxv = 0;
  boxptr which = NULL;

  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {
8000f8e8:	2f fa       	sub	r10,-1
8000f8ea:	0c 3a       	cp.w	r10,r6
8000f8ec:	c0 50       	breq	8000f8f6 <finish_pass1+0xce>
8000f8ee:	2e 08       	sub	r8,-32
8000f8f0:	12 9c       	mov	r12,r9
8000f8f2:	cf 5b       	rjmp	8000f8dc <finish_pass1+0xb4>
8000f8f4:	0a 9b       	mov	r11,r5
    if (numboxes*2 <= desired_colors) {
      b1 = find_biggest_color_pop(boxlist, numboxes);
    } else {
      b1 = find_biggest_volume(boxlist, numboxes);
    }
    if (b1 == NULL)		/* no splittable boxes left! */
8000f8f6:	58 0b       	cp.w	r11,0
8000f8f8:	c5 c0       	breq	8000f9b0 <finish_pass1+0x188>
8000f8fa:	50 37       	stdsp	sp[0xc],r7
      break;
    b2 = &boxlist[numboxes];	/* where new box will go */
    /* Copy the color bounds to the new box. */
    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
8000f8fc:	76 18       	ld.w	r8,r11[0x4]
8000f8fe:	8f 18       	st.w	r7[0x4],r8
8000f900:	76 38       	ld.w	r8,r11[0xc]
8000f902:	8f 38       	st.w	r7[0xc],r8
8000f904:	76 58       	ld.w	r8,r11[0x14]
8000f906:	8f 58       	st.w	r7[0x14],r8
    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
8000f908:	76 08       	ld.w	r8,r11[0x0]
8000f90a:	8f 08       	st.w	r7[0x0],r8
8000f90c:	76 28       	ld.w	r8,r11[0x8]
8000f90e:	8f 28       	st.w	r7[0x8],r8
8000f910:	76 48       	ld.w	r8,r11[0x10]
8000f912:	8f 48       	st.w	r7[0x10],r8
    /* Choose which axis to split the box on.
     * Current algorithm: longest scaled axis.
     * See notes in update_box about scaling distances.
     */
    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
8000f914:	76 1e       	ld.w	lr,r11[0x4]
8000f916:	76 01       	ld.w	r1,r11[0x0]
    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
8000f918:	76 3a       	ld.w	r10,r11[0xc]
8000f91a:	76 2c       	ld.w	r12,r11[0x8]
8000f91c:	f4 0c 01 08 	sub	r8,r10,r12
8000f920:	f0 09 15 03 	lsl	r9,r8,0x3
8000f924:	f2 08 00 29 	add	r9,r9,r8<<0x2
    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
8000f928:	76 58       	ld.w	r8,r11[0x14]
8000f92a:	50 18       	stdsp	sp[0x4],r8
8000f92c:	76 40       	ld.w	r0,r11[0x10]
8000f92e:	50 00       	stdsp	sp[0x0],r0
8000f930:	00 18       	sub	r8,r0
8000f932:	a5 68       	lsl	r8,0x4
    cmax = c1; n = 1;
    if (c0 > cmax) { cmax = c0; n = 0; }
    if (c2 > cmax) { n = 2; }
#else
    cmax = c1; n = 1;
    if (c2 > cmax) { cmax = c2; n = 2; }
8000f934:	10 39       	cp.w	r9,r8
8000f936:	f0 09 17 50 	movlt	r9,r8
8000f93a:	f9 b8 05 02 	movlt	r8,2
8000f93e:	f9 b8 04 01 	movge	r8,1
    if (c0 > cmax) { n = 0; }
8000f942:	fc 01 01 00 	sub	r0,lr,r1
8000f946:	a3 70       	lsl	r0,0x3
8000f948:	12 30       	cp.w	r0,r9
8000f94a:	e0 89 00 08 	brgt	8000f95a <finish_pass1+0x132>
     * Current algorithm: split at halfway point.
     * (Since the box has been shrunk to minimum volume,
     * any split will produce two nonempty subboxes.)
     * Note that lb value is max for lower box, so must be < old max.
     */
    switch (n) {
8000f94e:	58 18       	cp.w	r8,1
8000f950:	c0 f0       	breq	8000f96e <finish_pass1+0x146>
8000f952:	58 28       	cp.w	r8,2
8000f954:	c1 70       	breq	8000f982 <finish_pass1+0x15a>
8000f956:	58 08       	cp.w	r8,0
8000f958:	c2 01       	brne	8000f998 <finish_pass1+0x170>
    case 0:
      lb = (b1->c0max + b1->c0min) / 2;
8000f95a:	e2 0e 00 0e 	add	lr,r1,lr
8000f95e:	fc 08 16 1f 	lsr	r8,lr,0x1f
8000f962:	1c 08       	add	r8,lr
8000f964:	a1 58       	asr	r8,0x1
      b1->c0max = lb;
8000f966:	97 18       	st.w	r11[0x4],r8
      b2->c0min = lb+1;
8000f968:	2f f8       	sub	r8,-1
8000f96a:	8f 08       	st.w	r7[0x0],r8
8000f96c:	c1 68       	rjmp	8000f998 <finish_pass1+0x170>
      break;
    case 1:
      lb = (b1->c1max + b1->c1min) / 2;
8000f96e:	f8 0a 00 0a 	add	r10,r12,r10
8000f972:	f4 08 16 1f 	lsr	r8,r10,0x1f
8000f976:	14 08       	add	r8,r10
8000f978:	a1 58       	asr	r8,0x1
      b1->c1max = lb;
8000f97a:	97 38       	st.w	r11[0xc],r8
      b2->c1min = lb+1;
8000f97c:	2f f8       	sub	r8,-1
8000f97e:	8f 28       	st.w	r7[0x8],r8
8000f980:	c0 c8       	rjmp	8000f998 <finish_pass1+0x170>
      break;
    case 2:
      lb = (b1->c2max + b1->c2min) / 2;
8000f982:	40 08       	lddsp	r8,sp[0x0]
8000f984:	40 1a       	lddsp	r10,sp[0x4]
8000f986:	14 08       	add	r8,r10
8000f988:	f0 09 16 1f 	lsr	r9,r8,0x1f
8000f98c:	f2 08 00 08 	add	r8,r9,r8
8000f990:	a1 58       	asr	r8,0x1
      b1->c2max = lb;
8000f992:	97 58       	st.w	r11[0x14],r8
      b2->c2min = lb+1;
8000f994:	2f f8       	sub	r8,-1
8000f996:	8f 48       	st.w	r7[0x10],r8
      break;
    }
    /* Update stats for boxes */
    update_box(cinfo, b1);
8000f998:	40 4c       	lddsp	r12,sp[0x10]
8000f99a:	f0 1f 00 58 	mcall	8000faf8 <finish_pass1+0x2d0>
    update_box(cinfo, b2);
8000f99e:	40 3b       	lddsp	r11,sp[0xc]
8000f9a0:	40 4c       	lddsp	r12,sp[0x10]
8000f9a2:	f0 1f 00 56 	mcall	8000faf8 <finish_pass1+0x2d0>
    numboxes++;
8000f9a6:	2f f6       	sub	r6,-1
8000f9a8:	2e 07       	sub	r7,-32
{
  int n,lb;
  int c0,c1,c2,cmax;
  register boxptr b1,b2;

  while (numboxes < desired_colors) {
8000f9aa:	0c 34       	cp.w	r4,r6
8000f9ac:	fe 99 ff 72 	brgt	8000f890 <finish_pass1+0x68>
8000f9b0:	50 a6       	stdsp	sp[0x28],r6
8000f9b2:	04 96       	mov	r6,r2
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
  /* Perform median-cut to produce final box list */
  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
8000f9b4:	40 a9       	lddsp	r9,sp[0x28]
8000f9b6:	58 09       	cp.w	r9,0
8000f9b8:	fe 99 ff 5e 	brgt	8000f874 <finish_pass1+0x4c>
8000f9bc:	c8 a8       	rjmp	8000fad0 <finish_pass1+0x2a8>
8000f9be:	40 c8       	lddsp	r8,sp[0x30]
8000f9c0:	50 d8       	stdsp	sp[0x34],r8
/* Compute representative color for a box, put it in colormap[icolor] */
{
  /* Current algorithm: mean weighted by pixels (not colors) */
  /* Note it is important to get the rounding correct! */
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
  hist3d histogram = cquantize->histogram;
8000f9c2:	40 47       	lddsp	r7,sp[0x10]
8000f9c4:	ee f8 01 cc 	ld.w	r8,r7[460]
8000f9c8:	70 68       	ld.w	r8,r8[0x18]
  long total = 0;
  long c0total = 0;
  long c1total = 0;
  long c2total = 0;

  c0min = boxp->c0min;  c0max = boxp->c0max;
8000f9ca:	40 76       	lddsp	r6,sp[0x1c]
8000f9cc:	6c 06       	ld.w	r6,r6[0x0]
8000f9ce:	50 26       	stdsp	sp[0x8],r6
8000f9d0:	40 70       	lddsp	r0,sp[0x1c]
8000f9d2:	60 10       	ld.w	r0,r0[0x4]
8000f9d4:	50 60       	stdsp	sp[0x18],r0
  c1min = boxp->c1min;  c1max = boxp->c1max;
8000f9d6:	40 7a       	lddsp	r10,sp[0x1c]
8000f9d8:	74 2a       	ld.w	r10,r10[0x8]
8000f9da:	50 5a       	stdsp	sp[0x14],r10
8000f9dc:	40 79       	lddsp	r9,sp[0x1c]
8000f9de:	72 30       	ld.w	r0,r9[0xc]
  c2min = boxp->c2min;  c2max = boxp->c2max;
8000f9e0:	72 47       	ld.w	r7,r9[0x10]
8000f9e2:	50 07       	stdsp	sp[0x0],r7
8000f9e4:	72 5b       	ld.w	r11,r9[0x14]

  for (c0 = c0min; c0 <= c0max; c0++)
8000f9e6:	40 6a       	lddsp	r10,sp[0x18]
8000f9e8:	14 36       	cp.w	r6,r10
8000f9ea:	e0 89 00 46 	brgt	8000fa76 <finish_pass1+0x24e>
8000f9ee:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000f9f2:	50 38       	stdsp	sp[0xc],r8
8000f9f4:	30 0e       	mov	lr,0
8000f9f6:	40 b7       	lddsp	r7,sp[0x2c]
8000f9f8:	0e 96       	mov	r6,r7
8000f9fa:	0e 9c       	mov	r12,r7
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
	if ((count = *histp++) != 0) {
	  total += count;
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
8000f9fc:	40 58       	lddsp	r8,sp[0x14]
8000f9fe:	a5 78       	lsl	r8,0x5
8000fa00:	40 09       	lddsp	r9,sp[0x0]
8000fa02:	12 08       	add	r8,r9
8000fa04:	a1 78       	lsl	r8,0x1
8000fa06:	50 88       	stdsp	sp[0x20],r8
8000fa08:	40 58       	lddsp	r8,sp[0x14]
8000fa0a:	50 98       	stdsp	sp[0x24],r8
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
8000fa0c:	50 19       	stdsp	sp[0x4],r9
8000fa0e:	c2 78       	rjmp	8000fa5c <finish_pass1+0x234>
  c2min = boxp->c2min;  c2max = boxp->c2max;

  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
8000fa10:	40 0a       	lddsp	r10,sp[0x0]
8000fa12:	16 3a       	cp.w	r10,r11
8000fa14:	e0 89 00 17 	brgt	8000fa42 <finish_pass1+0x21a>
8000fa18:	02 9a       	mov	r10,r1
	if ((count = *histp++) != 0) {
	  total += count;
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
8000fa1a:	e4 04 15 02 	lsl	r4,r2,0x2
8000fa1e:	2f e4       	sub	r4,-2
8000fa20:	40 19       	lddsp	r9,sp[0x4]

  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
	if ((count = *histp++) != 0) {
8000fa22:	15 28       	ld.uh	r8,r10++
8000fa24:	58 08       	cp.w	r8,0
8000fa26:	c0 b0       	breq	8000fa3c <finish_pass1+0x214>
	  total += count;
8000fa28:	10 0c       	add	r12,r8
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
8000fa2a:	e6 08 03 46 	mac	r6,r3,r8
	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
8000fa2e:	e8 08 03 47 	mac	r7,r4,r8
	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
8000fa32:	f2 05 15 03 	lsl	r5,r9,0x3
8000fa36:	2f c5       	sub	r5,-4
8000fa38:	ea 08 03 4e 	mac	lr,r5,r8
  c2min = boxp->c2min;  c2max = boxp->c2max;

  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
8000fa3c:	2f f9       	sub	r9,-1
8000fa3e:	12 3b       	cp.w	r11,r9
8000fa40:	cf 14       	brge	8000fa22 <finish_pass1+0x1fa>
  c0min = boxp->c0min;  c0max = boxp->c0max;
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;

  for (c0 = c0min; c0 <= c0max; c0++)
    for (c1 = c1min; c1 <= c1max; c1++) {
8000fa42:	2f f2       	sub	r2,-1
8000fa44:	2c 01       	sub	r1,-64
8000fa46:	04 30       	cp.w	r0,r2
8000fa48:	ce 44       	brge	8000fa10 <finish_pass1+0x1e8>

  c0min = boxp->c0min;  c0max = boxp->c0max;
  c1min = boxp->c1min;  c1max = boxp->c1max;
  c2min = boxp->c2min;  c2max = boxp->c2max;

  for (c0 = c0min; c0 <= c0max; c0++)
8000fa4a:	40 29       	lddsp	r9,sp[0x8]
8000fa4c:	2f f9       	sub	r9,-1
8000fa4e:	50 29       	stdsp	sp[0x8],r9
8000fa50:	40 38       	lddsp	r8,sp[0xc]
8000fa52:	2f c8       	sub	r8,-4
8000fa54:	50 38       	stdsp	sp[0xc],r8
8000fa56:	40 6a       	lddsp	r10,sp[0x18]
8000fa58:	12 3a       	cp.w	r10,r9
8000fa5a:	c1 25       	brlt	8000fa7e <finish_pass1+0x256>
    for (c1 = c1min; c1 <= c1max; c1++) {
8000fa5c:	40 59       	lddsp	r9,sp[0x14]
8000fa5e:	00 39       	cp.w	r9,r0
8000fa60:	fe 99 ff f5 	brgt	8000fa4a <finish_pass1+0x222>
      histp = & histogram[c0][c1][c2min];
      for (c2 = c2min; c2 <= c2max; c2++) {
	if ((count = *histp++) != 0) {
	  total += count;
	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
8000fa64:	40 23       	lddsp	r3,sp[0x8]
8000fa66:	a3 73       	lsl	r3,0x3
8000fa68:	2f c3       	sub	r3,-4
8000fa6a:	40 38       	lddsp	r8,sp[0xc]
8000fa6c:	70 01       	ld.w	r1,r8[0x0]
8000fa6e:	40 8a       	lddsp	r10,sp[0x20]
8000fa70:	14 01       	add	r1,r10
8000fa72:	40 92       	lddsp	r2,sp[0x24]
8000fa74:	cc eb       	rjmp	8000fa10 <finish_pass1+0x1e8>
8000fa76:	30 0e       	mov	lr,0
8000fa78:	40 b7       	lddsp	r7,sp[0x2c]
8000fa7a:	0e 96       	mov	r6,r7
8000fa7c:	0e 9c       	mov	r12,r7
	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
	}
      }
    }

  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
8000fa7e:	f8 08 14 01 	asr	r8,r12,0x1
8000fa82:	40 40       	lddsp	r0,sp[0x10]
8000fa84:	e0 f9 00 88 	ld.w	r9,r0[136]
8000fa88:	72 09       	ld.w	r9,r9[0x0]
8000fa8a:	f0 06 00 0b 	add	r11,r8,r6
8000fa8e:	f6 0c 0c 0a 	divs	r10,r11,r12
8000fa92:	40 d6       	lddsp	r6,sp[0x34]
8000fa94:	f2 06 0b 0a 	st.b	r9[r6],r10
  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
8000fa98:	e0 f9 00 88 	ld.w	r9,r0[136]
8000fa9c:	72 19       	ld.w	r9,r9[0x4]
8000fa9e:	f0 07 00 0b 	add	r11,r8,r7
8000faa2:	f6 0c 0c 0a 	divs	r10,r11,r12
8000faa6:	f2 06 0b 0a 	st.b	r9[r6],r10
  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
8000faaa:	e0 f9 00 88 	ld.w	r9,r0[136]
8000faae:	72 29       	ld.w	r9,r9[0x8]
8000fab0:	f0 0e 00 0b 	add	r11,r8,lr
8000fab4:	f6 0c 0c 0a 	divs	r10,r11,r12
8000fab8:	f2 06 0b 0a 	st.b	r9[r6],r10
  /* Shrink it to actually-used volume and set its statistics */
  update_box(cinfo, & boxlist[0]);
  /* Perform median-cut to produce final box list */
  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
  /* Compute the representative color for each box, fill colormap */
  for (i = 0; i < numboxes; i++)
8000fabc:	40 c0       	lddsp	r0,sp[0x30]
8000fabe:	2f f0       	sub	r0,-1
8000fac0:	50 c0       	stdsp	sp[0x30],r0
8000fac2:	40 7a       	lddsp	r10,sp[0x1c]
8000fac4:	2e 0a       	sub	r10,-32
8000fac6:	50 7a       	stdsp	sp[0x1c],r10
8000fac8:	40 a9       	lddsp	r9,sp[0x28]
8000faca:	12 30       	cp.w	r0,r9
8000facc:	fe 95 ff 79 	brlt	8000f9be <finish_pass1+0x196>
    compute_color(cinfo, & boxlist[i], i);
  cinfo->actual_number_of_colors = numboxes;
8000fad0:	40 a7       	lddsp	r7,sp[0x28]
8000fad2:	40 48       	lddsp	r8,sp[0x10]
8000fad4:	f1 47 00 84 	st.w	r8[132],r7
  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
8000fad8:	40 46       	lddsp	r6,sp[0x10]
8000fada:	6c 08       	ld.w	r8,r6[0x0]
8000fadc:	36 09       	mov	r9,96
8000fade:	91 59       	st.w	r8[0x14],r9
8000fae0:	6c 08       	ld.w	r8,r6[0x0]
8000fae2:	91 67       	st.w	r8[0x18],r7
8000fae4:	6c 08       	ld.w	r8,r6[0x0]
8000fae6:	70 18       	ld.w	r8,r8[0x4]
8000fae8:	30 1b       	mov	r11,1
8000faea:	40 fc       	lddsp	r12,sp[0x3c]
8000faec:	5d 18       	icall	r8

  /* Select the representative colors and fill in cinfo->colormap */
  cinfo->colormap = cquantize->sv_colormap;
  select_colors(cinfo, cquantize->desired);
  /* Force next pass to zero the color index table */
  cquantize->needs_zeroed = TRUE;
8000faee:	30 18       	mov	r8,1
8000faf0:	40 e0       	lddsp	r0,sp[0x38]
8000faf2:	81 78       	st.w	r0[0x1c],r8
}
8000faf4:	2f 0d       	sub	sp,-64
8000faf6:	d8 32       	popm	r0-r7,pc
8000faf8:	80 00       	ld.sh	r0,r0[0x0]
8000fafa:	ee 8a 5e fc 	brle	801db8f2 <_data_sdram_lma+0x1bad2a>

8000fafc <finish_pass2>:

METHODDEF(void)
finish_pass2 (j_decompress_ptr cinfo)
{
  /* no work */
}
8000fafc:	5e fc       	retal	r12

8000fafe <new_color_map_2_quant>:
new_color_map_2_quant (j_decompress_ptr cinfo)
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;

  /* Reset the inverse color map */
  cquantize->needs_zeroed = TRUE;
8000fafe:	f8 f8 01 cc 	ld.w	r8,r12[460]
8000fb02:	30 19       	mov	r9,1
8000fb04:	91 79       	st.w	r8[0x1c],r9
}
8000fb06:	5e fc       	retal	r12

8000fb08 <jinit_2pass_quantizer>:
 * Module initialization routine for 2-pass color quantization.
 */

GLOBAL(void)
jinit_2pass_quantizer (j_decompress_ptr cinfo)
{
8000fb08:	eb cd 40 fe 	pushm	r1-r7,lr
8000fb0c:	18 96       	mov	r6,r12
  my_cquantize_ptr cquantize;
  int i;

  cquantize = (my_cquantize_ptr)
8000fb0e:	18 93       	mov	r3,r12
8000fb10:	78 18       	ld.w	r8,r12[0x4]
8000fb12:	70 08       	ld.w	r8,r8[0x0]
8000fb14:	32 ca       	mov	r10,44
8000fb16:	30 1b       	mov	r11,1
8000fb18:	5d 18       	icall	r8
8000fb1a:	18 95       	mov	r5,r12
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_cquantizer));
  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
8000fb1c:	ed 4c 01 cc 	st.w	r6[460],r12
  cquantize->pub.start_pass = start_pass_2_quant;
8000fb20:	4b 88       	lddpc	r8,8000fc00 <jinit_2pass_quantizer+0xf8>
8000fb22:	99 08       	st.w	r12[0x0],r8
  cquantize->pub.new_color_map = new_color_map_2_quant;
8000fb24:	4b 88       	lddpc	r8,8000fc04 <jinit_2pass_quantizer+0xfc>
8000fb26:	99 38       	st.w	r12[0xc],r8
  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
8000fb28:	30 08       	mov	r8,0
8000fb2a:	99 88       	st.w	r12[0x20],r8
  cquantize->error_limiter = NULL;
8000fb2c:	99 a8       	st.w	r12[0x28],r8

  /* Make sure jdmaster didn't give me a case I can't handle */
  if (cinfo->out_color_components != 3)
8000fb2e:	6d e8       	ld.w	r8,r6[0x78]
8000fb30:	58 38       	cp.w	r8,3
8000fb32:	c0 80       	breq	8000fb42 <jinit_2pass_quantizer+0x3a>
    ERREXIT(cinfo, JERR_NOTIMPL);
8000fb34:	6c 08       	ld.w	r8,r6[0x0]
8000fb36:	32 f9       	mov	r9,47
8000fb38:	91 59       	st.w	r8[0x14],r9
8000fb3a:	6c 08       	ld.w	r8,r6[0x0]
8000fb3c:	70 08       	ld.w	r8,r8[0x0]
8000fb3e:	0c 9c       	mov	r12,r6
8000fb40:	5d 18       	icall	r8

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
8000fb42:	6c 18       	ld.w	r8,r6[0x4]
8000fb44:	70 08       	ld.w	r8,r8[0x0]
8000fb46:	e0 6a 00 80 	mov	r10,128
8000fb4a:	30 1b       	mov	r11,1
8000fb4c:	06 9c       	mov	r12,r3
8000fb4e:	5d 18       	icall	r8
8000fb50:	8b 6c       	st.w	r5[0x18],r12
8000fb52:	30 07       	mov	r7,0
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
8000fb54:	e0 62 10 00 	mov	r2,4096
8000fb58:	30 11       	mov	r1,1
8000fb5a:	6a 64       	ld.w	r4,r5[0x18]
8000fb5c:	0e 04       	add	r4,r7
8000fb5e:	6c 18       	ld.w	r8,r6[0x4]
8000fb60:	70 18       	ld.w	r8,r8[0x4]
8000fb62:	04 9a       	mov	r10,r2
8000fb64:	02 9b       	mov	r11,r1
8000fb66:	06 9c       	mov	r12,r3
8000fb68:	5d 18       	icall	r8
8000fb6a:	89 0c       	st.w	r4[0x0],r12
8000fb6c:	2f c7       	sub	r7,-4
    ERREXIT(cinfo, JERR_NOTIMPL);

  /* Allocate the histogram/inverse colormap storage */
  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
    ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
  for (i = 0; i < HIST_C0_ELEMS; i++) {
8000fb6e:	e0 47 00 80 	cp.w	r7,128
8000fb72:	cf 41       	brne	8000fb5a <jinit_2pass_quantizer+0x52>
    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
  }
  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
8000fb74:	30 18       	mov	r8,1
8000fb76:	8b 78       	st.w	r5[0x1c],r8

  /* Allocate storage for the completed colormap, if required.
   * We do this now since it is FAR storage and may affect
   * the memory manager's space calculations.
   */
  if (cinfo->enable_2pass_quant) {
8000fb78:	6d b8       	ld.w	r8,r6[0x6c]
8000fb7a:	58 08       	cp.w	r8,0
8000fb7c:	c2 80       	breq	8000fbcc <jinit_2pass_quantizer+0xc4>
    /* Make sure color count is acceptable */
    int desired = cinfo->desired_number_of_colors;
8000fb7e:	6d 87       	ld.w	r7,r6[0x60]
    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
    if (desired < 8)
8000fb80:	58 77       	cp.w	r7,7
8000fb82:	e0 89 00 0c 	brgt	8000fb9a <jinit_2pass_quantizer+0x92>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
8000fb86:	6c 08       	ld.w	r8,r6[0x0]
8000fb88:	33 89       	mov	r9,56
8000fb8a:	91 59       	st.w	r8[0x14],r9
8000fb8c:	6c 08       	ld.w	r8,r6[0x0]
8000fb8e:	30 89       	mov	r9,8
8000fb90:	91 69       	st.w	r8[0x18],r9
8000fb92:	6c 08       	ld.w	r8,r6[0x0]
8000fb94:	70 08       	ld.w	r8,r8[0x0]
8000fb96:	06 9c       	mov	r12,r3
8000fb98:	5d 18       	icall	r8
    /* Make sure colormap indexes can be represented by JSAMPLEs */
    if (desired > MAXNUMCOLORS)
8000fb9a:	e0 47 01 00 	cp.w	r7,256
8000fb9e:	e0 8a 00 0d 	brle	8000fbb8 <jinit_2pass_quantizer+0xb0>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
8000fba2:	6c 08       	ld.w	r8,r6[0x0]
8000fba4:	33 99       	mov	r9,57
8000fba6:	91 59       	st.w	r8[0x14],r9
8000fba8:	6c 08       	ld.w	r8,r6[0x0]
8000fbaa:	e0 69 01 00 	mov	r9,256
8000fbae:	91 69       	st.w	r8[0x18],r9
8000fbb0:	6c 08       	ld.w	r8,r6[0x0]
8000fbb2:	70 08       	ld.w	r8,r8[0x0]
8000fbb4:	06 9c       	mov	r12,r3
8000fbb6:	5d 18       	icall	r8
    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
8000fbb8:	6c 18       	ld.w	r8,r6[0x4]
8000fbba:	70 28       	ld.w	r8,r8[0x8]
8000fbbc:	30 39       	mov	r9,3
8000fbbe:	0e 9a       	mov	r10,r7
8000fbc0:	30 1b       	mov	r11,1
8000fbc2:	06 9c       	mov	r12,r3
8000fbc4:	5d 18       	icall	r8
8000fbc6:	8b 4c       	st.w	r5[0x10],r12
      ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
    cquantize->desired = desired;
8000fbc8:	8b 57       	st.w	r5[0x14],r7
8000fbca:	c0 38       	rjmp	8000fbd0 <jinit_2pass_quantizer+0xc8>
  } else
    cquantize->sv_colormap = NULL;
8000fbcc:	30 08       	mov	r8,0
8000fbce:	8b 48       	st.w	r5[0x10],r8

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
8000fbd0:	6d 68       	ld.w	r8,r6[0x58]
8000fbd2:	58 08       	cp.w	r8,0
8000fbd4:	c1 30       	breq	8000fbfa <jinit_2pass_quantizer+0xf2>
    cinfo->dither_mode = JDITHER_FS;
8000fbd6:	30 28       	mov	r8,2
8000fbd8:	ed 48 00 58 	st.w	r6[88],r8
   * This isn't really needed until pass 2, but again it is FAR storage.
   * Although we will cope with a later change in dither_mode,
   * we do not promise to honor max_memory_to_use if dither_mode changes.
   */
  if (cinfo->dither_mode == JDITHER_FS) {
    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
8000fbdc:	6c 19       	ld.w	r9,r6[0x4]
8000fbde:	6d c8       	ld.w	r8,r6[0x70]
8000fbe0:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000fbe4:	f0 0a 15 01 	lsl	r10,r8,0x1
8000fbe8:	72 18       	ld.w	r8,r9[0x4]
8000fbea:	2f 4a       	sub	r10,-12
8000fbec:	30 1b       	mov	r11,1
8000fbee:	06 9c       	mov	r12,r3
8000fbf0:	5d 18       	icall	r8
8000fbf2:	8b 8c       	st.w	r5[0x20],r12
      ((j_common_ptr) cinfo, JPOOL_IMAGE,
       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
    /* Might as well create the error-limiting table too. */
    init_error_limit(cinfo);
8000fbf4:	0c 9c       	mov	r12,r6
8000fbf6:	f0 1f 00 05 	mcall	8000fc08 <jinit_2pass_quantizer+0x100>
8000fbfa:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000fbfe:	00 00       	add	r0,r0
8000fc00:	80 00       	ld.sh	r0,r0[0x0]
8000fc02:	fc 0c       	*unknown*
8000fc04:	80 00       	ld.sh	r0,r0[0x0]
8000fc06:	fa fe 80 00 	ld.w	lr,sp[-32768]
8000fc0a:	f7 b0       	*unknown*

8000fc0c <start_pass_2_quant>:
 * Initialize for each processing pass.
 */

METHODDEF(void)
start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
{
8000fc0c:	d4 21       	pushm	r4-r7,lr
8000fc0e:	18 97       	mov	r7,r12
  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
8000fc10:	f8 f4 01 cc 	ld.w	r4,r12[460]
  hist3d histogram = cquantize->histogram;
8000fc14:	68 66       	ld.w	r6,r4[0x18]
  int i;

  /* Only F-S dithering or no dithering is supported. */
  /* If user asks for ordered dither, give him F-S. */
  if (cinfo->dither_mode != JDITHER_NONE)
8000fc16:	79 68       	ld.w	r8,r12[0x58]
    cinfo->dither_mode = JDITHER_FS;
8000fc18:	58 08       	cp.w	r8,0
8000fc1a:	f9 b8 01 02 	movne	r8,2
8000fc1e:	ef f8 1a 16 	st.wne	r7[0x58],r8

  if (is_pre_scan) {
8000fc22:	58 0b       	cp.w	r11,0
8000fc24:	c0 80       	breq	8000fc34 <start_pass_2_quant+0x28>
    /* Set up method pointers */
    cquantize->pub.color_quantize = prescan_quantize;
8000fc26:	4b 18       	lddpc	r8,8000fce8 <start_pass_2_quant+0xdc>
8000fc28:	89 18       	st.w	r4[0x4],r8
    cquantize->pub.finish_pass = finish_pass1;
8000fc2a:	4b 18       	lddpc	r8,8000fcec <start_pass_2_quant+0xe0>
8000fc2c:	89 28       	st.w	r4[0x8],r8
    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
8000fc2e:	30 18       	mov	r8,1
8000fc30:	89 78       	st.w	r4[0x1c],r8
8000fc32:	c4 b8       	rjmp	8000fcc8 <start_pass_2_quant+0xbc>
  } else {
    /* Set up method pointers */
    if (cinfo->dither_mode == JDITHER_FS)
8000fc34:	79 68       	ld.w	r8,r12[0x58]
8000fc36:	58 28       	cp.w	r8,2
8000fc38:	c0 41       	brne	8000fc40 <start_pass_2_quant+0x34>
      cquantize->pub.color_quantize = pass2_fs_dither;
8000fc3a:	4a e8       	lddpc	r8,8000fcf0 <start_pass_2_quant+0xe4>
8000fc3c:	89 18       	st.w	r4[0x4],r8
8000fc3e:	c0 38       	rjmp	8000fc44 <start_pass_2_quant+0x38>
    else
      cquantize->pub.color_quantize = pass2_no_dither;
8000fc40:	4a d8       	lddpc	r8,8000fcf4 <start_pass_2_quant+0xe8>
8000fc42:	89 18       	st.w	r4[0x4],r8
    cquantize->pub.finish_pass = finish_pass2;
8000fc44:	4a d8       	lddpc	r8,8000fcf8 <start_pass_2_quant+0xec>
8000fc46:	89 28       	st.w	r4[0x8],r8

    /* Make sure color count is acceptable */
    i = cinfo->actual_number_of_colors;
8000fc48:	ee f5 00 84 	ld.w	r5,r7[132]
    if (i < 1)
8000fc4c:	58 05       	cp.w	r5,0
8000fc4e:	e0 89 00 0c 	brgt	8000fc66 <start_pass_2_quant+0x5a>
      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
8000fc52:	6e 08       	ld.w	r8,r7[0x0]
8000fc54:	33 89       	mov	r9,56
8000fc56:	91 59       	st.w	r8[0x14],r9
8000fc58:	6e 08       	ld.w	r8,r7[0x0]
8000fc5a:	30 19       	mov	r9,1
8000fc5c:	91 69       	st.w	r8[0x18],r9
8000fc5e:	6e 08       	ld.w	r8,r7[0x0]
8000fc60:	70 08       	ld.w	r8,r8[0x0]
8000fc62:	0e 9c       	mov	r12,r7
8000fc64:	5d 18       	icall	r8
    if (i > MAXNUMCOLORS)
8000fc66:	e0 45 01 00 	cp.w	r5,256
8000fc6a:	e0 8a 00 0d 	brle	8000fc84 <start_pass_2_quant+0x78>
      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
8000fc6e:	6e 08       	ld.w	r8,r7[0x0]
8000fc70:	33 99       	mov	r9,57
8000fc72:	91 59       	st.w	r8[0x14],r9
8000fc74:	6e 08       	ld.w	r8,r7[0x0]
8000fc76:	e0 69 01 00 	mov	r9,256
8000fc7a:	91 69       	st.w	r8[0x18],r9
8000fc7c:	6e 08       	ld.w	r8,r7[0x0]
8000fc7e:	70 08       	ld.w	r8,r8[0x0]
8000fc80:	0e 9c       	mov	r12,r7
8000fc82:	5d 18       	icall	r8

    if (cinfo->dither_mode == JDITHER_FS) {
8000fc84:	6f 68       	ld.w	r8,r7[0x58]
8000fc86:	58 28       	cp.w	r8,2
8000fc88:	c1 d1       	brne	8000fcc2 <start_pass_2_quant+0xb6>
      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
				   (3 * SIZEOF(FSERROR)));
8000fc8a:	6f c8       	ld.w	r8,r7[0x70]
8000fc8c:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000fc90:	f0 05 15 01 	lsl	r5,r8,0x1
8000fc94:	2f 45       	sub	r5,-12
      /* Allocate Floyd-Steinberg workspace if we didn't already. */
      if (cquantize->fserrors == NULL)
8000fc96:	68 88       	ld.w	r8,r4[0x20]
8000fc98:	58 08       	cp.w	r8,0
8000fc9a:	c0 81       	brne	8000fcaa <start_pass_2_quant+0x9e>
	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
8000fc9c:	6e 18       	ld.w	r8,r7[0x4]
8000fc9e:	70 18       	ld.w	r8,r8[0x4]
8000fca0:	0a 9a       	mov	r10,r5
8000fca2:	30 1b       	mov	r11,1
8000fca4:	0e 9c       	mov	r12,r7
8000fca6:	5d 18       	icall	r8
8000fca8:	89 8c       	st.w	r4[0x20],r12
	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
      /* Initialize the propagated errors to zero. */
      jzero_far((void FAR *) cquantize->fserrors, arraysize);
8000fcaa:	0a 9b       	mov	r11,r5
8000fcac:	68 8c       	ld.w	r12,r4[0x20]
8000fcae:	f0 1f 00 14 	mcall	8000fcfc <start_pass_2_quant+0xf0>
      /* Make the error-limit table if we didn't already. */
      if (cquantize->error_limiter == NULL)
8000fcb2:	68 a8       	ld.w	r8,r4[0x28]
8000fcb4:	58 08       	cp.w	r8,0
8000fcb6:	c0 41       	brne	8000fcbe <start_pass_2_quant+0xb2>
	init_error_limit(cinfo);
8000fcb8:	0e 9c       	mov	r12,r7
8000fcba:	f0 1f 00 12 	mcall	8000fd00 <start_pass_2_quant+0xf4>
      cquantize->on_odd_row = FALSE;
8000fcbe:	30 08       	mov	r8,0
8000fcc0:	89 98       	st.w	r4[0x24],r8
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
8000fcc2:	68 78       	ld.w	r8,r4[0x1c]
8000fcc4:	58 08       	cp.w	r8,0
8000fcc6:	c0 f0       	breq	8000fce4 <start_pass_2_quant+0xd8>
8000fcc8:	30 07       	mov	r7,0
    for (i = 0; i < HIST_C0_ELEMS; i++) {
      jzero_far((void FAR *) histogram[i],
8000fcca:	e0 65 10 00 	mov	r5,4096
8000fcce:	0a 9b       	mov	r11,r5
8000fcd0:	ec 07 03 0c 	ld.w	r12,r6[r7]
8000fcd4:	f0 1f 00 0a 	mcall	8000fcfc <start_pass_2_quant+0xf0>
8000fcd8:	2f c7       	sub	r7,-4
    }

  }
  /* Zero the histogram or inverse color map, if necessary */
  if (cquantize->needs_zeroed) {
    for (i = 0; i < HIST_C0_ELEMS; i++) {
8000fcda:	e0 47 00 80 	cp.w	r7,128
8000fcde:	cf 81       	brne	8000fcce <start_pass_2_quant+0xc2>
      jzero_far((void FAR *) histogram[i],
		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
    }
    cquantize->needs_zeroed = FALSE;
8000fce0:	30 08       	mov	r8,0
8000fce2:	89 78       	st.w	r4[0x1c],r8
8000fce4:	d8 22       	popm	r4-r7,pc
8000fce6:	00 00       	add	r0,r0
8000fce8:	80 00       	ld.sh	r0,r0[0x0]
8000fcea:	ee 30 80 00 	sub	r0,1015808
8000fcee:	f8 28 80 00 	sub	r8,-491520
8000fcf2:	f5 54 80 00 	st.h	r10[-32768],r4
8000fcf6:	f4 c8 80 00 	sub	r8,r10,-32768
8000fcfa:	fa fc 80 00 	ld.w	r12,sp[-32768]
8000fcfe:	fd 20 80 00 	ld.sb	r0,lr[-32768]
8000fd02:	f7 b0       	*unknown*

8000fd04 <jdiv_round_up>:

GLOBAL(long)
jdiv_round_up (long a, long b)
/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
/* Assumes a >= 0, b > 0 */
{
8000fd04:	20 1c       	sub	r12,1
8000fd06:	16 0c       	add	r12,r11
8000fd08:	f8 0b 0c 0a 	divs	r10,r12,r11
  return (a + b - 1L) / b;
}
8000fd0c:	5e fa       	retal	r10

8000fd0e <jround_up>:
GLOBAL(long)
jround_up (long a, long b)
/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
/* Assumes a >= 0, b > 0 */
{
  a += b - 1L;
8000fd0e:	f8 c8 00 01 	sub	r8,r12,1
8000fd12:	16 08       	add	r8,r11
8000fd14:	f0 0b 0c 0a 	divs	r10,r8,r11
  return a - (a % b);
}
8000fd18:	f0 0b 01 0c 	sub	r12,r8,r11
8000fd1c:	5e fc       	retal	r12
8000fd1e:	d7 03       	nop

8000fd20 <jzero_far>:

GLOBAL(void)
jzero_far (void FAR * target, size_t bytestozero)
/* Zero out a chunk of FAR memory. */
/* This might be sample-array data, block-array data, or alloc_large data. */
{
8000fd20:	d4 01       	pushm	lr
#ifdef FMEMZERO
  FMEMZERO(target, bytestozero);
8000fd22:	16 9a       	mov	r10,r11
8000fd24:	30 0b       	mov	r11,0
8000fd26:	f0 1f 00 02 	mcall	8000fd2c <jzero_far+0xc>

  for (count = bytestozero; count > 0; count--) {
    *ptr++ = 0;
  }
#endif
}
8000fd2a:	d8 02       	popm	pc
8000fd2c:	80 01       	ld.sh	r1,r0[0x0]
8000fd2e:	56 02       	stdsp	sp[0x180],r2

8000fd30 <jcopy_block_row>:

GLOBAL(void)
jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
		 JDIMENSION num_blocks)
/* Copy a row of coefficient blocks from one place to another. */
{
8000fd30:	d4 01       	pushm	lr
8000fd32:	16 98       	mov	r8,r11
#ifdef FMEMCOPY
  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
8000fd34:	a7 7a       	lsl	r10,0x7
8000fd36:	18 9b       	mov	r11,r12
8000fd38:	10 9c       	mov	r12,r8
8000fd3a:	f0 1f 00 02 	mcall	8000fd40 <jcopy_block_row+0x10>
  outptr = (JCOEFPTR) output_row;
  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
    *outptr++ = *inptr++;
  }
#endif
}
8000fd3e:	d8 02       	popm	pc
8000fd40:	80 01       	ld.sh	r1,r0[0x0]
8000fd42:	54 ba       	stdsp	sp[0x12c],r10

8000fd44 <jcopy_sample_rows>:
/* Copy some rows of samples from one place to another.
 * num_rows rows are copied from input_array[source_row++]
 * to output_array[dest_row++]; these areas may overlap for duplication.
 * The source and destination arrays must be at least as wide as num_cols.
 */
{
8000fd44:	eb cd 40 f8 	pushm	r3-r7,lr
8000fd48:	40 65       	lddsp	r5,sp[0x18]
  register int row;

  input_array += source_row;
  output_array += dest_row;

  for (row = num_rows; row > 0; row--) {
8000fd4a:	58 08       	cp.w	r8,0
8000fd4c:	e0 8a 00 14 	brle	8000fd74 <jcopy_sample_rows+0x30>
#else
  register JDIMENSION count;
#endif
  register int row;

  input_array += source_row;
8000fd50:	f8 0b 00 24 	add	r4,r12,r11<<0x2
  output_array += dest_row;
8000fd54:	f4 09 00 23 	add	r3,r10,r9<<0x2
8000fd58:	10 96       	mov	r6,r8
8000fd5a:	30 07       	mov	r7,0

  for (row = num_rows; row > 0; row--) {
    inptr = *input_array++;
    outptr = *output_array++;
#ifdef FMEMCOPY
    FMEMCOPY(outptr, inptr, count);
8000fd5c:	0a 9a       	mov	r10,r5
8000fd5e:	e8 07 03 0b 	ld.w	r11,r4[r7]
8000fd62:	e6 07 03 0c 	ld.w	r12,r3[r7]
8000fd66:	f0 1f 00 05 	mcall	8000fd78 <jcopy_sample_rows+0x34>
  register int row;

  input_array += source_row;
  output_array += dest_row;

  for (row = num_rows; row > 0; row--) {
8000fd6a:	20 16       	sub	r6,1
8000fd6c:	2f c7       	sub	r7,-4
8000fd6e:	58 06       	cp.w	r6,0
8000fd70:	fe 99 ff f6 	brgt	8000fd5c <jcopy_sample_rows+0x18>
8000fd74:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000fd78:	80 01       	ld.sh	r1,r0[0x0]
8000fd7a:	54 ba       	stdsp	sp[0x12c],r10

8000fd7c <filtro_movil>:
	RawImg  = (et024006_color_t const *)jpeg_lib_decode_ex(0, &width, &height);
	et024006_PutPixmap(RawImg , width, 0, 0, 0,0, width, height);
	jpeg_lib_exit();
}

void filtro_movil(void){
8000fd7c:	eb cd 40 e0 	pushm	r5-r7,lr
	y4=y3;
8000fd80:	4b c8       	lddpc	r8,8000fe70 <filtro_movil+0xf4>
8000fd82:	70 0e       	ld.w	lr,r8[0x0]
8000fd84:	4b c9       	lddpc	r9,8000fe74 <filtro_movil+0xf8>
8000fd86:	93 0e       	st.w	r9[0x0],lr
	y3=y2;
8000fd88:	4b cb       	lddpc	r11,8000fe78 <filtro_movil+0xfc>
8000fd8a:	76 09       	ld.w	r9,r11[0x0]
8000fd8c:	91 09       	st.w	r8[0x0],r9
	y2=ye1;
8000fd8e:	4b ca       	lddpc	r10,8000fe7c <filtro_movil+0x100>
8000fd90:	74 08       	ld.w	r8,r10[0x0]
8000fd92:	97 08       	st.w	r11[0x0],r8
	ye1=Y;
8000fd94:	4b bb       	lddpc	r11,8000fe80 <filtro_movil+0x104>
8000fd96:	76 0c       	ld.w	r12,r11[0x0]
8000fd98:	95 0c       	st.w	r10[0x0],r12
	x4=x3;
8000fd9a:	4b ba       	lddpc	r10,8000fe84 <filtro_movil+0x108>
8000fd9c:	74 06       	ld.w	r6,r10[0x0]
8000fd9e:	4b bb       	lddpc	r11,8000fe88 <filtro_movil+0x10c>
8000fda0:	97 06       	st.w	r11[0x0],r6
	x3=x2;
8000fda2:	4b b7       	lddpc	r7,8000fe8c <filtro_movil+0x110>
8000fda4:	6e 0b       	ld.w	r11,r7[0x0]
8000fda6:	95 0b       	st.w	r10[0x0],r11
	x2=x1;
8000fda8:	4b a5       	lddpc	r5,8000fe90 <filtro_movil+0x114>
8000fdaa:	6a 0a       	ld.w	r10,r5[0x0]
8000fdac:	8f 0a       	st.w	r7[0x0],r10
	x1=X;
8000fdae:	4b a7       	lddpc	r7,8000fe94 <filtro_movil+0x118>
8000fdb0:	6e 07       	ld.w	r7,r7[0x0]
8000fdb2:	8b 07       	st.w	r5[0x0],r7
	if(x4>x3)
8000fdb4:	16 36       	cp.w	r6,r11
8000fdb6:	e0 8a 00 06 	brle	8000fdc2 <filtro_movil+0x46>
	{
		x43=x4-x3;
8000fdba:	4b 85       	lddpc	r5,8000fe98 <filtro_movil+0x11c>
8000fdbc:	16 16       	sub	r6,r11
8000fdbe:	8b 06       	st.w	r5[0x0],r6
8000fdc0:	c0 58       	rjmp	8000fdca <filtro_movil+0x4e>
	}
	else
	{
		x43=x3-x4;
8000fdc2:	4b 65       	lddpc	r5,8000fe98 <filtro_movil+0x11c>
8000fdc4:	f6 06 01 06 	sub	r6,r11,r6
8000fdc8:	8b 06       	st.w	r5[0x0],r6
	}
	if(x3>x2)
8000fdca:	14 3b       	cp.w	r11,r10
8000fdcc:	e0 8a 00 06 	brle	8000fdd8 <filtro_movil+0x5c>
	{
		x32=x3-x2;
8000fdd0:	4b 36       	lddpc	r6,8000fe9c <filtro_movil+0x120>
8000fdd2:	14 1b       	sub	r11,r10
8000fdd4:	8d 0b       	st.w	r6[0x0],r11
8000fdd6:	c0 58       	rjmp	8000fde0 <filtro_movil+0x64>
	}
	else
	{
		x32=x2-x3;
8000fdd8:	4b 16       	lddpc	r6,8000fe9c <filtro_movil+0x120>
8000fdda:	f4 0b 01 0b 	sub	r11,r10,r11
8000fdde:	8d 0b       	st.w	r6[0x0],r11
	}
	if(x2>x1)
8000fde0:	0e 3a       	cp.w	r10,r7
8000fde2:	e0 8a 00 06 	brle	8000fdee <filtro_movil+0x72>
	{
		x21=x2-x1;
8000fde6:	4a fb       	lddpc	r11,8000fea0 <filtro_movil+0x124>
8000fde8:	0e 1a       	sub	r10,r7
8000fdea:	97 0a       	st.w	r11[0x0],r10
8000fdec:	c0 58       	rjmp	8000fdf6 <filtro_movil+0x7a>
	}
	else
	{
		x21=x1-x2;
8000fdee:	4a db       	lddpc	r11,8000fea0 <filtro_movil+0x124>
8000fdf0:	ee 0a 01 0a 	sub	r10,r7,r10
8000fdf4:	97 0a       	st.w	r11[0x0],r10
	}
	if(y4>y3)
8000fdf6:	12 3e       	cp.w	lr,r9
8000fdf8:	e0 8a 00 06 	brle	8000fe04 <filtro_movil+0x88>
	{
		y43=y4-y3;
8000fdfc:	4a aa       	lddpc	r10,8000fea4 <filtro_movil+0x128>
8000fdfe:	12 1e       	sub	lr,r9
8000fe00:	95 0e       	st.w	r10[0x0],lr
8000fe02:	c0 58       	rjmp	8000fe0c <filtro_movil+0x90>
	}
	else
	{
		y43=y3-y4;
8000fe04:	4a 8a       	lddpc	r10,8000fea4 <filtro_movil+0x128>
8000fe06:	f2 0e 01 0e 	sub	lr,r9,lr
8000fe0a:	95 0e       	st.w	r10[0x0],lr
	}
	if(y3>y2)
8000fe0c:	10 39       	cp.w	r9,r8
8000fe0e:	e0 8a 00 06 	brle	8000fe1a <filtro_movil+0x9e>
	{
		y32=y3-y2;
8000fe12:	4a 6a       	lddpc	r10,8000fea8 <filtro_movil+0x12c>
8000fe14:	10 19       	sub	r9,r8
8000fe16:	95 09       	st.w	r10[0x0],r9
8000fe18:	c0 58       	rjmp	8000fe22 <filtro_movil+0xa6>
	}
	else
	{
		y32=y2-y3;
8000fe1a:	4a 4a       	lddpc	r10,8000fea8 <filtro_movil+0x12c>
8000fe1c:	f0 09 01 09 	sub	r9,r8,r9
8000fe20:	95 09       	st.w	r10[0x0],r9
	}
	if(y2>ye1)
8000fe22:	18 38       	cp.w	r8,r12
8000fe24:	e0 8a 00 06 	brle	8000fe30 <filtro_movil+0xb4>
	{
		y21=y2-ye1;
8000fe28:	4a 19       	lddpc	r9,8000feac <filtro_movil+0x130>
8000fe2a:	18 18       	sub	r8,r12
8000fe2c:	93 08       	st.w	r9[0x0],r8
8000fe2e:	c0 58       	rjmp	8000fe38 <filtro_movil+0xbc>
	}
	else
	{
		y21=ye1-y2;
8000fe30:	49 f9       	lddpc	r9,8000feac <filtro_movil+0x130>
8000fe32:	f8 08 01 08 	sub	r8,r12,r8
8000fe36:	93 08       	st.w	r9[0x0],r8
	}
	ytot=y43+y32+y21;
8000fe38:	49 c8       	lddpc	r8,8000fea8 <filtro_movil+0x12c>
8000fe3a:	70 09       	ld.w	r9,r8[0x0]
8000fe3c:	49 a8       	lddpc	r8,8000fea4 <filtro_movil+0x128>
8000fe3e:	70 08       	ld.w	r8,r8[0x0]
8000fe40:	f2 08 00 08 	add	r8,r9,r8
8000fe44:	49 a9       	lddpc	r9,8000feac <filtro_movil+0x130>
8000fe46:	72 09       	ld.w	r9,r9[0x0]
8000fe48:	12 08       	add	r8,r9
8000fe4a:	49 a9       	lddpc	r9,8000feb0 <filtro_movil+0x134>
8000fe4c:	93 08       	st.w	r9[0x0],r8
	xtot=x43+x32+x21;
8000fe4e:	49 49       	lddpc	r9,8000fe9c <filtro_movil+0x120>
8000fe50:	72 0a       	ld.w	r10,r9[0x0]
8000fe52:	49 29       	lddpc	r9,8000fe98 <filtro_movil+0x11c>
8000fe54:	72 09       	ld.w	r9,r9[0x0]
8000fe56:	f4 09 00 09 	add	r9,r10,r9
8000fe5a:	49 2a       	lddpc	r10,8000fea0 <filtro_movil+0x124>
8000fe5c:	74 0a       	ld.w	r10,r10[0x0]
8000fe5e:	14 09       	add	r9,r10
8000fe60:	49 5a       	lddpc	r10,8000feb4 <filtro_movil+0x138>
8000fe62:	95 09       	st.w	r10[0x0],r9
	xytot=xtot+ytot;
8000fe64:	f2 08 00 08 	add	r8,r9,r8
8000fe68:	49 4a       	lddpc	r10,8000feb8 <filtro_movil+0x13c>
8000fe6a:	95 08       	st.w	r10[0x0],r8
}
8000fe6c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000fe70:	00 00       	add	r0,r0
8000fe72:	07 68       	ld.uh	r8,--r3
8000fe74:	00 00       	add	r0,r0
8000fe76:	07 6c       	ld.uh	r12,--r3
8000fe78:	00 00       	add	r0,r0
8000fe7a:	07 64       	ld.uh	r4,--r3
8000fe7c:	00 00       	add	r0,r0
8000fe7e:	06 90       	mov	r0,r3
8000fe80:	00 00       	add	r0,r0
8000fe82:	07 74       	ld.ub	r4,--r3
8000fe84:	00 00       	add	r0,r0
8000fe86:	06 c8       	st.b	r3++,r8
8000fe88:	00 00       	add	r0,r0
8000fe8a:	06 cc       	st.b	r3++,r12
8000fe8c:	00 00       	add	r0,r0
8000fe8e:	06 c4       	st.b	r3++,r4
8000fe90:	00 00       	add	r0,r0
8000fe92:	06 bc       	st.h	r3++,r12
8000fe94:	00 00       	add	r0,r0
8000fe96:	07 70       	ld.ub	r0,--r3
8000fe98:	00 00       	add	r0,r0
8000fe9a:	06 80       	andn	r0,r3
8000fe9c:	00 00       	add	r0,r0
8000fe9e:	06 dc       	st.w	--r3,r12
8000fea0:	00 00       	add	r0,r0
8000fea2:	07 78       	ld.ub	r8,--r3
8000fea4:	00 00       	add	r0,r0
8000fea6:	06 c0       	st.b	r3++,r0
8000fea8:	00 00       	add	r0,r0
8000feaa:	06 e0       	st.h	--r3,r0
8000feac:	00 00       	add	r0,r0
8000feae:	06 d4       	st.w	--r3,r4
8000feb0:	00 00       	add	r0,r0
8000feb2:	06 b4       	st.h	r3++,r4
8000feb4:	00 00       	add	r0,r0
8000feb6:	06 84       	andn	r4,r3
8000feb8:	00 00       	add	r0,r0
8000feba:	07 5c       	ld.sh	r12,--r3

8000febc <Timersetup>:
	gpio_set_gpio_pin(LED2_GPIO);
	gpio_set_gpio_pin(LED3_GPIO);
}

void Timersetup (void)
{
8000febc:	d4 01       	pushm	lr
		.cpbs  = 0,
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	tc_configure_interrupts(&AVR32_TC, 0, &TC_INTERRUPT);
8000febe:	48 7a       	lddpc	r10,8000fed8 <Timersetup+0x1c>
8000fec0:	30 0b       	mov	r11,0
8000fec2:	fe 7c 38 00 	mov	r12,-51200
8000fec6:	f0 1f 00 06 	mcall	8000fedc <Timersetup+0x20>
	tc_init_waveform(&AVR32_TC, &WAVEFORM_OPT);
8000feca:	48 6b       	lddpc	r11,8000fee0 <Timersetup+0x24>
8000fecc:	fe 7c 38 00 	mov	r12,-51200
8000fed0:	f0 1f 00 05 	mcall	8000fee4 <Timersetup+0x28>
8000fed4:	d8 02       	popm	pc
8000fed6:	00 00       	add	r0,r0
8000fed8:	80 01       	ld.sh	r1,r0[0x0]
8000feda:	fd 94       	*unknown*
8000fedc:	80 00       	ld.sh	r0,r0[0x0]
8000fede:	2e 78       	sub	r8,-25
8000fee0:	80 01       	ld.sh	r1,r0[0x0]
8000fee2:	fd b8       	*unknown*
8000fee4:	80 00       	ld.sh	r0,r0[0x0]
8000fee6:	2d ca       	sub	r10,-36

8000fee8 <Luces>:
	Y=270-Y;
	X=X-50;
}

void Luces (void)
{
8000fee8:	d4 21       	pushm	r4-r7,lr
8000feea:	fe f5 02 da 	ld.w	r5,pc[730]
	//Eliminacion de Offset
	Y=270-Y;
	X=X-50;
}

void Luces (void)
8000feee:	ea c7 ff fc 	sub	r7,r5,-4
8000fef2:	0a 96       	mov	r6,r5
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000fef4:	e0 64 8d 80 	mov	r4,36224
8000fef8:	ea 14 00 5b 	orh	r4,0x5b
{
	for (int i=0; i<4;i++)
	{
		gpio_set_gpio_pin(LEDS[i]);
8000fefc:	0d 8c       	ld.ub	r12,r6[0x0]
8000fefe:	f0 1f 00 b3 	mcall	800101c8 <Luces+0x2e0>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000ff02:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ff06:	f0 04 00 0a 	add	r10,r8,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ff0a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000ff0e:	14 38       	cp.w	r8,r10
8000ff10:	e0 88 00 09 	brls	8000ff22 <Luces+0x3a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000ff14:	12 38       	cp.w	r8,r9
8000ff16:	fe 98 ff fa 	brls	8000ff0a <Luces+0x22>
8000ff1a:	12 3a       	cp.w	r10,r9
8000ff1c:	e0 83 01 38 	brlo	8001018c <Luces+0x2a4>
8000ff20:	cf 5b       	rjmp	8000ff0a <Luces+0x22>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000ff22:	12 38       	cp.w	r8,r9
8000ff24:	e0 8b 01 34 	brhi	8001018c <Luces+0x2a4>
8000ff28:	12 3a       	cp.w	r10,r9
8000ff2a:	e0 83 01 31 	brlo	8001018c <Luces+0x2a4>
8000ff2e:	ce eb       	rjmp	8000ff0a <Luces+0x22>
8000ff30:	0a 96       	mov	r6,r5
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ff32:	e0 64 8d 80 	mov	r4,36224
8000ff36:	ea 14 00 5b 	orh	r4,0x5b
		delay_ms(100);
	}

	for (int i=0; i<4;i++)
	{
		gpio_clr_gpio_pin(LEDS[i]);
8000ff3a:	0d 8c       	ld.ub	r12,r6[0x0]
8000ff3c:	f0 1f 00 a4 	mcall	800101cc <Luces+0x2e4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000ff40:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ff44:	f0 04 00 0a 	add	r10,r8,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ff48:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000ff4c:	14 38       	cp.w	r8,r10
8000ff4e:	e0 88 00 09 	brls	8000ff60 <Luces+0x78>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000ff52:	12 38       	cp.w	r8,r9
8000ff54:	fe 98 ff fa 	brls	8000ff48 <Luces+0x60>
8000ff58:	12 3a       	cp.w	r10,r9
8000ff5a:	e0 83 01 1e 	brlo	80010196 <Luces+0x2ae>
8000ff5e:	cf 5b       	rjmp	8000ff48 <Luces+0x60>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000ff60:	12 38       	cp.w	r8,r9
8000ff62:	e0 8b 01 1a 	brhi	80010196 <Luces+0x2ae>
8000ff66:	12 3a       	cp.w	r10,r9
8000ff68:	e0 83 01 17 	brlo	80010196 <Luces+0x2ae>
8000ff6c:	ce eb       	rjmp	8000ff48 <Luces+0x60>
8000ff6e:	0a 96       	mov	r6,r5
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ff70:	e0 64 8d 80 	mov	r4,36224
8000ff74:	ea 14 00 5b 	orh	r4,0x5b
		delay_ms(100);
	}
	for (int i=0; i<4;i++)
	{
		gpio_set_gpio_pin(LEDS[i]);
8000ff78:	0d 8c       	ld.ub	r12,r6[0x0]
8000ff7a:	f0 1f 00 94 	mcall	800101c8 <Luces+0x2e0>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000ff7e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ff82:	f0 04 00 0a 	add	r10,r8,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ff86:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000ff8a:	14 38       	cp.w	r8,r10
8000ff8c:	e0 88 00 09 	brls	8000ff9e <Luces+0xb6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000ff90:	12 38       	cp.w	r8,r9
8000ff92:	fe 98 ff fa 	brls	8000ff86 <Luces+0x9e>
8000ff96:	12 3a       	cp.w	r10,r9
8000ff98:	e0 83 01 04 	brlo	800101a0 <Luces+0x2b8>
8000ff9c:	cf 5b       	rjmp	8000ff86 <Luces+0x9e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000ff9e:	12 38       	cp.w	r8,r9
8000ffa0:	e0 8b 01 00 	brhi	800101a0 <Luces+0x2b8>
8000ffa4:	12 3a       	cp.w	r10,r9
8000ffa6:	e0 83 00 fd 	brlo	800101a0 <Luces+0x2b8>
8000ffaa:	ce eb       	rjmp	8000ff86 <Luces+0x9e>
8000ffac:	0a 96       	mov	r6,r5
		delay_ms(100);
	}

	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
8000ffae:	0d 3c       	ld.ub	r12,r6++
8000ffb0:	f0 1f 00 88 	mcall	800101d0 <Luces+0x2e8>
	{
		gpio_set_gpio_pin(LEDS[i]);
		delay_ms(100);
	}

	for (int i=0; i<4;i++)
8000ffb4:	0c 37       	cp.w	r7,r6
8000ffb6:	cf c1       	brne	8000ffae <Luces+0xc6>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000ffb8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000ffbc:	e0 6a 1b 00 	mov	r10,6912
8000ffc0:	ea 1a 00 b7 	orh	r10,0xb7
8000ffc4:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000ffc8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000ffcc:	14 38       	cp.w	r8,r10
8000ffce:	e0 88 00 08 	brls	8000ffde <Luces+0xf6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000ffd2:	12 38       	cp.w	r8,r9
8000ffd4:	fe 98 ff fa 	brls	8000ffc8 <Luces+0xe0>
8000ffd8:	12 3a       	cp.w	r10,r9
8000ffda:	c0 73       	brcs	8000ffe8 <Luces+0x100>
8000ffdc:	cf 6b       	rjmp	8000ffc8 <Luces+0xe0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000ffde:	12 38       	cp.w	r8,r9
8000ffe0:	e0 8b 00 04 	brhi	8000ffe8 <Luces+0x100>
8000ffe4:	12 3a       	cp.w	r10,r9
8000ffe6:	cf 12       	brcc	8000ffc8 <Luces+0xe0>
8000ffe8:	0a 96       	mov	r6,r5
	}
	delay_ms(200);

	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
8000ffea:	0d 3c       	ld.ub	r12,r6++
8000ffec:	f0 1f 00 79 	mcall	800101d0 <Luces+0x2e8>
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(200);

	for (int i=0; i<4;i++)
8000fff0:	0c 37       	cp.w	r7,r6
8000fff2:	cf c1       	brne	8000ffea <Luces+0x102>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000fff4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000fff8:	e0 6a 1b 00 	mov	r10,6912
8000fffc:	ea 1a 00 b7 	orh	r10,0xb7
80010000:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010004:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010008:	14 38       	cp.w	r8,r10
8001000a:	e0 88 00 08 	brls	8001001a <Luces+0x132>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001000e:	12 38       	cp.w	r8,r9
80010010:	fe 98 ff fa 	brls	80010004 <Luces+0x11c>
80010014:	12 3a       	cp.w	r10,r9
80010016:	c0 73       	brcs	80010024 <Luces+0x13c>
80010018:	cf 6b       	rjmp	80010004 <Luces+0x11c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001001a:	12 38       	cp.w	r8,r9
8001001c:	e0 8b 00 04 	brhi	80010024 <Luces+0x13c>
80010020:	12 3a       	cp.w	r10,r9
80010022:	cf 12       	brcc	80010004 <Luces+0x11c>
80010024:	0a 96       	mov	r6,r5
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(200);
	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
80010026:	0d 3c       	ld.ub	r12,r6++
80010028:	f0 1f 00 6a 	mcall	800101d0 <Luces+0x2e8>
	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(200);
	for (int i=0; i<4;i++)
8001002c:	0c 37       	cp.w	r7,r6
8001002e:	cf c1       	brne	80010026 <Luces+0x13e>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010030:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010034:	e0 6a 8d 80 	mov	r10,36224
80010038:	ea 1a 00 5b 	orh	r10,0x5b
8001003c:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010040:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010044:	14 38       	cp.w	r8,r10
80010046:	e0 88 00 08 	brls	80010056 <Luces+0x16e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001004a:	12 38       	cp.w	r8,r9
8001004c:	fe 98 ff fa 	brls	80010040 <Luces+0x158>
80010050:	12 3a       	cp.w	r10,r9
80010052:	c0 73       	brcs	80010060 <Luces+0x178>
80010054:	cf 6b       	rjmp	80010040 <Luces+0x158>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010056:	12 38       	cp.w	r8,r9
80010058:	e0 8b 00 04 	brhi	80010060 <Luces+0x178>
8001005c:	12 3a       	cp.w	r10,r9
8001005e:	cf 12       	brcc	80010040 <Luces+0x158>
80010060:	0a 96       	mov	r6,r5
	}
	delay_ms(100);

	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
80010062:	0d 3c       	ld.ub	r12,r6++
80010064:	f0 1f 00 5b 	mcall	800101d0 <Luces+0x2e8>
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(100);

	for (int i=0; i<4;i++)
80010068:	0c 37       	cp.w	r7,r6
8001006a:	cf c1       	brne	80010062 <Luces+0x17a>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001006c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010070:	e0 6a 8d 80 	mov	r10,36224
80010074:	ea 1a 00 5b 	orh	r10,0x5b
80010078:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001007c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010080:	14 38       	cp.w	r8,r10
80010082:	e0 88 00 08 	brls	80010092 <Luces+0x1aa>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010086:	12 38       	cp.w	r8,r9
80010088:	fe 98 ff fa 	brls	8001007c <Luces+0x194>
8001008c:	12 3a       	cp.w	r10,r9
8001008e:	c0 73       	brcs	8001009c <Luces+0x1b4>
80010090:	cf 6b       	rjmp	8001007c <Luces+0x194>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010092:	12 38       	cp.w	r8,r9
80010094:	e0 8b 00 04 	brhi	8001009c <Luces+0x1b4>
80010098:	12 3a       	cp.w	r10,r9
8001009a:	cf 12       	brcc	8001007c <Luces+0x194>
8001009c:	0a 96       	mov	r6,r5
	}
	delay_ms(100);

	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
8001009e:	0d 3c       	ld.ub	r12,r6++
800100a0:	f0 1f 00 4c 	mcall	800101d0 <Luces+0x2e8>
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(100);

	for (int i=0; i<4;i++)
800100a4:	0e 36       	cp.w	r6,r7
800100a6:	cf c1       	brne	8001009e <Luces+0x1b6>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800100a8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800100ac:	e0 6a c6 c0 	mov	r10,50880
800100b0:	ea 1a 00 2d 	orh	r10,0x2d
800100b4:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800100b8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800100bc:	14 38       	cp.w	r8,r10
800100be:	e0 88 00 08 	brls	800100ce <Luces+0x1e6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800100c2:	12 38       	cp.w	r8,r9
800100c4:	fe 98 ff fa 	brls	800100b8 <Luces+0x1d0>
800100c8:	12 3a       	cp.w	r10,r9
800100ca:	c0 73       	brcs	800100d8 <Luces+0x1f0>
800100cc:	cf 6b       	rjmp	800100b8 <Luces+0x1d0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800100ce:	12 38       	cp.w	r8,r9
800100d0:	e0 8b 00 04 	brhi	800100d8 <Luces+0x1f0>
800100d4:	12 3a       	cp.w	r10,r9
800100d6:	cf 12       	brcc	800100b8 <Luces+0x1d0>
800100d8:	0a 96       	mov	r6,r5
	}
	delay_ms(50);

	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
800100da:	0d 3c       	ld.ub	r12,r6++
800100dc:	f0 1f 00 3d 	mcall	800101d0 <Luces+0x2e8>
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(50);

	for (int i=0; i<4;i++)
800100e0:	0c 37       	cp.w	r7,r6
800100e2:	cf c1       	brne	800100da <Luces+0x1f2>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800100e4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800100e8:	e0 6a c6 c0 	mov	r10,50880
800100ec:	ea 1a 00 2d 	orh	r10,0x2d
800100f0:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800100f4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800100f8:	14 38       	cp.w	r8,r10
800100fa:	e0 88 00 08 	brls	8001010a <Luces+0x222>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800100fe:	12 38       	cp.w	r8,r9
80010100:	fe 98 ff fa 	brls	800100f4 <Luces+0x20c>
80010104:	12 3a       	cp.w	r10,r9
80010106:	c0 73       	brcs	80010114 <Luces+0x22c>
80010108:	cf 6b       	rjmp	800100f4 <Luces+0x20c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001010a:	12 38       	cp.w	r8,r9
8001010c:	e0 8b 00 04 	brhi	80010114 <Luces+0x22c>
80010110:	12 3a       	cp.w	r10,r9
80010112:	cf 12       	brcc	800100f4 <Luces+0x20c>
80010114:	0a 96       	mov	r6,r5
	}
	delay_ms(50);

	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
80010116:	0d 3c       	ld.ub	r12,r6++
80010118:	f0 1f 00 2e 	mcall	800101d0 <Luces+0x2e8>
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(50);

	for (int i=0; i<4;i++)
8001011c:	0c 37       	cp.w	r7,r6
8001011e:	cf c1       	brne	80010116 <Luces+0x22e>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010120:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010124:	e0 6a e3 60 	mov	r10,58208
80010128:	ea 1a 00 16 	orh	r10,0x16
8001012c:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010130:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010134:	14 38       	cp.w	r8,r10
80010136:	e0 88 00 08 	brls	80010146 <Luces+0x25e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001013a:	12 38       	cp.w	r8,r9
8001013c:	fe 98 ff fa 	brls	80010130 <Luces+0x248>
80010140:	12 3a       	cp.w	r10,r9
80010142:	c0 73       	brcs	80010150 <Luces+0x268>
80010144:	cf 6b       	rjmp	80010130 <Luces+0x248>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010146:	12 38       	cp.w	r8,r9
80010148:	e0 8b 00 04 	brhi	80010150 <Luces+0x268>
8001014c:	12 3a       	cp.w	r10,r9
8001014e:	cf 12       	brcc	80010130 <Luces+0x248>
	}
	delay_ms(25);

	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
80010150:	0b 3c       	ld.ub	r12,r5++
80010152:	f0 1f 00 20 	mcall	800101d0 <Luces+0x2e8>
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(25);

	for (int i=0; i<4;i++)
80010156:	0e 35       	cp.w	r5,r7
80010158:	cf c1       	brne	80010150 <Luces+0x268>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001015a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001015e:	e0 6a e3 60 	mov	r10,58208
80010162:	ea 1a 00 16 	orh	r10,0x16
80010166:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001016a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001016e:	14 38       	cp.w	r8,r10
80010170:	e0 88 00 08 	brls	80010180 <Luces+0x298>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010174:	12 38       	cp.w	r8,r9
80010176:	fe 98 ff fa 	brls	8001016a <Luces+0x282>
8001017a:	12 3a       	cp.w	r10,r9
8001017c:	c1 73       	brcs	800101aa <Luces+0x2c2>
8001017e:	cf 6b       	rjmp	8001016a <Luces+0x282>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010180:	12 38       	cp.w	r8,r9
80010182:	e0 8b 00 14 	brhi	800101aa <Luces+0x2c2>
80010186:	12 3a       	cp.w	r10,r9
80010188:	c1 13       	brcs	800101aa <Luces+0x2c2>
8001018a:	cf 0b       	rjmp	8001016a <Luces+0x282>
8001018c:	2f f6       	sub	r6,-1
	X=X-50;
}

void Luces (void)
{
	for (int i=0; i<4;i++)
8001018e:	0e 36       	cp.w	r6,r7
80010190:	fe 91 fe b6 	brne	8000fefc <Luces+0x14>
80010194:	cc ea       	rjmp	8000ff30 <Luces+0x48>
80010196:	2f f6       	sub	r6,-1
	{
		gpio_set_gpio_pin(LEDS[i]);
		delay_ms(100);
	}

	for (int i=0; i<4;i++)
80010198:	0e 36       	cp.w	r6,r7
8001019a:	fe 91 fe d0 	brne	8000ff3a <Luces+0x52>
8001019e:	ce 8a       	rjmp	8000ff6e <Luces+0x86>
800101a0:	2f f6       	sub	r6,-1
	{
		gpio_clr_gpio_pin(LEDS[i]);
		delay_ms(100);
	}
	for (int i=0; i<4;i++)
800101a2:	0e 36       	cp.w	r6,r7
800101a4:	fe 91 fe ea 	brne	8000ff78 <Luces+0x90>
800101a8:	c0 2b       	rjmp	8000ffac <Luces+0xc4>
	for (int i=0; i<4;i++)
	{
		gpio_tgl_gpio_pin(LEDS[i]);
	}
	delay_ms(25);
	gpio_set_gpio_pin(LED0_GPIO);
800101aa:	33 bc       	mov	r12,59
800101ac:	f0 1f 00 07 	mcall	800101c8 <Luces+0x2e0>
	gpio_set_gpio_pin(LED1_GPIO);
800101b0:	33 cc       	mov	r12,60
800101b2:	f0 1f 00 06 	mcall	800101c8 <Luces+0x2e0>
	gpio_set_gpio_pin(LED2_GPIO);
800101b6:	30 5c       	mov	r12,5
800101b8:	f0 1f 00 04 	mcall	800101c8 <Luces+0x2e0>
	gpio_set_gpio_pin(LED3_GPIO);
800101bc:	30 6c       	mov	r12,6
800101be:	f0 1f 00 03 	mcall	800101c8 <Luces+0x2e0>
}
800101c2:	d8 22       	popm	r4-r7,pc
800101c4:	80 01       	ld.sh	r1,r0[0x0]
800101c6:	fd f8 80 00 	ld.wls	r8,lr[0x0]
800101ca:	6c 62       	ld.w	r2,r6[0x18]
800101cc:	80 00       	ld.sh	r0,r0[0x0]
800101ce:	6c 7e       	ld.w	lr,r6[0x1c]
800101d0:	80 00       	ld.sh	r0,r0[0x0]
800101d2:	6c 9a       	ld.w	r10,r6[0x24]

800101d4 <get_XY>:
	ytot=y43+y32+y21;
	xtot=x43+x32+x21;
	xytot=xtot+ytot;
}

void get_XY(void){
800101d4:	d4 01       	pushm	lr
	gpio_enable_gpio_pin(T_l);	//Reinicializacion de pines
800101d6:	31 5c       	mov	r12,21
800101d8:	f0 1f 00 96 	mcall	80010430 <get_XY+0x25c>
	gpio_enable_gpio_pin(T_r);
800101dc:	33 fc       	mov	r12,63
800101de:	f0 1f 00 95 	mcall	80010430 <get_XY+0x25c>
	gpio_set_gpio_pin(T_t);		//Polarizacion de la pantalla
800101e2:	33 ec       	mov	r12,62
800101e4:	f0 1f 00 94 	mcall	80010434 <get_XY+0x260>
	gpio_clr_gpio_pin(T_b);
800101e8:	31 7c       	mov	r12,23
800101ea:	f0 1f 00 94 	mcall	80010438 <get_XY+0x264>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800101ee:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800101f2:	e0 69 ea 60 	mov	r9,60000
800101f6:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800101fa:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800101fe:	14 38       	cp.w	r8,r10
80010200:	e0 88 00 09 	brls	80010212 <get_XY+0x3e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010204:	12 38       	cp.w	r8,r9
80010206:	fe 98 ff fa 	brls	800101fa <get_XY+0x26>
8001020a:	12 3a       	cp.w	r10,r9
8001020c:	e0 83 00 84 	brlo	80010314 <get_XY+0x140>
80010210:	cf 5b       	rjmp	800101fa <get_XY+0x26>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010212:	12 38       	cp.w	r8,r9
80010214:	e0 8b 00 80 	brhi	80010314 <get_XY+0x140>
80010218:	12 3a       	cp.w	r10,r9
8001021a:	c7 d3       	brcs	80010314 <get_XY+0x140>
8001021c:	ce fb       	rjmp	800101fa <get_XY+0x26>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001021e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010222:	14 38       	cp.w	r8,r10
80010224:	e0 88 00 08 	brls	80010234 <get_XY+0x60>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010228:	12 38       	cp.w	r8,r9
8001022a:	fe 98 ff fa 	brls	8001021e <get_XY+0x4a>
8001022e:	12 3a       	cp.w	r10,r9
80010230:	c7 e3       	brcs	8001032c <get_XY+0x158>
80010232:	cf 6b       	rjmp	8001021e <get_XY+0x4a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010234:	12 38       	cp.w	r8,r9
80010236:	e0 8b 00 7b 	brhi	8001032c <get_XY+0x158>
8001023a:	12 3a       	cp.w	r10,r9
8001023c:	c7 83       	brcs	8001032c <get_XY+0x158>
8001023e:	cf 0b       	rjmp	8001021e <get_XY+0x4a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010240:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010244:	14 38       	cp.w	r8,r10
80010246:	e0 88 00 08 	brls	80010256 <get_XY+0x82>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001024a:	12 38       	cp.w	r8,r9
8001024c:	fe 98 ff fa 	brls	80010240 <get_XY+0x6c>
80010250:	12 3a       	cp.w	r10,r9
80010252:	c7 83       	brcs	80010342 <get_XY+0x16e>
80010254:	cf 6b       	rjmp	80010240 <get_XY+0x6c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010256:	12 38       	cp.w	r8,r9
80010258:	e0 8b 00 75 	brhi	80010342 <get_XY+0x16e>
8001025c:	12 3a       	cp.w	r10,r9
8001025e:	c7 23       	brcs	80010342 <get_XY+0x16e>
80010260:	cf 0b       	rjmp	80010240 <get_XY+0x6c>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010262:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010266:	14 38       	cp.w	r8,r10
80010268:	e0 88 00 09 	brls	8001027a <get_XY+0xa6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001026c:	12 38       	cp.w	r8,r9
8001026e:	fe 98 ff fa 	brls	80010262 <get_XY+0x8e>
80010272:	12 3a       	cp.w	r10,r9
80010274:	e0 83 00 83 	brlo	8001037a <get_XY+0x1a6>
80010278:	cf 5b       	rjmp	80010262 <get_XY+0x8e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001027a:	12 38       	cp.w	r8,r9
8001027c:	e0 8b 00 7f 	brhi	8001037a <get_XY+0x1a6>
80010280:	12 3a       	cp.w	r10,r9
80010282:	c7 c3       	brcs	8001037a <get_XY+0x1a6>
80010284:	ce fb       	rjmp	80010262 <get_XY+0x8e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010286:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001028a:	14 38       	cp.w	r8,r10
8001028c:	e0 88 00 08 	brls	8001029c <get_XY+0xc8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010290:	12 38       	cp.w	r8,r9
80010292:	fe 98 ff fa 	brls	80010286 <get_XY+0xb2>
80010296:	12 3a       	cp.w	r10,r9
80010298:	c7 d3       	brcs	80010392 <get_XY+0x1be>
8001029a:	cf 6b       	rjmp	80010286 <get_XY+0xb2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001029c:	12 38       	cp.w	r8,r9
8001029e:	e0 8b 00 7a 	brhi	80010392 <get_XY+0x1be>
800102a2:	12 3a       	cp.w	r10,r9
800102a4:	c7 73       	brcs	80010392 <get_XY+0x1be>
800102a6:	cf 0b       	rjmp	80010286 <get_XY+0xb2>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800102a8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800102ac:	14 38       	cp.w	r8,r10
800102ae:	e0 88 00 09 	brls	800102c0 <get_XY+0xec>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800102b2:	12 38       	cp.w	r8,r9
800102b4:	fe 98 ff fa 	brls	800102a8 <get_XY+0xd4>
800102b8:	12 3a       	cp.w	r10,r9
800102ba:	e0 83 00 84 	brlo	800103c2 <get_XY+0x1ee>
800102be:	cf 5b       	rjmp	800102a8 <get_XY+0xd4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800102c0:	12 38       	cp.w	r8,r9
800102c2:	e0 8b 00 80 	brhi	800103c2 <get_XY+0x1ee>
800102c6:	12 3a       	cp.w	r10,r9
800102c8:	c7 d3       	brcs	800103c2 <get_XY+0x1ee>
800102ca:	ce fb       	rjmp	800102a8 <get_XY+0xd4>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800102cc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800102d0:	14 38       	cp.w	r8,r10
800102d2:	e0 88 00 08 	brls	800102e2 <get_XY+0x10e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800102d6:	12 38       	cp.w	r8,r9
800102d8:	fe 98 ff fa 	brls	800102cc <get_XY+0xf8>
800102dc:	12 3a       	cp.w	r10,r9
800102de:	c7 d3       	brcs	800103d8 <get_XY+0x204>
800102e0:	cf 6b       	rjmp	800102cc <get_XY+0xf8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800102e2:	12 38       	cp.w	r8,r9
800102e4:	e0 8b 00 7a 	brhi	800103d8 <get_XY+0x204>
800102e8:	12 3a       	cp.w	r10,r9
800102ea:	c7 73       	brcs	800103d8 <get_XY+0x204>
800102ec:	cf 0b       	rjmp	800102cc <get_XY+0xf8>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800102ee:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800102f2:	14 38       	cp.w	r8,r10
800102f4:	e0 88 00 09 	brls	80010306 <get_XY+0x132>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800102f8:	12 38       	cp.w	r8,r9
800102fa:	fe 98 ff fa 	brls	800102ee <get_XY+0x11a>
800102fe:	12 3a       	cp.w	r10,r9
80010300:	e0 83 00 88 	brlo	80010410 <get_XY+0x23c>
80010304:	cf 5b       	rjmp	800102ee <get_XY+0x11a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010306:	12 38       	cp.w	r8,r9
80010308:	e0 8b 00 84 	brhi	80010410 <get_XY+0x23c>
8001030c:	12 3a       	cp.w	r10,r9
8001030e:	e0 83 00 81 	brlo	80010410 <get_XY+0x23c>
80010312:	ce eb       	rjmp	800102ee <get_XY+0x11a>
	delay_ms(1);
	adc_enable(&AVR32_ADC,0);
80010314:	30 0b       	mov	r11,0
80010316:	fe 7c 3c 00 	mov	r12,-50176
8001031a:	f0 1f 00 49 	mcall	8001043c <get_XY+0x268>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001031e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010322:	e0 69 ea 60 	mov	r9,60000
80010326:	f0 09 00 0a 	add	r10,r8,r9
8001032a:	c7 ab       	rjmp	8001021e <get_XY+0x4a>
	delay_ms(1);
	adc_start(&AVR32_ADC);
8001032c:	fe 7c 3c 00 	mov	r12,-50176
80010330:	f0 1f 00 44 	mcall	80010440 <get_XY+0x26c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010334:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010338:	e0 69 ea 60 	mov	r9,60000
8001033c:	f0 09 00 0a 	add	r10,r8,r9
80010340:	c8 0b       	rjmp	80010240 <get_XY+0x6c>
	delay_ms(1);
	X=adc_get_value(&AVR32_ADC,0)*.4;	//Lectura y linealizacion
80010342:	30 0b       	mov	r11,0
80010344:	fe 7c 3c 00 	mov	r12,-50176
80010348:	f0 1f 00 3f 	mcall	80010444 <get_XY+0x270>
8001034c:	f0 1f 00 3f 	mcall	80010448 <get_XY+0x274>
80010350:	e0 68 99 9a 	mov	r8,39322
80010354:	ea 18 99 99 	orh	r8,0x9999
80010358:	e0 69 99 99 	mov	r9,39321
8001035c:	ea 19 3f d9 	orh	r9,0x3fd9
80010360:	f0 1f 00 3b 	mcall	8001044c <get_XY+0x278>
80010364:	f0 1f 00 3b 	mcall	80010450 <get_XY+0x27c>
80010368:	4b b8       	lddpc	r8,80010454 <get_XY+0x280>
8001036a:	91 0c       	st.w	r8[0x0],r12
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001036c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010370:	e0 69 ea 60 	mov	r9,60000
80010374:	f0 09 00 0a 	add	r10,r8,r9
80010378:	c7 5b       	rjmp	80010262 <get_XY+0x8e>
	delay_ms(1);
	adc_disable(&AVR32_ADC,0);
8001037a:	30 0b       	mov	r11,0
8001037c:	fe 7c 3c 00 	mov	r12,-50176
80010380:	f0 1f 00 36 	mcall	80010458 <get_XY+0x284>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010384:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010388:	e0 69 ea 60 	mov	r9,60000
8001038c:	f0 09 00 0a 	add	r10,r8,r9
80010390:	c7 bb       	rjmp	80010286 <get_XY+0xb2>
	delay_ms(1);
	gpio_enable_gpio_pin(T_t);	//Reinicializacion de pines
80010392:	33 ec       	mov	r12,62
80010394:	f0 1f 00 27 	mcall	80010430 <get_XY+0x25c>
	gpio_enable_gpio_pin(T_b);
80010398:	31 7c       	mov	r12,23
8001039a:	f0 1f 00 26 	mcall	80010430 <get_XY+0x25c>
	gpio_set_gpio_pin(T_l);		//Polarizacion de la pantalla
8001039e:	31 5c       	mov	r12,21
800103a0:	f0 1f 00 25 	mcall	80010434 <get_XY+0x260>
	gpio_clr_gpio_pin(T_r);
800103a4:	33 fc       	mov	r12,63
800103a6:	f0 1f 00 25 	mcall	80010438 <get_XY+0x264>
	adc_enable(&AVR32_ADC,2);
800103aa:	30 2b       	mov	r11,2
800103ac:	fe 7c 3c 00 	mov	r12,-50176
800103b0:	f0 1f 00 23 	mcall	8001043c <get_XY+0x268>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800103b4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800103b8:	e0 69 ea 60 	mov	r9,60000
800103bc:	f0 09 00 0a 	add	r10,r8,r9
800103c0:	c7 4b       	rjmp	800102a8 <get_XY+0xd4>
	delay_ms(1);
	adc_start(&AVR32_ADC);
800103c2:	fe 7c 3c 00 	mov	r12,-50176
800103c6:	f0 1f 00 1f 	mcall	80010440 <get_XY+0x26c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800103ca:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800103ce:	e0 69 ea 60 	mov	r9,60000
800103d2:	f0 09 00 0a 	add	r10,r8,r9
800103d6:	c7 bb       	rjmp	800102cc <get_XY+0xf8>
	delay_ms(1);
	Y=adc_get_value(&AVR32_ADC,2)*.3;	//Lectura y linealizacion
800103d8:	30 2b       	mov	r11,2
800103da:	fe 7c 3c 00 	mov	r12,-50176
800103de:	f0 1f 00 1a 	mcall	80010444 <get_XY+0x270>
800103e2:	f0 1f 00 1a 	mcall	80010448 <get_XY+0x274>
800103e6:	e0 68 33 33 	mov	r8,13107
800103ea:	ea 18 33 33 	orh	r8,0x3333
800103ee:	e0 69 33 33 	mov	r9,13107
800103f2:	ea 19 3f d3 	orh	r9,0x3fd3
800103f6:	f0 1f 00 16 	mcall	8001044c <get_XY+0x278>
800103fa:	f0 1f 00 16 	mcall	80010450 <get_XY+0x27c>
800103fe:	49 88       	lddpc	r8,8001045c <get_XY+0x288>
80010400:	91 0c       	st.w	r8[0x0],r12
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010402:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010406:	e0 69 ea 60 	mov	r9,60000
8001040a:	f0 09 00 0a 	add	r10,r8,r9
8001040e:	c7 0b       	rjmp	800102ee <get_XY+0x11a>
	delay_ms(1);
	adc_disable(&AVR32_ADC,2);
80010410:	30 2b       	mov	r11,2
80010412:	fe 7c 3c 00 	mov	r12,-50176
80010416:	f0 1f 00 11 	mcall	80010458 <get_XY+0x284>
	//Eliminacion de Offset
	Y=270-Y;
8001041a:	49 18       	lddpc	r8,8001045c <get_XY+0x288>
8001041c:	70 09       	ld.w	r9,r8[0x0]
8001041e:	e0 6a 01 0e 	mov	r10,270
80010422:	12 1a       	sub	r10,r9
80010424:	91 0a       	st.w	r8[0x0],r10
	X=X-50;
80010426:	48 c8       	lddpc	r8,80010454 <get_XY+0x280>
80010428:	70 09       	ld.w	r9,r8[0x0]
8001042a:	23 29       	sub	r9,50
8001042c:	91 09       	st.w	r8[0x0],r9
}
8001042e:	d8 02       	popm	pc
80010430:	80 00       	ld.sh	r0,r0[0x0]
80010432:	6c 34       	ld.w	r4,r6[0xc]
80010434:	80 00       	ld.sh	r0,r0[0x0]
80010436:	6c 62       	ld.w	r2,r6[0x18]
80010438:	80 00       	ld.sh	r0,r0[0x0]
8001043a:	6c 7e       	ld.w	lr,r6[0x1c]
8001043c:	80 00       	ld.sh	r0,r0[0x0]
8001043e:	2b 5c       	sub	r12,-75
80010440:	80 00       	ld.sh	r0,r0[0x0]
80010442:	2b 56       	sub	r6,-75
80010444:	80 00       	ld.sh	r0,r0[0x0]
80010446:	2b b0       	sub	r0,-69
80010448:	80 01       	ld.sh	r1,r0[0x0]
8001044a:	4c 5a       	lddpc	r10,8001055c <Pantalla+0x74>
8001044c:	80 01       	ld.sh	r1,r0[0x0]
8001044e:	4a 5c       	lddpc	r12,800104e0 <InicializarFiles+0x80>
80010450:	80 01       	ld.sh	r1,r0[0x0]
80010452:	4c 34       	lddpc	r4,8001055c <Pantalla+0x74>
80010454:	00 00       	add	r0,r0
80010456:	07 70       	ld.ub	r0,--r3
80010458:	80 00       	ld.sh	r0,r0[0x0]
8001045a:	2b 78       	sub	r8,-73
8001045c:	00 00       	add	r0,r0
8001045e:	07 74       	ld.ub	r4,--r3

80010460 <InicializarFiles>:
	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, pcl_freq_param.pba_f);
}

void InicializarFiles (void)
{
80010460:	eb cd 40 80 	pushm	r7,lr
	first_ls = true;
80010464:	30 19       	mov	r9,1
80010466:	49 78       	lddpc	r8,800104c0 <InicializarFiles+0x60>
80010468:	b0 89       	st.b	r8[0x0],r9
	if (nav_drive_get() >= nav_drive_nb() || first_ls)
8001046a:	f0 1f 00 17 	mcall	800104c4 <InicializarFiles+0x64>
8001046e:	18 97       	mov	r7,r12
80010470:	f0 1f 00 16 	mcall	800104c8 <InicializarFiles+0x68>
80010474:	f8 07 18 00 	cp.b	r7,r12
80010478:	c0 72       	brcc	80010486 <InicializarFiles+0x26>
8001047a:	49 28       	lddpc	r8,800104c0 <InicializarFiles+0x60>
8001047c:	11 89       	ld.ub	r9,r8[0x0]
8001047e:	30 08       	mov	r8,0
80010480:	f0 09 18 00 	cp.b	r9,r8
80010484:	c0 e0       	breq	800104a0 <InicializarFiles+0x40>
	{
		first_ls = false;
80010486:	30 09       	mov	r9,0
80010488:	48 e8       	lddpc	r8,800104c0 <InicializarFiles+0x60>
8001048a:	b0 89       	st.b	r8[0x0],r9
		// Reset navigators .
		nav_reset();
8001048c:	f0 1f 00 10 	mcall	800104cc <InicializarFiles+0x6c>
		// Use the last drive available as default.
		nav_drive_set(nav_drive_nb() - 1);
80010490:	f0 1f 00 0e 	mcall	800104c8 <InicializarFiles+0x68>
80010494:	20 1c       	sub	r12,1
80010496:	5c 5c       	castu.b	r12
80010498:	f0 1f 00 0e 	mcall	800104d0 <InicializarFiles+0x70>
		// Mount it.
		nav_partition_mount();
8001049c:	f0 1f 00 0e 	mcall	800104d4 <InicializarFiles+0x74>
	}
	nav_dir_name((FS_STRING)str_buff, MAX_FILE_PATH_LENGTH);
800104a0:	31 eb       	mov	r11,30
800104a2:	48 ec       	lddpc	r12,800104d8 <InicializarFiles+0x78>
800104a4:	f0 1f 00 0e 	mcall	800104dc <InicializarFiles+0x7c>
	// Try to sort items by folders
	if (!nav_filelist_first(FS_DIR))
800104a8:	30 0c       	mov	r12,0
800104aa:	f0 1f 00 0e 	mcall	800104e0 <InicializarFiles+0x80>
800104ae:	c0 41       	brne	800104b6 <InicializarFiles+0x56>
	{
		// Sort items by files
		nav_filelist_first(FS_FILE);
800104b0:	30 1c       	mov	r12,1
800104b2:	f0 1f 00 0c 	mcall	800104e0 <InicializarFiles+0x80>
	}
	nav_filelist_reset();
800104b6:	f0 1f 00 0c 	mcall	800104e4 <InicializarFiles+0x84>
}
800104ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800104be:	00 00       	add	r0,r0
800104c0:	00 00       	add	r0,r0
800104c2:	06 89       	andn	r9,r3
800104c4:	80 00       	ld.sh	r0,r0[0x0]
800104c6:	52 84       	stdsp	sp[0xa0],r4
800104c8:	80 00       	ld.sh	r0,r0[0x0]
800104ca:	5c 08       	acr	r8
800104cc:	80 00       	ld.sh	r0,r0[0x0]
800104ce:	5c 5c       	castu.b	r12
800104d0:	80 00       	ld.sh	r0,r0[0x0]
800104d2:	59 94       	cp.w	r4,25
800104d4:	80 00       	ld.sh	r0,r0[0x0]
800104d6:	59 4c       	cp.w	r12,20
800104d8:	00 00       	add	r0,r0
800104da:	06 94       	mov	r4,r3
800104dc:	80 00       	ld.sh	r0,r0[0x0]
800104de:	56 78       	stdsp	sp[0x19c],r8
800104e0:	80 00       	ld.sh	r0,r0[0x0]
800104e2:	57 bc       	stdsp	sp[0x1ec],r12
800104e4:	80 00       	ld.sh	r0,r0[0x0]
800104e6:	55 54       	stdsp	sp[0x154],r4

800104e8 <Pantalla>:
	file_close();

}

void Pantalla(void)
{
800104e8:	eb cd 40 c0 	pushm	r6-r7,lr
800104ec:	20 cd       	sub	sp,48
	avr32_pwm_channel_t pwm_channel6 =
	{
		.cdty = 0,
		.cprd = 100
	};
800104ee:	30 08       	mov	r8,0
800104f0:	30 09       	mov	r9,0
800104f2:	fa e9 00 10 	st.d	sp[16],r8
800104f6:	fa e9 00 18 	st.d	sp[24],r8
800104fa:	fa e9 00 20 	st.d	sp[32],r8
800104fe:	fa e9 00 28 	st.d	sp[40],r8
80010502:	36 48       	mov	r8,100
80010504:	50 68       	stdsp	sp[0x18],r8
	{
		.diva = 0,
		.divb = 0,
		.prea = 0,
		.preb = 0
	};
80010506:	30 08       	mov	r8,0
80010508:	50 08       	stdsp	sp[0x0],r8
8001050a:	50 18       	stdsp	sp[0x4],r8
8001050c:	50 28       	stdsp	sp[0x8],r8
8001050e:	50 38       	stdsp	sp[0xc],r8
	pwm_init(&opt);
80010510:	1a 9c       	mov	r12,sp
80010512:	f0 1f 00 1e 	mcall	80010588 <Pantalla+0xa0>
	pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
80010516:	40 48       	lddsp	r8,sp[0x10]
80010518:	e0 18 f8 ff 	andl	r8,0xf8ff
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
8001051c:	a9 b8       	sbr	r8,0x9
8001051e:	30 19       	mov	r9,1
80010520:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
80010524:	50 48       	stdsp	sp[0x10],r8
	pwm_channel_init(6, &pwm_channel6);
80010526:	fa cb ff f0 	sub	r11,sp,-16
8001052a:	30 6c       	mov	r12,6
8001052c:	f0 1f 00 18 	mcall	8001058c <Pantalla+0xa4>
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
80010530:	34 0c       	mov	r12,64
80010532:	f0 1f 00 18 	mcall	80010590 <Pantalla+0xa8>
	while(pwm_channel6.cdty < pwm_channel6.cprd)
	{
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80010536:	fa c6 ff f0 	sub	r6,sp,-16
8001053a:	30 67       	mov	r7,6
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
	pwm_channel_init(6, &pwm_channel6);
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
	while(pwm_channel6.cdty < pwm_channel6.cprd)
8001053c:	c1 e8       	rjmp	80010578 <Pantalla+0x90>
	{
		pwm_channel6.cdty++;
8001053e:	2f f8       	sub	r8,-1
80010540:	50 58       	stdsp	sp[0x14],r8
		pwm_channel6.cupd = pwm_channel6.cdty;
80010542:	50 88       	stdsp	sp[0x20],r8
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
80010544:	0c 9b       	mov	r11,r6
80010546:	0e 9c       	mov	r12,r7
80010548:	f0 1f 00 13 	mcall	80010594 <Pantalla+0xac>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001054c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010550:	e8 79 27 c0 	mov	r9,600000
80010554:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010558:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001055c:	14 38       	cp.w	r8,r10
8001055e:	e0 88 00 08 	brls	8001056e <Pantalla+0x86>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010562:	12 38       	cp.w	r8,r9
80010564:	fe 98 ff fa 	brls	80010558 <Pantalla+0x70>
80010568:	12 3a       	cp.w	r10,r9
8001056a:	c0 73       	brcs	80010578 <Pantalla+0x90>
8001056c:	cf 6b       	rjmp	80010558 <Pantalla+0x70>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001056e:	12 38       	cp.w	r8,r9
80010570:	e0 8b 00 04 	brhi	80010578 <Pantalla+0x90>
80010574:	12 3a       	cp.w	r10,r9
80010576:	cf 12       	brcc	80010558 <Pantalla+0x70>
	pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
	pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
	pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
	pwm_channel_init(6, &pwm_channel6);
	pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
	while(pwm_channel6.cdty < pwm_channel6.cprd)
80010578:	40 58       	lddsp	r8,sp[0x14]
8001057a:	40 69       	lddsp	r9,sp[0x18]
8001057c:	12 38       	cp.w	r8,r9
8001057e:	ce 03       	brcs	8001053e <Pantalla+0x56>
		pwm_channel6.cdty++;
		pwm_channel6.cupd = pwm_channel6.cdty;
		pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
		delay_ms(10);
	}
}
80010580:	2f 4d       	sub	sp,-48
80010582:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80010586:	00 00       	add	r0,r0
80010588:	80 00       	ld.sh	r0,r0[0x0]
8001058a:	71 d8       	ld.w	r8,r8[0x74]
8001058c:	80 00       	ld.sh	r0,r0[0x0]
8001058e:	71 68       	ld.w	r8,r8[0x58]
80010590:	80 00       	ld.sh	r0,r0[0x0]
80010592:	71 9e       	ld.w	lr,r8[0x64]
80010594:	80 00       	ld.sh	r0,r0[0x0]
80010596:	71 b0       	ld.w	r0,r8[0x6c]

80010598 <Writefile>:
	file_close();

}

void Writefile(char *Files)
{
80010598:	eb cd 40 f8 	pushm	r3-r7,lr
8001059c:	20 ed       	sub	sp,56
	nav_setcwd(Files, true, true);
8001059e:	30 1a       	mov	r10,1
800105a0:	14 9b       	mov	r11,r10
800105a2:	f0 1f 00 3a 	mcall	80010688 <Writefile+0xf0>
	file_open(FOPEN_MODE_APPEND);
800105a6:	30 2c       	mov	r12,2
800105a8:	f0 1f 00 39 	mcall	8001068c <Writefile+0xf4>
	U16 *puntero;
	puntero = RawImg;
800105ac:	4b 98       	lddpc	r8,80010690 <Writefile+0xf8>
800105ae:	70 04       	ld.w	r4,r8[0x0]
	int Value1;
	uint8_t r;
	uint8_t g;
	uint8_t b;
	const unsigned char Header[]={0x42, 0x4D,0x36,0x84, 0x03,0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00,0x00 ,0xF0 ,0x00 ,0x00 ,0x00, 0x01 ,0x00 ,0x18 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x84 ,0x03 ,0x00 ,0xC4 ,0x0E ,0x00 ,0x00 ,0xC4 ,0x0E ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00};
800105b0:	4b 98       	lddpc	r8,80010694 <Writefile+0xfc>
800105b2:	1a 96       	mov	r6,sp
800105b4:	f0 ea 00 00 	ld.d	r10,r8[0]
800105b8:	fa eb 00 00 	st.d	sp[0],r10
800105bc:	f0 ea 00 08 	ld.d	r10,r8[8]
800105c0:	fa eb 00 08 	st.d	sp[8],r10
800105c4:	f0 ea 00 10 	ld.d	r10,r8[16]
800105c8:	fa eb 00 10 	st.d	sp[16],r10
800105cc:	f0 ea 00 18 	ld.d	r10,r8[24]
800105d0:	fa eb 00 18 	st.d	sp[24],r10
800105d4:	f0 ea 00 20 	ld.d	r10,r8[32]
800105d8:	fa eb 00 20 	st.d	sp[32],r10
800105dc:	f0 ea 00 28 	ld.d	r10,r8[40]
800105e0:	fa eb 00 28 	st.d	sp[40],r10
800105e4:	70 c9       	ld.w	r9,r8[0x30]
800105e6:	50 c9       	stdsp	sp[0x30],r9
800105e8:	f1 39 00 34 	ld.ub	r9,r8[52]
800105ec:	fb 69 00 34 	st.b	sp[52],r9
800105f0:	f1 38 00 35 	ld.ub	r8,r8[53]
800105f4:	fb 68 00 35 	st.b	sp[53],r8
800105f8:	fc 34 aa 80 	sub	r4,-152960
	// Close the file.
	file_close();

}

void Writefile(char *Files)
800105fc:	fa c7 ff ca 	sub	r7,sp,-54
	{
		puntero++;
	}
	for (int k=0;k<(sizeof(Header)/sizeof(Header[0]));k++)
	{
		file_putc(Header[k]);
80010600:	0d 3c       	ld.ub	r12,r6++
80010602:	f0 1f 00 26 	mcall	80010698 <Writefile+0x100>
	const unsigned char Header[]={0x42, 0x4D,0x36,0x84, 0x03,0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00,0x00 ,0xF0 ,0x00 ,0x00 ,0x00, 0x01 ,0x00 ,0x18 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x84 ,0x03 ,0x00 ,0xC4 ,0x0E ,0x00 ,0x00 ,0xC4 ,0x0E ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00};
	for(int k=0;k<76480;k++)
	{
		puntero++;
	}
	for (int k=0;k<(sizeof(Header)/sizeof(Header[0]));k++)
80010606:	0e 36       	cp.w	r6,r7
80010608:	cf c1       	brne	80010600 <Writefile+0x68>
8001060a:	30 05       	mov	r5,0
8001060c:	0a 96       	mov	r6,r5
		file_putc(b);
		file_putc(g);
		file_putc(r);
		puntero++;
		l++;
		if(l==320)
8001060e:	0a 93       	mov	r3,r5
		file_putc(Header[k]);
	}
	int l=0;
	for (int k=0;k<76800;k++)
	{
		Value1=*puntero&0xFFFF;
80010610:	09 27       	ld.uh	r7,r4++
		r = ((((Value1 >> 11) & 0x1F) * 527) + 23) >> 6;
		g = ((((Value1 >> 5) & 0x3F) * 259) + 33) >> 6;
		b = (((Value1 & 0x1F) * 527) + 23) >> 6;
		file_putc(b);
80010612:	f1 d7 c0 05 	bfextu	r8,r7,0x0,0x5
80010616:	f0 09 15 04 	lsl	r9,r8,0x4
8001061a:	f2 08 00 08 	add	r8,r9,r8
8001061e:	f0 0c 15 05 	lsl	r12,r8,0x5
80010622:	f8 08 01 08 	sub	r8,r12,r8
80010626:	f0 cc ff e9 	sub	r12,r8,-23
8001062a:	f9 dc c0 c8 	bfextu	r12,r12,0x6,0x8
8001062e:	f0 1f 00 1b 	mcall	80010698 <Writefile+0x100>
		file_putc(g);
80010632:	f1 d7 c0 a6 	bfextu	r8,r7,0x5,0x6
80010636:	f0 0c 15 07 	lsl	r12,r8,0x7
8001063a:	10 0c       	add	r12,r8
8001063c:	f0 0c 00 18 	add	r8,r8,r12<<0x1
80010640:	f0 cc ff df 	sub	r12,r8,-33
80010644:	f9 dc c0 c8 	bfextu	r12,r12,0x6,0x8
80010648:	f0 1f 00 14 	mcall	80010698 <Writefile+0x100>
		file_putc(r);
8001064c:	ab 97       	lsr	r7,0xb
8001064e:	ee 08 15 04 	lsl	r8,r7,0x4
80010652:	f0 07 00 07 	add	r7,r8,r7
80010656:	ee 0c 15 05 	lsl	r12,r7,0x5
8001065a:	0e 1c       	sub	r12,r7
8001065c:	2e 9c       	sub	r12,-23
8001065e:	f9 dc c0 c8 	bfextu	r12,r12,0x6,0x8
80010662:	f0 1f 00 0e 	mcall	80010698 <Writefile+0x100>
		puntero++;
		l++;
80010666:	2f f6       	sub	r6,-1
		if(l==320)
80010668:	e0 46 01 40 	cp.w	r6,320
8001066c:	c0 41       	brne	80010674 <Writefile+0xdc>
8001066e:	e8 c4 05 00 	sub	r4,r4,1280
80010672:	06 96       	mov	r6,r3
	for (int k=0;k<(sizeof(Header)/sizeof(Header[0]));k++)
	{
		file_putc(Header[k]);
	}
	int l=0;
	for (int k=0;k<76800;k++)
80010674:	2f f5       	sub	r5,-1
80010676:	e0 55 2c 00 	cp.w	r5,76800
8001067a:	cc b1       	brne	80010610 <Writefile+0x78>
				puntero--;
			}
			l=0;
		}
	}
	file_close();
8001067c:	f0 1f 00 08 	mcall	8001069c <Writefile+0x104>

}
80010680:	2f 2d       	sub	sp,-56
80010682:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80010686:	00 00       	add	r0,r0
80010688:	80 00       	ld.sh	r0,r0[0x0]
8001068a:	5a 44       	cp.w	r4,-28
8001068c:	80 00       	ld.sh	r0,r0[0x0]
8001068e:	51 e4       	stdsp	sp[0x78],r4
80010690:	00 00       	add	r0,r0
80010692:	0d 28       	ld.uh	r8,r6++
80010694:	80 01       	ld.sh	r1,r0[0x0]
80010696:	fd c0       	*unknown*
80010698:	80 00       	ld.sh	r0,r0[0x0]
8001069a:	51 08       	stdsp	sp[0x40],r8
8001069c:	80 00       	ld.sh	r0,r0[0x0]
8001069e:	50 cc       	stdsp	sp[0x30],r12

800106a0 <Readfile>:
	}
	jpeg_lib_exit();
}

void Readfile(char *Files,unsigned char *Buffer,int Tam)
{
800106a0:	eb cd 40 c0 	pushm	r6-r7,lr
800106a4:	16 97       	mov	r7,r11
800106a6:	14 96       	mov	r6,r10
	nav_setcwd(Files, true, false);
800106a8:	30 0a       	mov	r10,0
800106aa:	30 1b       	mov	r11,1
800106ac:	f0 1f 00 0d 	mcall	800106e0 <Readfile+0x40>
	file_open(FOPEN_MODE_R);
800106b0:	30 9c       	mov	r12,9
800106b2:	f0 1f 00 0d 	mcall	800106e4 <Readfile+0x44>
	for (int i=0;i<Tam;i++)
800106b6:	58 06       	cp.w	r6,0
800106b8:	e0 8a 00 0d 	brle	800106d2 <Readfile+0x32>
800106bc:	30 08       	mov	r8,0
	{
		Buffer[i]=0;
800106be:	30 09       	mov	r9,0
800106c0:	ee 08 0b 09 	st.b	r7[r8],r9

void Readfile(char *Files,unsigned char *Buffer,int Tam)
{
	nav_setcwd(Files, true, false);
	file_open(FOPEN_MODE_R);
	for (int i=0;i<Tam;i++)
800106c4:	2f f8       	sub	r8,-1
800106c6:	0c 38       	cp.w	r8,r6
800106c8:	cf c1       	brne	800106c0 <Readfile+0x20>
800106ca:	c0 48       	rjmp	800106d2 <Readfile+0x32>
		Buffer[i]=0;
	}
	int k=0;
	while (!file_eof())
	{
		Buffer[k]=file_getc();
800106cc:	f0 1f 00 07 	mcall	800106e8 <Readfile+0x48>
800106d0:	0e cc       	st.b	r7++,r12
	for (int i=0;i<Tam;i++)
	{
		Buffer[i]=0;
	}
	int k=0;
	while (!file_eof())
800106d2:	f0 1f 00 07 	mcall	800106ec <Readfile+0x4c>
800106d6:	cf b0       	breq	800106cc <Readfile+0x2c>
	{
		Buffer[k]=file_getc();
		k++;
	}
	// Close the file.
	file_close();
800106d8:	f0 1f 00 06 	mcall	800106f0 <Readfile+0x50>

}
800106dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800106e0:	80 00       	ld.sh	r0,r0[0x0]
800106e2:	5a 44       	cp.w	r4,-28
800106e4:	80 00       	ld.sh	r0,r0[0x0]
800106e6:	51 e4       	stdsp	sp[0x78],r4
800106e8:	80 00       	ld.sh	r0,r0[0x0]
800106ea:	51 78       	stdsp	sp[0x5c],r8
800106ec:	80 00       	ld.sh	r0,r0[0x0]
800106ee:	50 a8       	stdsp	sp[0x28],r8
800106f0:	80 00       	ld.sh	r0,r0[0x0]
800106f2:	50 cc       	stdsp	sp[0x30],r12

800106f4 <InicializarFondo>:
	nav_filelist_reset();
}


void InicializarFondo(void)
{
800106f4:	eb cd 40 80 	pushm	r7,lr
800106f8:	fa cd 32 5c 	sub	sp,sp,12892
	if (!jpeg_lib_init())						// JPEG IJG lib initialization
800106fc:	f0 1f 00 1a 	mcall	80010764 <InicializarFondo+0x70>
80010700:	c0 51       	brne	8001070a <InicializarFondo+0x16>
	{
		print_dbg("\r\n Initialization failed");
80010702:	49 ac       	lddpc	r12,80010768 <InicializarFondo+0x74>
80010704:	f0 1f 00 1a 	mcall	8001076c <InicializarFondo+0x78>
80010708:	c0 08       	rjmp	80010708 <InicializarFondo+0x14>
		while (1);
	}
	unsigned char Buffer[12888];
	Readfile("EVKinst.jpg",&Buffer,(sizeof(Buffer)/sizeof(Buffer[0])));
8001070a:	fa c7 ff fc 	sub	r7,sp,-4
8001070e:	e0 6a 32 58 	mov	r10,12888
80010712:	0e 9b       	mov	r11,r7
80010714:	49 7c       	lddpc	r12,80010770 <InicializarFondo+0x7c>
80010716:	f0 1f 00 18 	mcall	80010774 <InicializarFondo+0x80>
	stream_jpeg_src_ptr = Buffer;
8001071a:	49 88       	lddpc	r8,80010778 <InicializarFondo+0x84>
8001071c:	91 07       	st.w	r8[0x0],r7
	stream_src_size = sizeof Buffer/sizeof Buffer[0];
8001071e:	e0 69 32 58 	mov	r9,12888
80010722:	49 78       	lddpc	r8,8001077c <InicializarFondo+0x88>
80010724:	b0 09       	st.h	r8[0x0],r9
	// main decoder
	U16 width;
	U16 height;
	width= 320;
80010726:	e0 68 01 40 	mov	r8,320
8001072a:	ba 18       	st.h	sp[0x2],r8
	height= 240;
8001072c:	e0 68 00 f0 	mov	r8,240
80010730:	ba 08       	st.h	sp[0x0],r8
	RawImg  = (et024006_color_t const *)jpeg_lib_decode_ex(0, &width, &height);
80010732:	1a 9a       	mov	r10,sp
80010734:	fa cb ff fe 	sub	r11,sp,-2
80010738:	30 0c       	mov	r12,0
8001073a:	f0 1f 00 12 	mcall	80010780 <InicializarFondo+0x8c>
8001073e:	49 28       	lddpc	r8,80010784 <InicializarFondo+0x90>
80010740:	91 0c       	st.w	r8[0x0],r12
	et024006_PutPixmap(RawImg , width, 0, 0, 0,0, width, height);
80010742:	9a 9b       	ld.uh	r11,sp[0x2]
80010744:	9a 88       	ld.uh	r8,sp[0x0]
80010746:	1a d8       	st.w	--sp,r8
80010748:	1a db       	st.w	--sp,r11
8001074a:	30 0a       	mov	r10,0
8001074c:	1a da       	st.w	--sp,r10
8001074e:	14 98       	mov	r8,r10
80010750:	14 99       	mov	r9,r10
80010752:	f0 1f 00 0e 	mcall	80010788 <InicializarFondo+0x94>
	jpeg_lib_exit();
80010756:	f0 1f 00 0e 	mcall	8001078c <InicializarFondo+0x98>
8001075a:	2f dd       	sub	sp,-12
}
8001075c:	fe 3d cd a4 	sub	sp,-12892
80010760:	e3 cd 80 80 	ldm	sp++,r7,pc
80010764:	80 01       	ld.sh	r1,r0[0x0]
80010766:	47 88       	lddsp	r8,sp[0x1e0]
80010768:	80 01       	ld.sh	r1,r0[0x0]
8001076a:	fe 0c       	*unknown*
8001076c:	80 00       	ld.sh	r0,r0[0x0]
8001076e:	73 e0       	ld.w	r0,r9[0x78]
80010770:	80 01       	ld.sh	r1,r0[0x0]
80010772:	fe 28 80 01 	sub	r8,-98303
80010776:	06 a0       	st.w	r3++,r0
80010778:	00 00       	add	r0,r0
8001077a:	0d 2c       	ld.uh	r12,r6++
8001077c:	00 00       	add	r0,r0
8001077e:	0d 30       	ld.ub	r0,r6++
80010780:	80 01       	ld.sh	r1,r0[0x0]
80010782:	49 68       	lddpc	r8,800107d8 <Desplegar+0x48>
80010784:	00 00       	add	r0,r0
80010786:	0d 28       	ld.uh	r8,r6++
80010788:	80 00       	ld.sh	r0,r0[0x0]
8001078a:	63 3c       	ld.w	r12,r1[0x4c]
8001078c:	80 01       	ld.sh	r1,r0[0x0]
8001078e:	47 48       	lddsp	r8,sp[0x1d0]

80010790 <Desplegar>:
		delay_ms(500);
	}
}

void Desplegar (void)
{
80010790:	d4 31       	pushm	r0-r7,lr
80010792:	1a 97       	mov	r7,sp
80010794:	20 4d       	sub	sp,16
			et024006_PrintString(str_buff,FONT8x16,width,height*(counter-1),BLACK,WHITE);
		}
		counter++;
	}
	jpeg_lib_exit();
}
80010796:	ef 4d ff f8 	st.w	r7[-8],sp
	}
}

void Desplegar (void)
{
	nav_filelist_reset();
8001079a:	f0 1f 00 40 	mcall	80010898 <Desplegar+0x108>
	int counter=0;
	if (!jpeg_lib_init())						// JPEG IJG lib initialization
8001079e:	f0 1f 00 40 	mcall	8001089c <Desplegar+0x10c>
800107a2:	c0 c0       	breq	800107ba <Desplegar+0x2a>
800107a4:	4b f6       	lddpc	r6,800108a0 <Desplegar+0x110>
800107a6:	21 e6       	sub	r6,30
800107a8:	4b f5       	lddpc	r5,800108a4 <Desplegar+0x114>
800107aa:	20 45       	sub	r5,4
800107ac:	3f f3       	mov	r3,-1
	{
		print_dbg("\r\n Initialization failed");
		while (1);
	}
	while (nav_filelist_set(0, FS_FIND_NEXT))
800107ae:	30 12       	mov	r2,1
800107b0:	30 04       	mov	r4,0
	{
		if(counter>0 && counter<5)
		{
			nav_file_name((FS_STRING)str_buff, MAX_FILE_PATH_LENGTH, FS_NAME_GET, true);
800107b2:	4b e1       	lddpc	r1,800108a8 <Desplegar+0x118>
800107b4:	ef 43 ff f0 	st.w	r7[-16],r3
800107b8:	c6 48       	rjmp	80010880 <Desplegar+0xf0>
{
	nav_filelist_reset();
	int counter=0;
	if (!jpeg_lib_init())						// JPEG IJG lib initialization
	{
		print_dbg("\r\n Initialization failed");
800107ba:	4b dc       	lddpc	r12,800108ac <Desplegar+0x11c>
800107bc:	f0 1f 00 3d 	mcall	800108b0 <Desplegar+0x120>
800107c0:	c0 08       	rjmp	800107c0 <Desplegar+0x30>
		while (1);
	}
	while (nav_filelist_set(0, FS_FIND_NEXT))
	{
		if(counter>0 && counter<5)
800107c2:	ee f9 ff f0 	ld.w	r9,r7[-16]
800107c6:	58 39       	cp.w	r9,3
800107c8:	e0 8b 00 55 	brhi	80010872 <Desplegar+0xe2>
800107cc:	ef 4d ff f4 	st.w	r7[-12],sp
		{
			nav_file_name((FS_STRING)str_buff, MAX_FILE_PATH_LENGTH, FS_NAME_GET, true);
800107d0:	04 99       	mov	r9,r2
800107d2:	04 9a       	mov	r10,r2
800107d4:	31 eb       	mov	r11,30
800107d6:	02 9c       	mov	r12,r1
800107d8:	f0 1f 00 37 	mcall	800108b4 <Desplegar+0x124>
			nav_file_name((FS_STRING)filenames[counter-1], MAX_FILE_PATH_LENGTH, FS_NAME_GET, true);
800107dc:	04 99       	mov	r9,r2
800107de:	04 9a       	mov	r10,r2
800107e0:	31 eb       	mov	r11,30
800107e2:	0c 9c       	mov	r12,r6
800107e4:	f0 1f 00 34 	mcall	800108b4 <Desplegar+0x124>
			Filessize[counter-1]=nav_file_lgt();
800107e8:	f0 1f 00 34 	mcall	800108b8 <Desplegar+0x128>
800107ec:	18 93       	mov	r3,r12
800107ee:	8b 0c       	st.w	r5[0x0],r12
			unsigned char Buffer[Filessize[counter-1]];
800107f0:	f8 c8 ff fa 	sub	r8,r12,-6
800107f4:	e0 18 ff fc 	andl	r8,0xfffc
800107f8:	10 1d       	sub	sp,r8
800107fa:	1a 90       	mov	r0,sp
			Readfile(str_buff,&Buffer,(sizeof(Buffer)/sizeof(Buffer[0])));
800107fc:	18 9a       	mov	r10,r12
800107fe:	1a 9b       	mov	r11,sp
80010800:	02 9c       	mov	r12,r1
80010802:	f0 1f 00 2f 	mcall	800108bc <Desplegar+0x12c>
			stream_jpeg_src_ptr = Buffer;
80010806:	4a f8       	lddpc	r8,800108c0 <Desplegar+0x130>
80010808:	91 0d       	st.w	r8[0x0],sp
			stream_src_size = sizeof Buffer/sizeof Buffer[0];
8001080a:	4a f9       	lddpc	r9,800108c4 <Desplegar+0x134>
8001080c:	b2 03       	st.h	r9[0x0],r3
			// main decoder
			U16 width;
			U16 height;
			width= 80;
8001080e:	35 08       	mov	r8,80
80010810:	ef 58 ff fe 	st.h	r7[-2],r8
			height= 60;
80010814:	33 c9       	mov	r9,60
80010816:	ef 59 ff fc 	st.h	r7[-4],r9
			RawImg = (et024006_color_t const *)jpeg_lib_decode_ex(0, &width, &height);
8001081a:	ee ca 00 04 	sub	r10,r7,4
8001081e:	ee cb 00 02 	sub	r11,r7,2
80010822:	08 9c       	mov	r12,r4
80010824:	f0 1f 00 29 	mcall	800108c8 <Desplegar+0x138>
80010828:	4a 98       	lddpc	r8,800108cc <Desplegar+0x13c>
8001082a:	91 0c       	st.w	r8[0x0],r12
			et024006_PutPixmap(RawImg, width, 0, 0, 0,0+height*(counter-1), width, height );
8001082c:	ef 08 ff fc 	ld.sh	r8,r7[-4]
80010830:	ef 1b ff fe 	ld.uh	r11,r7[-2]
80010834:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80010838:	1a d9       	st.w	--sp,r9
8001083a:	1a db       	st.w	--sp,r11
8001083c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80010840:	12 93       	mov	r3,r9
80010842:	a7 38       	mul	r8,r3
80010844:	5c 78       	castu.h	r8
80010846:	1a d8       	st.w	--sp,r8
80010848:	08 98       	mov	r8,r4
8001084a:	08 99       	mov	r9,r4
8001084c:	08 9a       	mov	r10,r4
8001084e:	f0 1f 00 21 	mcall	800108d0 <Desplegar+0x140>
			et024006_PrintString(str_buff,FONT8x16,width,height*(counter-1),BLACK,WHITE);
80010852:	ef 09 ff fc 	ld.sh	r9,r7[-4]
80010856:	a7 39       	mul	r9,r3
80010858:	e0 68 ff ff 	mov	r8,65535
8001085c:	1a d8       	st.w	--sp,r8
8001085e:	08 98       	mov	r8,r4
80010860:	5c 79       	castu.h	r9
80010862:	ef 1a ff fe 	ld.uh	r10,r7[-2]
80010866:	49 cb       	lddpc	r11,800108d4 <Desplegar+0x144>
80010868:	02 9c       	mov	r12,r1
8001086a:	f0 1f 00 1c 	mcall	800108d8 <Desplegar+0x148>
8001086e:	ee fd ff f4 	ld.w	sp,r7[-12]
80010872:	ee f8 ff f0 	ld.w	r8,r7[-16]
80010876:	2f f8       	sub	r8,-1
80010878:	ef 48 ff f0 	st.w	r7[-16],r8
8001087c:	2e 26       	sub	r6,-30
8001087e:	2f c5       	sub	r5,-4
	if (!jpeg_lib_init())						// JPEG IJG lib initialization
	{
		print_dbg("\r\n Initialization failed");
		while (1);
	}
	while (nav_filelist_set(0, FS_FIND_NEXT))
80010880:	04 9b       	mov	r11,r2
80010882:	08 9c       	mov	r12,r4
80010884:	f0 1f 00 16 	mcall	800108dc <Desplegar+0x14c>
80010888:	c9 d1       	brne	800107c2 <Desplegar+0x32>
			et024006_PutPixmap(RawImg, width, 0, 0, 0,0+height*(counter-1), width, height );
			et024006_PrintString(str_buff,FONT8x16,width,height*(counter-1),BLACK,WHITE);
		}
		counter++;
	}
	jpeg_lib_exit();
8001088a:	f0 1f 00 16 	mcall	800108e0 <Desplegar+0x150>
}
8001088e:	ee fd ff f8 	ld.w	sp,r7[-8]
80010892:	2f cd       	sub	sp,-16
80010894:	d8 32       	popm	r0-r7,pc
80010896:	00 00       	add	r0,r0
80010898:	80 00       	ld.sh	r0,r0[0x0]
8001089a:	55 54       	stdsp	sp[0x154],r4
8001089c:	80 01       	ld.sh	r1,r0[0x0]
8001089e:	47 88       	lddsp	r8,sp[0x1e0]
800108a0:	00 00       	add	r0,r0
800108a2:	06 e4       	st.h	--r3,r4
800108a4:	00 00       	add	r0,r0
800108a6:	0d 00       	ld.w	r0,r6++
800108a8:	00 00       	add	r0,r0
800108aa:	06 94       	mov	r4,r3
800108ac:	80 01       	ld.sh	r1,r0[0x0]
800108ae:	fe 0c       	*unknown*
800108b0:	80 00       	ld.sh	r0,r0[0x0]
800108b2:	73 e0       	ld.w	r0,r9[0x78]
800108b4:	80 00       	ld.sh	r0,r0[0x0]
800108b6:	52 d8       	stdsp	sp[0xb4],r8
800108b8:	80 00       	ld.sh	r0,r0[0x0]
800108ba:	52 cc       	stdsp	sp[0xb0],r12
800108bc:	80 01       	ld.sh	r1,r0[0x0]
800108be:	06 a0       	st.w	r3++,r0
800108c0:	00 00       	add	r0,r0
800108c2:	0d 2c       	ld.uh	r12,r6++
800108c4:	00 00       	add	r0,r0
800108c6:	0d 30       	ld.ub	r0,r6++
800108c8:	80 01       	ld.sh	r1,r0[0x0]
800108ca:	49 68       	lddpc	r8,80010920 <imgcheck4+0x3c>
800108cc:	00 00       	add	r0,r0
800108ce:	0d 28       	ld.uh	r8,r6++
800108d0:	80 00       	ld.sh	r0,r0[0x0]
800108d2:	63 3c       	ld.w	r12,r1[0x4c]
800108d4:	80 01       	ld.sh	r1,r0[0x0]
800108d6:	dc 90       	acall	0xc9
800108d8:	80 00       	ld.sh	r0,r0[0x0]
800108da:	60 18       	ld.w	r8,r0[0x4]
800108dc:	80 00       	ld.sh	r0,r0[0x0]
800108de:	53 bc       	stdsp	sp[0xec],r12
800108e0:	80 01       	ld.sh	r1,r0[0x0]
800108e2:	47 48       	lddsp	r8,sp[0x1d0]

800108e4 <imgcheck4>:
		gpio_set_gpio_pin(LED0_GPIO);
		delay_ms(500);
	}
}
void imgcheck4 (void)
{
800108e4:	d4 31       	pushm	r0-r7,lr
800108e6:	1a 97       	mov	r7,sp
800108e8:	20 bd       	sub	sp,44
		et024006_PrintString(Salirr,(const unsigned char *)&FONT8x16,260,56,BLACK,WHITE);
		step=1;
		gpio_set_gpio_pin(LED0_GPIO);
		delay_ms(500);
	}
}
800108ea:	1a 91       	mov	r1,sp
		delay_ms(500);
	}
}
void imgcheck4 (void)
{
	if ((X>0 && X<=80 && Y>180 && Y<=240 && xytot<filtro && busy==false)|| (forzada==4&&entrada==true))
800108ec:	fe f8 02 04 	ld.w	r8,pc[516]
800108f0:	70 08       	ld.w	r8,r8[0x0]
800108f2:	20 18       	sub	r8,1
800108f4:	e0 48 00 4f 	cp.w	r8,79
800108f8:	e0 8b 00 17 	brhi	80010926 <imgcheck4+0x42>
800108fc:	4f e8       	lddpc	r8,80010af4 <imgcheck4+0x210>
800108fe:	70 08       	ld.w	r8,r8[0x0]
80010900:	e0 48 00 b4 	cp.w	r8,180
80010904:	e0 8a 00 11 	brle	80010926 <imgcheck4+0x42>
80010908:	e0 48 00 f0 	cp.w	r8,240
8001090c:	e0 89 00 0d 	brgt	80010926 <imgcheck4+0x42>
80010910:	4f a8       	lddpc	r8,80010af8 <imgcheck4+0x214>
80010912:	70 08       	ld.w	r8,r8[0x0]
80010914:	58 28       	cp.w	r8,2
80010916:	e0 89 00 08 	brgt	80010926 <imgcheck4+0x42>
8001091a:	4f 98       	lddpc	r8,80010afc <imgcheck4+0x218>
8001091c:	11 89       	ld.ub	r9,r8[0x0]
8001091e:	30 08       	mov	r8,0
80010920:	f0 09 18 00 	cp.b	r9,r8
80010924:	c0 d0       	breq	8001093e <imgcheck4+0x5a>
80010926:	4f 78       	lddpc	r8,80010b00 <imgcheck4+0x21c>
80010928:	70 08       	ld.w	r8,r8[0x0]
8001092a:	58 48       	cp.w	r8,4
8001092c:	e0 81 00 de 	brne	80010ae8 <imgcheck4+0x204>
80010930:	4f 58       	lddpc	r8,80010b04 <imgcheck4+0x220>
80010932:	11 89       	ld.ub	r9,r8[0x0]
80010934:	30 08       	mov	r8,0
80010936:	f0 09 18 00 	cp.b	r9,r8
8001093a:	e0 80 00 d7 	breq	80010ae8 <imgcheck4+0x204>
8001093e:	1a 92       	mov	r2,sp
	{
		entrada=false;
80010940:	30 09       	mov	r9,0
80010942:	4f 18       	lddpc	r8,80010b04 <imgcheck4+0x220>
80010944:	b0 89       	st.b	r8[0x0],r9
		forzada=4;
80010946:	30 49       	mov	r9,4
80010948:	4e e8       	lddpc	r8,80010b00 <imgcheck4+0x21c>
8001094a:	91 09       	st.w	r8[0x0],r9
		busy=true;
8001094c:	30 19       	mov	r9,1
8001094e:	4e c8       	lddpc	r8,80010afc <imgcheck4+0x218>
80010950:	b0 89       	st.b	r8[0x0],r9
		if (!jpeg_lib_init())						// JPEG IJG lib initialization
80010952:	f0 1f 00 6e 	mcall	80010b08 <imgcheck4+0x224>
80010956:	c0 51       	brne	80010960 <imgcheck4+0x7c>
		{
			print_dbg("\r\n Initialization failed");
80010958:	4e dc       	lddpc	r12,80010b0c <imgcheck4+0x228>
8001095a:	f0 1f 00 6e 	mcall	80010b10 <imgcheck4+0x22c>
8001095e:	c0 08       	rjmp	8001095e <imgcheck4+0x7a>
			while (1);
		}
		unsigned char Buffer[Filessize[3]];
80010960:	4e d8       	lddpc	r8,80010b14 <imgcheck4+0x230>
80010962:	70 35       	ld.w	r5,r8[0xc]
80010964:	ea c8 ff fa 	sub	r8,r5,-6
80010968:	e0 18 ff fc 	andl	r8,0xfffc
8001096c:	10 1d       	sub	sp,r8
		Readfile(filenames[3],&Buffer,(sizeof(Buffer)/sizeof(Buffer[0])));
8001096e:	0a 9a       	mov	r10,r5
80010970:	1a 9b       	mov	r11,sp
80010972:	4e ac       	lddpc	r12,80010b18 <imgcheck4+0x234>
80010974:	2a 6c       	sub	r12,-90
80010976:	f0 1f 00 6a 	mcall	80010b1c <imgcheck4+0x238>
		stream_jpeg_src_ptr = Buffer;
8001097a:	4e a8       	lddpc	r8,80010b20 <imgcheck4+0x23c>
8001097c:	91 0d       	st.w	r8[0x0],sp
		stream_src_size = sizeof Buffer/sizeof Buffer[0];
8001097e:	4e a8       	lddpc	r8,80010b24 <imgcheck4+0x240>
80010980:	b0 05       	st.h	r8[0x0],r5
		// main decoder
		U16 width;
		U16 height;
		width= 320;
80010982:	e0 68 01 40 	mov	r8,320
80010986:	ef 58 ff fe 	st.h	r7[-2],r8
		height= 240;
8001098a:	e0 68 00 f0 	mov	r8,240
8001098e:	ef 58 ff fc 	st.h	r7[-4],r8
		RawImg  = (et024006_color_t const *)jpeg_lib_decode_ex(0, &width, &height);
80010992:	ee ca 00 04 	sub	r10,r7,4
80010996:	ee cb 00 02 	sub	r11,r7,2
8001099a:	30 0c       	mov	r12,0
8001099c:	f0 1f 00 63 	mcall	80010b28 <imgcheck4+0x244>
800109a0:	4e 36       	lddpc	r6,80010b2c <imgcheck4+0x248>
800109a2:	8d 0c       	st.w	r6[0x0],r12
		et024006_PutPixmap(RawImg , width, 0, 0, 0,0, width, height);
800109a4:	ef 1b ff fe 	ld.uh	r11,r7[-2]
800109a8:	ef 18 ff fc 	ld.uh	r8,r7[-4]
800109ac:	1a d8       	st.w	--sp,r8
800109ae:	1a db       	st.w	--sp,r11
800109b0:	30 00       	mov	r0,0
800109b2:	1a d0       	st.w	--sp,r0
800109b4:	00 98       	mov	r8,r0
800109b6:	00 99       	mov	r9,r0
800109b8:	00 9a       	mov	r10,r0
800109ba:	f0 1f 00 5e 	mcall	80010b30 <imgcheck4+0x24c>
		jpeg_lib_exit();
800109be:	f0 1f 00 5e 	mcall	80010b34 <imgcheck4+0x250>
		gpio_clr_gpio_pin(LED0_GPIO);
800109c2:	33 bc       	mov	r12,59
800109c4:	f0 1f 00 5d 	mcall	80010b38 <imgcheck4+0x254>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
800109c8:	e0 63 00 f0 	mov	r3,240
800109cc:	1a d3       	st.w	--sp,r3
800109ce:	e0 6b 01 40 	mov	r11,320
800109d2:	1a db       	st.w	--sp,r11
800109d4:	1a d0       	st.w	--sp,r0
800109d6:	00 98       	mov	r8,r0
800109d8:	00 99       	mov	r9,r0
800109da:	00 9a       	mov	r10,r0
800109dc:	6c 0c       	ld.w	r12,r6[0x0]
800109de:	f0 1f 00 55 	mcall	80010b30 <imgcheck4+0x24c>
		char menuTXT[]="Menu Filtros";
800109e2:	4d 78       	lddpc	r8,80010b3c <imgcheck4+0x258>
800109e4:	ee c6 00 1c 	sub	r6,r7,28
800109e8:	f0 ea 00 00 	ld.d	r10,r8[0]
800109ec:	ec eb 00 00 	st.d	r6[0],r10
800109f0:	70 29       	ld.w	r9,r8[0x8]
800109f2:	8d 29       	st.w	r6[0x8],r9
800109f4:	f1 38 00 0c 	ld.ub	r8,r8[12]
800109f8:	ed 68 00 0c 	st.b	r6[12],r8
		et024006_DrawFilledRect(200,200,120,40,WHITE);
800109fc:	e0 68 ff ff 	mov	r8,65535
80010a00:	32 89       	mov	r9,40
80010a02:	37 8a       	mov	r10,120
80010a04:	e0 6b 00 c8 	mov	r11,200
80010a08:	16 9c       	mov	r12,r11
80010a0a:	f0 1f 00 4e 	mcall	80010b40 <imgcheck4+0x25c>
		et024006_PrintString(menuTXT,(const unsigned char *)&FONT8x16,210,210,BLACK,WHITE);
80010a0e:	4c e4       	lddpc	r4,80010b44 <imgcheck4+0x260>
80010a10:	e0 65 ff ff 	mov	r5,65535
80010a14:	1a d5       	st.w	--sp,r5
80010a16:	00 98       	mov	r8,r0
80010a18:	e0 69 00 d2 	mov	r9,210
80010a1c:	12 9a       	mov	r10,r9
80010a1e:	08 9b       	mov	r11,r4
80010a20:	0c 9c       	mov	r12,r6
80010a22:	f0 1f 00 4a 	mcall	80010b48 <imgcheck4+0x264>
		char Salir[]="Salir y Salvar";
80010a26:	4c a8       	lddpc	r8,80010b4c <imgcheck4+0x268>
80010a28:	ee c6 00 2c 	sub	r6,r7,44
80010a2c:	f0 ea 00 00 	ld.d	r10,r8[0]
80010a30:	ec eb 00 00 	st.d	r6[0],r10
80010a34:	70 29       	ld.w	r9,r8[0x8]
80010a36:	8d 29       	st.w	r6[0x8],r9
80010a38:	f1 39 00 0c 	ld.ub	r9,r8[12]
80010a3c:	ed 69 00 0c 	st.b	r6[12],r9
80010a40:	f1 39 00 0d 	ld.ub	r9,r8[13]
80010a44:	ed 69 00 0d 	st.b	r6[13],r9
80010a48:	f1 38 00 0e 	ld.ub	r8,r8[14]
80010a4c:	ed 68 00 0e 	st.b	r6[14],r8
		et024006_DrawFilledRect(200,0,140,40,WHITE);
80010a50:	0a 98       	mov	r8,r5
80010a52:	32 89       	mov	r9,40
80010a54:	e0 6a 00 8c 	mov	r10,140
80010a58:	00 9b       	mov	r11,r0
80010a5a:	e0 6c 00 c8 	mov	r12,200
80010a5e:	f0 1f 00 39 	mcall	80010b40 <imgcheck4+0x25c>
		et024006_PrintString(Salir,(const unsigned char *)&FONT8x16,200,16,BLACK,WHITE);
80010a62:	1a d5       	st.w	--sp,r5
80010a64:	00 98       	mov	r8,r0
80010a66:	31 09       	mov	r9,16
80010a68:	e0 6a 00 c8 	mov	r10,200
80010a6c:	08 9b       	mov	r11,r4
80010a6e:	0c 9c       	mov	r12,r6
80010a70:	f0 1f 00 36 	mcall	80010b48 <imgcheck4+0x264>
		char Salirr[]="Salir";
80010a74:	4b 78       	lddpc	r8,80010b50 <imgcheck4+0x26c>
80010a76:	ee c6 00 0c 	sub	r6,r7,12
80010a7a:	70 09       	ld.w	r9,r8[0x0]
80010a7c:	8d 09       	st.w	r6[0x0],r9
80010a7e:	11 c9       	ld.ub	r9,r8[0x4]
80010a80:	ac c9       	st.b	r6[0x4],r9
80010a82:	11 d8       	ld.ub	r8,r8[0x5]
80010a84:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,40,80,40,WHITE);
80010a86:	2f 8d       	sub	sp,-32
80010a88:	0a 98       	mov	r8,r5
80010a8a:	32 89       	mov	r9,40
80010a8c:	35 0a       	mov	r10,80
80010a8e:	12 9b       	mov	r11,r9
80010a90:	06 9c       	mov	r12,r3
80010a92:	f0 1f 00 2c 	mcall	80010b40 <imgcheck4+0x25c>
		et024006_PrintString(Salirr,(const unsigned char *)&FONT8x16,260,56,BLACK,WHITE);
80010a96:	1a d5       	st.w	--sp,r5
80010a98:	00 98       	mov	r8,r0
80010a9a:	33 89       	mov	r9,56
80010a9c:	e0 6a 01 04 	mov	r10,260
80010aa0:	08 9b       	mov	r11,r4
80010aa2:	0c 9c       	mov	r12,r6
80010aa4:	f0 1f 00 29 	mcall	80010b48 <imgcheck4+0x264>
		step=1;
80010aa8:	30 19       	mov	r9,1
80010aaa:	4a b8       	lddpc	r8,80010b54 <imgcheck4+0x270>
80010aac:	b0 89       	st.b	r8[0x0],r9
		gpio_set_gpio_pin(LED0_GPIO);
80010aae:	33 bc       	mov	r12,59
80010ab0:	f0 1f 00 2a 	mcall	80010b58 <imgcheck4+0x274>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010ab4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010ab8:	e0 6a c3 80 	mov	r10,50048
80010abc:	ea 1a 01 c9 	orh	r10,0x1c9
80010ac0:	f0 0a 00 0a 	add	r10,r8,r10
80010ac4:	2f fd       	sub	sp,-4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010ac6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010aca:	14 38       	cp.w	r8,r10
80010acc:	e0 88 00 08 	brls	80010adc <imgcheck4+0x1f8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010ad0:	12 38       	cp.w	r8,r9
80010ad2:	fe 98 ff fa 	brls	80010ac6 <imgcheck4+0x1e2>
80010ad6:	12 3a       	cp.w	r10,r9
80010ad8:	c0 73       	brcs	80010ae6 <imgcheck4+0x202>
80010ada:	cf 6b       	rjmp	80010ac6 <imgcheck4+0x1e2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010adc:	12 38       	cp.w	r8,r9
80010ade:	e0 8b 00 04 	brhi	80010ae6 <imgcheck4+0x202>
80010ae2:	12 3a       	cp.w	r10,r9
80010ae4:	cf 12       	brcc	80010ac6 <imgcheck4+0x1e2>
		delay_ms(500);
	}
}
80010ae6:	04 9d       	mov	sp,r2
80010ae8:	02 9d       	mov	sp,r1
80010aea:	2f 5d       	sub	sp,-44
80010aec:	d8 32       	popm	r0-r7,pc
80010aee:	00 00       	add	r0,r0
80010af0:	00 00       	add	r0,r0
80010af2:	07 70       	ld.ub	r0,--r3
80010af4:	00 00       	add	r0,r0
80010af6:	07 74       	ld.ub	r4,--r3
80010af8:	00 00       	add	r0,r0
80010afa:	07 5c       	ld.sh	r12,--r3
80010afc:	00 00       	add	r0,r0
80010afe:	07 63       	ld.uh	r3,--r3
80010b00:	00 00       	add	r0,r0
80010b02:	06 8c       	andn	r12,r3
80010b04:	00 00       	add	r0,r0
80010b06:	06 d8       	st.w	--r3,r8
80010b08:	80 01       	ld.sh	r1,r0[0x0]
80010b0a:	47 88       	lddsp	r8,sp[0x1e0]
80010b0c:	80 01       	ld.sh	r1,r0[0x0]
80010b0e:	fe 0c       	*unknown*
80010b10:	80 00       	ld.sh	r0,r0[0x0]
80010b12:	73 e0       	ld.w	r0,r9[0x78]
80010b14:	00 00       	add	r0,r0
80010b16:	0d 00       	ld.w	r0,r6++
80010b18:	00 00       	add	r0,r0
80010b1a:	06 e4       	st.h	--r3,r4
80010b1c:	80 01       	ld.sh	r1,r0[0x0]
80010b1e:	06 a0       	st.w	r3++,r0
80010b20:	00 00       	add	r0,r0
80010b22:	0d 2c       	ld.uh	r12,r6++
80010b24:	00 00       	add	r0,r0
80010b26:	0d 30       	ld.ub	r0,r6++
80010b28:	80 01       	ld.sh	r1,r0[0x0]
80010b2a:	49 68       	lddpc	r8,80010b80 <imgcheck3+0x24>
80010b2c:	00 00       	add	r0,r0
80010b2e:	0d 28       	ld.uh	r8,r6++
80010b30:	80 00       	ld.sh	r0,r0[0x0]
80010b32:	63 3c       	ld.w	r12,r1[0x4c]
80010b34:	80 01       	ld.sh	r1,r0[0x0]
80010b36:	47 48       	lddsp	r8,sp[0x1d0]
80010b38:	80 00       	ld.sh	r0,r0[0x0]
80010b3a:	6c 7e       	ld.w	lr,r6[0x1c]
80010b3c:	80 01       	ld.sh	r1,r0[0x0]
80010b3e:	fe 34 80 00 	sub	r4,-32768
80010b42:	62 94       	ld.w	r4,r1[0x24]
80010b44:	80 01       	ld.sh	r1,r0[0x0]
80010b46:	dc 90       	acall	0xc9
80010b48:	80 00       	ld.sh	r0,r0[0x0]
80010b4a:	60 18       	ld.w	r8,r0[0x4]
80010b4c:	80 01       	ld.sh	r1,r0[0x0]
80010b4e:	fe 44 80 01 	cp.w	r4,-98303
80010b52:	fe 54 00 00 	cp.w	r4,-65536
80010b56:	07 60       	ld.uh	r0,--r3
80010b58:	80 00       	ld.sh	r0,r0[0x0]
80010b5a:	6c 62       	ld.w	r2,r6[0x18]

80010b5c <imgcheck3>:
		gpio_set_gpio_pin(LED0_GPIO);
		delay_ms(500);
	}
}
void imgcheck3 (void)
{
80010b5c:	d4 31       	pushm	r0-r7,lr
80010b5e:	1a 97       	mov	r7,sp
80010b60:	20 bd       	sub	sp,44
		delay_ms(250);
		step=1;
		gpio_set_gpio_pin(LED0_GPIO);
		delay_ms(500);
	}
}
80010b62:	1a 91       	mov	r1,sp
		delay_ms(500);
	}
}
void imgcheck3 (void)
{
	if ((X>0 && X<=80 && Y>120 && Y<=180 && xytot<filtro && busy==false)|| (forzada==3&&entrada==true))
80010b64:	fe f8 02 44 	ld.w	r8,pc[580]
80010b68:	70 08       	ld.w	r8,r8[0x0]
80010b6a:	20 18       	sub	r8,1
80010b6c:	e0 48 00 4f 	cp.w	r8,79
80010b70:	e0 8b 00 1a 	brhi	80010ba4 <imgcheck3+0x48>
80010b74:	fe f8 02 38 	ld.w	r8,pc[568]
80010b78:	70 08       	ld.w	r8,r8[0x0]
80010b7a:	e0 48 00 78 	cp.w	r8,120
80010b7e:	e0 8a 00 13 	brle	80010ba4 <imgcheck3+0x48>
80010b82:	e0 48 00 b4 	cp.w	r8,180
80010b86:	e0 89 00 0f 	brgt	80010ba4 <imgcheck3+0x48>
80010b8a:	fe f8 02 26 	ld.w	r8,pc[550]
80010b8e:	70 08       	ld.w	r8,r8[0x0]
80010b90:	58 28       	cp.w	r8,2
80010b92:	e0 89 00 09 	brgt	80010ba4 <imgcheck3+0x48>
80010b96:	fe f8 02 1e 	ld.w	r8,pc[542]
80010b9a:	11 89       	ld.ub	r9,r8[0x0]
80010b9c:	30 08       	mov	r8,0
80010b9e:	f0 09 18 00 	cp.b	r9,r8
80010ba2:	c0 f0       	breq	80010bc0 <imgcheck3+0x64>
80010ba4:	fe f8 02 14 	ld.w	r8,pc[532]
80010ba8:	70 08       	ld.w	r8,r8[0x0]
80010baa:	58 38       	cp.w	r8,3
80010bac:	e0 81 00 fa 	brne	80010da0 <imgcheck3+0x244>
80010bb0:	fe f8 02 0c 	ld.w	r8,pc[524]
80010bb4:	11 89       	ld.ub	r9,r8[0x0]
80010bb6:	30 08       	mov	r8,0
80010bb8:	f0 09 18 00 	cp.b	r9,r8
80010bbc:	e0 80 00 f2 	breq	80010da0 <imgcheck3+0x244>
80010bc0:	1a 92       	mov	r2,sp
	{
		entrada=false;
80010bc2:	30 09       	mov	r9,0
80010bc4:	4f e8       	lddpc	r8,80010dbc <imgcheck3+0x260>
80010bc6:	b0 89       	st.b	r8[0x0],r9
		forzada=3;
80010bc8:	30 39       	mov	r9,3
80010bca:	4f c8       	lddpc	r8,80010db8 <imgcheck3+0x25c>
80010bcc:	91 09       	st.w	r8[0x0],r9
		busy=true;
80010bce:	30 19       	mov	r9,1
80010bd0:	4f 98       	lddpc	r8,80010db4 <imgcheck3+0x258>
80010bd2:	b0 89       	st.b	r8[0x0],r9
		if (!jpeg_lib_init())						// JPEG IJG lib initialization
80010bd4:	f0 1f 00 7b 	mcall	80010dc0 <imgcheck3+0x264>
80010bd8:	c0 51       	brne	80010be2 <imgcheck3+0x86>
		{
			print_dbg("\r\n Initialization failed");
80010bda:	4f bc       	lddpc	r12,80010dc4 <imgcheck3+0x268>
80010bdc:	f0 1f 00 7b 	mcall	80010dc8 <imgcheck3+0x26c>
80010be0:	c0 08       	rjmp	80010be0 <imgcheck3+0x84>
			while (1);
		}
		unsigned char Buffer[Filessize[2]];
80010be2:	4f b8       	lddpc	r8,80010dcc <imgcheck3+0x270>
80010be4:	70 25       	ld.w	r5,r8[0x8]
80010be6:	ea c8 ff fa 	sub	r8,r5,-6
80010bea:	e0 18 ff fc 	andl	r8,0xfffc
80010bee:	10 1d       	sub	sp,r8
		Readfile(filenames[2],&Buffer,(sizeof(Buffer)/sizeof(Buffer[0])));
80010bf0:	0a 9a       	mov	r10,r5
80010bf2:	1a 9b       	mov	r11,sp
80010bf4:	4f 7c       	lddpc	r12,80010dd0 <imgcheck3+0x274>
80010bf6:	2c 4c       	sub	r12,-60
80010bf8:	f0 1f 00 77 	mcall	80010dd4 <imgcheck3+0x278>
		stream_jpeg_src_ptr = Buffer;
80010bfc:	4f 78       	lddpc	r8,80010dd8 <imgcheck3+0x27c>
80010bfe:	91 0d       	st.w	r8[0x0],sp
		stream_src_size = sizeof Buffer/sizeof Buffer[0];
80010c00:	4f 78       	lddpc	r8,80010ddc <imgcheck3+0x280>
80010c02:	b0 05       	st.h	r8[0x0],r5
		// main decoder
		U16 width;
		U16 height;
		width= 320;
80010c04:	e0 68 01 40 	mov	r8,320
80010c08:	ef 58 ff fe 	st.h	r7[-2],r8
		height= 240;
80010c0c:	e0 68 00 f0 	mov	r8,240
80010c10:	ef 58 ff fc 	st.h	r7[-4],r8
		RawImg  = (et024006_color_t const *)jpeg_lib_decode_ex(0, &width, &height);
80010c14:	ee ca 00 04 	sub	r10,r7,4
80010c18:	ee cb 00 02 	sub	r11,r7,2
80010c1c:	30 0c       	mov	r12,0
80010c1e:	f0 1f 00 71 	mcall	80010de0 <imgcheck3+0x284>
80010c22:	4f 16       	lddpc	r6,80010de4 <imgcheck3+0x288>
80010c24:	8d 0c       	st.w	r6[0x0],r12
		et024006_PutPixmap(RawImg , width, 0, 0, 0,0, width, height);
80010c26:	ef 1b ff fe 	ld.uh	r11,r7[-2]
80010c2a:	ef 18 ff fc 	ld.uh	r8,r7[-4]
80010c2e:	1a d8       	st.w	--sp,r8
80010c30:	1a db       	st.w	--sp,r11
80010c32:	30 00       	mov	r0,0
80010c34:	1a d0       	st.w	--sp,r0
80010c36:	00 98       	mov	r8,r0
80010c38:	00 99       	mov	r9,r0
80010c3a:	00 9a       	mov	r10,r0
80010c3c:	f0 1f 00 6b 	mcall	80010de8 <imgcheck3+0x28c>
		jpeg_lib_exit();
80010c40:	f0 1f 00 6b 	mcall	80010dec <imgcheck3+0x290>
		gpio_clr_gpio_pin(LED0_GPIO);
80010c44:	33 bc       	mov	r12,59
80010c46:	f0 1f 00 6b 	mcall	80010df0 <imgcheck3+0x294>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80010c4a:	e0 63 00 f0 	mov	r3,240
80010c4e:	1a d3       	st.w	--sp,r3
80010c50:	e0 6b 01 40 	mov	r11,320
80010c54:	1a db       	st.w	--sp,r11
80010c56:	1a d0       	st.w	--sp,r0
80010c58:	00 98       	mov	r8,r0
80010c5a:	00 99       	mov	r9,r0
80010c5c:	00 9a       	mov	r10,r0
80010c5e:	6c 0c       	ld.w	r12,r6[0x0]
80010c60:	f0 1f 00 62 	mcall	80010de8 <imgcheck3+0x28c>
		char menuTXT[]="Menu Filtros";
80010c64:	4e 48       	lddpc	r8,80010df4 <imgcheck3+0x298>
80010c66:	ee c6 00 1c 	sub	r6,r7,28
80010c6a:	f0 ea 00 00 	ld.d	r10,r8[0]
80010c6e:	ec eb 00 00 	st.d	r6[0],r10
80010c72:	70 29       	ld.w	r9,r8[0x8]
80010c74:	8d 29       	st.w	r6[0x8],r9
80010c76:	f1 38 00 0c 	ld.ub	r8,r8[12]
80010c7a:	ed 68 00 0c 	st.b	r6[12],r8
		et024006_DrawFilledRect(200,200,120,40,WHITE);
80010c7e:	e0 68 ff ff 	mov	r8,65535
80010c82:	32 89       	mov	r9,40
80010c84:	37 8a       	mov	r10,120
80010c86:	e0 6b 00 c8 	mov	r11,200
80010c8a:	16 9c       	mov	r12,r11
80010c8c:	f0 1f 00 5b 	mcall	80010df8 <imgcheck3+0x29c>
		et024006_PrintString(menuTXT,(const unsigned char *)&FONT8x16,210,210,BLACK,WHITE);
80010c90:	4d b4       	lddpc	r4,80010dfc <imgcheck3+0x2a0>
80010c92:	e0 65 ff ff 	mov	r5,65535
80010c96:	1a d5       	st.w	--sp,r5
80010c98:	00 98       	mov	r8,r0
80010c9a:	e0 69 00 d2 	mov	r9,210
80010c9e:	12 9a       	mov	r10,r9
80010ca0:	08 9b       	mov	r11,r4
80010ca2:	0c 9c       	mov	r12,r6
80010ca4:	f0 1f 00 57 	mcall	80010e00 <imgcheck3+0x2a4>
		char Salir[]="Salir y Salvar";
80010ca8:	4d 78       	lddpc	r8,80010e04 <imgcheck3+0x2a8>
80010caa:	ee c6 00 2c 	sub	r6,r7,44
80010cae:	f0 ea 00 00 	ld.d	r10,r8[0]
80010cb2:	ec eb 00 00 	st.d	r6[0],r10
80010cb6:	70 29       	ld.w	r9,r8[0x8]
80010cb8:	8d 29       	st.w	r6[0x8],r9
80010cba:	f1 39 00 0c 	ld.ub	r9,r8[12]
80010cbe:	ed 69 00 0c 	st.b	r6[12],r9
80010cc2:	f1 39 00 0d 	ld.ub	r9,r8[13]
80010cc6:	ed 69 00 0d 	st.b	r6[13],r9
80010cca:	f1 38 00 0e 	ld.ub	r8,r8[14]
80010cce:	ed 68 00 0e 	st.b	r6[14],r8
		et024006_DrawFilledRect(200,0,140,40,WHITE);
80010cd2:	0a 98       	mov	r8,r5
80010cd4:	32 89       	mov	r9,40
80010cd6:	e0 6a 00 8c 	mov	r10,140
80010cda:	00 9b       	mov	r11,r0
80010cdc:	e0 6c 00 c8 	mov	r12,200
80010ce0:	f0 1f 00 46 	mcall	80010df8 <imgcheck3+0x29c>
		et024006_PrintString(Salir,(const unsigned char *)&FONT8x16,200,16,BLACK,WHITE);
80010ce4:	1a d5       	st.w	--sp,r5
80010ce6:	00 98       	mov	r8,r0
80010ce8:	31 09       	mov	r9,16
80010cea:	e0 6a 00 c8 	mov	r10,200
80010cee:	08 9b       	mov	r11,r4
80010cf0:	0c 9c       	mov	r12,r6
80010cf2:	f0 1f 00 44 	mcall	80010e00 <imgcheck3+0x2a4>
		char Salirr[]="Salir";
80010cf6:	4c 58       	lddpc	r8,80010e08 <imgcheck3+0x2ac>
80010cf8:	ee c6 00 0c 	sub	r6,r7,12
80010cfc:	70 09       	ld.w	r9,r8[0x0]
80010cfe:	8d 09       	st.w	r6[0x0],r9
80010d00:	11 c9       	ld.ub	r9,r8[0x4]
80010d02:	ac c9       	st.b	r6[0x4],r9
80010d04:	11 d8       	ld.ub	r8,r8[0x5]
80010d06:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,40,80,40,WHITE);
80010d08:	2f 8d       	sub	sp,-32
80010d0a:	0a 98       	mov	r8,r5
80010d0c:	32 89       	mov	r9,40
80010d0e:	35 0a       	mov	r10,80
80010d10:	12 9b       	mov	r11,r9
80010d12:	06 9c       	mov	r12,r3
80010d14:	f0 1f 00 39 	mcall	80010df8 <imgcheck3+0x29c>
		et024006_PrintString(Salirr,(const unsigned char *)&FONT8x16,260,56,BLACK,WHITE);
80010d18:	1a d5       	st.w	--sp,r5
80010d1a:	00 98       	mov	r8,r0
80010d1c:	33 89       	mov	r9,56
80010d1e:	e0 6a 01 04 	mov	r10,260
80010d22:	08 9b       	mov	r11,r4
80010d24:	0c 9c       	mov	r12,r6
80010d26:	f0 1f 00 37 	mcall	80010e00 <imgcheck3+0x2a4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010d2a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010d2e:	e0 6a e1 c0 	mov	r10,57792
80010d32:	ea 1a 00 e4 	orh	r10,0xe4
80010d36:	f0 0a 00 0a 	add	r10,r8,r10
80010d3a:	2f fd       	sub	sp,-4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010d3c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010d40:	14 38       	cp.w	r8,r10
80010d42:	e0 88 00 08 	brls	80010d52 <imgcheck3+0x1f6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010d46:	12 38       	cp.w	r8,r9
80010d48:	fe 98 ff fa 	brls	80010d3c <imgcheck3+0x1e0>
80010d4c:	12 3a       	cp.w	r10,r9
80010d4e:	c1 93       	brcs	80010d80 <imgcheck3+0x224>
80010d50:	cf 6b       	rjmp	80010d3c <imgcheck3+0x1e0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010d52:	12 38       	cp.w	r8,r9
80010d54:	e0 8b 00 16 	brhi	80010d80 <imgcheck3+0x224>
80010d58:	12 3a       	cp.w	r10,r9
80010d5a:	c1 33       	brcs	80010d80 <imgcheck3+0x224>
80010d5c:	cf 0b       	rjmp	80010d3c <imgcheck3+0x1e0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010d5e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010d62:	14 38       	cp.w	r8,r10
80010d64:	e0 88 00 08 	brls	80010d74 <imgcheck3+0x218>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010d68:	12 38       	cp.w	r8,r9
80010d6a:	fe 98 ff fa 	brls	80010d5e <imgcheck3+0x202>
80010d6e:	12 3a       	cp.w	r10,r9
80010d70:	c1 73       	brcs	80010d9e <imgcheck3+0x242>
80010d72:	cf 6b       	rjmp	80010d5e <imgcheck3+0x202>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80010d74:	12 38       	cp.w	r8,r9
80010d76:	e0 8b 00 14 	brhi	80010d9e <imgcheck3+0x242>
80010d7a:	12 3a       	cp.w	r10,r9
80010d7c:	c1 13       	brcs	80010d9e <imgcheck3+0x242>
80010d7e:	cf 0b       	rjmp	80010d5e <imgcheck3+0x202>
		delay_ms(250);
		step=1;
80010d80:	30 19       	mov	r9,1
80010d82:	4a 38       	lddpc	r8,80010e0c <imgcheck3+0x2b0>
80010d84:	b0 89       	st.b	r8[0x0],r9
		gpio_set_gpio_pin(LED0_GPIO);
80010d86:	33 bc       	mov	r12,59
80010d88:	f0 1f 00 22 	mcall	80010e10 <imgcheck3+0x2b4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010d8c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010d90:	e0 6a c3 80 	mov	r10,50048
80010d94:	ea 1a 01 c9 	orh	r10,0x1c9
80010d98:	f0 0a 00 0a 	add	r10,r8,r10
80010d9c:	ce 1b       	rjmp	80010d5e <imgcheck3+0x202>
80010d9e:	04 9d       	mov	sp,r2
		delay_ms(500);
	}
}
80010da0:	02 9d       	mov	sp,r1
80010da2:	2f 5d       	sub	sp,-44
80010da4:	d8 32       	popm	r0-r7,pc
80010da6:	00 00       	add	r0,r0
80010da8:	00 00       	add	r0,r0
80010daa:	07 70       	ld.ub	r0,--r3
80010dac:	00 00       	add	r0,r0
80010dae:	07 74       	ld.ub	r4,--r3
80010db0:	00 00       	add	r0,r0
80010db2:	07 5c       	ld.sh	r12,--r3
80010db4:	00 00       	add	r0,r0
80010db6:	07 63       	ld.uh	r3,--r3
80010db8:	00 00       	add	r0,r0
80010dba:	06 8c       	andn	r12,r3
80010dbc:	00 00       	add	r0,r0
80010dbe:	06 d8       	st.w	--r3,r8
80010dc0:	80 01       	ld.sh	r1,r0[0x0]
80010dc2:	47 88       	lddsp	r8,sp[0x1e0]
80010dc4:	80 01       	ld.sh	r1,r0[0x0]
80010dc6:	fe 0c       	*unknown*
80010dc8:	80 00       	ld.sh	r0,r0[0x0]
80010dca:	73 e0       	ld.w	r0,r9[0x78]
80010dcc:	00 00       	add	r0,r0
80010dce:	0d 00       	ld.w	r0,r6++
80010dd0:	00 00       	add	r0,r0
80010dd2:	06 e4       	st.h	--r3,r4
80010dd4:	80 01       	ld.sh	r1,r0[0x0]
80010dd6:	06 a0       	st.w	r3++,r0
80010dd8:	00 00       	add	r0,r0
80010dda:	0d 2c       	ld.uh	r12,r6++
80010ddc:	00 00       	add	r0,r0
80010dde:	0d 30       	ld.ub	r0,r6++
80010de0:	80 01       	ld.sh	r1,r0[0x0]
80010de2:	49 68       	lddpc	r8,80010e38 <imgcheck2+0x24>
80010de4:	00 00       	add	r0,r0
80010de6:	0d 28       	ld.uh	r8,r6++
80010de8:	80 00       	ld.sh	r0,r0[0x0]
80010dea:	63 3c       	ld.w	r12,r1[0x4c]
80010dec:	80 01       	ld.sh	r1,r0[0x0]
80010dee:	47 48       	lddsp	r8,sp[0x1d0]
80010df0:	80 00       	ld.sh	r0,r0[0x0]
80010df2:	6c 7e       	ld.w	lr,r6[0x1c]
80010df4:	80 01       	ld.sh	r1,r0[0x0]
80010df6:	fe 34 80 00 	sub	r4,-32768
80010dfa:	62 94       	ld.w	r4,r1[0x24]
80010dfc:	80 01       	ld.sh	r1,r0[0x0]
80010dfe:	dc 90       	acall	0xc9
80010e00:	80 00       	ld.sh	r0,r0[0x0]
80010e02:	60 18       	ld.w	r8,r0[0x4]
80010e04:	80 01       	ld.sh	r1,r0[0x0]
80010e06:	fe 44 80 01 	cp.w	r4,-98303
80010e0a:	fe 54 00 00 	cp.w	r4,-65536
80010e0e:	07 60       	ld.uh	r0,--r3
80010e10:	80 00       	ld.sh	r0,r0[0x0]
80010e12:	6c 62       	ld.w	r2,r6[0x18]

80010e14 <imgcheck2>:
		gpio_set_gpio_pin(LED0_GPIO);
		delay_ms(500);
	}
}
void imgcheck2 (void)
{
80010e14:	d4 31       	pushm	r0-r7,lr
80010e16:	1a 97       	mov	r7,sp
80010e18:	20 bd       	sub	sp,44
		delay_ms(250);
		step=1;
		gpio_set_gpio_pin(LED0_GPIO);
		delay_ms(500);
	}
}
80010e1a:	1a 91       	mov	r1,sp
		delay_ms(500);
	}
}
void imgcheck2 (void)
{
	if ((X>0 && X<=80 && Y>60 && Y<=120 && xytot<filtro && busy==false)|| (forzada==2&&entrada==true))
80010e1c:	fe f8 02 44 	ld.w	r8,pc[580]
80010e20:	70 08       	ld.w	r8,r8[0x0]
80010e22:	20 18       	sub	r8,1
80010e24:	e0 48 00 4f 	cp.w	r8,79
80010e28:	e0 8b 00 1a 	brhi	80010e5c <imgcheck2+0x48>
80010e2c:	fe f8 02 38 	ld.w	r8,pc[568]
80010e30:	70 08       	ld.w	r8,r8[0x0]
80010e32:	e0 48 00 3c 	cp.w	r8,60
80010e36:	e0 8a 00 13 	brle	80010e5c <imgcheck2+0x48>
80010e3a:	e0 48 00 78 	cp.w	r8,120
80010e3e:	e0 89 00 0f 	brgt	80010e5c <imgcheck2+0x48>
80010e42:	fe f8 02 26 	ld.w	r8,pc[550]
80010e46:	70 08       	ld.w	r8,r8[0x0]
80010e48:	58 28       	cp.w	r8,2
80010e4a:	e0 89 00 09 	brgt	80010e5c <imgcheck2+0x48>
80010e4e:	fe f8 02 1e 	ld.w	r8,pc[542]
80010e52:	11 89       	ld.ub	r9,r8[0x0]
80010e54:	30 08       	mov	r8,0
80010e56:	f0 09 18 00 	cp.b	r9,r8
80010e5a:	c0 f0       	breq	80010e78 <imgcheck2+0x64>
80010e5c:	fe f8 02 14 	ld.w	r8,pc[532]
80010e60:	70 08       	ld.w	r8,r8[0x0]
80010e62:	58 28       	cp.w	r8,2
80010e64:	e0 81 00 fa 	brne	80011058 <imgcheck2+0x244>
80010e68:	fe f8 02 0c 	ld.w	r8,pc[524]
80010e6c:	11 89       	ld.ub	r9,r8[0x0]
80010e6e:	30 08       	mov	r8,0
80010e70:	f0 09 18 00 	cp.b	r9,r8
80010e74:	e0 80 00 f2 	breq	80011058 <imgcheck2+0x244>
80010e78:	1a 92       	mov	r2,sp
	{
		entrada=false;
80010e7a:	30 09       	mov	r9,0
80010e7c:	4f e8       	lddpc	r8,80011074 <imgcheck2+0x260>
80010e7e:	b0 89       	st.b	r8[0x0],r9
		forzada=2;
80010e80:	30 29       	mov	r9,2
80010e82:	4f c8       	lddpc	r8,80011070 <imgcheck2+0x25c>
80010e84:	91 09       	st.w	r8[0x0],r9
		busy=true;
80010e86:	30 19       	mov	r9,1
80010e88:	4f 98       	lddpc	r8,8001106c <imgcheck2+0x258>
80010e8a:	b0 89       	st.b	r8[0x0],r9
		if (!jpeg_lib_init())						// JPEG IJG lib initialization
80010e8c:	f0 1f 00 7b 	mcall	80011078 <imgcheck2+0x264>
80010e90:	c0 51       	brne	80010e9a <imgcheck2+0x86>
		{
			print_dbg("\r\n Initialization failed");
80010e92:	4f bc       	lddpc	r12,8001107c <imgcheck2+0x268>
80010e94:	f0 1f 00 7b 	mcall	80011080 <imgcheck2+0x26c>
80010e98:	c0 08       	rjmp	80010e98 <imgcheck2+0x84>
			while (1);
		}
		unsigned char Buffer[Filessize[1]];
80010e9a:	4f b8       	lddpc	r8,80011084 <imgcheck2+0x270>
80010e9c:	70 15       	ld.w	r5,r8[0x4]
80010e9e:	ea c8 ff fa 	sub	r8,r5,-6
80010ea2:	e0 18 ff fc 	andl	r8,0xfffc
80010ea6:	10 1d       	sub	sp,r8
		Readfile(filenames[1],&Buffer,(sizeof(Buffer)/sizeof(Buffer[0])));
80010ea8:	0a 9a       	mov	r10,r5
80010eaa:	1a 9b       	mov	r11,sp
80010eac:	4f 7c       	lddpc	r12,80011088 <imgcheck2+0x274>
80010eae:	2e 2c       	sub	r12,-30
80010eb0:	f0 1f 00 77 	mcall	8001108c <imgcheck2+0x278>
		stream_jpeg_src_ptr = Buffer;
80010eb4:	4f 78       	lddpc	r8,80011090 <imgcheck2+0x27c>
80010eb6:	91 0d       	st.w	r8[0x0],sp
		stream_src_size = sizeof Buffer/sizeof Buffer[0];
80010eb8:	4f 78       	lddpc	r8,80011094 <imgcheck2+0x280>
80010eba:	b0 05       	st.h	r8[0x0],r5
		// main decoder
		U16 width;
		U16 height;
		width= 320;
80010ebc:	e0 68 01 40 	mov	r8,320
80010ec0:	ef 58 ff fe 	st.h	r7[-2],r8
		height= 240;
80010ec4:	e0 68 00 f0 	mov	r8,240
80010ec8:	ef 58 ff fc 	st.h	r7[-4],r8
		RawImg  = (et024006_color_t const *)jpeg_lib_decode_ex(0, &width, &height);
80010ecc:	ee ca 00 04 	sub	r10,r7,4
80010ed0:	ee cb 00 02 	sub	r11,r7,2
80010ed4:	30 0c       	mov	r12,0
80010ed6:	f0 1f 00 71 	mcall	80011098 <imgcheck2+0x284>
80010eda:	4f 16       	lddpc	r6,8001109c <imgcheck2+0x288>
80010edc:	8d 0c       	st.w	r6[0x0],r12
		et024006_PutPixmap(RawImg , width, 0, 0, 0,0, width, height);
80010ede:	ef 1b ff fe 	ld.uh	r11,r7[-2]
80010ee2:	ef 18 ff fc 	ld.uh	r8,r7[-4]
80010ee6:	1a d8       	st.w	--sp,r8
80010ee8:	1a db       	st.w	--sp,r11
80010eea:	30 00       	mov	r0,0
80010eec:	1a d0       	st.w	--sp,r0
80010eee:	00 98       	mov	r8,r0
80010ef0:	00 99       	mov	r9,r0
80010ef2:	00 9a       	mov	r10,r0
80010ef4:	f0 1f 00 6b 	mcall	800110a0 <imgcheck2+0x28c>
		jpeg_lib_exit();
80010ef8:	f0 1f 00 6b 	mcall	800110a4 <imgcheck2+0x290>
		gpio_clr_gpio_pin(LED0_GPIO);
80010efc:	33 bc       	mov	r12,59
80010efe:	f0 1f 00 6b 	mcall	800110a8 <imgcheck2+0x294>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80010f02:	e0 63 00 f0 	mov	r3,240
80010f06:	1a d3       	st.w	--sp,r3
80010f08:	e0 6b 01 40 	mov	r11,320
80010f0c:	1a db       	st.w	--sp,r11
80010f0e:	1a d0       	st.w	--sp,r0
80010f10:	00 98       	mov	r8,r0
80010f12:	00 99       	mov	r9,r0
80010f14:	00 9a       	mov	r10,r0
80010f16:	6c 0c       	ld.w	r12,r6[0x0]
80010f18:	f0 1f 00 62 	mcall	800110a0 <imgcheck2+0x28c>
		char menuTXT[]="Menu Filtros";
80010f1c:	4e 48       	lddpc	r8,800110ac <imgcheck2+0x298>
80010f1e:	ee c6 00 1c 	sub	r6,r7,28
80010f22:	f0 ea 00 00 	ld.d	r10,r8[0]
80010f26:	ec eb 00 00 	st.d	r6[0],r10
80010f2a:	70 29       	ld.w	r9,r8[0x8]
80010f2c:	8d 29       	st.w	r6[0x8],r9
80010f2e:	f1 38 00 0c 	ld.ub	r8,r8[12]
80010f32:	ed 68 00 0c 	st.b	r6[12],r8
		et024006_DrawFilledRect(200,200,120,40,WHITE);
80010f36:	e0 68 ff ff 	mov	r8,65535
80010f3a:	32 89       	mov	r9,40
80010f3c:	37 8a       	mov	r10,120
80010f3e:	e0 6b 00 c8 	mov	r11,200
80010f42:	16 9c       	mov	r12,r11
80010f44:	f0 1f 00 5b 	mcall	800110b0 <imgcheck2+0x29c>
		et024006_PrintString(menuTXT,(const unsigned char *)&FONT8x16,210,210,BLACK,WHITE);
80010f48:	4d b4       	lddpc	r4,800110b4 <imgcheck2+0x2a0>
80010f4a:	e0 65 ff ff 	mov	r5,65535
80010f4e:	1a d5       	st.w	--sp,r5
80010f50:	00 98       	mov	r8,r0
80010f52:	e0 69 00 d2 	mov	r9,210
80010f56:	12 9a       	mov	r10,r9
80010f58:	08 9b       	mov	r11,r4
80010f5a:	0c 9c       	mov	r12,r6
80010f5c:	f0 1f 00 57 	mcall	800110b8 <imgcheck2+0x2a4>
		char Salir[]="Salir y Salvar";
80010f60:	4d 78       	lddpc	r8,800110bc <imgcheck2+0x2a8>
80010f62:	ee c6 00 2c 	sub	r6,r7,44
80010f66:	f0 ea 00 00 	ld.d	r10,r8[0]
80010f6a:	ec eb 00 00 	st.d	r6[0],r10
80010f6e:	70 29       	ld.w	r9,r8[0x8]
80010f70:	8d 29       	st.w	r6[0x8],r9
80010f72:	f1 39 00 0c 	ld.ub	r9,r8[12]
80010f76:	ed 69 00 0c 	st.b	r6[12],r9
80010f7a:	f1 39 00 0d 	ld.ub	r9,r8[13]
80010f7e:	ed 69 00 0d 	st.b	r6[13],r9
80010f82:	f1 38 00 0e 	ld.ub	r8,r8[14]
80010f86:	ed 68 00 0e 	st.b	r6[14],r8
		et024006_DrawFilledRect(200,0,140,40,WHITE);
80010f8a:	0a 98       	mov	r8,r5
80010f8c:	32 89       	mov	r9,40
80010f8e:	e0 6a 00 8c 	mov	r10,140
80010f92:	00 9b       	mov	r11,r0
80010f94:	e0 6c 00 c8 	mov	r12,200
80010f98:	f0 1f 00 46 	mcall	800110b0 <imgcheck2+0x29c>
		et024006_PrintString(Salir,(const unsigned char *)&FONT8x16,200,16,BLACK,WHITE);
80010f9c:	1a d5       	st.w	--sp,r5
80010f9e:	00 98       	mov	r8,r0
80010fa0:	31 09       	mov	r9,16
80010fa2:	e0 6a 00 c8 	mov	r10,200
80010fa6:	08 9b       	mov	r11,r4
80010fa8:	0c 9c       	mov	r12,r6
80010faa:	f0 1f 00 44 	mcall	800110b8 <imgcheck2+0x2a4>
		char Salirr[]="Salir";
80010fae:	4c 58       	lddpc	r8,800110c0 <imgcheck2+0x2ac>
80010fb0:	ee c6 00 0c 	sub	r6,r7,12
80010fb4:	70 09       	ld.w	r9,r8[0x0]
80010fb6:	8d 09       	st.w	r6[0x0],r9
80010fb8:	11 c9       	ld.ub	r9,r8[0x4]
80010fba:	ac c9       	st.b	r6[0x4],r9
80010fbc:	11 d8       	ld.ub	r8,r8[0x5]
80010fbe:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,40,80,40,WHITE);
80010fc0:	2f 8d       	sub	sp,-32
80010fc2:	0a 98       	mov	r8,r5
80010fc4:	32 89       	mov	r9,40
80010fc6:	35 0a       	mov	r10,80
80010fc8:	12 9b       	mov	r11,r9
80010fca:	06 9c       	mov	r12,r3
80010fcc:	f0 1f 00 39 	mcall	800110b0 <imgcheck2+0x29c>
		et024006_PrintString(Salirr,(const unsigned char *)&FONT8x16,260,56,BLACK,WHITE);
80010fd0:	1a d5       	st.w	--sp,r5
80010fd2:	00 98       	mov	r8,r0
80010fd4:	33 89       	mov	r9,56
80010fd6:	e0 6a 01 04 	mov	r10,260
80010fda:	08 9b       	mov	r11,r4
80010fdc:	0c 9c       	mov	r12,r6
80010fde:	f0 1f 00 37 	mcall	800110b8 <imgcheck2+0x2a4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80010fe2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80010fe6:	e0 6a e1 c0 	mov	r10,57792
80010fea:	ea 1a 00 e4 	orh	r10,0xe4
80010fee:	f0 0a 00 0a 	add	r10,r8,r10
80010ff2:	2f fd       	sub	sp,-4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80010ff4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80010ff8:	14 38       	cp.w	r8,r10
80010ffa:	e0 88 00 08 	brls	8001100a <imgcheck2+0x1f6>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80010ffe:	12 38       	cp.w	r8,r9
80011000:	fe 98 ff fa 	brls	80010ff4 <imgcheck2+0x1e0>
80011004:	12 3a       	cp.w	r10,r9
80011006:	c1 93       	brcs	80011038 <imgcheck2+0x224>
80011008:	cf 6b       	rjmp	80010ff4 <imgcheck2+0x1e0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001100a:	12 38       	cp.w	r8,r9
8001100c:	e0 8b 00 16 	brhi	80011038 <imgcheck2+0x224>
80011010:	12 3a       	cp.w	r10,r9
80011012:	c1 33       	brcs	80011038 <imgcheck2+0x224>
80011014:	cf 0b       	rjmp	80010ff4 <imgcheck2+0x1e0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80011016:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001101a:	14 38       	cp.w	r8,r10
8001101c:	e0 88 00 08 	brls	8001102c <imgcheck2+0x218>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80011020:	12 38       	cp.w	r8,r9
80011022:	fe 98 ff fa 	brls	80011016 <imgcheck2+0x202>
80011026:	12 3a       	cp.w	r10,r9
80011028:	c1 73       	brcs	80011056 <imgcheck2+0x242>
8001102a:	cf 6b       	rjmp	80011016 <imgcheck2+0x202>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001102c:	12 38       	cp.w	r8,r9
8001102e:	e0 8b 00 14 	brhi	80011056 <imgcheck2+0x242>
80011032:	12 3a       	cp.w	r10,r9
80011034:	c1 13       	brcs	80011056 <imgcheck2+0x242>
80011036:	cf 0b       	rjmp	80011016 <imgcheck2+0x202>
		delay_ms(250);
		step=1;
80011038:	30 19       	mov	r9,1
8001103a:	4a 38       	lddpc	r8,800110c4 <imgcheck2+0x2b0>
8001103c:	b0 89       	st.b	r8[0x0],r9
		gpio_set_gpio_pin(LED0_GPIO);
8001103e:	33 bc       	mov	r12,59
80011040:	f0 1f 00 22 	mcall	800110c8 <imgcheck2+0x2b4>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80011044:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80011048:	e0 6a c3 80 	mov	r10,50048
8001104c:	ea 1a 01 c9 	orh	r10,0x1c9
80011050:	f0 0a 00 0a 	add	r10,r8,r10
80011054:	ce 1b       	rjmp	80011016 <imgcheck2+0x202>
80011056:	04 9d       	mov	sp,r2
		delay_ms(500);
	}
}
80011058:	02 9d       	mov	sp,r1
8001105a:	2f 5d       	sub	sp,-44
8001105c:	d8 32       	popm	r0-r7,pc
8001105e:	00 00       	add	r0,r0
80011060:	00 00       	add	r0,r0
80011062:	07 70       	ld.ub	r0,--r3
80011064:	00 00       	add	r0,r0
80011066:	07 74       	ld.ub	r4,--r3
80011068:	00 00       	add	r0,r0
8001106a:	07 5c       	ld.sh	r12,--r3
8001106c:	00 00       	add	r0,r0
8001106e:	07 63       	ld.uh	r3,--r3
80011070:	00 00       	add	r0,r0
80011072:	06 8c       	andn	r12,r3
80011074:	00 00       	add	r0,r0
80011076:	06 d8       	st.w	--r3,r8
80011078:	80 01       	ld.sh	r1,r0[0x0]
8001107a:	47 88       	lddsp	r8,sp[0x1e0]
8001107c:	80 01       	ld.sh	r1,r0[0x0]
8001107e:	fe 0c       	*unknown*
80011080:	80 00       	ld.sh	r0,r0[0x0]
80011082:	73 e0       	ld.w	r0,r9[0x78]
80011084:	00 00       	add	r0,r0
80011086:	0d 00       	ld.w	r0,r6++
80011088:	00 00       	add	r0,r0
8001108a:	06 e4       	st.h	--r3,r4
8001108c:	80 01       	ld.sh	r1,r0[0x0]
8001108e:	06 a0       	st.w	r3++,r0
80011090:	00 00       	add	r0,r0
80011092:	0d 2c       	ld.uh	r12,r6++
80011094:	00 00       	add	r0,r0
80011096:	0d 30       	ld.ub	r0,r6++
80011098:	80 01       	ld.sh	r1,r0[0x0]
8001109a:	49 68       	lddpc	r8,800110f0 <imgcheck1+0x24>
8001109c:	00 00       	add	r0,r0
8001109e:	0d 28       	ld.uh	r8,r6++
800110a0:	80 00       	ld.sh	r0,r0[0x0]
800110a2:	63 3c       	ld.w	r12,r1[0x4c]
800110a4:	80 01       	ld.sh	r1,r0[0x0]
800110a6:	47 48       	lddsp	r8,sp[0x1d0]
800110a8:	80 00       	ld.sh	r0,r0[0x0]
800110aa:	6c 7e       	ld.w	lr,r6[0x1c]
800110ac:	80 01       	ld.sh	r1,r0[0x0]
800110ae:	fe 34 80 00 	sub	r4,-32768
800110b2:	62 94       	ld.w	r4,r1[0x24]
800110b4:	80 01       	ld.sh	r1,r0[0x0]
800110b6:	dc 90       	acall	0xc9
800110b8:	80 00       	ld.sh	r0,r0[0x0]
800110ba:	60 18       	ld.w	r8,r0[0x4]
800110bc:	80 01       	ld.sh	r1,r0[0x0]
800110be:	fe 44 80 01 	cp.w	r4,-98303
800110c2:	fe 54 00 00 	cp.w	r4,-65536
800110c6:	07 60       	ld.uh	r0,--r3
800110c8:	80 00       	ld.sh	r0,r0[0x0]
800110ca:	6c 62       	ld.w	r2,r6[0x18]

800110cc <imgcheck1>:
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void imgcheck1 (void)
{
800110cc:	d4 31       	pushm	r0-r7,lr
800110ce:	1a 97       	mov	r7,sp
800110d0:	20 bd       	sub	sp,44
		delay_ms(250);
		step=1;
		gpio_set_gpio_pin(LED0_GPIO);
		delay_ms(500);
	}
}
800110d2:	1a 91       	mov	r1,sp
	}
}

void imgcheck1 (void)
{
	if ((X>0 && X<=80 && Y>0 && Y<=60 && xytot<filtro && busy==false)|| (forzada==1 &&entrada==true))
800110d4:	fe f8 02 3c 	ld.w	r8,pc[572]
800110d8:	70 08       	ld.w	r8,r8[0x0]
800110da:	20 18       	sub	r8,1
800110dc:	e0 48 00 4f 	cp.w	r8,79
800110e0:	e0 8b 00 19 	brhi	80011112 <imgcheck1+0x46>
800110e4:	fe f8 02 30 	ld.w	r8,pc[560]
800110e8:	70 08       	ld.w	r8,r8[0x0]
800110ea:	58 08       	cp.w	r8,0
800110ec:	e0 8a 00 13 	brle	80011112 <imgcheck1+0x46>
800110f0:	e0 48 00 3c 	cp.w	r8,60
800110f4:	e0 89 00 0f 	brgt	80011112 <imgcheck1+0x46>
800110f8:	fe f8 02 20 	ld.w	r8,pc[544]
800110fc:	70 08       	ld.w	r8,r8[0x0]
800110fe:	58 28       	cp.w	r8,2
80011100:	e0 89 00 09 	brgt	80011112 <imgcheck1+0x46>
80011104:	fe f8 02 18 	ld.w	r8,pc[536]
80011108:	11 89       	ld.ub	r9,r8[0x0]
8001110a:	30 08       	mov	r8,0
8001110c:	f0 09 18 00 	cp.b	r9,r8
80011110:	c0 f0       	breq	8001112e <imgcheck1+0x62>
80011112:	fe f8 02 0e 	ld.w	r8,pc[526]
80011116:	70 08       	ld.w	r8,r8[0x0]
80011118:	58 18       	cp.w	r8,1
8001111a:	e0 81 00 f8 	brne	8001130a <imgcheck1+0x23e>
8001111e:	fe f8 02 06 	ld.w	r8,pc[518]
80011122:	11 89       	ld.ub	r9,r8[0x0]
80011124:	30 08       	mov	r8,0
80011126:	f0 09 18 00 	cp.b	r9,r8
8001112a:	e0 80 00 f0 	breq	8001130a <imgcheck1+0x23e>
8001112e:	1a 92       	mov	r2,sp
	{
		entrada=false;
80011130:	30 09       	mov	r9,0
80011132:	4f d8       	lddpc	r8,80011324 <imgcheck1+0x258>
80011134:	b0 89       	st.b	r8[0x0],r9
		forzada=1;
80011136:	30 18       	mov	r8,1
80011138:	4f a9       	lddpc	r9,80011320 <imgcheck1+0x254>
8001113a:	93 08       	st.w	r9[0x0],r8
		busy=true;
8001113c:	4f 89       	lddpc	r9,8001131c <imgcheck1+0x250>
8001113e:	b2 88       	st.b	r9[0x0],r8
		if (!jpeg_lib_init())						// JPEG IJG lib initialization
80011140:	f0 1f 00 7a 	mcall	80011328 <imgcheck1+0x25c>
80011144:	c0 51       	brne	8001114e <imgcheck1+0x82>
		{
			print_dbg("\r\n Initialization failed");
80011146:	4f ac       	lddpc	r12,8001132c <imgcheck1+0x260>
80011148:	f0 1f 00 7a 	mcall	80011330 <imgcheck1+0x264>
8001114c:	c0 08       	rjmp	8001114c <imgcheck1+0x80>
			while (1);
		}
		unsigned char Buffer[Filessize[0]];
8001114e:	4f a8       	lddpc	r8,80011334 <imgcheck1+0x268>
80011150:	70 05       	ld.w	r5,r8[0x0]
80011152:	ea c8 ff fa 	sub	r8,r5,-6
80011156:	e0 18 ff fc 	andl	r8,0xfffc
8001115a:	10 1d       	sub	sp,r8
		Readfile(filenames[0],&Buffer,(sizeof(Buffer)/sizeof(Buffer[0])));
8001115c:	0a 9a       	mov	r10,r5
8001115e:	1a 9b       	mov	r11,sp
80011160:	4f 6c       	lddpc	r12,80011338 <imgcheck1+0x26c>
80011162:	f0 1f 00 77 	mcall	8001133c <imgcheck1+0x270>
		stream_jpeg_src_ptr = Buffer;
80011166:	4f 78       	lddpc	r8,80011340 <imgcheck1+0x274>
80011168:	91 0d       	st.w	r8[0x0],sp
		stream_src_size = sizeof Buffer/sizeof Buffer[0];
8001116a:	4f 78       	lddpc	r8,80011344 <imgcheck1+0x278>
8001116c:	b0 05       	st.h	r8[0x0],r5
		// main decoder
		U16 width;
		U16 height;
		width= 320;
8001116e:	e0 68 01 40 	mov	r8,320
80011172:	ef 58 ff fe 	st.h	r7[-2],r8
		height= 240;
80011176:	e0 68 00 f0 	mov	r8,240
8001117a:	ef 58 ff fc 	st.h	r7[-4],r8
		RawImg = (et024006_color_t const *)jpeg_lib_decode_ex(0, &width, &height);
8001117e:	ee ca 00 04 	sub	r10,r7,4
80011182:	ee cb 00 02 	sub	r11,r7,2
80011186:	30 0c       	mov	r12,0
80011188:	f0 1f 00 70 	mcall	80011348 <imgcheck1+0x27c>
8001118c:	4f 06       	lddpc	r6,8001134c <imgcheck1+0x280>
8001118e:	8d 0c       	st.w	r6[0x0],r12
		et024006_PutPixmap(RawImg, width, 0, 0, 0,0, width, height);
80011190:	ef 1b ff fe 	ld.uh	r11,r7[-2]
80011194:	ef 18 ff fc 	ld.uh	r8,r7[-4]
80011198:	1a d8       	st.w	--sp,r8
8001119a:	1a db       	st.w	--sp,r11
8001119c:	30 00       	mov	r0,0
8001119e:	1a d0       	st.w	--sp,r0
800111a0:	00 98       	mov	r8,r0
800111a2:	00 99       	mov	r9,r0
800111a4:	00 9a       	mov	r10,r0
800111a6:	f0 1f 00 6b 	mcall	80011350 <imgcheck1+0x284>
		jpeg_lib_exit();
800111aa:	f0 1f 00 6b 	mcall	80011354 <imgcheck1+0x288>
		gpio_clr_gpio_pin(LED0_GPIO);
800111ae:	33 bc       	mov	r12,59
800111b0:	f0 1f 00 6a 	mcall	80011358 <imgcheck1+0x28c>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
800111b4:	e0 63 00 f0 	mov	r3,240
800111b8:	1a d3       	st.w	--sp,r3
800111ba:	e0 6b 01 40 	mov	r11,320
800111be:	1a db       	st.w	--sp,r11
800111c0:	1a d0       	st.w	--sp,r0
800111c2:	00 98       	mov	r8,r0
800111c4:	00 99       	mov	r9,r0
800111c6:	00 9a       	mov	r10,r0
800111c8:	6c 0c       	ld.w	r12,r6[0x0]
800111ca:	f0 1f 00 62 	mcall	80011350 <imgcheck1+0x284>
		char menuTXT[]="Menu Filtros";
800111ce:	4e 48       	lddpc	r8,8001135c <imgcheck1+0x290>
800111d0:	ee c6 00 1c 	sub	r6,r7,28
800111d4:	f0 ea 00 00 	ld.d	r10,r8[0]
800111d8:	ec eb 00 00 	st.d	r6[0],r10
800111dc:	70 29       	ld.w	r9,r8[0x8]
800111de:	8d 29       	st.w	r6[0x8],r9
800111e0:	f1 38 00 0c 	ld.ub	r8,r8[12]
800111e4:	ed 68 00 0c 	st.b	r6[12],r8
		et024006_DrawFilledRect(200,200,120,40,WHITE);
800111e8:	e0 68 ff ff 	mov	r8,65535
800111ec:	32 89       	mov	r9,40
800111ee:	37 8a       	mov	r10,120
800111f0:	e0 6b 00 c8 	mov	r11,200
800111f4:	16 9c       	mov	r12,r11
800111f6:	f0 1f 00 5b 	mcall	80011360 <imgcheck1+0x294>
		et024006_PrintString(menuTXT,(const unsigned char *)&FONT8x16,210,210,BLACK,WHITE);
800111fa:	4d b4       	lddpc	r4,80011364 <imgcheck1+0x298>
800111fc:	e0 65 ff ff 	mov	r5,65535
80011200:	1a d5       	st.w	--sp,r5
80011202:	00 98       	mov	r8,r0
80011204:	e0 69 00 d2 	mov	r9,210
80011208:	12 9a       	mov	r10,r9
8001120a:	08 9b       	mov	r11,r4
8001120c:	0c 9c       	mov	r12,r6
8001120e:	f0 1f 00 57 	mcall	80011368 <imgcheck1+0x29c>
		char Salir[]="Salir y Salvar";
80011212:	4d 78       	lddpc	r8,8001136c <imgcheck1+0x2a0>
80011214:	ee c6 00 2c 	sub	r6,r7,44
80011218:	f0 ea 00 00 	ld.d	r10,r8[0]
8001121c:	ec eb 00 00 	st.d	r6[0],r10
80011220:	70 29       	ld.w	r9,r8[0x8]
80011222:	8d 29       	st.w	r6[0x8],r9
80011224:	f1 39 00 0c 	ld.ub	r9,r8[12]
80011228:	ed 69 00 0c 	st.b	r6[12],r9
8001122c:	f1 39 00 0d 	ld.ub	r9,r8[13]
80011230:	ed 69 00 0d 	st.b	r6[13],r9
80011234:	f1 38 00 0e 	ld.ub	r8,r8[14]
80011238:	ed 68 00 0e 	st.b	r6[14],r8
		et024006_DrawFilledRect(200,0,140,40,WHITE);
8001123c:	0a 98       	mov	r8,r5
8001123e:	32 89       	mov	r9,40
80011240:	e0 6a 00 8c 	mov	r10,140
80011244:	00 9b       	mov	r11,r0
80011246:	e0 6c 00 c8 	mov	r12,200
8001124a:	f0 1f 00 46 	mcall	80011360 <imgcheck1+0x294>
		et024006_PrintString(Salir,(const unsigned char *)&FONT8x16,200,16,BLACK,WHITE);
8001124e:	1a d5       	st.w	--sp,r5
80011250:	00 98       	mov	r8,r0
80011252:	31 09       	mov	r9,16
80011254:	e0 6a 00 c8 	mov	r10,200
80011258:	08 9b       	mov	r11,r4
8001125a:	0c 9c       	mov	r12,r6
8001125c:	f0 1f 00 43 	mcall	80011368 <imgcheck1+0x29c>
		char Salirr[]="Salir";
80011260:	4c 48       	lddpc	r8,80011370 <imgcheck1+0x2a4>
80011262:	ee c6 00 0c 	sub	r6,r7,12
80011266:	70 09       	ld.w	r9,r8[0x0]
80011268:	8d 09       	st.w	r6[0x0],r9
8001126a:	11 c9       	ld.ub	r9,r8[0x4]
8001126c:	ac c9       	st.b	r6[0x4],r9
8001126e:	11 d8       	ld.ub	r8,r8[0x5]
80011270:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,40,80,40,WHITE);
80011272:	2f 8d       	sub	sp,-32
80011274:	0a 98       	mov	r8,r5
80011276:	32 89       	mov	r9,40
80011278:	35 0a       	mov	r10,80
8001127a:	12 9b       	mov	r11,r9
8001127c:	06 9c       	mov	r12,r3
8001127e:	f0 1f 00 39 	mcall	80011360 <imgcheck1+0x294>
		et024006_PrintString(Salirr,(const unsigned char *)&FONT8x16,260,56,BLACK,WHITE);
80011282:	1a d5       	st.w	--sp,r5
80011284:	00 98       	mov	r8,r0
80011286:	33 89       	mov	r9,56
80011288:	e0 6a 01 04 	mov	r10,260
8001128c:	08 9b       	mov	r11,r4
8001128e:	0c 9c       	mov	r12,r6
80011290:	f0 1f 00 36 	mcall	80011368 <imgcheck1+0x29c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80011294:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80011298:	e0 6a e1 c0 	mov	r10,57792
8001129c:	ea 1a 00 e4 	orh	r10,0xe4
800112a0:	f0 0a 00 0a 	add	r10,r8,r10
800112a4:	2f fd       	sub	sp,-4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800112a6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800112aa:	14 38       	cp.w	r8,r10
800112ac:	e0 88 00 08 	brls	800112bc <imgcheck1+0x1f0>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800112b0:	12 38       	cp.w	r8,r9
800112b2:	fe 98 ff fa 	brls	800112a6 <imgcheck1+0x1da>
800112b6:	12 3a       	cp.w	r10,r9
800112b8:	c1 93       	brcs	800112ea <imgcheck1+0x21e>
800112ba:	cf 6b       	rjmp	800112a6 <imgcheck1+0x1da>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800112bc:	12 38       	cp.w	r8,r9
800112be:	e0 8b 00 16 	brhi	800112ea <imgcheck1+0x21e>
800112c2:	12 3a       	cp.w	r10,r9
800112c4:	c1 33       	brcs	800112ea <imgcheck1+0x21e>
800112c6:	cf 0b       	rjmp	800112a6 <imgcheck1+0x1da>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800112c8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800112cc:	14 38       	cp.w	r8,r10
800112ce:	e0 88 00 08 	brls	800112de <imgcheck1+0x212>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800112d2:	12 38       	cp.w	r8,r9
800112d4:	fe 98 ff fa 	brls	800112c8 <imgcheck1+0x1fc>
800112d8:	12 3a       	cp.w	r10,r9
800112da:	c1 73       	brcs	80011308 <imgcheck1+0x23c>
800112dc:	cf 6b       	rjmp	800112c8 <imgcheck1+0x1fc>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800112de:	12 38       	cp.w	r8,r9
800112e0:	e0 8b 00 14 	brhi	80011308 <imgcheck1+0x23c>
800112e4:	12 3a       	cp.w	r10,r9
800112e6:	c1 13       	brcs	80011308 <imgcheck1+0x23c>
800112e8:	cf 0b       	rjmp	800112c8 <imgcheck1+0x1fc>
		delay_ms(250);
		step=1;
800112ea:	30 19       	mov	r9,1
800112ec:	4a 28       	lddpc	r8,80011374 <imgcheck1+0x2a8>
800112ee:	b0 89       	st.b	r8[0x0],r9
		gpio_set_gpio_pin(LED0_GPIO);
800112f0:	33 bc       	mov	r12,59
800112f2:	f0 1f 00 22 	mcall	80011378 <imgcheck1+0x2ac>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800112f6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800112fa:	e0 6a c3 80 	mov	r10,50048
800112fe:	ea 1a 01 c9 	orh	r10,0x1c9
80011302:	f0 0a 00 0a 	add	r10,r8,r10
80011306:	ce 1b       	rjmp	800112c8 <imgcheck1+0x1fc>
80011308:	04 9d       	mov	sp,r2
		delay_ms(500);
	}
}
8001130a:	02 9d       	mov	sp,r1
8001130c:	2f 5d       	sub	sp,-44
8001130e:	d8 32       	popm	r0-r7,pc
80011310:	00 00       	add	r0,r0
80011312:	07 70       	ld.ub	r0,--r3
80011314:	00 00       	add	r0,r0
80011316:	07 74       	ld.ub	r4,--r3
80011318:	00 00       	add	r0,r0
8001131a:	07 5c       	ld.sh	r12,--r3
8001131c:	00 00       	add	r0,r0
8001131e:	07 63       	ld.uh	r3,--r3
80011320:	00 00       	add	r0,r0
80011322:	06 8c       	andn	r12,r3
80011324:	00 00       	add	r0,r0
80011326:	06 d8       	st.w	--r3,r8
80011328:	80 01       	ld.sh	r1,r0[0x0]
8001132a:	47 88       	lddsp	r8,sp[0x1e0]
8001132c:	80 01       	ld.sh	r1,r0[0x0]
8001132e:	fe 0c       	*unknown*
80011330:	80 00       	ld.sh	r0,r0[0x0]
80011332:	73 e0       	ld.w	r0,r9[0x78]
80011334:	00 00       	add	r0,r0
80011336:	0d 00       	ld.w	r0,r6++
80011338:	00 00       	add	r0,r0
8001133a:	06 e4       	st.h	--r3,r4
8001133c:	80 01       	ld.sh	r1,r0[0x0]
8001133e:	06 a0       	st.w	r3++,r0
80011340:	00 00       	add	r0,r0
80011342:	0d 2c       	ld.uh	r12,r6++
80011344:	00 00       	add	r0,r0
80011346:	0d 30       	ld.ub	r0,r6++
80011348:	80 01       	ld.sh	r1,r0[0x0]
8001134a:	49 68       	lddpc	r8,800113a0 <Dilatar+0x24>
8001134c:	00 00       	add	r0,r0
8001134e:	0d 28       	ld.uh	r8,r6++
80011350:	80 00       	ld.sh	r0,r0[0x0]
80011352:	63 3c       	ld.w	r12,r1[0x4c]
80011354:	80 01       	ld.sh	r1,r0[0x0]
80011356:	47 48       	lddsp	r8,sp[0x1d0]
80011358:	80 00       	ld.sh	r0,r0[0x0]
8001135a:	6c 7e       	ld.w	lr,r6[0x1c]
8001135c:	80 01       	ld.sh	r1,r0[0x0]
8001135e:	fe 34 80 00 	sub	r4,-32768
80011362:	62 94       	ld.w	r4,r1[0x24]
80011364:	80 01       	ld.sh	r1,r0[0x0]
80011366:	dc 90       	acall	0xc9
80011368:	80 00       	ld.sh	r0,r0[0x0]
8001136a:	60 18       	ld.w	r8,r0[0x4]
8001136c:	80 01       	ld.sh	r1,r0[0x0]
8001136e:	fe 44 80 01 	cp.w	r4,-98303
80011372:	fe 54 00 00 	cp.w	r4,-65536
80011376:	07 60       	ld.uh	r0,--r3
80011378:	80 00       	ld.sh	r0,r0[0x0]
8001137a:	6c 62       	ld.w	r2,r6[0x18]

8001137c <Dilatar>:
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Dilatar (void)
{
8001137c:	eb cd 40 fc 	pushm	r2-r7,lr
80011380:	21 3d       	sub	sp,76

	if(dilatar == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
80011382:	fe f8 05 36 	ld.w	r8,pc[1334]
80011386:	11 88       	ld.ub	r8,r8[0x0]
80011388:	58 08       	cp.w	r8,0
8001138a:	e0 80 02 94 	breq	800118b2 <Dilatar+0x536>
8001138e:	fe f9 05 2e 	ld.w	r9,pc[1326]
80011392:	72 09       	ld.w	r9,r9[0x0]
80011394:	e0 49 00 f0 	cp.w	r9,240
80011398:	e0 8a 01 44 	brle	80011620 <Dilatar+0x2a4>
8001139c:	e0 49 01 40 	cp.w	r9,320
800113a0:	e0 89 01 40 	brgt	80011620 <Dilatar+0x2a4>
800113a4:	fe fa 05 1c 	ld.w	r10,pc[1308]
800113a8:	74 0a       	ld.w	r10,r10[0x0]
800113aa:	58 0a       	cp.w	r10,0
800113ac:	e0 8a 01 3a 	brle	80011620 <Dilatar+0x2a4>
800113b0:	e0 4a 00 28 	cp.w	r10,40
800113b4:	e0 89 01 36 	brgt	80011620 <Dilatar+0x2a4>
800113b8:	fe fa 05 0c 	ld.w	r10,pc[1292]
800113bc:	74 0a       	ld.w	r10,r10[0x0]
800113be:	58 2a       	cp.w	r10,2
800113c0:	e0 89 01 30 	brgt	80011620 <Dilatar+0x2a4>
800113c4:	fe fa 05 04 	ld.w	r10,pc[1284]
800113c8:	15 8b       	ld.ub	r11,r10[0x0]
800113ca:	30 0a       	mov	r10,0
800113cc:	f4 0b 18 00 	cp.b	r11,r10
800113d0:	e0 80 01 28 	breq	80011620 <Dilatar+0x2a4>
800113d4:	fe fa 04 f8 	ld.w	r10,pc[1272]
800113d8:	15 8b       	ld.ub	r11,r10[0x0]
800113da:	30 3a       	mov	r10,3
800113dc:	f4 0b 18 00 	cp.b	r11,r10
800113e0:	e0 81 01 20 	brne	80011620 <Dilatar+0x2a4>
	{gpio_clr_gpio_pin(LED0_GPIO);
800113e4:	33 bc       	mov	r12,59
800113e6:	f0 1f 01 3b 	mcall	800118d0 <Dilatar+0x554>
			U16 *puntero;
			puntero = RawImg+76160;
800113ea:	fe f8 04 ea 	ld.w	r8,pc[1258]
800113ee:	70 0a       	ld.w	r10,r8[0x0]
800113f0:	e2 69 53 00 	mov	r9,152320
800113f4:	f4 09 00 08 	add	r8,r10,r9
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Dilatar (void)
800113f8:	fc 3a a8 00 	sub	r10,-153600
	{gpio_clr_gpio_pin(LED0_GPIO);
			U16 *puntero;
			puntero = RawImg+76160;
			for (int i=0; i<640;i++)
			{
				*puntero=0;
800113fc:	30 09       	mov	r9,0
800113fe:	10 b9       	st.h	r8++,r9

	if(dilatar == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
	{gpio_clr_gpio_pin(LED0_GPIO);
			U16 *puntero;
			puntero = RawImg+76160;
			for (int i=0; i<640;i++)
80011400:	14 38       	cp.w	r8,r10
80011402:	cf e1       	brne	800113fe <Dilatar+0x82>
				*puntero=0;
				puntero++;
			}
			int R1,G1,B1, R2,G2, B2, promedio;
			int Value1, Value2;
			puntero = RawImg;
80011404:	fe f8 04 d0 	ld.w	r8,pc[1232]
80011408:	70 08       	ld.w	r8,r8[0x0]
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Dilatar (void)
8001140a:	e2 69 58 00 	mov	r9,153600
8001140e:	f0 09 00 07 	add	r7,r8,r9
			{
				Value1=*puntero&0xFFFF;
				B1=Value1&BLUE;
				G1=(Value1&GREEN)>>5;
				R1=(Value1&RED)>>11;
				promedio=(B1+(G1/2)+R1)/3;
80011412:	e0 6c 55 56 	mov	r12,21846
80011416:	ea 1c 55 55 	orh	r12,0x5555
			int R1,G1,B1, R2,G2, B2, promedio;
			int Value1, Value2;
			puntero = RawImg;
			for (int i=0; i<76800;i++)
			{
				Value1=*puntero&0xFFFF;
8001141a:	90 8a       	ld.uh	r10,r8[0x0]
				B1=Value1&BLUE;
				G1=(Value1&GREEN)>>5;
				R1=(Value1&RED)>>11;
				promedio=(B1+(G1/2)+R1)/3;
8001141c:	f4 0b 16 0b 	lsr	r11,r10,0xb
80011420:	f3 da c0 05 	bfextu	r9,r10,0x0,0x5
80011424:	12 0b       	add	r11,r9
80011426:	f5 da c0 c5 	bfextu	r10,r10,0x6,0x5
8001142a:	14 0b       	add	r11,r10
8001142c:	f6 0c 04 4a 	muls.d	r10,r11,r12
80011430:	16 99       	mov	r9,r11
				B1=promedio;
				G1=(promedio*2)<<5;
				R1=promedio<<11;
				*puntero=B1+G1+R1;
80011432:	f2 0a 15 0b 	lsl	r10,r9,0xb
80011436:	12 0a       	add	r10,r9
80011438:	a7 69       	lsl	r9,0x6
8001143a:	f4 09 00 09 	add	r9,r10,r9
8001143e:	10 b9       	st.h	r8++,r9
				puntero++;
			}
			int R1,G1,B1, R2,G2, B2, promedio;
			int Value1, Value2;
			puntero = RawImg;
			for (int i=0; i<76800;i++)
80011440:	0e 38       	cp.w	r8,r7
80011442:	ce c1       	brne	8001141a <Dilatar+0x9e>
				G1=(promedio*2)<<5;
				R1=promedio<<11;
				*puntero=B1+G1+R1;
				puntero++;
			}
			puntero = RawImg;
80011444:	fe f8 04 90 	ld.w	r8,pc[1168]
80011448:	70 07       	ld.w	r7,r8[0x0]
8001144a:	ee c9 ff fe 	sub	r9,r7,-2
8001144e:	ee cc 02 82 	sub	r12,r7,642
80011452:	ee c5 fd 80 	sub	r5,r7,-640
80011456:	ee c6 02 80 	sub	r6,r7,640
8001145a:	20 27       	sub	r7,2
8001145c:	30 08       	mov	r8,0
								
								*(puntero-320) = R2+G2+B2;
								
							}
						}
						if((i%319)!=0){
8001145e:	e0 64 49 d5 	mov	r4,18901
80011462:	ea 14 33 5c 	orh	r4,0x335c
				puntero++;
			}
			puntero = RawImg;
			for (int i=0; i<76480;i++)
			{
				Value1=*puntero&0xFFFF;
80011466:	f3 1a ff fe 	ld.uh	r10,r9[-2]
				B1=Value1&BLUE;
8001146a:	f7 da c0 05 	bfextu	r11,r10,0x0,0x5
				G1=(Value1&GREEN)>>5;
				R1=(Value1&RED)>>11;
				
				if(B1==R1){
8001146e:	ab 9a       	lsr	r10,0xb
80011470:	14 3b       	cp.w	r11,r10
80011472:	c5 11       	brne	80011514 <Dilatar+0x198>
					
					if(R1<0b01111){
80011474:	58 eb       	cp.w	r11,14
80011476:	e0 89 00 4f 	brgt	80011514 <Dilatar+0x198>
						if(i>=320){
8001147a:	e0 48 01 3f 	cp.w	r8,319
8001147e:	e0 8a 00 0f 	brle	8001149c <Dilatar+0x120>
							Value2 = *(puntero-320);
80011482:	8c 8a       	ld.uh	r10,r6[0x0]
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							if(R1<R2){
80011484:	f4 03 16 0b 	lsr	r3,r10,0xb
80011488:	06 3b       	cp.w	r11,r3
8001148a:	c0 94       	brge	8001149c <Dilatar+0x120>
								B2 = 0b11111;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero-320) = R2+G2+B2;
8001148c:	f6 03 15 0b 	lsl	r3,r11,0xb
80011490:	2e 13       	sub	r3,-31
80011492:	e2 1a 07 e0 	andl	r10,0x7e0,COH
80011496:	e6 0a 00 0a 	add	r10,r3,r10
8001149a:	ac 0a       	st.h	r6[0x0],r10
								
							}
						}
						if((i%319)!=0){
8001149c:	f0 04 04 42 	muls.d	r2,r8,r4
800114a0:	a7 43       	asr	r3,0x6
800114a2:	f0 0a 14 1f 	asr	r10,r8,0x1f
800114a6:	e6 0a 01 0a 	sub	r10,r3,r10
800114aa:	f4 0a 00 23 	add	r3,r10,r10<<0x2
800114ae:	a7 63       	lsl	r3,0x6
800114b0:	e6 0a 01 0a 	sub	r10,r3,r10
800114b4:	f0 0a 01 0a 	sub	r10,r8,r10
800114b8:	c0 e0       	breq	800114d4 <Dilatar+0x158>
							
							Value2 = *(puntero+1);
800114ba:	92 8a       	ld.uh	r10,r9[0x0]
							
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							
							if(R1<R2){
800114bc:	f4 03 16 0b 	lsr	r3,r10,0xb
800114c0:	06 3b       	cp.w	r11,r3
800114c2:	c0 94       	brge	800114d4 <Dilatar+0x158>
								B2 = 0b11111;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero+1) = R2+G2+B2;
800114c4:	f6 03 15 0b 	lsl	r3,r11,0xb
800114c8:	2e 13       	sub	r3,-31
800114ca:	e2 1a 07 e0 	andl	r10,0x7e0,COH
800114ce:	e6 0a 00 0a 	add	r10,r3,r10
800114d2:	b2 0a       	st.h	r9[0x0],r10
								
							}
						}
						if(i<=76480){
800114d4:	e0 58 2a c0 	cp.w	r8,76480
800114d8:	e0 89 00 0f 	brgt	800114f6 <Dilatar+0x17a>
							
							Value2 = *(puntero+320);
800114dc:	8a 8a       	ld.uh	r10,r5[0x0]
							
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							
							if(R1<R2){
800114de:	f4 03 16 0b 	lsr	r3,r10,0xb
800114e2:	06 3b       	cp.w	r11,r3
800114e4:	c0 94       	brge	800114f6 <Dilatar+0x17a>
								B2 = 0b11111;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero+320) = R2+G2+B2;
800114e6:	f6 03 15 0b 	lsl	r3,r11,0xb
800114ea:	2e 13       	sub	r3,-31
800114ec:	e2 1a 07 e0 	andl	r10,0x7e0,COH
800114f0:	e6 0a 00 0a 	add	r10,r3,r10
800114f4:	aa 0a       	st.h	r5[0x0],r10
								
							}
							
						}
						if((i!=0)||((i%320)!=0)){
800114f6:	58 08       	cp.w	r8,0
800114f8:	e0 80 01 d5 	breq	800118a2 <Dilatar+0x526>
							
							Value2 = *(puntero-1);
800114fc:	8e 8a       	ld.uh	r10,r7[0x0]
							
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							
							if(R1<R2){
800114fe:	f4 03 16 0b 	lsr	r3,r10,0xb
80011502:	06 3b       	cp.w	r11,r3
80011504:	c0 84       	brge	80011514 <Dilatar+0x198>
								B2 = 0b11111;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero-1) = R2+G2+B2;
80011506:	ab 7b       	lsl	r11,0xb
80011508:	2e 1b       	sub	r11,-31
8001150a:	e2 1a 07 e0 	andl	r10,0x7e0,COH
8001150e:	f6 0a 00 0a 	add	r10,r11,r10
80011512:	ae 0a       	st.h	r7[0x0],r10

					}
					
				}
				
				if(i>320){
80011514:	e0 48 01 40 	cp.w	r8,320
80011518:	e0 8a 00 0f 	brle	80011536 <Dilatar+0x1ba>
					
					Value2 = *(puntero - 321);
8001151c:	98 8a       	ld.uh	r10,r12[0x0]
					
					B2=Value2&BLUE;
					G2=(Value2&GREEN)>>5;
					R2=(Value2&RED)>>11;
					
					if(B2==0b11111){
8001151e:	f7 da c0 05 	bfextu	r11,r10,0x0,0x5
80011522:	59 fb       	cp.w	r11,31
80011524:	c0 91       	brne	80011536 <Dilatar+0x1ba>
					
					Value2 = *(puntero - 321);
					
					B2=Value2&BLUE;
					G2=(Value2&GREEN)>>5;
					R2=(Value2&RED)>>11;
80011526:	ab 9a       	lsr	r10,0xb
						G2 = R2*2;
						
						R2 = R2<<11;
						G2 = G2<<5;
						
						*(puntero - 321) = R2+G2+B2;
80011528:	f4 0b 15 0b 	lsl	r11,r10,0xb
8001152c:	14 0b       	add	r11,r10
8001152e:	a7 6a       	lsl	r10,0x6
80011530:	f6 0a 00 0a 	add	r10,r11,r10
80011534:	b8 0a       	st.h	r12[0x0],r10
				R1=promedio<<11;
				*puntero=B1+G1+R1;
				puntero++;
			}
			puntero = RawImg;
			for (int i=0; i<76480;i++)
80011536:	2f f8       	sub	r8,-1
80011538:	2f e9       	sub	r9,-2
8001153a:	2f ec       	sub	r12,-2
8001153c:	2f e5       	sub	r5,-2
8001153e:	2f e6       	sub	r6,-2
80011540:	2f e7       	sub	r7,-2
80011542:	e0 58 2a c0 	cp.w	r8,76480
80011546:	c9 01       	brne	80011466 <Dilatar+0xea>
					
				}

				puntero++;
			}
			et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80011548:	e0 65 00 f0 	mov	r5,240
8001154c:	1a d5       	st.w	--sp,r5
8001154e:	e0 66 01 40 	mov	r6,320
80011552:	1a d6       	st.w	--sp,r6
80011554:	30 07       	mov	r7,0
80011556:	1a d7       	st.w	--sp,r7
80011558:	0e 98       	mov	r8,r7
8001155a:	0e 99       	mov	r9,r7
8001155c:	0e 9a       	mov	r10,r7
8001155e:	0c 9b       	mov	r11,r6
80011560:	fe fc 03 74 	ld.w	r12,pc[884]
80011564:	78 0c       	ld.w	r12,r12[0x0]
80011566:	f0 1f 00 dd 	mcall	800118d8 <Dilatar+0x55c>
			et024006_DrawFilledRect(0,238,320,2,BLACK);
8001156a:	0e 98       	mov	r8,r7
8001156c:	30 29       	mov	r9,2
8001156e:	0c 9a       	mov	r10,r6
80011570:	e0 6b 00 ee 	mov	r11,238
80011574:	0e 9c       	mov	r12,r7
80011576:	f0 1f 00 da 	mcall	800118dc <Dilatar+0x560>
			char NEG[]="Dilatar Activado";
8001157a:	fe f8 03 66 	ld.w	r8,pc[870]
8001157e:	fa cc ff f4 	sub	r12,sp,-12
80011582:	f0 ea 00 00 	ld.d	r10,r8[0]
80011586:	f8 eb 00 00 	st.d	r12[0],r10
8001158a:	f0 ea 00 08 	ld.d	r10,r8[8]
8001158e:	f8 eb 00 08 	st.d	r12[8],r10
80011592:	f1 38 00 10 	ld.ub	r8,r8[16]
80011596:	f9 68 00 10 	st.b	r12[16],r8
			et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
8001159a:	fe f4 03 4a 	ld.w	r4,pc[842]
8001159e:	e0 66 ff ff 	mov	r6,65535
800115a2:	1a d6       	st.w	--sp,r6
800115a4:	0e 98       	mov	r8,r7
800115a6:	e0 69 00 dc 	mov	r9,220
800115aa:	35 aa       	mov	r10,90
800115ac:	08 9b       	mov	r11,r4
800115ae:	f0 1f 00 cf 	mcall	800118e8 <Dilatar+0x56c>
			char NEG2[]="Dilatar";
800115b2:	e0 68 72 00 	mov	r8,29184
800115b6:	ea 18 74 61 	orh	r8,0x7461
800115ba:	e0 69 6c 61 	mov	r9,27745
800115be:	ea 19 44 69 	orh	r9,0x4469
800115c2:	fa e9 00 40 	st.d	sp[64],r8
			et024006_DrawFilledRect(240,0,80,40,WHITE);
800115c6:	0c 98       	mov	r8,r6
800115c8:	32 89       	mov	r9,40
800115ca:	35 0a       	mov	r10,80
800115cc:	0e 9b       	mov	r11,r7
800115ce:	0a 9c       	mov	r12,r5
800115d0:	f0 1f 00 c3 	mcall	800118dc <Dilatar+0x560>
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
800115d4:	1a d6       	st.w	--sp,r6
800115d6:	0e 98       	mov	r8,r7
800115d8:	31 09       	mov	r9,16
800115da:	e0 6a 00 fa 	mov	r10,250
800115de:	08 9b       	mov	r11,r4
800115e0:	fa cc ff bc 	sub	r12,sp,-68
800115e4:	f0 1f 00 c1 	mcall	800118e8 <Dilatar+0x56c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800115e8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800115ec:	e0 6a e1 c0 	mov	r10,57792
800115f0:	ea 1a 00 e4 	orh	r10,0xe4
800115f4:	f0 0a 00 0a 	add	r10,r8,r10
800115f8:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800115fa:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800115fe:	14 38       	cp.w	r8,r10
80011600:	e0 88 00 09 	brls	80011612 <Dilatar+0x296>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80011604:	12 38       	cp.w	r8,r9
80011606:	fe 98 ff fa 	brls	800115fa <Dilatar+0x27e>
8001160a:	12 3a       	cp.w	r10,r9
8001160c:	e0 83 01 43 	brlo	80011892 <Dilatar+0x516>
80011610:	cf 5b       	rjmp	800115fa <Dilatar+0x27e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80011612:	12 38       	cp.w	r8,r9
80011614:	e0 8b 01 3f 	brhi	80011892 <Dilatar+0x516>
80011618:	12 3a       	cp.w	r10,r9
8001161a:	e0 83 01 3c 	brlo	80011892 <Dilatar+0x516>
8001161e:	ce eb       	rjmp	800115fa <Dilatar+0x27e>
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);	
	}
	else if(dilatar== true && X>96 && X<=232 && Y>220 && Y<=240 && xytot<filtro && busy==true && step==3)
80011620:	58 08       	cp.w	r8,0
80011622:	e0 80 01 48 	breq	800118b2 <Dilatar+0x536>
80011626:	e0 49 00 60 	cp.w	r9,96
8001162a:	e0 8a 01 44 	brle	800118b2 <Dilatar+0x536>
8001162e:	e0 49 00 e8 	cp.w	r9,232
80011632:	e0 89 01 40 	brgt	800118b2 <Dilatar+0x536>
80011636:	fe f8 02 8a 	ld.w	r8,pc[650]
8001163a:	70 08       	ld.w	r8,r8[0x0]
8001163c:	e0 48 00 dc 	cp.w	r8,220
80011640:	e0 8a 01 39 	brle	800118b2 <Dilatar+0x536>
80011644:	e0 48 00 f0 	cp.w	r8,240
80011648:	e0 89 01 35 	brgt	800118b2 <Dilatar+0x536>
8001164c:	fe f8 02 78 	ld.w	r8,pc[632]
80011650:	70 08       	ld.w	r8,r8[0x0]
80011652:	58 28       	cp.w	r8,2
80011654:	e0 89 01 2f 	brgt	800118b2 <Dilatar+0x536>
80011658:	fe f8 02 70 	ld.w	r8,pc[624]
8001165c:	11 89       	ld.ub	r9,r8[0x0]
8001165e:	30 08       	mov	r8,0
80011660:	f0 09 18 00 	cp.b	r9,r8
80011664:	e0 80 01 27 	breq	800118b2 <Dilatar+0x536>
80011668:	fe f8 02 64 	ld.w	r8,pc[612]
8001166c:	11 89       	ld.ub	r9,r8[0x0]
8001166e:	30 38       	mov	r8,3
80011670:	f0 09 18 00 	cp.b	r9,r8
80011674:	e0 81 01 1f 	brne	800118b2 <Dilatar+0x536>
	{
	dilatar=false;
80011678:	30 09       	mov	r9,0
8001167a:	fe f8 02 3e 	ld.w	r8,pc[574]
8001167e:	b0 89       	st.b	r8[0x0],r9
gpio_clr_gpio_pin(LED0_GPIO);
80011680:	33 bc       	mov	r12,59
80011682:	f0 1f 00 94 	mcall	800118d0 <Dilatar+0x554>
et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80011686:	e0 62 00 f0 	mov	r2,240
8001168a:	1a d2       	st.w	--sp,r2
8001168c:	e0 6b 01 40 	mov	r11,320
80011690:	1a db       	st.w	--sp,r11
80011692:	30 06       	mov	r6,0
80011694:	1a d6       	st.w	--sp,r6
80011696:	0c 98       	mov	r8,r6
80011698:	0c 99       	mov	r9,r6
8001169a:	0c 9a       	mov	r10,r6
8001169c:	fe fc 02 38 	ld.w	r12,pc[568]
800116a0:	78 0c       	ld.w	r12,r12[0x0]
800116a2:	f0 1f 00 8e 	mcall	800118d8 <Dilatar+0x55c>
char brillo[]="Brillo";
800116a6:	fe f8 02 46 	ld.w	r8,pc[582]
800116aa:	fa c4 ff c4 	sub	r4,sp,-60
800116ae:	70 09       	ld.w	r9,r8[0x0]
800116b0:	89 09       	st.w	r4[0x0],r9
800116b2:	11 c9       	ld.ub	r9,r8[0x4]
800116b4:	a8 c9       	st.b	r4[0x4],r9
800116b6:	11 d9       	ld.ub	r9,r8[0x5]
800116b8:	a8 d9       	st.b	r4[0x5],r9
800116ba:	11 e8       	ld.ub	r8,r8[0x6]
800116bc:	a8 e8       	st.b	r4[0x6],r8
char Negativo[]="Negativo";
800116be:	fe f8 02 32 	ld.w	r8,pc[562]
800116c2:	fa c3 ff e0 	sub	r3,sp,-32
800116c6:	f0 ea 00 00 	ld.d	r10,r8[0]
800116ca:	e6 eb 00 00 	st.d	r3[0],r10
800116ce:	f1 38 00 08 	ld.ub	r8,r8[8]
800116d2:	e7 68 00 08 	st.b	r3[8],r8
char BlNe[]="B/N";
800116d6:	e0 68 4e 00 	mov	r8,19968
800116da:	ea 18 42 2f 	orh	r8,0x422f
800116de:	51 58       	stdsp	sp[0x54],r8
char dila[]="Dilatar";
800116e0:	e0 68 72 00 	mov	r8,29184
800116e4:	ea 18 74 61 	orh	r8,0x7461
800116e8:	e0 69 6c 61 	mov	r9,27745
800116ec:	ea 19 44 69 	orh	r9,0x4469
800116f0:	fa e9 00 34 	st.d	sp[52],r8
et024006_DrawFilledRect(20,20,80,20,WHITE);
800116f4:	e0 68 ff ff 	mov	r8,65535
800116f8:	31 49       	mov	r9,20
800116fa:	35 0a       	mov	r10,80
800116fc:	12 9b       	mov	r11,r9
800116fe:	12 9c       	mov	r12,r9
80011700:	f0 1f 00 77 	mcall	800118dc <Dilatar+0x560>
et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
80011704:	4f 85       	lddpc	r5,800118e4 <Dilatar+0x568>
80011706:	e0 67 ff ff 	mov	r7,65535
8001170a:	1a d7       	st.w	--sp,r7
8001170c:	0c 98       	mov	r8,r6
8001170e:	31 49       	mov	r9,20
80011710:	12 9a       	mov	r10,r9
80011712:	0a 9b       	mov	r11,r5
80011714:	08 9c       	mov	r12,r4
80011716:	f0 1f 00 75 	mcall	800118e8 <Dilatar+0x56c>
et024006_DrawFilledRect(20,50,80,20,WHITE);
8001171a:	0e 98       	mov	r8,r7
8001171c:	31 49       	mov	r9,20
8001171e:	35 0a       	mov	r10,80
80011720:	33 2b       	mov	r11,50
80011722:	12 9c       	mov	r12,r9
80011724:	f0 1f 00 6e 	mcall	800118dc <Dilatar+0x560>
et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
80011728:	1a d7       	st.w	--sp,r7
8001172a:	0c 98       	mov	r8,r6
8001172c:	33 29       	mov	r9,50
8001172e:	31 4a       	mov	r10,20
80011730:	0a 9b       	mov	r11,r5
80011732:	06 9c       	mov	r12,r3
80011734:	f0 1f 00 6d 	mcall	800118e8 <Dilatar+0x56c>
et024006_DrawFilledRect(20,80,80,20,WHITE);
80011738:	0e 98       	mov	r8,r7
8001173a:	31 49       	mov	r9,20
8001173c:	35 0a       	mov	r10,80
8001173e:	14 9b       	mov	r11,r10
80011740:	12 9c       	mov	r12,r9
80011742:	f0 1f 00 67 	mcall	800118dc <Dilatar+0x560>
et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
80011746:	1a d7       	st.w	--sp,r7
80011748:	0c 98       	mov	r8,r6
8001174a:	35 09       	mov	r9,80
8001174c:	31 4a       	mov	r10,20
8001174e:	0a 9b       	mov	r11,r5
80011750:	fa cc ff a0 	sub	r12,sp,-96
80011754:	f0 1f 00 65 	mcall	800118e8 <Dilatar+0x56c>
et024006_DrawFilledRect(20,110,80,20,WHITE);
80011758:	0e 98       	mov	r8,r7
8001175a:	31 49       	mov	r9,20
8001175c:	35 0a       	mov	r10,80
8001175e:	36 eb       	mov	r11,110
80011760:	12 9c       	mov	r12,r9
80011762:	f0 1f 00 5f 	mcall	800118dc <Dilatar+0x560>
char AutoFiltro[]="AutoFiltro";
80011766:	4e 48       	lddpc	r8,800118f4 <Dilatar+0x578>
80011768:	fa cc ff e8 	sub	r12,sp,-24
8001176c:	f0 ea 00 00 	ld.d	r10,r8[0]
80011770:	f8 eb 00 00 	st.d	r12[0],r10
80011774:	f1 39 00 08 	ld.ub	r9,r8[8]
80011778:	f9 69 00 08 	st.b	r12[8],r9
8001177c:	f1 39 00 09 	ld.ub	r9,r8[9]
80011780:	f9 69 00 09 	st.b	r12[9],r9
80011784:	f1 38 00 0a 	ld.ub	r8,r8[10]
80011788:	f9 68 00 0a 	st.b	r12[10],r8
et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
8001178c:	1a d7       	st.w	--sp,r7
8001178e:	0c 98       	mov	r8,r6
80011790:	36 e9       	mov	r9,110
80011792:	31 4a       	mov	r10,20
80011794:	0a 9b       	mov	r11,r5
80011796:	f0 1f 00 55 	mcall	800118e8 <Dilatar+0x56c>
et024006_DrawFilledRect(20,140,80,20,WHITE);
8001179a:	0e 98       	mov	r8,r7
8001179c:	31 49       	mov	r9,20
8001179e:	35 0a       	mov	r10,80
800117a0:	e0 6b 00 8c 	mov	r11,140
800117a4:	12 9c       	mov	r12,r9
800117a6:	f0 1f 00 4e 	mcall	800118dc <Dilatar+0x560>
et024006_PrintString(dila,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
800117aa:	1a d7       	st.w	--sp,r7
800117ac:	0c 98       	mov	r8,r6
800117ae:	e0 69 00 8c 	mov	r9,140
800117b2:	31 4a       	mov	r10,20
800117b4:	0a 9b       	mov	r11,r5
800117b6:	fa cc ff b8 	sub	r12,sp,-72
800117ba:	f0 1f 00 4c 	mcall	800118e8 <Dilatar+0x56c>
et024006_DrawFilledRect(20,170,80,20,WHITE);
800117be:	2f 8d       	sub	sp,-32
800117c0:	0e 98       	mov	r8,r7
800117c2:	31 49       	mov	r9,20
800117c4:	35 0a       	mov	r10,80
800117c6:	e0 6b 00 aa 	mov	r11,170
800117ca:	12 9c       	mov	r12,r9
800117cc:	f0 1f 00 44 	mcall	800118dc <Dilatar+0x560>
et024006_DrawFilledRect(20,200,80,20,WHITE);
800117d0:	0e 98       	mov	r8,r7
800117d2:	31 49       	mov	r9,20
800117d4:	35 0a       	mov	r10,80
800117d6:	e0 6b 00 c8 	mov	r11,200
800117da:	12 9c       	mov	r12,r9
800117dc:	f0 1f 00 40 	mcall	800118dc <Dilatar+0x560>
char Eros[]="Erosion";
800117e0:	e0 68 6e 00 	mov	r8,28160
800117e4:	ea 18 69 6f 	orh	r8,0x696f
800117e8:	e0 69 6f 73 	mov	r9,28531
800117ec:	ea 19 45 72 	orh	r9,0x4572
800117f0:	fa e9 00 20 	st.d	sp[32],r8
et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
800117f4:	1a d7       	st.w	--sp,r7
800117f6:	0c 98       	mov	r8,r6
800117f8:	e0 69 00 c8 	mov	r9,200
800117fc:	31 4a       	mov	r10,20
800117fe:	0a 9b       	mov	r11,r5
80011800:	fa cc ff dc 	sub	r12,sp,-36
80011804:	f0 1f 00 39 	mcall	800118e8 <Dilatar+0x56c>
char BlNs[]="Blur";
80011808:	4b c8       	lddpc	r8,800118f8 <Dilatar+0x57c>
8001180a:	fa cc ff bc 	sub	r12,sp,-68
8001180e:	70 09       	ld.w	r9,r8[0x0]
80011810:	99 09       	st.w	r12[0x0],r9
80011812:	11 c8       	ld.ub	r8,r8[0x4]
80011814:	b8 c8       	st.b	r12[0x4],r8
et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
80011816:	1a d7       	st.w	--sp,r7
80011818:	0c 98       	mov	r8,r6
8001181a:	e0 69 00 aa 	mov	r9,170
8001181e:	31 4a       	mov	r10,20
80011820:	0a 9b       	mov	r11,r5
80011822:	f0 1f 00 32 	mcall	800118e8 <Dilatar+0x56c>
char Exit[]="SALIR";
80011826:	4b 68       	lddpc	r8,800118fc <Dilatar+0x580>
80011828:	fa c4 ff c0 	sub	r4,sp,-64
8001182c:	70 09       	ld.w	r9,r8[0x0]
8001182e:	89 09       	st.w	r4[0x0],r9
80011830:	11 c9       	ld.ub	r9,r8[0x4]
80011832:	a8 c9       	st.b	r4[0x4],r9
80011834:	11 d8       	ld.ub	r8,r8[0x5]
80011836:	a8 d8       	st.b	r4[0x5],r8
et024006_DrawFilledRect(240,0,80,40,WHITE);
80011838:	0e 98       	mov	r8,r7
8001183a:	32 89       	mov	r9,40
8001183c:	35 0a       	mov	r10,80
8001183e:	0c 9b       	mov	r11,r6
80011840:	04 9c       	mov	r12,r2
80011842:	f0 1f 00 27 	mcall	800118dc <Dilatar+0x560>
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80011846:	1a d7       	st.w	--sp,r7
80011848:	0c 98       	mov	r8,r6
8001184a:	31 09       	mov	r9,16
8001184c:	e0 6a 01 04 	mov	r10,260
80011850:	0a 9b       	mov	r11,r5
80011852:	08 9c       	mov	r12,r4
80011854:	f0 1f 00 25 	mcall	800118e8 <Dilatar+0x56c>
step=2;
80011858:	30 29       	mov	r9,2
8001185a:	49 d8       	lddpc	r8,800118cc <Dilatar+0x550>
8001185c:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001185e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80011862:	e0 6a e1 c0 	mov	r10,57792
80011866:	ea 1a 00 e4 	orh	r10,0xe4
8001186a:	f0 0a 00 0a 	add	r10,r8,r10
8001186e:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80011870:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80011874:	14 38       	cp.w	r8,r10
80011876:	e0 88 00 08 	brls	80011886 <Dilatar+0x50a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001187a:	12 38       	cp.w	r8,r9
8001187c:	fe 98 ff fa 	brls	80011870 <Dilatar+0x4f4>
80011880:	12 3a       	cp.w	r10,r9
80011882:	c0 c3       	brcs	8001189a <Dilatar+0x51e>
80011884:	cf 6b       	rjmp	80011870 <Dilatar+0x4f4>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80011886:	12 38       	cp.w	r8,r9
80011888:	e0 8b 00 09 	brhi	8001189a <Dilatar+0x51e>
8001188c:	12 3a       	cp.w	r10,r9
8001188e:	c0 63       	brcs	8001189a <Dilatar+0x51e>
80011890:	cf 0b       	rjmp	80011870 <Dilatar+0x4f4>
			et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
			char NEG2[]="Dilatar";
			et024006_DrawFilledRect(240,0,80,40,WHITE);
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);	
80011892:	33 bc       	mov	r12,59
80011894:	f0 1f 00 1b 	mcall	80011900 <Dilatar+0x584>
}

void Dilatar (void)
{

	if(dilatar == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
80011898:	c0 d8       	rjmp	800118b2 <Dilatar+0x536>
char Exit[]="SALIR";
et024006_DrawFilledRect(240,0,80,40,WHITE);
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
step=2;
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
8001189a:	33 bc       	mov	r12,59
8001189c:	f0 1f 00 19 	mcall	80011900 <Dilatar+0x584>
800118a0:	c0 98       	rjmp	800118b2 <Dilatar+0x536>
				R1=promedio<<11;
				*puntero=B1+G1+R1;
				puntero++;
			}
			puntero = RawImg;
			for (int i=0; i<76480;i++)
800118a2:	2f f8       	sub	r8,-1
800118a4:	2f e9       	sub	r9,-2
800118a6:	2f ec       	sub	r12,-2
800118a8:	2f e5       	sub	r5,-2
800118aa:	2f e6       	sub	r6,-2
800118ac:	2f e7       	sub	r7,-2
800118ae:	fe 9f fd dc 	bral	80011466 <Dilatar+0xea>
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
	}
	
	
}
800118b2:	2e dd       	sub	sp,-76
800118b4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800118b8:	00 00       	add	r0,r0
800118ba:	06 d0       	st.w	--r3,r0
800118bc:	00 00       	add	r0,r0
800118be:	07 70       	ld.ub	r0,--r3
800118c0:	00 00       	add	r0,r0
800118c2:	07 74       	ld.ub	r4,--r3
800118c4:	00 00       	add	r0,r0
800118c6:	07 5c       	ld.sh	r12,--r3
800118c8:	00 00       	add	r0,r0
800118ca:	07 63       	ld.uh	r3,--r3
800118cc:	00 00       	add	r0,r0
800118ce:	07 60       	ld.uh	r0,--r3
800118d0:	80 00       	ld.sh	r0,r0[0x0]
800118d2:	6c 7e       	ld.w	lr,r6[0x1c]
800118d4:	00 00       	add	r0,r0
800118d6:	0d 28       	ld.uh	r8,r6++
800118d8:	80 00       	ld.sh	r0,r0[0x0]
800118da:	63 3c       	ld.w	r12,r1[0x4c]
800118dc:	80 00       	ld.sh	r0,r0[0x0]
800118de:	62 94       	ld.w	r4,r1[0x24]
800118e0:	80 01       	ld.sh	r1,r0[0x0]
800118e2:	fe 5c 80 01 	cp.w	r12,-32767
800118e6:	dc 90       	acall	0xc9
800118e8:	80 00       	ld.sh	r0,r0[0x0]
800118ea:	60 18       	ld.w	r8,r0[0x4]
800118ec:	80 01       	ld.sh	r1,r0[0x0]
800118ee:	fe 70 80 01 	mov	r0,-32767
800118f2:	fe 78 80 01 	mov	r8,-32767
800118f6:	fe 84 80 01 	brge	7ffe18f8 <__heap_size__+0x7dfe18f8>
800118fa:	fe 90 80 01 	breq	800018fc <_trampoline+0x18fc>
800118fe:	fe 98 80 00 	brls	800018fe <_trampoline+0x18fe>
80011902:	6c 62       	ld.w	r2,r6[0x18]

80011904 <BlancoNegro>:
		}
	//Prueba de blur
}

void BlancoNegro (void)
{
80011904:	eb cd 40 fc 	pushm	r2-r7,lr
80011908:	21 2d       	sub	sp,72
	if(BNACT == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
8001190a:	fe f8 03 ea 	ld.w	r8,pc[1002]
8001190e:	11 88       	ld.ub	r8,r8[0x0]
80011910:	58 08       	cp.w	r8,0
80011912:	e0 80 01 ed 	breq	80011cec <BlancoNegro+0x3e8>
80011916:	fe f9 03 e2 	ld.w	r9,pc[994]
8001191a:	72 09       	ld.w	r9,r9[0x0]
8001191c:	e0 49 00 f0 	cp.w	r9,240
80011920:	e0 8a 00 a6 	brle	80011a6c <BlancoNegro+0x168>
80011924:	e0 49 01 40 	cp.w	r9,320
80011928:	e0 89 00 a2 	brgt	80011a6c <BlancoNegro+0x168>
8001192c:	fe fa 03 d0 	ld.w	r10,pc[976]
80011930:	74 0a       	ld.w	r10,r10[0x0]
80011932:	58 0a       	cp.w	r10,0
80011934:	e0 8a 00 9c 	brle	80011a6c <BlancoNegro+0x168>
80011938:	e0 4a 00 28 	cp.w	r10,40
8001193c:	e0 89 00 98 	brgt	80011a6c <BlancoNegro+0x168>
80011940:	fe fa 03 c0 	ld.w	r10,pc[960]
80011944:	74 0a       	ld.w	r10,r10[0x0]
80011946:	58 2a       	cp.w	r10,2
80011948:	e0 89 00 92 	brgt	80011a6c <BlancoNegro+0x168>
8001194c:	fe f8 03 b8 	ld.w	r8,pc[952]
80011950:	11 8a       	ld.ub	r10,r8[0x0]
80011952:	30 08       	mov	r8,0
80011954:	f0 0a 18 00 	cp.b	r10,r8
80011958:	e0 80 00 8d 	breq	80011a72 <BlancoNegro+0x16e>
8001195c:	fe f8 03 ac 	ld.w	r8,pc[940]
80011960:	11 8a       	ld.ub	r10,r8[0x0]
80011962:	30 38       	mov	r8,3
80011964:	f0 0a 18 00 	cp.b	r10,r8
80011968:	e0 81 00 85 	brne	80011a72 <BlancoNegro+0x16e>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
8001196c:	33 bc       	mov	r12,59
8001196e:	f0 1f 00 e8 	mcall	80011d0c <BlancoNegro+0x408>
		int R1,G1,B1,promedio;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
80011972:	fe f8 03 9e 	ld.w	r8,pc[926]
80011976:	70 08       	ld.w	r8,r8[0x0]
			gpio_set_gpio_pin(LED0_GPIO);
		}
	//Prueba de blur
}

void BlancoNegro (void)
80011978:	e2 69 58 00 	mov	r9,153600
8001197c:	f0 09 00 07 	add	r7,r8,r9
		{
			Value1=*puntero&0xFFFF;
			B1=Value1&BLUE;
			G1=(Value1&GREEN)>>5;
			R1=(Value1&RED)>>11;
			promedio=(B1+(G1/2)+R1)/3;
80011980:	e0 6c 55 56 	mov	r12,21846
80011984:	ea 1c 55 55 	orh	r12,0x5555
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
		{
			Value1=*puntero&0xFFFF;
80011988:	90 8a       	ld.uh	r10,r8[0x0]
			B1=Value1&BLUE;
			G1=(Value1&GREEN)>>5;
			R1=(Value1&RED)>>11;
			promedio=(B1+(G1/2)+R1)/3;
8001198a:	f4 0b 16 0b 	lsr	r11,r10,0xb
8001198e:	f3 da c0 05 	bfextu	r9,r10,0x0,0x5
80011992:	12 0b       	add	r11,r9
80011994:	f5 da c0 c5 	bfextu	r10,r10,0x6,0x5
80011998:	14 0b       	add	r11,r10
8001199a:	f6 0c 04 4a 	muls.d	r10,r11,r12
8001199e:	16 99       	mov	r9,r11
			B1=promedio;
			G1=(promedio*2)<<5;
			R1=promedio<<11;
			*puntero=B1+G1+R1;
800119a0:	f2 0a 15 0b 	lsl	r10,r9,0xb
800119a4:	12 0a       	add	r10,r9
800119a6:	a7 69       	lsl	r9,0x6
800119a8:	f4 09 00 09 	add	r9,r10,r9
800119ac:	10 b9       	st.h	r8++,r9
		gpio_clr_gpio_pin(LED0_GPIO);
		int R1,G1,B1,promedio;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
800119ae:	0e 38       	cp.w	r8,r7
800119b0:	ce c1       	brne	80011988 <BlancoNegro+0x84>
			G1=(promedio*2)<<5;
			R1=promedio<<11;
			*puntero=B1+G1+R1;
			puntero++;
		}
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
800119b2:	e0 64 00 f0 	mov	r4,240
800119b6:	1a d4       	st.w	--sp,r4
800119b8:	e0 6b 01 40 	mov	r11,320
800119bc:	1a db       	st.w	--sp,r11
800119be:	30 06       	mov	r6,0
800119c0:	1a d6       	st.w	--sp,r6
800119c2:	0c 98       	mov	r8,r6
800119c4:	0c 99       	mov	r9,r6
800119c6:	0c 9a       	mov	r10,r6
800119c8:	fe fc 03 48 	ld.w	r12,pc[840]
800119cc:	78 0c       	ld.w	r12,r12[0x0]
800119ce:	f0 1f 00 d2 	mcall	80011d14 <BlancoNegro+0x410>
		char NEG[]="B/N Activado";
800119d2:	fe f8 03 46 	ld.w	r8,pc[838]
800119d6:	fa cc ff f4 	sub	r12,sp,-12
800119da:	f0 ea 00 00 	ld.d	r10,r8[0]
800119de:	f8 eb 00 00 	st.d	r12[0],r10
800119e2:	70 29       	ld.w	r9,r8[0x8]
800119e4:	99 29       	st.w	r12[0x8],r9
800119e6:	f1 38 00 0c 	ld.ub	r8,r8[12]
800119ea:	f9 68 00 0c 	st.b	r12[12],r8
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
800119ee:	fe f3 03 2e 	ld.w	r3,pc[814]
800119f2:	e0 65 ff ff 	mov	r5,65535
800119f6:	1a d5       	st.w	--sp,r5
800119f8:	0c 98       	mov	r8,r6
800119fa:	e0 69 00 dc 	mov	r9,220
800119fe:	36 0a       	mov	r10,96
80011a00:	06 9b       	mov	r11,r3
80011a02:	f0 1f 00 c8 	mcall	80011d20 <BlancoNegro+0x41c>
		char NEG2[]="B/N";
80011a06:	fa c7 ff a8 	sub	r7,sp,-88
80011a0a:	e0 68 4e 00 	mov	r8,19968
80011a0e:	ea 18 42 2f 	orh	r8,0x422f
80011a12:	0e d8       	st.w	--r7,r8
		et024006_DrawFilledRect(240,0,80,40,WHITE);
80011a14:	0a 98       	mov	r8,r5
80011a16:	32 89       	mov	r9,40
80011a18:	35 0a       	mov	r10,80
80011a1a:	0c 9b       	mov	r11,r6
80011a1c:	08 9c       	mov	r12,r4
80011a1e:	f0 1f 00 c2 	mcall	80011d24 <BlancoNegro+0x420>
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80011a22:	1a d5       	st.w	--sp,r5
80011a24:	0c 98       	mov	r8,r6
80011a26:	31 09       	mov	r9,16
80011a28:	e0 6a 01 04 	mov	r10,260
80011a2c:	06 9b       	mov	r11,r3
80011a2e:	0e 9c       	mov	r12,r7
80011a30:	f0 1f 00 bc 	mcall	80011d20 <BlancoNegro+0x41c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80011a34:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80011a38:	e0 6a e1 c0 	mov	r10,57792
80011a3c:	ea 1a 00 e4 	orh	r10,0xe4
80011a40:	f0 0a 00 0a 	add	r10,r8,r10
80011a44:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80011a46:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80011a4a:	14 38       	cp.w	r8,r10
80011a4c:	e0 88 00 09 	brls	80011a5e <BlancoNegro+0x15a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80011a50:	12 38       	cp.w	r8,r9
80011a52:	fe 98 ff fa 	brls	80011a46 <BlancoNegro+0x142>
80011a56:	12 3a       	cp.w	r10,r9
80011a58:	e0 83 01 43 	brlo	80011cde <BlancoNegro+0x3da>
80011a5c:	cf 5b       	rjmp	80011a46 <BlancoNegro+0x142>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80011a5e:	12 38       	cp.w	r8,r9
80011a60:	e0 8b 01 3f 	brhi	80011cde <BlancoNegro+0x3da>
80011a64:	12 3a       	cp.w	r10,r9
80011a66:	e0 83 01 3c 	brlo	80011cde <BlancoNegro+0x3da>
80011a6a:	ce eb       	rjmp	80011a46 <BlancoNegro+0x142>
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(BNACT== true && X>96 && X<=232 && Y>220 && Y<=240 && xytot<filtro && busy==true && step==3)
80011a6c:	58 08       	cp.w	r8,0
80011a6e:	e0 80 01 3f 	breq	80011cec <BlancoNegro+0x3e8>
80011a72:	e0 49 00 60 	cp.w	r9,96
80011a76:	e0 8a 01 3b 	brle	80011cec <BlancoNegro+0x3e8>
80011a7a:	e0 49 00 e8 	cp.w	r9,232
80011a7e:	e0 89 01 37 	brgt	80011cec <BlancoNegro+0x3e8>
80011a82:	fe f8 02 7a 	ld.w	r8,pc[634]
80011a86:	70 08       	ld.w	r8,r8[0x0]
80011a88:	e0 48 00 dc 	cp.w	r8,220
80011a8c:	e0 8a 01 30 	brle	80011cec <BlancoNegro+0x3e8>
80011a90:	e0 48 00 f0 	cp.w	r8,240
80011a94:	e0 89 01 2c 	brgt	80011cec <BlancoNegro+0x3e8>
80011a98:	fe f8 02 68 	ld.w	r8,pc[616]
80011a9c:	70 08       	ld.w	r8,r8[0x0]
80011a9e:	58 28       	cp.w	r8,2
80011aa0:	e0 89 01 26 	brgt	80011cec <BlancoNegro+0x3e8>
80011aa4:	fe f8 02 60 	ld.w	r8,pc[608]
80011aa8:	11 89       	ld.ub	r9,r8[0x0]
80011aaa:	30 08       	mov	r8,0
80011aac:	f0 09 18 00 	cp.b	r9,r8
80011ab0:	e0 80 01 1e 	breq	80011cec <BlancoNegro+0x3e8>
80011ab4:	fe f8 02 54 	ld.w	r8,pc[596]
80011ab8:	11 89       	ld.ub	r9,r8[0x0]
80011aba:	30 38       	mov	r8,3
80011abc:	f0 09 18 00 	cp.b	r9,r8
80011ac0:	e0 81 01 16 	brne	80011cec <BlancoNegro+0x3e8>
	{
		BNACT=false;
80011ac4:	30 09       	mov	r9,0
80011ac6:	fe f8 02 2e 	ld.w	r8,pc[558]
80011aca:	b0 89       	st.b	r8[0x0],r9
gpio_clr_gpio_pin(LED0_GPIO);
80011acc:	33 bc       	mov	r12,59
80011ace:	f0 1f 00 90 	mcall	80011d0c <BlancoNegro+0x408>
et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80011ad2:	e0 62 00 f0 	mov	r2,240
80011ad6:	1a d2       	st.w	--sp,r2
80011ad8:	e0 6b 01 40 	mov	r11,320
80011adc:	1a db       	st.w	--sp,r11
80011ade:	30 06       	mov	r6,0
80011ae0:	1a d6       	st.w	--sp,r6
80011ae2:	0c 98       	mov	r8,r6
80011ae4:	0c 99       	mov	r9,r6
80011ae6:	0c 9a       	mov	r10,r6
80011ae8:	fe fc 02 28 	ld.w	r12,pc[552]
80011aec:	78 0c       	ld.w	r12,r12[0x0]
80011aee:	f0 1f 00 8a 	mcall	80011d14 <BlancoNegro+0x410>
char brillo[]="Brillo";
80011af2:	fe f8 02 36 	ld.w	r8,pc[566]
80011af6:	fa c4 ff c8 	sub	r4,sp,-56
80011afa:	70 09       	ld.w	r9,r8[0x0]
80011afc:	89 09       	st.w	r4[0x0],r9
80011afe:	11 c9       	ld.ub	r9,r8[0x4]
80011b00:	a8 c9       	st.b	r4[0x4],r9
80011b02:	11 d9       	ld.ub	r9,r8[0x5]
80011b04:	a8 d9       	st.b	r4[0x5],r9
80011b06:	11 e8       	ld.ub	r8,r8[0x6]
80011b08:	a8 e8       	st.b	r4[0x6],r8
char Negativo[]="Negativo";
80011b0a:	fe f8 02 22 	ld.w	r8,pc[546]
80011b0e:	fa c3 ff e4 	sub	r3,sp,-28
80011b12:	f0 ea 00 00 	ld.d	r10,r8[0]
80011b16:	e6 eb 00 00 	st.d	r3[0],r10
80011b1a:	f1 38 00 08 	ld.ub	r8,r8[8]
80011b1e:	e7 68 00 08 	st.b	r3[8],r8
char BlNe[]="B/N";
80011b22:	e0 68 4e 00 	mov	r8,19968
80011b26:	ea 18 42 2f 	orh	r8,0x422f
80011b2a:	51 48       	stdsp	sp[0x50],r8
char dila[]="Dilatar";
80011b2c:	e0 68 72 00 	mov	r8,29184
80011b30:	ea 18 74 61 	orh	r8,0x7461
80011b34:	e0 69 6c 61 	mov	r9,27745
80011b38:	ea 19 44 69 	orh	r9,0x4469
80011b3c:	fa e9 00 30 	st.d	sp[48],r8
et024006_DrawFilledRect(20,20,80,20,WHITE);
80011b40:	e0 68 ff ff 	mov	r8,65535
80011b44:	31 49       	mov	r9,20
80011b46:	35 0a       	mov	r10,80
80011b48:	12 9b       	mov	r11,r9
80011b4a:	12 9c       	mov	r12,r9
80011b4c:	f0 1f 00 76 	mcall	80011d24 <BlancoNegro+0x420>
et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
80011b50:	4f 35       	lddpc	r5,80011d1c <BlancoNegro+0x418>
80011b52:	e0 67 ff ff 	mov	r7,65535
80011b56:	1a d7       	st.w	--sp,r7
80011b58:	0c 98       	mov	r8,r6
80011b5a:	31 49       	mov	r9,20
80011b5c:	12 9a       	mov	r10,r9
80011b5e:	0a 9b       	mov	r11,r5
80011b60:	08 9c       	mov	r12,r4
80011b62:	f0 1f 00 70 	mcall	80011d20 <BlancoNegro+0x41c>
et024006_DrawFilledRect(20,50,80,20,WHITE);
80011b66:	0e 98       	mov	r8,r7
80011b68:	31 49       	mov	r9,20
80011b6a:	35 0a       	mov	r10,80
80011b6c:	33 2b       	mov	r11,50
80011b6e:	12 9c       	mov	r12,r9
80011b70:	f0 1f 00 6d 	mcall	80011d24 <BlancoNegro+0x420>
et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
80011b74:	1a d7       	st.w	--sp,r7
80011b76:	0c 98       	mov	r8,r6
80011b78:	33 29       	mov	r9,50
80011b7a:	31 4a       	mov	r10,20
80011b7c:	0a 9b       	mov	r11,r5
80011b7e:	06 9c       	mov	r12,r3
80011b80:	f0 1f 00 68 	mcall	80011d20 <BlancoNegro+0x41c>
et024006_DrawFilledRect(20,80,80,20,WHITE);
80011b84:	0e 98       	mov	r8,r7
80011b86:	31 49       	mov	r9,20
80011b88:	35 0a       	mov	r10,80
80011b8a:	14 9b       	mov	r11,r10
80011b8c:	12 9c       	mov	r12,r9
80011b8e:	f0 1f 00 66 	mcall	80011d24 <BlancoNegro+0x420>
et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
80011b92:	1a d7       	st.w	--sp,r7
80011b94:	0c 98       	mov	r8,r6
80011b96:	35 09       	mov	r9,80
80011b98:	31 4a       	mov	r10,20
80011b9a:	0a 9b       	mov	r11,r5
80011b9c:	fa cc ff a4 	sub	r12,sp,-92
80011ba0:	f0 1f 00 60 	mcall	80011d20 <BlancoNegro+0x41c>
et024006_DrawFilledRect(20,110,80,20,WHITE);
80011ba4:	0e 98       	mov	r8,r7
80011ba6:	31 49       	mov	r9,20
80011ba8:	35 0a       	mov	r10,80
80011baa:	36 eb       	mov	r11,110
80011bac:	12 9c       	mov	r12,r9
80011bae:	f0 1f 00 5e 	mcall	80011d24 <BlancoNegro+0x420>
char AutoFiltro[]="AutoFiltro";
80011bb2:	4e 08       	lddpc	r8,80011d30 <BlancoNegro+0x42c>
80011bb4:	fa cc ff e8 	sub	r12,sp,-24
80011bb8:	f0 ea 00 00 	ld.d	r10,r8[0]
80011bbc:	f8 eb 00 00 	st.d	r12[0],r10
80011bc0:	f1 39 00 08 	ld.ub	r9,r8[8]
80011bc4:	f9 69 00 08 	st.b	r12[8],r9
80011bc8:	f1 39 00 09 	ld.ub	r9,r8[9]
80011bcc:	f9 69 00 09 	st.b	r12[9],r9
80011bd0:	f1 38 00 0a 	ld.ub	r8,r8[10]
80011bd4:	f9 68 00 0a 	st.b	r12[10],r8
et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
80011bd8:	1a d7       	st.w	--sp,r7
80011bda:	0c 98       	mov	r8,r6
80011bdc:	36 e9       	mov	r9,110
80011bde:	31 4a       	mov	r10,20
80011be0:	0a 9b       	mov	r11,r5
80011be2:	f0 1f 00 50 	mcall	80011d20 <BlancoNegro+0x41c>
et024006_DrawFilledRect(20,140,80,20,WHITE);
80011be6:	0e 98       	mov	r8,r7
80011be8:	31 49       	mov	r9,20
80011bea:	35 0a       	mov	r10,80
80011bec:	e0 6b 00 8c 	mov	r11,140
80011bf0:	12 9c       	mov	r12,r9
80011bf2:	f0 1f 00 4d 	mcall	80011d24 <BlancoNegro+0x420>
et024006_PrintString(dila,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
80011bf6:	1a d7       	st.w	--sp,r7
80011bf8:	0c 98       	mov	r8,r6
80011bfa:	e0 69 00 8c 	mov	r9,140
80011bfe:	31 4a       	mov	r10,20
80011c00:	0a 9b       	mov	r11,r5
80011c02:	fa cc ff bc 	sub	r12,sp,-68
80011c06:	f0 1f 00 47 	mcall	80011d20 <BlancoNegro+0x41c>
et024006_DrawFilledRect(20,200,80,20,WHITE);
80011c0a:	2f 8d       	sub	sp,-32
80011c0c:	0e 98       	mov	r8,r7
80011c0e:	31 49       	mov	r9,20
80011c10:	35 0a       	mov	r10,80
80011c12:	e0 6b 00 c8 	mov	r11,200
80011c16:	12 9c       	mov	r12,r9
80011c18:	f0 1f 00 43 	mcall	80011d24 <BlancoNegro+0x420>
char Eros[]="Erosion";
80011c1c:	e0 68 6e 00 	mov	r8,28160
80011c20:	ea 18 69 6f 	orh	r8,0x696f
80011c24:	e0 69 6f 73 	mov	r9,28531
80011c28:	ea 19 45 72 	orh	r9,0x4572
80011c2c:	fa e9 00 1c 	st.d	sp[28],r8
et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
80011c30:	1a d7       	st.w	--sp,r7
80011c32:	0c 98       	mov	r8,r6
80011c34:	e0 69 00 c8 	mov	r9,200
80011c38:	31 4a       	mov	r10,20
80011c3a:	0a 9b       	mov	r11,r5
80011c3c:	fa cc ff e0 	sub	r12,sp,-32
80011c40:	f0 1f 00 38 	mcall	80011d20 <BlancoNegro+0x41c>
et024006_DrawFilledRect(20,170,80,20,WHITE);
80011c44:	0e 98       	mov	r8,r7
80011c46:	31 49       	mov	r9,20
80011c48:	35 0a       	mov	r10,80
80011c4a:	e0 6b 00 aa 	mov	r11,170
80011c4e:	12 9c       	mov	r12,r9
80011c50:	f0 1f 00 35 	mcall	80011d24 <BlancoNegro+0x420>
char BlNs[]="Blur";
80011c54:	4b 88       	lddpc	r8,80011d34 <BlancoNegro+0x430>
80011c56:	fa cc ff c0 	sub	r12,sp,-64
80011c5a:	70 09       	ld.w	r9,r8[0x0]
80011c5c:	99 09       	st.w	r12[0x0],r9
80011c5e:	11 c8       	ld.ub	r8,r8[0x4]
80011c60:	b8 c8       	st.b	r12[0x4],r8
et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
80011c62:	1a d7       	st.w	--sp,r7
80011c64:	0c 98       	mov	r8,r6
80011c66:	e0 69 00 aa 	mov	r9,170
80011c6a:	31 4a       	mov	r10,20
80011c6c:	0a 9b       	mov	r11,r5
80011c6e:	f0 1f 00 2d 	mcall	80011d20 <BlancoNegro+0x41c>
char Exit[]="SALIR";
80011c72:	4b 28       	lddpc	r8,80011d38 <BlancoNegro+0x434>
80011c74:	fa c4 ff c4 	sub	r4,sp,-60
80011c78:	70 09       	ld.w	r9,r8[0x0]
80011c7a:	89 09       	st.w	r4[0x0],r9
80011c7c:	11 c9       	ld.ub	r9,r8[0x4]
80011c7e:	a8 c9       	st.b	r4[0x4],r9
80011c80:	11 d8       	ld.ub	r8,r8[0x5]
80011c82:	a8 d8       	st.b	r4[0x5],r8
et024006_DrawFilledRect(240,0,80,40,WHITE);
80011c84:	0e 98       	mov	r8,r7
80011c86:	32 89       	mov	r9,40
80011c88:	35 0a       	mov	r10,80
80011c8a:	0c 9b       	mov	r11,r6
80011c8c:	04 9c       	mov	r12,r2
80011c8e:	f0 1f 00 26 	mcall	80011d24 <BlancoNegro+0x420>
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80011c92:	1a d7       	st.w	--sp,r7
80011c94:	0c 98       	mov	r8,r6
80011c96:	31 09       	mov	r9,16
80011c98:	e0 6a 01 04 	mov	r10,260
80011c9c:	0a 9b       	mov	r11,r5
80011c9e:	08 9c       	mov	r12,r4
80011ca0:	f0 1f 00 20 	mcall	80011d20 <BlancoNegro+0x41c>
step=2;
80011ca4:	30 29       	mov	r9,2
80011ca6:	49 98       	lddpc	r8,80011d08 <BlancoNegro+0x404>
80011ca8:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80011caa:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80011cae:	e0 6a e1 c0 	mov	r10,57792
80011cb2:	ea 1a 00 e4 	orh	r10,0xe4
80011cb6:	f0 0a 00 0a 	add	r10,r8,r10
80011cba:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80011cbc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80011cc0:	14 38       	cp.w	r8,r10
80011cc2:	e0 88 00 08 	brls	80011cd2 <BlancoNegro+0x3ce>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80011cc6:	12 38       	cp.w	r8,r9
80011cc8:	fe 98 ff fa 	brls	80011cbc <BlancoNegro+0x3b8>
80011ccc:	12 3a       	cp.w	r10,r9
80011cce:	c0 c3       	brcs	80011ce6 <BlancoNegro+0x3e2>
80011cd0:	cf 6b       	rjmp	80011cbc <BlancoNegro+0x3b8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80011cd2:	12 38       	cp.w	r8,r9
80011cd4:	e0 8b 00 09 	brhi	80011ce6 <BlancoNegro+0x3e2>
80011cd8:	12 3a       	cp.w	r10,r9
80011cda:	c0 63       	brcs	80011ce6 <BlancoNegro+0x3e2>
80011cdc:	cf 0b       	rjmp	80011cbc <BlancoNegro+0x3b8>
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
		char NEG2[]="B/N";
		et024006_DrawFilledRect(240,0,80,40,WHITE);
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
80011cde:	33 bc       	mov	r12,59
80011ce0:	f0 1f 00 17 	mcall	80011d3c <BlancoNegro+0x438>
	//Prueba de blur
}

void BlancoNegro (void)
{
	if(BNACT == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
80011ce4:	c0 48       	rjmp	80011cec <BlancoNegro+0x3e8>
char Exit[]="SALIR";
et024006_DrawFilledRect(240,0,80,40,WHITE);
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
step=2;
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
80011ce6:	33 bc       	mov	r12,59
80011ce8:	f0 1f 00 15 	mcall	80011d3c <BlancoNegro+0x438>
	}
}
80011cec:	2e ed       	sub	sp,-72
80011cee:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80011cf2:	00 00       	add	r0,r0
80011cf4:	00 00       	add	r0,r0
80011cf6:	07 61       	ld.uh	r1,--r3
80011cf8:	00 00       	add	r0,r0
80011cfa:	07 70       	ld.ub	r0,--r3
80011cfc:	00 00       	add	r0,r0
80011cfe:	07 74       	ld.ub	r4,--r3
80011d00:	00 00       	add	r0,r0
80011d02:	07 5c       	ld.sh	r12,--r3
80011d04:	00 00       	add	r0,r0
80011d06:	07 63       	ld.uh	r3,--r3
80011d08:	00 00       	add	r0,r0
80011d0a:	07 60       	ld.uh	r0,--r3
80011d0c:	80 00       	ld.sh	r0,r0[0x0]
80011d0e:	6c 7e       	ld.w	lr,r6[0x1c]
80011d10:	00 00       	add	r0,r0
80011d12:	0d 28       	ld.uh	r8,r6++
80011d14:	80 00       	ld.sh	r0,r0[0x0]
80011d16:	63 3c       	ld.w	r12,r1[0x4c]
80011d18:	80 01       	ld.sh	r1,r0[0x0]
80011d1a:	fe a0 80 01 	rcall	7ffe1d1c <__heap_size__+0x7dfe1d1c>
80011d1e:	dc 90       	acall	0xc9
80011d20:	80 00       	ld.sh	r0,r0[0x0]
80011d22:	60 18       	ld.w	r8,r0[0x4]
80011d24:	80 00       	ld.sh	r0,r0[0x0]
80011d26:	62 94       	ld.w	r4,r1[0x24]
80011d28:	80 01       	ld.sh	r1,r0[0x0]
80011d2a:	fe 70 80 01 	mov	r0,-32767
80011d2e:	fe 78 80 01 	mov	r8,-32767
80011d32:	fe 84 80 01 	brge	7ffe1d34 <__heap_size__+0x7dfe1d34>
80011d36:	fe 90 80 01 	breq	80001d38 <_trampoline+0x1d38>
80011d3a:	fe 98 80 00 	brls	80001d3a <_trampoline+0x1d3a>
80011d3e:	6c 62       	ld.w	r2,r6[0x18]

80011d40 <Blur>:
	
	}
}

void Blur (void)
{
80011d40:	d4 31       	pushm	r0-r7,lr
80011d42:	21 5d       	sub	sp,84
	//Prueba de blur
	if(blur == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
80011d44:	fe f8 05 0c 	ld.w	r8,pc[1292]
80011d48:	11 88       	ld.ub	r8,r8[0x0]
80011d4a:	58 08       	cp.w	r8,0
80011d4c:	e0 80 02 80 	breq	8001224c <Blur+0x50c>
80011d50:	fe f9 05 04 	ld.w	r9,pc[1284]
80011d54:	72 09       	ld.w	r9,r9[0x0]
80011d56:	e0 49 00 f0 	cp.w	r9,240
80011d5a:	e0 8a 01 39 	brle	80011fcc <Blur+0x28c>
80011d5e:	e0 49 01 40 	cp.w	r9,320
80011d62:	e0 89 01 35 	brgt	80011fcc <Blur+0x28c>
80011d66:	fe fa 04 f2 	ld.w	r10,pc[1266]
80011d6a:	74 0a       	ld.w	r10,r10[0x0]
80011d6c:	58 0a       	cp.w	r10,0
80011d6e:	e0 8a 01 2f 	brle	80011fcc <Blur+0x28c>
80011d72:	e0 4a 00 28 	cp.w	r10,40
80011d76:	e0 89 01 2b 	brgt	80011fcc <Blur+0x28c>
80011d7a:	fe fa 04 e2 	ld.w	r10,pc[1250]
80011d7e:	74 0a       	ld.w	r10,r10[0x0]
80011d80:	58 2a       	cp.w	r10,2
80011d82:	e0 89 01 25 	brgt	80011fcc <Blur+0x28c>
80011d86:	fe fa 04 da 	ld.w	r10,pc[1242]
80011d8a:	15 8b       	ld.ub	r11,r10[0x0]
80011d8c:	30 0a       	mov	r10,0
80011d8e:	f4 0b 18 00 	cp.b	r11,r10
80011d92:	e0 80 01 1d 	breq	80011fcc <Blur+0x28c>
80011d96:	fe fa 04 ce 	ld.w	r10,pc[1230]
80011d9a:	15 8b       	ld.ub	r11,r10[0x0]
80011d9c:	30 3a       	mov	r10,3
80011d9e:	f4 0b 18 00 	cp.b	r11,r10
80011da2:	e0 81 01 15 	brne	80011fcc <Blur+0x28c>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80011da6:	33 bc       	mov	r12,59
80011da8:	f0 1f 01 30 	mcall	80012268 <Blur+0x528>
	int R1,G1,B1, R2,G2, B2, promedio;
	int Value1, Value2;
	U16 *puntero;
	puntero = RawImg;
80011dac:	fe f8 04 c0 	ld.w	r8,pc[1216]
80011db0:	70 0a       	ld.w	r10,r8[0x0]
	promedio = 1;
	for (int i=0; i<76800;i++)
	{
		Value1=*puntero&0xFFFF;
80011db2:	94 8c       	ld.uh	r12,r10[0x0]
		B1=Value1&BLUE;
80011db4:	ed dc c0 05 	bfextu	r6,r12,0x0,0x5
		G1=(Value1&GREEN)>>5;
80011db8:	ef dc c0 a6 	bfextu	r7,r12,0x5,0x6
		R1=(Value1&RED)>>11;
80011dbc:	ab 9c       	lsr	r12,0xb
80011dbe:	30 08       	mov	r8,0
80011dc0:	30 19       	mov	r9,1
			R1+=R2;
			
			promedio++;
			
		}
		if((i%319)!=0){
80011dc2:	e0 64 49 d5 	mov	r4,18901
80011dc6:	ea 14 33 5c 	orh	r4,0x335c
80011dca:	c2 68       	rjmp	80011e16 <Blur+0xd6>
		G1=G1<<5;
		R1=R1<<11;
		
		*puntero = R1+G1+B1;

		puntero++;
80011dcc:	2f ea       	sub	r10,-2
	U16 *puntero;
	puntero = RawImg;
	promedio = 1;
	for (int i=0; i<76800;i++)
	{
		Value1=*puntero&0xFFFF;
80011dce:	94 8c       	ld.uh	r12,r10[0x0]
		B1=Value1&BLUE;
80011dd0:	ed dc c0 05 	bfextu	r6,r12,0x0,0x5
		G1=(Value1&GREEN)>>5;
80011dd4:	ef dc c0 a6 	bfextu	r7,r12,0x5,0x6
		R1=(Value1&RED)>>11;
80011dd8:	ab 9c       	lsr	r12,0xb
		
		if(i>320){
80011dda:	e0 48 01 40 	cp.w	r8,320
80011dde:	e0 89 00 04 	brgt	80011de6 <Blur+0xa6>
80011de2:	30 19       	mov	r9,1
80011de4:	c1 98       	rjmp	80011e16 <Blur+0xd6>
			Value2 = *(puntero-321);
80011de6:	f5 15 fd 7e 	ld.uh	r5,r10[-642]
			G1+=G2;
			R1+=R2;
			
			promedio++;
			
			Value2 = *(puntero-320);
80011dea:	f5 1b fd 80 	ld.uh	r11,r10[-640]
			Value2 = *(puntero-321);
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011dee:	f3 d5 c0 05 	bfextu	r9,r5,0x0,0x5
80011df2:	f2 06 00 06 	add	r6,r9,r6
			Value2 = *(puntero-320);
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011df6:	fd db c0 05 	bfextu	lr,r11,0x0,0x5
80011dfa:	1c 06       	add	r6,lr
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
80011dfc:	f3 d5 c0 a6 	bfextu	r9,r5,0x5,0x6
80011e00:	f2 07 00 07 	add	r7,r9,r7
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
80011e04:	f3 db c0 a6 	bfextu	r9,r11,0x5,0x6
80011e08:	12 07       	add	r7,r9
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
			R1+=R2;
80011e0a:	ab 95       	lsr	r5,0xb
80011e0c:	ea 0c 00 0c 	add	r12,r5,r12
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
			R1+=R2;
80011e10:	ab 9b       	lsr	r11,0xb
80011e12:	16 0c       	add	r12,r11
80011e14:	30 39       	mov	r9,3
			
			promedio++;
			
		}
		if((i%319)!=0){
80011e16:	f0 04 04 40 	muls.d	r0,r8,r4
80011e1a:	e2 0b 14 06 	asr	r11,r1,0x6
80011e1e:	f0 05 14 1f 	asr	r5,r8,0x1f
80011e22:	0a 1b       	sub	r11,r5
80011e24:	f6 0b 00 25 	add	r5,r11,r11<<0x2
80011e28:	a7 65       	lsl	r5,0x6
80011e2a:	ea 0b 01 0b 	sub	r11,r5,r11
80011e2e:	f0 0b 01 0b 	sub	r11,r8,r11
80011e32:	c1 80       	breq	80011e62 <Blur+0x122>
			
			Value2 = *(puntero+1);
80011e34:	94 95       	ld.uh	r5,r10[0x2]
			G1+=G2;
			R1+=R2;
			
			promedio++;
			
			Value2 = *(puntero-319);
80011e36:	f5 11 fd 82 	ld.uh	r1,r10[-638]
			
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011e3a:	e1 d1 c0 05 	bfextu	r0,r1,0x0,0x5
80011e3e:	fd d5 c0 05 	bfextu	lr,r5,0x0,0x5
80011e42:	e0 0e 00 0e 	add	lr,r0,lr
			
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011e46:	1c 06       	add	r6,lr
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
80011e48:	e1 d1 c0 a6 	bfextu	r0,r1,0x5,0x6
80011e4c:	fd d5 c0 a6 	bfextu	lr,r5,0x5,0x6
80011e50:	e0 0e 00 0e 	add	lr,r0,lr
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
80011e54:	1c 07       	add	r7,lr
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
			R1+=R2;
80011e56:	ab 91       	lsr	r1,0xb
80011e58:	ab 95       	lsr	r5,0xb
80011e5a:	e2 05 00 05 	add	r5,r1,r5
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
			R1+=R2;
80011e5e:	0a 0c       	add	r12,r5
			
			promedio++;
80011e60:	2f e9       	sub	r9,-2
			
			
		}
		if(i<=76480){
80011e62:	e0 58 2a c0 	cp.w	r8,76480
80011e66:	e0 89 00 0d 	brgt	80011e80 <Blur+0x140>
			
			Value2 = *(puntero+320);
80011e6a:	f5 15 02 80 	ld.uh	r5,r10[640]
			
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011e6e:	e3 d5 c0 05 	bfextu	r1,r5,0x0,0x5
80011e72:	02 06       	add	r6,r1
			G1+=G2;
80011e74:	e3 d5 c0 a6 	bfextu	r1,r5,0x5,0x6
80011e78:	02 07       	add	r7,r1
			R1+=R2;
80011e7a:	ab 95       	lsr	r5,0xb
80011e7c:	0a 0c       	add	r12,r5
			
			promedio++;
80011e7e:	2f f9       	sub	r9,-1
			
			
			
		}
		if((i!=0)||((i%320)!=0)){
80011e80:	58 08       	cp.w	r8,0
80011e82:	c0 c0       	breq	80011e9a <Blur+0x15a>
			
			Value2 = *(puntero-1);
80011e84:	f5 15 ff fe 	ld.uh	r5,r10[-2]
			
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011e88:	e3 d5 c0 05 	bfextu	r1,r5,0x0,0x5
80011e8c:	02 06       	add	r6,r1
			G1+=G2;
80011e8e:	e3 d5 c0 a6 	bfextu	r1,r5,0x5,0x6
80011e92:	02 07       	add	r7,r1
			R1+=R2;
80011e94:	ab 95       	lsr	r5,0xb
80011e96:	0a 0c       	add	r12,r5
			
			promedio++;
80011e98:	2f f9       	sub	r9,-1
			
		}
		
		if(((i%319)!=0)&&((i!=0)||((i%320)!=0))&&(i<=76480)){
80011e9a:	58 0b       	cp.w	r11,0
80011e9c:	c1 f0       	breq	80011eda <Blur+0x19a>
80011e9e:	58 08       	cp.w	r8,0
80011ea0:	c1 d0       	breq	80011eda <Blur+0x19a>
80011ea2:	e0 58 2a c0 	cp.w	r8,76480
80011ea6:	e0 89 00 1a 	brgt	80011eda <Blur+0x19a>
			
			Value2 = *(puntero+319);
80011eaa:	f5 1b 02 7e 	ld.uh	r11,r10[638]
			G1+=G2;
			R1+=R2;
			
			promedio++;
			
			Value2 = *(puntero+321);
80011eae:	f5 1e 02 82 	ld.uh	lr,r10[642]
			
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011eb2:	e3 de c0 05 	bfextu	r1,lr,0x0,0x5
80011eb6:	eb db c0 05 	bfextu	r5,r11,0x0,0x5
80011eba:	e2 05 00 05 	add	r5,r1,r5
			
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
80011ebe:	0a 06       	add	r6,r5
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
80011ec0:	e3 de c0 a6 	bfextu	r1,lr,0x5,0x6
80011ec4:	eb db c0 a6 	bfextu	r5,r11,0x5,0x6
80011ec8:	e2 05 00 05 	add	r5,r1,r5
			B2=Value2&BLUE;
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
80011ecc:	0a 07       	add	r7,r5
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
			R1+=R2;
80011ece:	ab 9e       	lsr	lr,0xb
80011ed0:	ab 9b       	lsr	r11,0xb
80011ed2:	fc 0b 00 0b 	add	r11,lr,r11
			G2=(Value2&GREEN)>>5;
			R2=(Value2&RED)>>11;
			
			B1+=B2;
			G1+=G2;
			R1+=R2;
80011ed6:	16 0c       	add	r12,r11
			
			promedio++;
80011ed8:	2f e9       	sub	r9,-2
			
		}
		
		B1/=promedio;
		G1/=promedio;
80011eda:	ee 09 0c 00 	divs	r0,r7,r9
		R1/=promedio;
80011ede:	f8 09 0c 02 	divs	r2,r12,r9
80011ee2:	fa e3 00 00 	st.d	sp[0],r2
		
		G1=G1<<5;
		R1=R1<<11;
		
		*puntero = R1+G1+B1;
80011ee6:	40 1c       	lddsp	r12,sp[0x4]
80011ee8:	ab 7c       	lsl	r12,0xb
80011eea:	e0 0b 15 05 	lsl	r11,r0,0x5
80011eee:	f8 0b 00 0b 	add	r11,r12,r11
80011ef2:	ec 09 0c 06 	divs	r6,r6,r9
80011ef6:	0c 92       	mov	r2,r6
80011ef8:	f6 06 00 09 	add	r9,r11,r6
80011efc:	b4 09       	st.h	r10[0x0],r9
	int R1,G1,B1, R2,G2, B2, promedio;
	int Value1, Value2;
	U16 *puntero;
	puntero = RawImg;
	promedio = 1;
	for (int i=0; i<76800;i++)
80011efe:	2f f8       	sub	r8,-1
80011f00:	e0 58 2c 00 	cp.w	r8,76800
80011f04:	fe 91 ff 64 	brne	80011dcc <Blur+0x8c>
		*puntero = R1+G1+B1;

		puntero++;
		promedio = 1;
	}
	et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80011f08:	e0 64 00 f0 	mov	r4,240
80011f0c:	1a d4       	st.w	--sp,r4
80011f0e:	e0 6b 01 40 	mov	r11,320
80011f12:	1a db       	st.w	--sp,r11
80011f14:	30 07       	mov	r7,0
80011f16:	1a d7       	st.w	--sp,r7
80011f18:	0e 98       	mov	r8,r7
80011f1a:	0e 99       	mov	r9,r7
80011f1c:	0e 9a       	mov	r10,r7
80011f1e:	fe fc 03 4e 	ld.w	r12,pc[846]
80011f22:	78 0c       	ld.w	r12,r12[0x0]
80011f24:	f0 1f 00 d3 	mcall	80012270 <Blur+0x530>
	char brillo[]="Blur Activado";
80011f28:	fe f8 03 4c 	ld.w	r8,pc[844]
80011f2c:	fa cc ff ec 	sub	r12,sp,-20
80011f30:	f0 ea 00 00 	ld.d	r10,r8[0]
80011f34:	f8 eb 00 00 	st.d	r12[0],r10
80011f38:	70 29       	ld.w	r9,r8[0x8]
80011f3a:	99 29       	st.w	r12[0x8],r9
80011f3c:	f1 39 00 0c 	ld.ub	r9,r8[12]
80011f40:	f9 69 00 0c 	st.b	r12[12],r9
80011f44:	f1 38 00 0d 	ld.ub	r8,r8[13]
80011f48:	f9 68 00 0d 	st.b	r12[13],r8
	et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
80011f4c:	fe f3 03 2c 	ld.w	r3,pc[812]
80011f50:	e0 66 ff ff 	mov	r6,65535
80011f54:	1a d6       	st.w	--sp,r6
80011f56:	0e 98       	mov	r8,r7
80011f58:	e0 69 00 dc 	mov	r9,220
80011f5c:	35 aa       	mov	r10,90
80011f5e:	06 9b       	mov	r11,r3
80011f60:	f0 1f 00 c7 	mcall	8001227c <Blur+0x53c>
	char NEG2[]="Blur";
80011f64:	fe f8 03 1c 	ld.w	r8,pc[796]
80011f68:	fa c5 ff a4 	sub	r5,sp,-92
80011f6c:	70 09       	ld.w	r9,r8[0x0]
80011f6e:	8b 09       	st.w	r5[0x0],r9
80011f70:	11 c8       	ld.ub	r8,r8[0x4]
80011f72:	aa c8       	st.b	r5[0x4],r8
	et024006_DrawFilledRect(240,0,80,40,WHITE);
80011f74:	0c 98       	mov	r8,r6
80011f76:	32 89       	mov	r9,40
80011f78:	35 0a       	mov	r10,80
80011f7a:	0e 9b       	mov	r11,r7
80011f7c:	08 9c       	mov	r12,r4
80011f7e:	f0 1f 00 c2 	mcall	80012284 <Blur+0x544>
	et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
80011f82:	1a d6       	st.w	--sp,r6
80011f84:	0e 98       	mov	r8,r7
80011f86:	31 09       	mov	r9,16
80011f88:	e0 6a 00 fa 	mov	r10,250
80011f8c:	06 9b       	mov	r11,r3
80011f8e:	0a 9c       	mov	r12,r5
80011f90:	f0 1f 00 bb 	mcall	8001227c <Blur+0x53c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80011f94:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80011f98:	e0 6a e1 c0 	mov	r10,57792
80011f9c:	ea 1a 00 e4 	orh	r10,0xe4
80011fa0:	f0 0a 00 0a 	add	r10,r8,r10
80011fa4:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80011fa6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80011faa:	14 38       	cp.w	r8,r10
80011fac:	e0 88 00 09 	brls	80011fbe <Blur+0x27e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80011fb0:	12 38       	cp.w	r8,r9
80011fb2:	fe 98 ff fa 	brls	80011fa6 <Blur+0x266>
80011fb6:	12 3a       	cp.w	r10,r9
80011fb8:	e0 83 01 43 	brlo	8001223e <Blur+0x4fe>
80011fbc:	cf 5b       	rjmp	80011fa6 <Blur+0x266>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80011fbe:	12 38       	cp.w	r8,r9
80011fc0:	e0 8b 01 3f 	brhi	8001223e <Blur+0x4fe>
80011fc4:	12 3a       	cp.w	r10,r9
80011fc6:	e0 83 01 3c 	brlo	8001223e <Blur+0x4fe>
80011fca:	ce eb       	rjmp	80011fa6 <Blur+0x266>
	delay_ms(250);
	gpio_set_gpio_pin(LED0_GPIO);
	}
		else if(blur== true && X>96 && X<=232 && Y>220 && Y<=240 && xytot<filtro && busy==true && step==3)
80011fcc:	58 08       	cp.w	r8,0
80011fce:	e0 80 01 3f 	breq	8001224c <Blur+0x50c>
80011fd2:	e0 49 00 60 	cp.w	r9,96
80011fd6:	e0 8a 01 3b 	brle	8001224c <Blur+0x50c>
80011fda:	e0 49 00 e8 	cp.w	r9,232
80011fde:	e0 89 01 37 	brgt	8001224c <Blur+0x50c>
80011fe2:	fe f8 02 76 	ld.w	r8,pc[630]
80011fe6:	70 08       	ld.w	r8,r8[0x0]
80011fe8:	e0 48 00 dc 	cp.w	r8,220
80011fec:	e0 8a 01 30 	brle	8001224c <Blur+0x50c>
80011ff0:	e0 48 00 f0 	cp.w	r8,240
80011ff4:	e0 89 01 2c 	brgt	8001224c <Blur+0x50c>
80011ff8:	fe f8 02 64 	ld.w	r8,pc[612]
80011ffc:	70 08       	ld.w	r8,r8[0x0]
80011ffe:	58 28       	cp.w	r8,2
80012000:	e0 89 01 26 	brgt	8001224c <Blur+0x50c>
80012004:	fe f8 02 5c 	ld.w	r8,pc[604]
80012008:	11 89       	ld.ub	r9,r8[0x0]
8001200a:	30 08       	mov	r8,0
8001200c:	f0 09 18 00 	cp.b	r9,r8
80012010:	e0 80 01 1e 	breq	8001224c <Blur+0x50c>
80012014:	fe f8 02 50 	ld.w	r8,pc[592]
80012018:	11 89       	ld.ub	r9,r8[0x0]
8001201a:	30 38       	mov	r8,3
8001201c:	f0 09 18 00 	cp.b	r9,r8
80012020:	e0 81 01 16 	brne	8001224c <Blur+0x50c>
		{
			blur=false;
80012024:	30 09       	mov	r9,0
80012026:	fe f8 02 2a 	ld.w	r8,pc[554]
8001202a:	b0 89       	st.b	r8[0x0],r9
			gpio_clr_gpio_pin(LED0_GPIO);
8001202c:	33 bc       	mov	r12,59
8001202e:	f0 1f 00 8f 	mcall	80012268 <Blur+0x528>
			et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80012032:	e0 62 00 f0 	mov	r2,240
80012036:	1a d2       	st.w	--sp,r2
80012038:	e0 6b 01 40 	mov	r11,320
8001203c:	1a db       	st.w	--sp,r11
8001203e:	30 06       	mov	r6,0
80012040:	1a d6       	st.w	--sp,r6
80012042:	0c 98       	mov	r8,r6
80012044:	0c 99       	mov	r9,r6
80012046:	0c 9a       	mov	r10,r6
80012048:	fe fc 02 24 	ld.w	r12,pc[548]
8001204c:	78 0c       	ld.w	r12,r12[0x0]
8001204e:	f0 1f 00 89 	mcall	80012270 <Blur+0x530>
			char brillo[]="Brillo";
80012052:	fe f8 02 36 	ld.w	r8,pc[566]
80012056:	fa c4 ff c0 	sub	r4,sp,-64
8001205a:	70 09       	ld.w	r9,r8[0x0]
8001205c:	89 09       	st.w	r4[0x0],r9
8001205e:	11 c9       	ld.ub	r9,r8[0x4]
80012060:	a8 c9       	st.b	r4[0x4],r9
80012062:	11 d9       	ld.ub	r9,r8[0x5]
80012064:	a8 d9       	st.b	r4[0x5],r9
80012066:	11 e8       	ld.ub	r8,r8[0x6]
80012068:	a8 e8       	st.b	r4[0x6],r8
			char Negativo[]="Negativo";
8001206a:	fe f8 02 22 	ld.w	r8,pc[546]
8001206e:	fa c3 ff dc 	sub	r3,sp,-36
80012072:	f0 ea 00 00 	ld.d	r10,r8[0]
80012076:	e6 eb 00 00 	st.d	r3[0],r10
8001207a:	f1 38 00 08 	ld.ub	r8,r8[8]
8001207e:	e7 68 00 08 	st.b	r3[8],r8
			char BlNe[]="B/N";
80012082:	e0 68 4e 00 	mov	r8,19968
80012086:	ea 18 42 2f 	orh	r8,0x422f
8001208a:	51 68       	stdsp	sp[0x58],r8
			char dila[]="Dilatar";
8001208c:	e0 68 72 00 	mov	r8,29184
80012090:	ea 18 74 61 	orh	r8,0x7461
80012094:	e0 69 6c 61 	mov	r9,27745
80012098:	ea 19 44 69 	orh	r9,0x4469
8001209c:	fa e9 00 38 	st.d	sp[56],r8
			et024006_DrawFilledRect(20,20,80,20,WHITE);
800120a0:	e0 68 ff ff 	mov	r8,65535
800120a4:	31 49       	mov	r9,20
800120a6:	35 0a       	mov	r10,80
800120a8:	12 9b       	mov	r11,r9
800120aa:	12 9c       	mov	r12,r9
800120ac:	f0 1f 00 76 	mcall	80012284 <Blur+0x544>
			et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
800120b0:	4f 25       	lddpc	r5,80012278 <Blur+0x538>
800120b2:	e0 67 ff ff 	mov	r7,65535
800120b6:	1a d7       	st.w	--sp,r7
800120b8:	0c 98       	mov	r8,r6
800120ba:	31 49       	mov	r9,20
800120bc:	12 9a       	mov	r10,r9
800120be:	0a 9b       	mov	r11,r5
800120c0:	08 9c       	mov	r12,r4
800120c2:	f0 1f 00 6f 	mcall	8001227c <Blur+0x53c>
			et024006_DrawFilledRect(20,50,80,20,WHITE);
800120c6:	0e 98       	mov	r8,r7
800120c8:	31 49       	mov	r9,20
800120ca:	35 0a       	mov	r10,80
800120cc:	33 2b       	mov	r11,50
800120ce:	12 9c       	mov	r12,r9
800120d0:	f0 1f 00 6d 	mcall	80012284 <Blur+0x544>
			et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
800120d4:	1a d7       	st.w	--sp,r7
800120d6:	0c 98       	mov	r8,r6
800120d8:	33 29       	mov	r9,50
800120da:	31 4a       	mov	r10,20
800120dc:	0a 9b       	mov	r11,r5
800120de:	06 9c       	mov	r12,r3
800120e0:	f0 1f 00 67 	mcall	8001227c <Blur+0x53c>
			et024006_DrawFilledRect(20,80,80,20,WHITE);
800120e4:	0e 98       	mov	r8,r7
800120e6:	31 49       	mov	r9,20
800120e8:	35 0a       	mov	r10,80
800120ea:	14 9b       	mov	r11,r10
800120ec:	12 9c       	mov	r12,r9
800120ee:	f0 1f 00 66 	mcall	80012284 <Blur+0x544>
			et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
800120f2:	1a d7       	st.w	--sp,r7
800120f4:	0c 98       	mov	r8,r6
800120f6:	35 09       	mov	r9,80
800120f8:	31 4a       	mov	r10,20
800120fa:	0a 9b       	mov	r11,r5
800120fc:	fa cc ff 9c 	sub	r12,sp,-100
80012100:	f0 1f 00 5f 	mcall	8001227c <Blur+0x53c>
			et024006_DrawFilledRect(20,110,80,20,WHITE);
80012104:	0e 98       	mov	r8,r7
80012106:	31 49       	mov	r9,20
80012108:	35 0a       	mov	r10,80
8001210a:	36 eb       	mov	r11,110
8001210c:	12 9c       	mov	r12,r9
8001210e:	f0 1f 00 5e 	mcall	80012284 <Blur+0x544>
			char AutoFiltro[]="AutoFiltro";
80012112:	4e 08       	lddpc	r8,80012290 <Blur+0x550>
80012114:	fa cc ff e0 	sub	r12,sp,-32
80012118:	f0 ea 00 00 	ld.d	r10,r8[0]
8001211c:	f8 eb 00 00 	st.d	r12[0],r10
80012120:	f1 39 00 08 	ld.ub	r9,r8[8]
80012124:	f9 69 00 08 	st.b	r12[8],r9
80012128:	f1 39 00 09 	ld.ub	r9,r8[9]
8001212c:	f9 69 00 09 	st.b	r12[9],r9
80012130:	f1 38 00 0a 	ld.ub	r8,r8[10]
80012134:	f9 68 00 0a 	st.b	r12[10],r8
			et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
80012138:	1a d7       	st.w	--sp,r7
8001213a:	0c 98       	mov	r8,r6
8001213c:	36 e9       	mov	r9,110
8001213e:	31 4a       	mov	r10,20
80012140:	0a 9b       	mov	r11,r5
80012142:	f0 1f 00 4f 	mcall	8001227c <Blur+0x53c>
			et024006_DrawFilledRect(20,140,80,20,WHITE);
80012146:	0e 98       	mov	r8,r7
80012148:	31 49       	mov	r9,20
8001214a:	35 0a       	mov	r10,80
8001214c:	e0 6b 00 8c 	mov	r11,140
80012150:	12 9c       	mov	r12,r9
80012152:	f0 1f 00 4d 	mcall	80012284 <Blur+0x544>
			et024006_PrintString(dila,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
80012156:	1a d7       	st.w	--sp,r7
80012158:	0c 98       	mov	r8,r6
8001215a:	e0 69 00 8c 	mov	r9,140
8001215e:	31 4a       	mov	r10,20
80012160:	0a 9b       	mov	r11,r5
80012162:	fa cc ff b4 	sub	r12,sp,-76
80012166:	f0 1f 00 46 	mcall	8001227c <Blur+0x53c>
			et024006_DrawFilledRect(20,200,80,20,WHITE);
8001216a:	2f 8d       	sub	sp,-32
8001216c:	0e 98       	mov	r8,r7
8001216e:	31 49       	mov	r9,20
80012170:	35 0a       	mov	r10,80
80012172:	e0 6b 00 c8 	mov	r11,200
80012176:	12 9c       	mov	r12,r9
80012178:	f0 1f 00 43 	mcall	80012284 <Blur+0x544>
			char Eros[]="Erosion";
8001217c:	e0 68 6e 00 	mov	r8,28160
80012180:	ea 18 69 6f 	orh	r8,0x696f
80012184:	e0 69 6f 73 	mov	r9,28531
80012188:	ea 19 45 72 	orh	r9,0x4572
8001218c:	fa e9 00 24 	st.d	sp[36],r8
			et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
80012190:	1a d7       	st.w	--sp,r7
80012192:	0c 98       	mov	r8,r6
80012194:	e0 69 00 c8 	mov	r9,200
80012198:	31 4a       	mov	r10,20
8001219a:	0a 9b       	mov	r11,r5
8001219c:	fa cc ff d8 	sub	r12,sp,-40
800121a0:	f0 1f 00 37 	mcall	8001227c <Blur+0x53c>
			et024006_DrawFilledRect(20,170,80,20,WHITE);
800121a4:	0e 98       	mov	r8,r7
800121a6:	31 49       	mov	r9,20
800121a8:	35 0a       	mov	r10,80
800121aa:	e0 6b 00 aa 	mov	r11,170
800121ae:	12 9c       	mov	r12,r9
800121b0:	f0 1f 00 35 	mcall	80012284 <Blur+0x544>
			char BlNs[]="Blur";
800121b4:	4b 38       	lddpc	r8,80012280 <Blur+0x540>
800121b6:	fa cc ff b8 	sub	r12,sp,-72
800121ba:	70 09       	ld.w	r9,r8[0x0]
800121bc:	99 09       	st.w	r12[0x0],r9
800121be:	11 c8       	ld.ub	r8,r8[0x4]
800121c0:	b8 c8       	st.b	r12[0x4],r8
			et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
800121c2:	1a d7       	st.w	--sp,r7
800121c4:	0c 98       	mov	r8,r6
800121c6:	e0 69 00 aa 	mov	r9,170
800121ca:	31 4a       	mov	r10,20
800121cc:	0a 9b       	mov	r11,r5
800121ce:	f0 1f 00 2c 	mcall	8001227c <Blur+0x53c>
			char Exit[]="SALIR";
800121d2:	4b 18       	lddpc	r8,80012294 <Blur+0x554>
800121d4:	fa c4 ff bc 	sub	r4,sp,-68
800121d8:	70 09       	ld.w	r9,r8[0x0]
800121da:	89 09       	st.w	r4[0x0],r9
800121dc:	11 c9       	ld.ub	r9,r8[0x4]
800121de:	a8 c9       	st.b	r4[0x4],r9
800121e0:	11 d8       	ld.ub	r8,r8[0x5]
800121e2:	a8 d8       	st.b	r4[0x5],r8
			et024006_DrawFilledRect(240,0,80,40,WHITE);
800121e4:	0e 98       	mov	r8,r7
800121e6:	32 89       	mov	r9,40
800121e8:	35 0a       	mov	r10,80
800121ea:	0c 9b       	mov	r11,r6
800121ec:	04 9c       	mov	r12,r2
800121ee:	f0 1f 00 26 	mcall	80012284 <Blur+0x544>
			et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
800121f2:	1a d7       	st.w	--sp,r7
800121f4:	0c 98       	mov	r8,r6
800121f6:	31 09       	mov	r9,16
800121f8:	e0 6a 01 04 	mov	r10,260
800121fc:	0a 9b       	mov	r11,r5
800121fe:	08 9c       	mov	r12,r4
80012200:	f0 1f 00 1f 	mcall	8001227c <Blur+0x53c>
			step=2;
80012204:	30 29       	mov	r9,2
80012206:	49 88       	lddpc	r8,80012264 <Blur+0x524>
80012208:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8001220a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001220e:	e0 6a e1 c0 	mov	r10,57792
80012212:	ea 1a 00 e4 	orh	r10,0xe4
80012216:	f0 0a 00 0a 	add	r10,r8,r10
8001221a:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8001221c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80012220:	14 38       	cp.w	r8,r10
80012222:	e0 88 00 08 	brls	80012232 <Blur+0x4f2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80012226:	12 38       	cp.w	r8,r9
80012228:	fe 98 ff fa 	brls	8001221c <Blur+0x4dc>
8001222c:	12 3a       	cp.w	r10,r9
8001222e:	c0 c3       	brcs	80012246 <Blur+0x506>
80012230:	cf 6b       	rjmp	8001221c <Blur+0x4dc>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80012232:	12 38       	cp.w	r8,r9
80012234:	e0 8b 00 09 	brhi	80012246 <Blur+0x506>
80012238:	12 3a       	cp.w	r10,r9
8001223a:	c0 63       	brcs	80012246 <Blur+0x506>
8001223c:	cf 0b       	rjmp	8001221c <Blur+0x4dc>
	et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
	char NEG2[]="Blur";
	et024006_DrawFilledRect(240,0,80,40,WHITE);
	et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
	delay_ms(250);
	gpio_set_gpio_pin(LED0_GPIO);
8001223e:	33 bc       	mov	r12,59
80012240:	f0 1f 00 16 	mcall	80012298 <Blur+0x558>
}

void Blur (void)
{
	//Prueba de blur
	if(blur == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
80012244:	c0 48       	rjmp	8001224c <Blur+0x50c>
			char Exit[]="SALIR";
			et024006_DrawFilledRect(240,0,80,40,WHITE);
			et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
			step=2;
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
80012246:	33 bc       	mov	r12,59
80012248:	f0 1f 00 14 	mcall	80012298 <Blur+0x558>
		}
	//Prueba de blur
}
8001224c:	2e bd       	sub	sp,-84
8001224e:	d8 32       	popm	r0-r7,pc
80012250:	00 00       	add	r0,r0
80012252:	07 62       	ld.uh	r2,--r3
80012254:	00 00       	add	r0,r0
80012256:	07 70       	ld.ub	r0,--r3
80012258:	00 00       	add	r0,r0
8001225a:	07 74       	ld.ub	r4,--r3
8001225c:	00 00       	add	r0,r0
8001225e:	07 5c       	ld.sh	r12,--r3
80012260:	00 00       	add	r0,r0
80012262:	07 63       	ld.uh	r3,--r3
80012264:	00 00       	add	r0,r0
80012266:	07 60       	ld.uh	r0,--r3
80012268:	80 00       	ld.sh	r0,r0[0x0]
8001226a:	6c 7e       	ld.w	lr,r6[0x1c]
8001226c:	00 00       	add	r0,r0
8001226e:	0d 28       	ld.uh	r8,r6++
80012270:	80 00       	ld.sh	r0,r0[0x0]
80012272:	63 3c       	ld.w	r12,r1[0x4c]
80012274:	80 01       	ld.sh	r1,r0[0x0]
80012276:	fe b0 80 01 	rcall	80002278 <sd_mmc_spi_command+0x8c>
8001227a:	dc 90       	acall	0xc9
8001227c:	80 00       	ld.sh	r0,r0[0x0]
8001227e:	60 18       	ld.w	r8,r0[0x4]
80012280:	80 01       	ld.sh	r1,r0[0x0]
80012282:	fe 90 80 00 	breq	80002282 <sd_mmc_spi_command+0x96>
80012286:	62 94       	ld.w	r4,r1[0x24]
80012288:	80 01       	ld.sh	r1,r0[0x0]
8001228a:	fe 70 80 01 	mov	r0,-32767
8001228e:	fe 78 80 01 	mov	r8,-32767
80012292:	fe 84 80 01 	brge	7ffe2294 <__heap_size__+0x7dfe2294>
80012296:	fe 98 80 00 	brls	80002296 <sd_mmc_spi_command+0xaa>
8001229a:	6c 62       	ld.w	r2,r6[0x18]

8001229c <Erosion>:
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Erosion (void)
{
8001229c:	eb cd 40 fe 	pushm	r1-r7,lr
800122a0:	21 3d       	sub	sp,76
		if (X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3 && eros==true)
800122a2:	fe f8 05 0e 	ld.w	r8,pc[1294]
800122a6:	70 08       	ld.w	r8,r8[0x0]
800122a8:	f0 c9 00 f1 	sub	r9,r8,241
800122ac:	e0 49 00 4f 	cp.w	r9,79
800122b0:	e0 8b 01 2d 	brhi	8001250a <Erosion+0x26e>
800122b4:	fe f9 05 00 	ld.w	r9,pc[1280]
800122b8:	72 09       	ld.w	r9,r9[0x0]
800122ba:	58 09       	cp.w	r9,0
800122bc:	e0 8a 01 27 	brle	8001250a <Erosion+0x26e>
800122c0:	e0 49 00 28 	cp.w	r9,40
800122c4:	e0 89 01 23 	brgt	8001250a <Erosion+0x26e>
800122c8:	fe f9 04 f0 	ld.w	r9,pc[1264]
800122cc:	72 09       	ld.w	r9,r9[0x0]
800122ce:	58 29       	cp.w	r9,2
800122d0:	e0 89 01 1d 	brgt	8001250a <Erosion+0x26e>
800122d4:	fe f9 04 e8 	ld.w	r9,pc[1256]
800122d8:	13 8a       	ld.ub	r10,r9[0x0]
800122da:	30 09       	mov	r9,0
800122dc:	f2 0a 18 00 	cp.b	r10,r9
800122e0:	e0 80 01 15 	breq	8001250a <Erosion+0x26e>
800122e4:	fe f9 04 dc 	ld.w	r9,pc[1244]
800122e8:	13 8a       	ld.ub	r10,r9[0x0]
800122ea:	30 39       	mov	r9,3
800122ec:	f2 0a 18 00 	cp.b	r10,r9
800122f0:	e0 81 01 0d 	brne	8001250a <Erosion+0x26e>
800122f4:	fe f8 04 d0 	ld.w	r8,pc[1232]
800122f8:	11 89       	ld.ub	r9,r8[0x0]
800122fa:	30 08       	mov	r8,0
800122fc:	f0 09 18 00 	cp.b	r9,r8
80012300:	e0 80 02 54 	breq	800127a8 <Erosion+0x50c>
		{
			gpio_clr_gpio_pin(LED0_GPIO);
80012304:	33 bc       	mov	r12,59
80012306:	f0 1f 01 31 	mcall	800127c8 <Erosion+0x52c>
			int R1,G1,B1, R2,G2, B2, promedio;
			int Value1, Value2;
			U16 *puntero;
			puntero = RawImg;
8001230a:	fe f8 04 c2 	ld.w	r8,pc[1218]
8001230e:	70 08       	ld.w	r8,r8[0x0]
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Erosion (void)
80012310:	e2 69 58 00 	mov	r9,153600
80012314:	f0 09 00 07 	add	r7,r8,r9
			{
				Value1=*puntero&0xFFFF;
				B1=Value1&BLUE;
				G1=(Value1&GREEN)>>5;
				R1=(Value1&RED)>>11;
				promedio=(B1+(G1/2)+R1)/3;
80012318:	e0 6c 55 56 	mov	r12,21846
8001231c:	ea 1c 55 55 	orh	r12,0x5555
			int Value1, Value2;
			U16 *puntero;
			puntero = RawImg;
			for (int i=0; i<76800;i++)
			{
				Value1=*puntero&0xFFFF;
80012320:	90 8a       	ld.uh	r10,r8[0x0]
				B1=Value1&BLUE;
				G1=(Value1&GREEN)>>5;
				R1=(Value1&RED)>>11;
				promedio=(B1+(G1/2)+R1)/3;
80012322:	f4 0b 16 0b 	lsr	r11,r10,0xb
80012326:	f3 da c0 05 	bfextu	r9,r10,0x0,0x5
8001232a:	12 0b       	add	r11,r9
8001232c:	f5 da c0 c5 	bfextu	r10,r10,0x6,0x5
80012330:	14 0b       	add	r11,r10
80012332:	f6 0c 04 4a 	muls.d	r10,r11,r12
80012336:	16 99       	mov	r9,r11
				B1=promedio;
				G1=(promedio*2)<<5;
				R1=promedio<<11;
				*puntero=B1+G1+R1;
80012338:	f2 0a 15 0b 	lsl	r10,r9,0xb
8001233c:	12 0a       	add	r10,r9
8001233e:	a7 69       	lsl	r9,0x6
80012340:	f4 09 00 09 	add	r9,r10,r9
80012344:	10 b9       	st.h	r8++,r9
			gpio_clr_gpio_pin(LED0_GPIO);
			int R1,G1,B1, R2,G2, B2, promedio;
			int Value1, Value2;
			U16 *puntero;
			puntero = RawImg;
			for (int i=0; i<76800;i++)
80012346:	0e 38       	cp.w	r8,r7
80012348:	ce c1       	brne	80012320 <Erosion+0x84>
				G1=(promedio*2)<<5;
				R1=promedio<<11;
				*puntero=B1+G1+R1;
				puntero++;
			}
			puntero = RawImg;
8001234a:	fe f8 04 82 	ld.w	r8,pc[1154]
8001234e:	70 07       	ld.w	r7,r8[0x0]
80012350:	ee c9 ff fe 	sub	r9,r7,-2
80012354:	ee cb 02 82 	sub	r11,r7,642
80012358:	ee c5 fd 80 	sub	r5,r7,-640
8001235c:	ee c6 02 80 	sub	r6,r7,640
80012360:	20 27       	sub	r7,2
80012362:	30 08       	mov	r8,0
								
								*(puntero-320) = R2+G2+B2;
								
							}
						}
						if((i%319)!=0){
80012364:	e0 64 49 d5 	mov	r4,18901
80012368:	ea 14 33 5c 	orh	r4,0x335c
				puntero++;
			}
			puntero = RawImg;
			for (int i=0; i<76480;i++)
			{
				Value1=*puntero&0xFFFF;
8001236c:	f3 1a ff fe 	ld.uh	r10,r9[-2]
				B1=Value1&BLUE;
80012370:	f9 da c0 05 	bfextu	r12,r10,0x0,0x5
				G1=(Value1&GREEN)>>5;
				R1=(Value1&RED)>>11;
				
				if(B1==R1){
80012374:	ab 9a       	lsr	r10,0xb
80012376:	14 3c       	cp.w	r12,r10
80012378:	c4 d1       	brne	80012412 <Erosion+0x176>
					
					if(R1>0b01111){
8001237a:	58 fc       	cp.w	r12,15
8001237c:	e0 8a 00 4b 	brle	80012412 <Erosion+0x176>
						if(i>=320){
80012380:	e0 48 01 3f 	cp.w	r8,319
80012384:	e0 8a 00 0e 	brle	800123a0 <Erosion+0x104>
							Value2 = *(puntero-320);
80012388:	8c 8a       	ld.uh	r10,r6[0x0]
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							if(R1>R2){
8001238a:	f4 03 16 0b 	lsr	r3,r10,0xb
8001238e:	06 3c       	cp.w	r12,r3
80012390:	e0 8a 00 08 	brle	800123a0 <Erosion+0x104>
								B2 = 0b00000;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero-320) = R2+G2+B2;
80012394:	e2 1a 07 e0 	andl	r10,0x7e0,COH
80012398:	f8 03 15 0b 	lsl	r3,r12,0xb
8001239c:	06 0a       	add	r10,r3
8001239e:	ac 0a       	st.h	r6[0x0],r10
								
							}
						}
						if((i%319)!=0){
800123a0:	f0 04 04 42 	muls.d	r2,r8,r4
800123a4:	e6 0a 14 06 	asr	r10,r3,0x6
800123a8:	f0 03 14 1f 	asr	r3,r8,0x1f
800123ac:	06 1a       	sub	r10,r3
800123ae:	f4 0a 00 23 	add	r3,r10,r10<<0x2
800123b2:	a7 63       	lsl	r3,0x6
800123b4:	e6 0a 01 0a 	sub	r10,r3,r10
800123b8:	f0 0a 01 0a 	sub	r10,r8,r10
800123bc:	c0 d0       	breq	800123d6 <Erosion+0x13a>
							
							Value2 = *(puntero+1);
800123be:	92 8a       	ld.uh	r10,r9[0x0]
							
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							
							if(R1>R2){
800123c0:	f4 03 16 0b 	lsr	r3,r10,0xb
800123c4:	06 3c       	cp.w	r12,r3
800123c6:	e0 8a 00 08 	brle	800123d6 <Erosion+0x13a>
								B2 = 0b00000;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero+1) = R2+G2+B2;
800123ca:	e2 1a 07 e0 	andl	r10,0x7e0,COH
800123ce:	f8 03 15 0b 	lsl	r3,r12,0xb
800123d2:	06 0a       	add	r10,r3
800123d4:	b2 0a       	st.h	r9[0x0],r10
								
							}
						}
						if(i<=76480){
800123d6:	e0 58 2a c0 	cp.w	r8,76480
800123da:	e0 89 00 0e 	brgt	800123f6 <Erosion+0x15a>
							
							Value2 = *(puntero+320);
800123de:	8a 8a       	ld.uh	r10,r5[0x0]
							
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							
							if(R1>R2){
800123e0:	f4 03 16 0b 	lsr	r3,r10,0xb
800123e4:	06 3c       	cp.w	r12,r3
800123e6:	e0 8a 00 08 	brle	800123f6 <Erosion+0x15a>
								B2 = 0b00000;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero+320) = R2+G2+B2;
800123ea:	e2 1a 07 e0 	andl	r10,0x7e0,COH
800123ee:	f8 03 15 0b 	lsl	r3,r12,0xb
800123f2:	06 0a       	add	r10,r3
800123f4:	aa 0a       	st.h	r5[0x0],r10
								
							}
							
						}
						if((i!=0)||((i%320)!=0)){
800123f6:	58 08       	cp.w	r8,0
800123f8:	e0 80 01 d0 	breq	80012798 <Erosion+0x4fc>
							
							Value2 = *(puntero-1);
800123fc:	8e 8a       	ld.uh	r10,r7[0x0]
							
							B2=Value2&BLUE;
							G2=(Value2&GREEN)>>5;
							R2=(Value2&RED)>>11;
							
							if(R1>R2){
800123fe:	f4 03 16 0b 	lsr	r3,r10,0xb
80012402:	06 3c       	cp.w	r12,r3
80012404:	e0 8a 00 07 	brle	80012412 <Erosion+0x176>
								B2 = 0b00000;
								
								R2 = R2<<11;
								G2 = G2<<5;
								
								*(puntero-1) = R2+G2+B2;
80012408:	e2 1a 07 e0 	andl	r10,0x7e0,COH
8001240c:	ab 7c       	lsl	r12,0xb
8001240e:	18 0a       	add	r10,r12
80012410:	ae 0a       	st.h	r7[0x0],r10

					}
					
				}
				
				if(i>320){
80012412:	e0 48 01 40 	cp.w	r8,320
80012416:	e0 8a 00 0e 	brle	80012432 <Erosion+0x196>
					
					Value2 = *(puntero - 321);
8001241a:	96 8a       	ld.uh	r10,r11[0x0]
					
					B2=Value2&BLUE;
					G2=(Value2&GREEN)>>5;
					R2=(Value2&RED)>>11;
					
					if(B2==0b00000){
8001241c:	f9 da c0 05 	bfextu	r12,r10,0x0,0x5
80012420:	c0 91       	brne	80012432 <Erosion+0x196>
					
					Value2 = *(puntero - 321);
					
					B2=Value2&BLUE;
					G2=(Value2&GREEN)>>5;
					R2=(Value2&RED)>>11;
80012422:	ab 9a       	lsr	r10,0xb
						G2 = R2*2;
						
						R2 = R2<<11;
						G2 = G2<<5;
						
						*(puntero - 321) = R2+G2+B2;
80012424:	f4 0c 15 0b 	lsl	r12,r10,0xb
80012428:	14 0c       	add	r12,r10
8001242a:	a7 6a       	lsl	r10,0x6
8001242c:	f8 0a 00 0a 	add	r10,r12,r10
80012430:	b6 0a       	st.h	r11[0x0],r10
				R1=promedio<<11;
				*puntero=B1+G1+R1;
				puntero++;
			}
			puntero = RawImg;
			for (int i=0; i<76480;i++)
80012432:	2f f8       	sub	r8,-1
80012434:	2f e9       	sub	r9,-2
80012436:	2f eb       	sub	r11,-2
80012438:	2f e5       	sub	r5,-2
8001243a:	2f e6       	sub	r6,-2
8001243c:	2f e7       	sub	r7,-2
8001243e:	e0 58 2a c0 	cp.w	r8,76480
80012442:	c9 51       	brne	8001236c <Erosion+0xd0>
					
				}

				puntero++;
			}
			et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80012444:	e0 65 00 f0 	mov	r5,240
80012448:	1a d5       	st.w	--sp,r5
8001244a:	e0 6b 01 40 	mov	r11,320
8001244e:	1a db       	st.w	--sp,r11
80012450:	30 07       	mov	r7,0
80012452:	1a d7       	st.w	--sp,r7
80012454:	0e 98       	mov	r8,r7
80012456:	0e 99       	mov	r9,r7
80012458:	0e 9a       	mov	r10,r7
8001245a:	fe fc 03 72 	ld.w	r12,pc[882]
8001245e:	78 0c       	ld.w	r12,r12[0x0]
80012460:	f0 1f 00 dc 	mcall	800127d0 <Erosion+0x534>
			char brillo[]="Erosion Activado";
80012464:	fe f8 03 70 	ld.w	r8,pc[880]
80012468:	fa cc ff f4 	sub	r12,sp,-12
8001246c:	f0 ea 00 00 	ld.d	r10,r8[0]
80012470:	f8 eb 00 00 	st.d	r12[0],r10
80012474:	f0 ea 00 08 	ld.d	r10,r8[8]
80012478:	f8 eb 00 08 	st.d	r12[8],r10
8001247c:	f1 38 00 10 	ld.ub	r8,r8[16]
80012480:	f9 68 00 10 	st.b	r12[16],r8
			et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
80012484:	fe f4 03 54 	ld.w	r4,pc[852]
80012488:	e0 66 ff ff 	mov	r6,65535
8001248c:	1a d6       	st.w	--sp,r6
8001248e:	0e 98       	mov	r8,r7
80012490:	e0 69 00 dc 	mov	r9,220
80012494:	35 aa       	mov	r10,90
80012496:	08 9b       	mov	r11,r4
80012498:	f0 1f 00 d1 	mcall	800127dc <Erosion+0x540>
			char NEG2[]="Erosion";
8001249c:	e0 68 6e 00 	mov	r8,28160
800124a0:	ea 18 69 6f 	orh	r8,0x696f
800124a4:	e0 69 6f 73 	mov	r9,28531
800124a8:	ea 19 45 72 	orh	r9,0x4572
800124ac:	fa e9 00 40 	st.d	sp[64],r8
			et024006_DrawFilledRect(240,0,80,40,WHITE);
800124b0:	0c 98       	mov	r8,r6
800124b2:	32 89       	mov	r9,40
800124b4:	35 0a       	mov	r10,80
800124b6:	0e 9b       	mov	r11,r7
800124b8:	0a 9c       	mov	r12,r5
800124ba:	f0 1f 00 ca 	mcall	800127e0 <Erosion+0x544>
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
800124be:	1a d6       	st.w	--sp,r6
800124c0:	0e 98       	mov	r8,r7
800124c2:	31 09       	mov	r9,16
800124c4:	e0 6a 00 fa 	mov	r10,250
800124c8:	08 9b       	mov	r11,r4
800124ca:	fa cc ff bc 	sub	r12,sp,-68
800124ce:	f0 1f 00 c4 	mcall	800127dc <Erosion+0x540>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800124d2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800124d6:	e0 6a e1 c0 	mov	r10,57792
800124da:	ea 1a 00 e4 	orh	r10,0xe4
800124de:	f0 0a 00 0a 	add	r10,r8,r10
800124e2:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800124e4:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800124e8:	14 38       	cp.w	r8,r10
800124ea:	e0 88 00 09 	brls	800124fc <Erosion+0x260>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800124ee:	12 38       	cp.w	r8,r9
800124f0:	fe 98 ff fa 	brls	800124e4 <Erosion+0x248>
800124f4:	12 3a       	cp.w	r10,r9
800124f6:	e0 83 01 49 	brlo	80012788 <Erosion+0x4ec>
800124fa:	cf 5b       	rjmp	800124e4 <Erosion+0x248>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800124fc:	12 38       	cp.w	r8,r9
800124fe:	e0 8b 01 45 	brhi	80012788 <Erosion+0x4ec>
80012502:	12 3a       	cp.w	r10,r9
80012504:	e0 83 01 42 	brlo	80012788 <Erosion+0x4ec>
80012508:	ce eb       	rjmp	800124e4 <Erosion+0x248>
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
		}
	
	else if(eros== true && X>96 && X<=232 && Y>220 && Y<=240 && xytot<filtro && busy==true && step==3)
8001250a:	fe f9 02 ba 	ld.w	r9,pc[698]
8001250e:	13 8a       	ld.ub	r10,r9[0x0]
80012510:	30 09       	mov	r9,0
80012512:	f2 0a 18 00 	cp.b	r10,r9
80012516:	e0 80 01 49 	breq	800127a8 <Erosion+0x50c>
8001251a:	e0 48 00 60 	cp.w	r8,96
8001251e:	e0 8a 01 45 	brle	800127a8 <Erosion+0x50c>
80012522:	e0 48 00 e8 	cp.w	r8,232
80012526:	e0 89 01 41 	brgt	800127a8 <Erosion+0x50c>
8001252a:	fe f8 02 8a 	ld.w	r8,pc[650]
8001252e:	70 08       	ld.w	r8,r8[0x0]
80012530:	e0 48 00 dc 	cp.w	r8,220
80012534:	e0 8a 01 3a 	brle	800127a8 <Erosion+0x50c>
80012538:	e0 48 00 f0 	cp.w	r8,240
8001253c:	e0 89 01 36 	brgt	800127a8 <Erosion+0x50c>
80012540:	fe f8 02 78 	ld.w	r8,pc[632]
80012544:	70 08       	ld.w	r8,r8[0x0]
80012546:	58 28       	cp.w	r8,2
80012548:	e0 89 01 30 	brgt	800127a8 <Erosion+0x50c>
8001254c:	fe f8 02 70 	ld.w	r8,pc[624]
80012550:	11 89       	ld.ub	r9,r8[0x0]
80012552:	30 08       	mov	r8,0
80012554:	f0 09 18 00 	cp.b	r9,r8
80012558:	e0 80 01 28 	breq	800127a8 <Erosion+0x50c>
8001255c:	fe f8 02 64 	ld.w	r8,pc[612]
80012560:	11 89       	ld.ub	r9,r8[0x0]
80012562:	30 38       	mov	r8,3
80012564:	f0 09 18 00 	cp.b	r9,r8
80012568:	e0 81 01 20 	brne	800127a8 <Erosion+0x50c>
	{
	eros=false;
8001256c:	30 09       	mov	r9,0
8001256e:	fe f8 02 56 	ld.w	r8,pc[598]
80012572:	b0 89       	st.b	r8[0x0],r9
	gpio_clr_gpio_pin(LED0_GPIO);
80012574:	33 bc       	mov	r12,59
80012576:	f0 1f 00 95 	mcall	800127c8 <Erosion+0x52c>
	et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
8001257a:	e0 61 00 f0 	mov	r1,240
8001257e:	1a d1       	st.w	--sp,r1
80012580:	e0 6b 01 40 	mov	r11,320
80012584:	1a db       	st.w	--sp,r11
80012586:	30 06       	mov	r6,0
80012588:	1a d6       	st.w	--sp,r6
8001258a:	0c 98       	mov	r8,r6
8001258c:	0c 99       	mov	r9,r6
8001258e:	0c 9a       	mov	r10,r6
80012590:	fe fc 02 3c 	ld.w	r12,pc[572]
80012594:	78 0c       	ld.w	r12,r12[0x0]
80012596:	f0 1f 00 8f 	mcall	800127d0 <Erosion+0x534>
	char brillo[]="Brillo";
8001259a:	fe f8 02 4a 	ld.w	r8,pc[586]
8001259e:	fa c4 ff c4 	sub	r4,sp,-60
800125a2:	70 09       	ld.w	r9,r8[0x0]
800125a4:	89 09       	st.w	r4[0x0],r9
800125a6:	11 c9       	ld.ub	r9,r8[0x4]
800125a8:	a8 c9       	st.b	r4[0x4],r9
800125aa:	11 d9       	ld.ub	r9,r8[0x5]
800125ac:	a8 d9       	st.b	r4[0x5],r9
800125ae:	11 e8       	ld.ub	r8,r8[0x6]
800125b0:	a8 e8       	st.b	r4[0x6],r8
	char Negativo[]="Negativo";
800125b2:	fe f8 02 36 	ld.w	r8,pc[566]
800125b6:	fa c2 ff e0 	sub	r2,sp,-32
800125ba:	f0 ea 00 00 	ld.d	r10,r8[0]
800125be:	e4 eb 00 00 	st.d	r2[0],r10
800125c2:	f1 38 00 08 	ld.ub	r8,r8[8]
800125c6:	e5 68 00 08 	st.b	r2[8],r8
	char BlNe[]="B/N";
800125ca:	fa c3 ff a8 	sub	r3,sp,-88
800125ce:	e0 68 4e 00 	mov	r8,19968
800125d2:	ea 18 42 2f 	orh	r8,0x422f
800125d6:	06 d8       	st.w	--r3,r8
	et024006_DrawFilledRect(20,20,80,20,WHITE);
800125d8:	e0 68 ff ff 	mov	r8,65535
800125dc:	31 49       	mov	r9,20
800125de:	35 0a       	mov	r10,80
800125e0:	12 9b       	mov	r11,r9
800125e2:	12 9c       	mov	r12,r9
800125e4:	f0 1f 00 7f 	mcall	800127e0 <Erosion+0x544>
	et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
800125e8:	4f c5       	lddpc	r5,800127d8 <Erosion+0x53c>
800125ea:	e0 67 ff ff 	mov	r7,65535
800125ee:	1a d7       	st.w	--sp,r7
800125f0:	0c 98       	mov	r8,r6
800125f2:	31 49       	mov	r9,20
800125f4:	12 9a       	mov	r10,r9
800125f6:	0a 9b       	mov	r11,r5
800125f8:	08 9c       	mov	r12,r4
800125fa:	f0 1f 00 79 	mcall	800127dc <Erosion+0x540>
	et024006_DrawFilledRect(20,50,80,20,WHITE);
800125fe:	0e 98       	mov	r8,r7
80012600:	31 49       	mov	r9,20
80012602:	35 0a       	mov	r10,80
80012604:	33 2b       	mov	r11,50
80012606:	12 9c       	mov	r12,r9
80012608:	f0 1f 00 76 	mcall	800127e0 <Erosion+0x544>
	et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
8001260c:	1a d7       	st.w	--sp,r7
8001260e:	0c 98       	mov	r8,r6
80012610:	33 29       	mov	r9,50
80012612:	31 4a       	mov	r10,20
80012614:	0a 9b       	mov	r11,r5
80012616:	04 9c       	mov	r12,r2
80012618:	f0 1f 00 71 	mcall	800127dc <Erosion+0x540>
	et024006_DrawFilledRect(20,80,80,20,WHITE);
8001261c:	0e 98       	mov	r8,r7
8001261e:	31 49       	mov	r9,20
80012620:	35 0a       	mov	r10,80
80012622:	14 9b       	mov	r11,r10
80012624:	12 9c       	mov	r12,r9
80012626:	f0 1f 00 6f 	mcall	800127e0 <Erosion+0x544>
	et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
8001262a:	1a d7       	st.w	--sp,r7
8001262c:	0c 98       	mov	r8,r6
8001262e:	35 09       	mov	r9,80
80012630:	31 4a       	mov	r10,20
80012632:	0a 9b       	mov	r11,r5
80012634:	06 9c       	mov	r12,r3
80012636:	f0 1f 00 6a 	mcall	800127dc <Erosion+0x540>
	et024006_DrawFilledRect(20,110,80,20,WHITE);
8001263a:	0e 98       	mov	r8,r7
8001263c:	31 49       	mov	r9,20
8001263e:	35 0a       	mov	r10,80
80012640:	36 eb       	mov	r11,110
80012642:	12 9c       	mov	r12,r9
80012644:	f0 1f 00 67 	mcall	800127e0 <Erosion+0x544>
	char AutoFiltro[]="AutoFiltro";
80012648:	4e 98       	lddpc	r8,800127ec <Erosion+0x550>
8001264a:	fa cc ff e8 	sub	r12,sp,-24
8001264e:	f0 ea 00 00 	ld.d	r10,r8[0]
80012652:	f8 eb 00 00 	st.d	r12[0],r10
80012656:	f1 39 00 08 	ld.ub	r9,r8[8]
8001265a:	f9 69 00 08 	st.b	r12[8],r9
8001265e:	f1 39 00 09 	ld.ub	r9,r8[9]
80012662:	f9 69 00 09 	st.b	r12[9],r9
80012666:	f1 38 00 0a 	ld.ub	r8,r8[10]
8001266a:	f9 68 00 0a 	st.b	r12[10],r8
	et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
8001266e:	1a d7       	st.w	--sp,r7
80012670:	0c 98       	mov	r8,r6
80012672:	36 e9       	mov	r9,110
80012674:	31 4a       	mov	r10,20
80012676:	0a 9b       	mov	r11,r5
80012678:	f0 1f 00 59 	mcall	800127dc <Erosion+0x540>
	et024006_DrawFilledRect(20,140,80,20,WHITE);
8001267c:	0e 98       	mov	r8,r7
8001267e:	31 49       	mov	r9,20
80012680:	35 0a       	mov	r10,80
80012682:	e0 6b 00 8c 	mov	r11,140
80012686:	12 9c       	mov	r12,r9
80012688:	f0 1f 00 56 	mcall	800127e0 <Erosion+0x544>
	char BlNes[]="Dilatar";
8001268c:	e0 68 72 00 	mov	r8,29184
80012690:	ea 18 74 61 	orh	r8,0x7461
80012694:	e0 69 6c 61 	mov	r9,27745
80012698:	ea 19 44 69 	orh	r9,0x4469
8001269c:	fa e9 00 44 	st.d	sp[68],r8
	et024006_PrintString(BlNes,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
800126a0:	1a d7       	st.w	--sp,r7
800126a2:	0c 98       	mov	r8,r6
800126a4:	e0 69 00 8c 	mov	r9,140
800126a8:	31 4a       	mov	r10,20
800126aa:	0a 9b       	mov	r11,r5
800126ac:	fa cc ff b8 	sub	r12,sp,-72
800126b0:	f0 1f 00 4b 	mcall	800127dc <Erosion+0x540>
	et024006_DrawFilledRect(20,170,80,20,WHITE);
800126b4:	2f 8d       	sub	sp,-32
800126b6:	0e 98       	mov	r8,r7
800126b8:	31 49       	mov	r9,20
800126ba:	35 0a       	mov	r10,80
800126bc:	e0 6b 00 aa 	mov	r11,170
800126c0:	12 9c       	mov	r12,r9
800126c2:	f0 1f 00 48 	mcall	800127e0 <Erosion+0x544>
	char BlNs[]="Blur";
800126c6:	4c b8       	lddpc	r8,800127f0 <Erosion+0x554>
800126c8:	fa cc ff c0 	sub	r12,sp,-64
800126cc:	70 09       	ld.w	r9,r8[0x0]
800126ce:	99 09       	st.w	r12[0x0],r9
800126d0:	11 c8       	ld.ub	r8,r8[0x4]
800126d2:	b8 c8       	st.b	r12[0x4],r8
	et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
800126d4:	1a d7       	st.w	--sp,r7
800126d6:	0c 98       	mov	r8,r6
800126d8:	e0 69 00 aa 	mov	r9,170
800126dc:	31 4a       	mov	r10,20
800126de:	0a 9b       	mov	r11,r5
800126e0:	f0 1f 00 3f 	mcall	800127dc <Erosion+0x540>
	et024006_DrawFilledRect(20,200,80,20,WHITE);
800126e4:	0e 98       	mov	r8,r7
800126e6:	31 49       	mov	r9,20
800126e8:	35 0a       	mov	r10,80
800126ea:	e0 6b 00 c8 	mov	r11,200
800126ee:	12 9c       	mov	r12,r9
800126f0:	f0 1f 00 3c 	mcall	800127e0 <Erosion+0x544>
	char Eros[]="Erosion";
800126f4:	e0 68 6e 00 	mov	r8,28160
800126f8:	ea 18 69 6f 	orh	r8,0x696f
800126fc:	e0 69 6f 73 	mov	r9,28531
80012700:	ea 19 45 72 	orh	r9,0x4572
80012704:	fa e9 00 24 	st.d	sp[36],r8
	et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
80012708:	1a d7       	st.w	--sp,r7
8001270a:	0c 98       	mov	r8,r6
8001270c:	e0 69 00 c8 	mov	r9,200
80012710:	31 4a       	mov	r10,20
80012712:	0a 9b       	mov	r11,r5
80012714:	fa cc ff d8 	sub	r12,sp,-40
80012718:	f0 1f 00 31 	mcall	800127dc <Erosion+0x540>
	char Exit[]="SALIR";
8001271c:	4b 68       	lddpc	r8,800127f4 <Erosion+0x558>
8001271e:	fa c4 ff c0 	sub	r4,sp,-64
80012722:	70 09       	ld.w	r9,r8[0x0]
80012724:	89 09       	st.w	r4[0x0],r9
80012726:	11 c9       	ld.ub	r9,r8[0x4]
80012728:	a8 c9       	st.b	r4[0x4],r9
8001272a:	11 d8       	ld.ub	r8,r8[0x5]
8001272c:	a8 d8       	st.b	r4[0x5],r8
	et024006_DrawFilledRect(240,0,80,40,WHITE);
8001272e:	0e 98       	mov	r8,r7
80012730:	32 89       	mov	r9,40
80012732:	35 0a       	mov	r10,80
80012734:	0c 9b       	mov	r11,r6
80012736:	02 9c       	mov	r12,r1
80012738:	f0 1f 00 2a 	mcall	800127e0 <Erosion+0x544>
	et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
8001273c:	1a d7       	st.w	--sp,r7
8001273e:	0c 98       	mov	r8,r6
80012740:	31 09       	mov	r9,16
80012742:	e0 6a 01 04 	mov	r10,260
80012746:	0a 9b       	mov	r11,r5
80012748:	08 9c       	mov	r12,r4
8001274a:	f0 1f 00 25 	mcall	800127dc <Erosion+0x540>
	step=2;
8001274e:	30 29       	mov	r9,2
80012750:	49 c8       	lddpc	r8,800127c0 <Erosion+0x524>
80012752:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80012754:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80012758:	e0 6a e1 c0 	mov	r10,57792
8001275c:	ea 1a 00 e4 	orh	r10,0xe4
80012760:	f0 0a 00 0a 	add	r10,r8,r10
80012764:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80012766:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001276a:	14 38       	cp.w	r8,r10
8001276c:	e0 88 00 08 	brls	8001277c <Erosion+0x4e0>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80012770:	12 38       	cp.w	r8,r9
80012772:	fe 98 ff fa 	brls	80012766 <Erosion+0x4ca>
80012776:	12 3a       	cp.w	r10,r9
80012778:	c0 c3       	brcs	80012790 <Erosion+0x4f4>
8001277a:	cf 6b       	rjmp	80012766 <Erosion+0x4ca>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001277c:	12 38       	cp.w	r8,r9
8001277e:	e0 8b 00 09 	brhi	80012790 <Erosion+0x4f4>
80012782:	12 3a       	cp.w	r10,r9
80012784:	c0 63       	brcs	80012790 <Erosion+0x4f4>
80012786:	cf 0b       	rjmp	80012766 <Erosion+0x4ca>
			et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
			char NEG2[]="Erosion";
			et024006_DrawFilledRect(240,0,80,40,WHITE);
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
80012788:	33 bc       	mov	r12,59
8001278a:	f0 1f 00 1c 	mcall	800127f8 <Erosion+0x55c>
	}
}

void Erosion (void)
{
		if (X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3 && eros==true)
8001278e:	c0 d8       	rjmp	800127a8 <Erosion+0x50c>
	char Exit[]="SALIR";
	et024006_DrawFilledRect(240,0,80,40,WHITE);
	et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
	step=2;
	delay_ms(250);
	gpio_set_gpio_pin(LED0_GPIO);
80012790:	33 bc       	mov	r12,59
80012792:	f0 1f 00 1a 	mcall	800127f8 <Erosion+0x55c>
80012796:	c0 98       	rjmp	800127a8 <Erosion+0x50c>
				R1=promedio<<11;
				*puntero=B1+G1+R1;
				puntero++;
			}
			puntero = RawImg;
			for (int i=0; i<76480;i++)
80012798:	2f f8       	sub	r8,-1
8001279a:	2f e9       	sub	r9,-2
8001279c:	2f eb       	sub	r11,-2
8001279e:	2f e5       	sub	r5,-2
800127a0:	2f e6       	sub	r6,-2
800127a2:	2f e7       	sub	r7,-2
800127a4:	fe 9f fd e4 	bral	8001236c <Erosion+0xd0>
	step=2;
	delay_ms(250);
	gpio_set_gpio_pin(LED0_GPIO);
	
	}
}
800127a8:	2e dd       	sub	sp,-76
800127aa:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800127ae:	00 00       	add	r0,r0
800127b0:	00 00       	add	r0,r0
800127b2:	07 70       	ld.ub	r0,--r3
800127b4:	00 00       	add	r0,r0
800127b6:	07 74       	ld.ub	r4,--r3
800127b8:	00 00       	add	r0,r0
800127ba:	07 5c       	ld.sh	r12,--r3
800127bc:	00 00       	add	r0,r0
800127be:	07 63       	ld.uh	r3,--r3
800127c0:	00 00       	add	r0,r0
800127c2:	07 60       	ld.uh	r0,--r3
800127c4:	00 00       	add	r0,r0
800127c6:	06 b8       	st.h	r3++,r8
800127c8:	80 00       	ld.sh	r0,r0[0x0]
800127ca:	6c 7e       	ld.w	lr,r6[0x1c]
800127cc:	00 00       	add	r0,r0
800127ce:	0d 28       	ld.uh	r8,r6++
800127d0:	80 00       	ld.sh	r0,r0[0x0]
800127d2:	63 3c       	ld.w	r12,r1[0x4c]
800127d4:	80 01       	ld.sh	r1,r0[0x0]
800127d6:	fe c0 80 01 	sub	r0,pc,-32767
800127da:	dc 90       	acall	0xc9
800127dc:	80 00       	ld.sh	r0,r0[0x0]
800127de:	60 18       	ld.w	r8,r0[0x4]
800127e0:	80 00       	ld.sh	r0,r0[0x0]
800127e2:	62 94       	ld.w	r4,r1[0x24]
800127e4:	80 01       	ld.sh	r1,r0[0x0]
800127e6:	fe 70 80 01 	mov	r0,-32767
800127ea:	fe 78 80 01 	mov	r8,-32767
800127ee:	fe 84 80 01 	brge	7ffe27f0 <__heap_size__+0x7dfe27f0>
800127f2:	fe 90 80 01 	breq	800027f4 <sd_mmc_spi_get_csd+0xa4>
800127f6:	fe 98 80 00 	brls	800027f6 <sd_mmc_spi_get_csd+0xa6>
800127fa:	6c 62       	ld.w	r2,r6[0x18]

800127fc <Autofilto>:
		gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Autofilto (void)
{
800127fc:	eb cd 40 fc 	pushm	r2-r7,lr
80012800:	21 3d       	sub	sp,76
	if (X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3 && AutoFiltroACT==true)
80012802:	fe f8 04 5a 	ld.w	r8,pc[1114]
80012806:	70 08       	ld.w	r8,r8[0x0]
80012808:	f0 c9 00 f1 	sub	r9,r8,241
8001280c:	e0 49 00 4f 	cp.w	r9,79
80012810:	e0 8b 00 de 	brhi	800129cc <Autofilto+0x1d0>
80012814:	fe f9 04 4c 	ld.w	r9,pc[1100]
80012818:	72 09       	ld.w	r9,r9[0x0]
8001281a:	58 09       	cp.w	r9,0
8001281c:	e0 8a 00 d8 	brle	800129cc <Autofilto+0x1d0>
80012820:	e0 49 00 28 	cp.w	r9,40
80012824:	e0 89 00 d4 	brgt	800129cc <Autofilto+0x1d0>
80012828:	fe f9 04 3c 	ld.w	r9,pc[1084]
8001282c:	72 09       	ld.w	r9,r9[0x0]
8001282e:	58 29       	cp.w	r9,2
80012830:	e0 89 00 ce 	brgt	800129cc <Autofilto+0x1d0>
80012834:	fe f9 04 34 	ld.w	r9,pc[1076]
80012838:	13 8a       	ld.ub	r10,r9[0x0]
8001283a:	30 09       	mov	r9,0
8001283c:	f2 0a 18 00 	cp.b	r10,r9
80012840:	e0 80 00 c6 	breq	800129cc <Autofilto+0x1d0>
80012844:	fe f9 04 28 	ld.w	r9,pc[1064]
80012848:	13 8a       	ld.ub	r10,r9[0x0]
8001284a:	30 39       	mov	r9,3
8001284c:	f2 0a 18 00 	cp.b	r10,r9
80012850:	e0 81 00 be 	brne	800129cc <Autofilto+0x1d0>
80012854:	fe f8 04 1c 	ld.w	r8,pc[1052]
80012858:	11 89       	ld.ub	r9,r8[0x0]
8001285a:	30 08       	mov	r8,0
8001285c:	f0 09 18 00 	cp.b	r9,r8
80012860:	e0 80 01 fb 	breq	80012c56 <Autofilto+0x45a>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80012864:	33 bc       	mov	r12,59
80012866:	f0 1f 01 04 	mcall	80012c74 <Autofilto+0x478>
		int R1,G1,B1,promedio;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
8001286a:	fe f8 04 0e 	ld.w	r8,pc[1038]
8001286e:	70 08       	ld.w	r8,r8[0x0]
80012870:	f0 ca ff fe 	sub	r10,r8,-2
		step=1;
		gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Autofilto (void)
80012874:	e2 69 58 02 	mov	r9,153602
80012878:	f0 09 00 03 	add	r3,r8,r9
		{
			Value1=*puntero&0xFFFF;
			B1=Value1&BLUE;
			G1=(Value1&GREEN)>>5;
			R1=(Value1&RED)>>11;
			promedio=(B1+(G1/2)+R1)/3;
8001287c:	e0 64 55 56 	mov	r4,21846
80012880:	ea 14 55 55 	orh	r4,0x5555
				B1+=1;
				if (B1>=32)
				{
					B1=BLUE;
				}
				G1+=2;
80012884:	33 fe       	mov	lr,63
				if (G1>=64)
				{
					G1=63;
				}
				R1+=1;
80012886:	31 f2       	mov	r2,31
				B1-=1;
				if (B1<=0)
				{
					B1=0;
				}
				G1-=2;
80012888:	30 05       	mov	r5,0
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
		{
			Value1=*puntero&0xFFFF;
8001288a:	90 89       	ld.uh	r9,r8[0x0]
			B1=Value1&BLUE;
8001288c:	f7 d9 c0 05 	bfextu	r11,r9,0x0,0x5
			G1=(Value1&GREEN)>>5;
80012890:	f9 d9 c0 a6 	bfextu	r12,r9,0x5,0x6
			R1=(Value1&RED)>>11;
80012894:	ab 99       	lsr	r9,0xb
			promedio=(B1+(G1/2)+R1)/3;
80012896:	f2 0b 00 06 	add	r6,r9,r11
8001289a:	f8 07 16 01 	lsr	r7,r12,0x1
8001289e:	ec 07 00 07 	add	r7,r6,r7
800128a2:	ee 04 04 46 	muls.d	r6,r7,r4
			if(promedio>24)
800128a6:	59 87       	cp.w	r7,24
800128a8:	e0 8a 00 13 	brle	800128ce <Autofilto+0xd2>
			{
				B1-=1;
800128ac:	20 1b       	sub	r11,1
				if (B1<=0)
				{
					B1=0;
				}
				G1-=2;
800128ae:	20 2c       	sub	r12,2
800128b0:	f8 05 0c 4c 	max	r12,r12,r5
				if (G1<=0)
				{
					G1=0;
				}
				R1-=1;
800128b4:	20 19       	sub	r9,1
800128b6:	f2 05 0c 49 	max	r9,r9,r5
				{
					R1=0;
				}
				G1=G1<<5;
				R1=R1<<11;
				*puntero=B1+G1+R1;
800128ba:	a5 7c       	lsl	r12,0x5
800128bc:	ab 79       	lsl	r9,0xb
800128be:	f8 09 00 09 	add	r9,r12,r9
800128c2:	f6 05 0c 4b 	max	r11,r11,r5
800128c6:	f2 0b 00 0b 	add	r11,r9,r11
800128ca:	b0 0b       	st.h	r8[0x0],r11
800128cc:	c1 c8       	rjmp	80012904 <Autofilto+0x108>
				puntero++;
			}
			else if (promedio<10)
800128ce:	58 97       	cp.w	r7,9
800128d0:	e0 89 00 13 	brgt	800128f6 <Autofilto+0xfa>
			{
				B1+=1;
800128d4:	2f fb       	sub	r11,-1
				if (B1>=32)
				{
					B1=BLUE;
				}
				G1+=2;
800128d6:	2f ec       	sub	r12,-2
800128d8:	f8 0e 0d 4c 	min	r12,r12,lr
				if (G1>=64)
				{
					G1=63;
				}
				R1+=1;
800128dc:	2f f9       	sub	r9,-1
800128de:	f2 02 0d 49 	min	r9,r9,r2
				{
					R1=31;
				}
				G1=G1<<5;
				R1=R1<<11;
				*puntero=B1+G1+R1;
800128e2:	a5 7c       	lsl	r12,0x5
800128e4:	ab 79       	lsl	r9,0xb
800128e6:	f8 09 00 09 	add	r9,r12,r9
800128ea:	f6 02 0d 4b 	min	r11,r11,r2
800128ee:	f2 0b 00 0b 	add	r11,r9,r11
800128f2:	b0 0b       	st.h	r8[0x0],r11
800128f4:	c0 88       	rjmp	80012904 <Autofilto+0x108>
			else
			{
				G1=(G1)<<5;
				R1=(R1)<<11;
				B1=(B1);
				*puntero=B1+G1+R1;
800128f6:	a5 7c       	lsl	r12,0x5
800128f8:	ab 79       	lsl	r9,0xb
800128fa:	f8 09 00 09 	add	r9,r12,r9
800128fe:	f2 0b 00 0b 	add	r11,r9,r11
80012902:	b0 0b       	st.h	r8[0x0],r11
80012904:	2f e8       	sub	r8,-2
80012906:	2f ea       	sub	r10,-2
		gpio_clr_gpio_pin(LED0_GPIO);
		int R1,G1,B1,promedio;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
80012908:	06 3a       	cp.w	r10,r3
8001290a:	cc 01       	brne	8001288a <Autofilto+0x8e>
				B1=(B1);
				*puntero=B1+G1+R1;
				puntero++;
			}
		}
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
8001290c:	e0 64 00 f0 	mov	r4,240
80012910:	1a d4       	st.w	--sp,r4
80012912:	e0 6b 01 40 	mov	r11,320
80012916:	1a db       	st.w	--sp,r11
80012918:	30 07       	mov	r7,0
8001291a:	1a d7       	st.w	--sp,r7
8001291c:	0e 98       	mov	r8,r7
8001291e:	0e 99       	mov	r9,r7
80012920:	0e 9a       	mov	r10,r7
80012922:	fe fc 03 56 	ld.w	r12,pc[854]
80012926:	78 0c       	ld.w	r12,r12[0x0]
80012928:	f0 1f 00 d5 	mcall	80012c7c <Autofilto+0x480>
		char NEG[]="Autofiltro Activado";
8001292c:	fe f8 03 54 	ld.w	r8,pc[852]
80012930:	fa cc ff f4 	sub	r12,sp,-12
80012934:	f0 ea 00 00 	ld.d	r10,r8[0]
80012938:	f8 eb 00 00 	st.d	r12[0],r10
8001293c:	f0 ea 00 08 	ld.d	r10,r8[8]
80012940:	f8 eb 00 08 	st.d	r12[8],r10
80012944:	70 48       	ld.w	r8,r8[0x10]
80012946:	99 48       	st.w	r12[0x10],r8
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
80012948:	fe f3 03 3c 	ld.w	r3,pc[828]
8001294c:	e0 65 ff ff 	mov	r5,65535
80012950:	1a d5       	st.w	--sp,r5
80012952:	0e 98       	mov	r8,r7
80012954:	e0 69 00 dc 	mov	r9,220
80012958:	36 0a       	mov	r10,96
8001295a:	06 9b       	mov	r11,r3
8001295c:	f0 1f 00 cb 	mcall	80012c88 <Autofilto+0x48c>
		char NEG2[]="AutoF";
80012960:	fe f8 03 2c 	ld.w	r8,pc[812]
80012964:	fa c6 ff b0 	sub	r6,sp,-80
80012968:	70 09       	ld.w	r9,r8[0x0]
8001296a:	8d 09       	st.w	r6[0x0],r9
8001296c:	11 c9       	ld.ub	r9,r8[0x4]
8001296e:	ac c9       	st.b	r6[0x4],r9
80012970:	11 d8       	ld.ub	r8,r8[0x5]
80012972:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,0,80,40,WHITE);
80012974:	0a 98       	mov	r8,r5
80012976:	32 89       	mov	r9,40
80012978:	35 0a       	mov	r10,80
8001297a:	0e 9b       	mov	r11,r7
8001297c:	08 9c       	mov	r12,r4
8001297e:	f0 1f 00 c5 	mcall	80012c90 <Autofilto+0x494>
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80012982:	1a d5       	st.w	--sp,r5
80012984:	0e 98       	mov	r8,r7
80012986:	31 09       	mov	r9,16
80012988:	e0 6a 01 04 	mov	r10,260
8001298c:	06 9b       	mov	r11,r3
8001298e:	0c 9c       	mov	r12,r6
80012990:	f0 1f 00 be 	mcall	80012c88 <Autofilto+0x48c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80012994:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80012998:	e0 6a e1 c0 	mov	r10,57792
8001299c:	ea 1a 00 e4 	orh	r10,0xe4
800129a0:	f0 0a 00 0a 	add	r10,r8,r10
800129a4:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800129a6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800129aa:	14 38       	cp.w	r8,r10
800129ac:	e0 88 00 09 	brls	800129be <Autofilto+0x1c2>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800129b0:	12 38       	cp.w	r8,r9
800129b2:	fe 98 ff fa 	brls	800129a6 <Autofilto+0x1aa>
800129b6:	12 3a       	cp.w	r10,r9
800129b8:	e0 83 01 48 	brlo	80012c48 <Autofilto+0x44c>
800129bc:	cf 5b       	rjmp	800129a6 <Autofilto+0x1aa>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800129be:	12 38       	cp.w	r8,r9
800129c0:	e0 8b 01 44 	brhi	80012c48 <Autofilto+0x44c>
800129c4:	12 3a       	cp.w	r10,r9
800129c6:	e0 83 01 41 	brlo	80012c48 <Autofilto+0x44c>
800129ca:	ce eb       	rjmp	800129a6 <Autofilto+0x1aa>
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(AutoFiltroACT== true && X>96 && X<=232 && Y>220 && Y<=240 && xytot<filtro && busy==true && step==3)
800129cc:	fe f9 02 a4 	ld.w	r9,pc[676]
800129d0:	13 8a       	ld.ub	r10,r9[0x0]
800129d2:	30 09       	mov	r9,0
800129d4:	f2 0a 18 00 	cp.b	r10,r9
800129d8:	e0 80 01 3f 	breq	80012c56 <Autofilto+0x45a>
800129dc:	e0 48 00 60 	cp.w	r8,96
800129e0:	e0 8a 01 3b 	brle	80012c56 <Autofilto+0x45a>
800129e4:	e0 48 00 e8 	cp.w	r8,232
800129e8:	e0 89 01 37 	brgt	80012c56 <Autofilto+0x45a>
800129ec:	fe f8 02 74 	ld.w	r8,pc[628]
800129f0:	70 08       	ld.w	r8,r8[0x0]
800129f2:	e0 48 00 dc 	cp.w	r8,220
800129f6:	e0 8a 01 30 	brle	80012c56 <Autofilto+0x45a>
800129fa:	e0 48 00 f0 	cp.w	r8,240
800129fe:	e0 89 01 2c 	brgt	80012c56 <Autofilto+0x45a>
80012a02:	fe f8 02 62 	ld.w	r8,pc[610]
80012a06:	70 08       	ld.w	r8,r8[0x0]
80012a08:	58 28       	cp.w	r8,2
80012a0a:	e0 89 01 26 	brgt	80012c56 <Autofilto+0x45a>
80012a0e:	fe f8 02 5a 	ld.w	r8,pc[602]
80012a12:	11 89       	ld.ub	r9,r8[0x0]
80012a14:	30 08       	mov	r8,0
80012a16:	f0 09 18 00 	cp.b	r9,r8
80012a1a:	e0 80 01 1e 	breq	80012c56 <Autofilto+0x45a>
80012a1e:	fe f8 02 4e 	ld.w	r8,pc[590]
80012a22:	11 89       	ld.ub	r9,r8[0x0]
80012a24:	30 38       	mov	r8,3
80012a26:	f0 09 18 00 	cp.b	r9,r8
80012a2a:	e0 81 01 16 	brne	80012c56 <Autofilto+0x45a>
	{
		AutoFiltroACT=false;
80012a2e:	30 09       	mov	r9,0
80012a30:	fe f8 02 40 	ld.w	r8,pc[576]
80012a34:	b0 89       	st.b	r8[0x0],r9
gpio_clr_gpio_pin(LED0_GPIO);
80012a36:	33 bc       	mov	r12,59
80012a38:	f0 1f 00 8f 	mcall	80012c74 <Autofilto+0x478>
et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80012a3c:	e0 62 00 f0 	mov	r2,240
80012a40:	1a d2       	st.w	--sp,r2
80012a42:	e0 6b 01 40 	mov	r11,320
80012a46:	1a db       	st.w	--sp,r11
80012a48:	30 06       	mov	r6,0
80012a4a:	1a d6       	st.w	--sp,r6
80012a4c:	0c 98       	mov	r8,r6
80012a4e:	0c 99       	mov	r9,r6
80012a50:	0c 9a       	mov	r10,r6
80012a52:	fe fc 02 26 	ld.w	r12,pc[550]
80012a56:	78 0c       	ld.w	r12,r12[0x0]
80012a58:	f0 1f 00 89 	mcall	80012c7c <Autofilto+0x480>
char brillo[]="Brillo";
80012a5c:	fe f8 02 38 	ld.w	r8,pc[568]
80012a60:	fa c4 ff c4 	sub	r4,sp,-60
80012a64:	70 09       	ld.w	r9,r8[0x0]
80012a66:	89 09       	st.w	r4[0x0],r9
80012a68:	11 c9       	ld.ub	r9,r8[0x4]
80012a6a:	a8 c9       	st.b	r4[0x4],r9
80012a6c:	11 d9       	ld.ub	r9,r8[0x5]
80012a6e:	a8 d9       	st.b	r4[0x5],r9
80012a70:	11 e8       	ld.ub	r8,r8[0x6]
80012a72:	a8 e8       	st.b	r4[0x6],r8
char Negativo[]="Negativo";
80012a74:	fe f8 02 24 	ld.w	r8,pc[548]
80012a78:	fa c3 ff e0 	sub	r3,sp,-32
80012a7c:	f0 ea 00 00 	ld.d	r10,r8[0]
80012a80:	e6 eb 00 00 	st.d	r3[0],r10
80012a84:	f1 38 00 08 	ld.ub	r8,r8[8]
80012a88:	e7 68 00 08 	st.b	r3[8],r8
char BlNe[]="B/N";
80012a8c:	e0 68 4e 00 	mov	r8,19968
80012a90:	ea 18 42 2f 	orh	r8,0x422f
80012a94:	51 58       	stdsp	sp[0x54],r8
char dila[]="Dilatar";
80012a96:	e0 68 72 00 	mov	r8,29184
80012a9a:	ea 18 74 61 	orh	r8,0x7461
80012a9e:	e0 69 6c 61 	mov	r9,27745
80012aa2:	ea 19 44 69 	orh	r9,0x4469
80012aa6:	fa e9 00 34 	st.d	sp[52],r8
et024006_DrawFilledRect(20,20,80,20,WHITE);
80012aaa:	e0 68 ff ff 	mov	r8,65535
80012aae:	31 49       	mov	r9,20
80012ab0:	35 0a       	mov	r10,80
80012ab2:	12 9b       	mov	r11,r9
80012ab4:	12 9c       	mov	r12,r9
80012ab6:	f0 1f 00 77 	mcall	80012c90 <Autofilto+0x494>
et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
80012aba:	4f 35       	lddpc	r5,80012c84 <Autofilto+0x488>
80012abc:	e0 67 ff ff 	mov	r7,65535
80012ac0:	1a d7       	st.w	--sp,r7
80012ac2:	0c 98       	mov	r8,r6
80012ac4:	31 49       	mov	r9,20
80012ac6:	12 9a       	mov	r10,r9
80012ac8:	0a 9b       	mov	r11,r5
80012aca:	08 9c       	mov	r12,r4
80012acc:	f0 1f 00 6f 	mcall	80012c88 <Autofilto+0x48c>
et024006_DrawFilledRect(20,50,80,20,WHITE);
80012ad0:	0e 98       	mov	r8,r7
80012ad2:	31 49       	mov	r9,20
80012ad4:	35 0a       	mov	r10,80
80012ad6:	33 2b       	mov	r11,50
80012ad8:	12 9c       	mov	r12,r9
80012ada:	f0 1f 00 6e 	mcall	80012c90 <Autofilto+0x494>
et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
80012ade:	1a d7       	st.w	--sp,r7
80012ae0:	0c 98       	mov	r8,r6
80012ae2:	33 29       	mov	r9,50
80012ae4:	31 4a       	mov	r10,20
80012ae6:	0a 9b       	mov	r11,r5
80012ae8:	06 9c       	mov	r12,r3
80012aea:	f0 1f 00 68 	mcall	80012c88 <Autofilto+0x48c>
et024006_DrawFilledRect(20,80,80,20,WHITE);
80012aee:	0e 98       	mov	r8,r7
80012af0:	31 49       	mov	r9,20
80012af2:	35 0a       	mov	r10,80
80012af4:	14 9b       	mov	r11,r10
80012af6:	12 9c       	mov	r12,r9
80012af8:	f0 1f 00 66 	mcall	80012c90 <Autofilto+0x494>
et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
80012afc:	1a d7       	st.w	--sp,r7
80012afe:	0c 98       	mov	r8,r6
80012b00:	35 09       	mov	r9,80
80012b02:	31 4a       	mov	r10,20
80012b04:	0a 9b       	mov	r11,r5
80012b06:	fa cc ff a0 	sub	r12,sp,-96
80012b0a:	f0 1f 00 60 	mcall	80012c88 <Autofilto+0x48c>
et024006_DrawFilledRect(20,110,80,20,WHITE);
80012b0e:	0e 98       	mov	r8,r7
80012b10:	31 49       	mov	r9,20
80012b12:	35 0a       	mov	r10,80
80012b14:	36 eb       	mov	r11,110
80012b16:	12 9c       	mov	r12,r9
80012b18:	f0 1f 00 5e 	mcall	80012c90 <Autofilto+0x494>
char AutoFiltro[]="AutoFiltro";
80012b1c:	4e 08       	lddpc	r8,80012c9c <Autofilto+0x4a0>
80012b1e:	fa cc ff e8 	sub	r12,sp,-24
80012b22:	f0 ea 00 00 	ld.d	r10,r8[0]
80012b26:	f8 eb 00 00 	st.d	r12[0],r10
80012b2a:	f1 39 00 08 	ld.ub	r9,r8[8]
80012b2e:	f9 69 00 08 	st.b	r12[8],r9
80012b32:	f1 39 00 09 	ld.ub	r9,r8[9]
80012b36:	f9 69 00 09 	st.b	r12[9],r9
80012b3a:	f1 38 00 0a 	ld.ub	r8,r8[10]
80012b3e:	f9 68 00 0a 	st.b	r12[10],r8
et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
80012b42:	1a d7       	st.w	--sp,r7
80012b44:	0c 98       	mov	r8,r6
80012b46:	36 e9       	mov	r9,110
80012b48:	31 4a       	mov	r10,20
80012b4a:	0a 9b       	mov	r11,r5
80012b4c:	f0 1f 00 4f 	mcall	80012c88 <Autofilto+0x48c>
et024006_DrawFilledRect(20,140,80,20,WHITE);
80012b50:	0e 98       	mov	r8,r7
80012b52:	31 49       	mov	r9,20
80012b54:	35 0a       	mov	r10,80
80012b56:	e0 6b 00 8c 	mov	r11,140
80012b5a:	12 9c       	mov	r12,r9
80012b5c:	f0 1f 00 4d 	mcall	80012c90 <Autofilto+0x494>
et024006_PrintString(dila,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
80012b60:	1a d7       	st.w	--sp,r7
80012b62:	0c 98       	mov	r8,r6
80012b64:	e0 69 00 8c 	mov	r9,140
80012b68:	31 4a       	mov	r10,20
80012b6a:	0a 9b       	mov	r11,r5
80012b6c:	fa cc ff b8 	sub	r12,sp,-72
80012b70:	f0 1f 00 46 	mcall	80012c88 <Autofilto+0x48c>
et024006_DrawFilledRect(20,170,80,20,WHITE);
80012b74:	2f 8d       	sub	sp,-32
80012b76:	0e 98       	mov	r8,r7
80012b78:	31 49       	mov	r9,20
80012b7a:	35 0a       	mov	r10,80
80012b7c:	e0 6b 00 aa 	mov	r11,170
80012b80:	12 9c       	mov	r12,r9
80012b82:	f0 1f 00 44 	mcall	80012c90 <Autofilto+0x494>
char BlNs[]="Blur";
80012b86:	4c 78       	lddpc	r8,80012ca0 <Autofilto+0x4a4>
80012b88:	fa cc ff c0 	sub	r12,sp,-64
80012b8c:	70 09       	ld.w	r9,r8[0x0]
80012b8e:	99 09       	st.w	r12[0x0],r9
80012b90:	11 c8       	ld.ub	r8,r8[0x4]
80012b92:	b8 c8       	st.b	r12[0x4],r8
et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
80012b94:	1a d7       	st.w	--sp,r7
80012b96:	0c 98       	mov	r8,r6
80012b98:	e0 69 00 aa 	mov	r9,170
80012b9c:	31 4a       	mov	r10,20
80012b9e:	0a 9b       	mov	r11,r5
80012ba0:	f0 1f 00 3a 	mcall	80012c88 <Autofilto+0x48c>
et024006_DrawFilledRect(20,200,80,20,WHITE);
80012ba4:	0e 98       	mov	r8,r7
80012ba6:	31 49       	mov	r9,20
80012ba8:	35 0a       	mov	r10,80
80012baa:	e0 6b 00 c8 	mov	r11,200
80012bae:	12 9c       	mov	r12,r9
80012bb0:	f0 1f 00 38 	mcall	80012c90 <Autofilto+0x494>
char Eros[]="Erosion";
80012bb4:	e0 68 6e 00 	mov	r8,28160
80012bb8:	ea 18 69 6f 	orh	r8,0x696f
80012bbc:	e0 69 6f 73 	mov	r9,28531
80012bc0:	ea 19 45 72 	orh	r9,0x4572
80012bc4:	fa e9 00 24 	st.d	sp[36],r8
et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
80012bc8:	1a d7       	st.w	--sp,r7
80012bca:	0c 98       	mov	r8,r6
80012bcc:	e0 69 00 c8 	mov	r9,200
80012bd0:	31 4a       	mov	r10,20
80012bd2:	0a 9b       	mov	r11,r5
80012bd4:	fa cc ff d8 	sub	r12,sp,-40
80012bd8:	f0 1f 00 2c 	mcall	80012c88 <Autofilto+0x48c>
char Exit[]="SALIR";
80012bdc:	4b 28       	lddpc	r8,80012ca4 <Autofilto+0x4a8>
80012bde:	fa c4 ff c0 	sub	r4,sp,-64
80012be2:	70 09       	ld.w	r9,r8[0x0]
80012be4:	89 09       	st.w	r4[0x0],r9
80012be6:	11 c9       	ld.ub	r9,r8[0x4]
80012be8:	a8 c9       	st.b	r4[0x4],r9
80012bea:	11 d8       	ld.ub	r8,r8[0x5]
80012bec:	a8 d8       	st.b	r4[0x5],r8
et024006_DrawFilledRect(240,0,80,40,WHITE);
80012bee:	0e 98       	mov	r8,r7
80012bf0:	32 89       	mov	r9,40
80012bf2:	35 0a       	mov	r10,80
80012bf4:	0c 9b       	mov	r11,r6
80012bf6:	04 9c       	mov	r12,r2
80012bf8:	f0 1f 00 26 	mcall	80012c90 <Autofilto+0x494>
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80012bfc:	1a d7       	st.w	--sp,r7
80012bfe:	0c 98       	mov	r8,r6
80012c00:	31 09       	mov	r9,16
80012c02:	e0 6a 01 04 	mov	r10,260
80012c06:	0a 9b       	mov	r11,r5
80012c08:	08 9c       	mov	r12,r4
80012c0a:	f0 1f 00 20 	mcall	80012c88 <Autofilto+0x48c>
step=2;
80012c0e:	30 29       	mov	r9,2
80012c10:	49 78       	lddpc	r8,80012c6c <Autofilto+0x470>
80012c12:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80012c14:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80012c18:	e0 6a e1 c0 	mov	r10,57792
80012c1c:	ea 1a 00 e4 	orh	r10,0xe4
80012c20:	f0 0a 00 0a 	add	r10,r8,r10
80012c24:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80012c26:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80012c2a:	14 38       	cp.w	r8,r10
80012c2c:	e0 88 00 08 	brls	80012c3c <Autofilto+0x440>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80012c30:	12 38       	cp.w	r8,r9
80012c32:	fe 98 ff fa 	brls	80012c26 <Autofilto+0x42a>
80012c36:	12 3a       	cp.w	r10,r9
80012c38:	c0 c3       	brcs	80012c50 <Autofilto+0x454>
80012c3a:	cf 6b       	rjmp	80012c26 <Autofilto+0x42a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80012c3c:	12 38       	cp.w	r8,r9
80012c3e:	e0 8b 00 09 	brhi	80012c50 <Autofilto+0x454>
80012c42:	12 3a       	cp.w	r10,r9
80012c44:	c0 63       	brcs	80012c50 <Autofilto+0x454>
80012c46:	cf 0b       	rjmp	80012c26 <Autofilto+0x42a>
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
		char NEG2[]="AutoF";
		et024006_DrawFilledRect(240,0,80,40,WHITE);
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
80012c48:	33 bc       	mov	r12,59
80012c4a:	f0 1f 00 18 	mcall	80012ca8 <Autofilto+0x4ac>
	}
}

void Autofilto (void)
{
	if (X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3 && AutoFiltroACT==true)
80012c4e:	c0 48       	rjmp	80012c56 <Autofilto+0x45a>
char Exit[]="SALIR";
et024006_DrawFilledRect(240,0,80,40,WHITE);
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
step=2;
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
80012c50:	33 bc       	mov	r12,59
80012c52:	f0 1f 00 16 	mcall	80012ca8 <Autofilto+0x4ac>
	}
}
80012c56:	2e dd       	sub	sp,-76
80012c58:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80012c5c:	00 00       	add	r0,r0
80012c5e:	07 70       	ld.ub	r0,--r3
80012c60:	00 00       	add	r0,r0
80012c62:	07 74       	ld.ub	r4,--r3
80012c64:	00 00       	add	r0,r0
80012c66:	07 5c       	ld.sh	r12,--r3
80012c68:	00 00       	add	r0,r0
80012c6a:	07 63       	ld.uh	r3,--r3
80012c6c:	00 00       	add	r0,r0
80012c6e:	07 60       	ld.uh	r0,--r3
80012c70:	00 00       	add	r0,r0
80012c72:	06 8a       	andn	r10,r3
80012c74:	80 00       	ld.sh	r0,r0[0x0]
80012c76:	6c 7e       	ld.w	lr,r6[0x1c]
80012c78:	00 00       	add	r0,r0
80012c7a:	0d 28       	ld.uh	r8,r6++
80012c7c:	80 00       	ld.sh	r0,r0[0x0]
80012c7e:	63 3c       	ld.w	r12,r1[0x4c]
80012c80:	80 01       	ld.sh	r1,r0[0x0]
80012c82:	fe d4 80 01 	satsub.w	r4,pc,-32767
80012c86:	dc 90       	acall	0xc9
80012c88:	80 00       	ld.sh	r0,r0[0x0]
80012c8a:	60 18       	ld.w	r8,r0[0x4]
80012c8c:	80 01       	ld.sh	r1,r0[0x0]
80012c8e:	fe e8 80 00 	ld.d	r8,pc[-32768]
80012c92:	62 94       	ld.w	r4,r1[0x24]
80012c94:	80 01       	ld.sh	r1,r0[0x0]
80012c96:	fe 70 80 01 	mov	r0,-32767
80012c9a:	fe 78 80 01 	mov	r8,-32767
80012c9e:	fe 84 80 01 	brge	7ffe2ca0 <__heap_size__+0x7dfe2ca0>
80012ca2:	fe 90 80 01 	breq	80002ca4 <spi_selectChip+0x48>
80012ca6:	fe 98 80 00 	brls	80002ca6 <spi_selectChip+0x4a>
80012caa:	6c 62       	ld.w	r2,r6[0x18]

80012cac <MenuFiltros>:
	Enable_global_interrupt();
	while(1);
}

void MenuFiltros(void)
{
80012cac:	eb cd 40 fe 	pushm	r1-r7,lr
80012cb0:	21 5d       	sub	sp,84

	if (X>200 && X<=320 && Y>200 && Y<=240 && xytot<filtro && busy==true && step==1)
80012cb2:	fe f8 0d 2a 	ld.w	r8,pc[3370]
80012cb6:	70 08       	ld.w	r8,r8[0x0]
80012cb8:	f0 c9 00 c9 	sub	r9,r8,201
80012cbc:	e0 49 00 77 	cp.w	r9,119
80012cc0:	e0 8b 01 b5 	brhi	8001302a <MenuFiltros+0x37e>
80012cc4:	fe f9 0d 1c 	ld.w	r9,pc[3356]
80012cc8:	72 09       	ld.w	r9,r9[0x0]
80012cca:	e0 49 00 c8 	cp.w	r9,200
80012cce:	e0 8a 01 2d 	brle	80012f28 <MenuFiltros+0x27c>
80012cd2:	e0 49 00 f0 	cp.w	r9,240
80012cd6:	e0 89 01 29 	brgt	80012f28 <MenuFiltros+0x27c>
80012cda:	fe fa 0d 0a 	ld.w	r10,pc[3338]
80012cde:	74 0a       	ld.w	r10,r10[0x0]
80012ce0:	58 2a       	cp.w	r10,2
80012ce2:	e0 89 01 23 	brgt	80012f28 <MenuFiltros+0x27c>
80012ce6:	fe fa 0d 02 	ld.w	r10,pc[3330]
80012cea:	15 8b       	ld.ub	r11,r10[0x0]
80012cec:	30 0a       	mov	r10,0
80012cee:	f4 0b 18 00 	cp.b	r11,r10
80012cf2:	e0 80 01 1b 	breq	80012f28 <MenuFiltros+0x27c>
80012cf6:	fe fa 0c f6 	ld.w	r10,pc[3318]
80012cfa:	15 8b       	ld.ub	r11,r10[0x0]
80012cfc:	30 1a       	mov	r10,1
80012cfe:	f4 0b 18 00 	cp.b	r11,r10
80012d02:	e0 81 01 13 	brne	80012f28 <MenuFiltros+0x27c>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80012d06:	33 bc       	mov	r12,59
80012d08:	f0 1f 03 3a 	mcall	800139f0 <MenuFiltros+0xd44>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80012d0c:	e0 61 00 f0 	mov	r1,240
80012d10:	1a d1       	st.w	--sp,r1
80012d12:	e0 6b 01 40 	mov	r11,320
80012d16:	1a db       	st.w	--sp,r11
80012d18:	30 06       	mov	r6,0
80012d1a:	1a d6       	st.w	--sp,r6
80012d1c:	0c 98       	mov	r8,r6
80012d1e:	0c 99       	mov	r9,r6
80012d20:	0c 9a       	mov	r10,r6
80012d22:	fe fc 0c d2 	ld.w	r12,pc[3282]
80012d26:	78 0c       	ld.w	r12,r12[0x0]
80012d28:	f0 1f 03 34 	mcall	800139f8 <MenuFiltros+0xd4c>
		char brillo[]="Brillo";
80012d2c:	fe f8 0c d0 	ld.w	r8,pc[3280]
80012d30:	fa c4 ff bc 	sub	r4,sp,-68
80012d34:	70 09       	ld.w	r9,r8[0x0]
80012d36:	89 09       	st.w	r4[0x0],r9
80012d38:	11 c9       	ld.ub	r9,r8[0x4]
80012d3a:	a8 c9       	st.b	r4[0x4],r9
80012d3c:	11 d9       	ld.ub	r9,r8[0x5]
80012d3e:	a8 d9       	st.b	r4[0x5],r9
80012d40:	11 e8       	ld.ub	r8,r8[0x6]
80012d42:	a8 e8       	st.b	r4[0x6],r8
		char Negativo[]="Negativo";
80012d44:	fe f8 0c bc 	ld.w	r8,pc[3260]
80012d48:	fa c2 ff f4 	sub	r2,sp,-12
80012d4c:	f0 ea 00 00 	ld.d	r10,r8[0]
80012d50:	e4 eb 00 00 	st.d	r2[0],r10
80012d54:	f1 38 00 08 	ld.ub	r8,r8[8]
80012d58:	e5 68 00 08 	st.b	r2[8],r8
		char BlNe[]="B/N";
80012d5c:	fa c3 ff a0 	sub	r3,sp,-96
80012d60:	e0 68 4e 00 	mov	r8,19968
80012d64:	ea 18 42 2f 	orh	r8,0x422f
80012d68:	06 d8       	st.w	--r3,r8
		et024006_DrawFilledRect(20,20,80,20,WHITE);
80012d6a:	e0 68 ff ff 	mov	r8,65535
80012d6e:	31 49       	mov	r9,20
80012d70:	35 0a       	mov	r10,80
80012d72:	12 9b       	mov	r11,r9
80012d74:	12 9c       	mov	r12,r9
80012d76:	f0 1f 03 24 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
80012d7a:	fe f5 0c 8e 	ld.w	r5,pc[3214]
80012d7e:	e0 67 ff ff 	mov	r7,65535
80012d82:	1a d7       	st.w	--sp,r7
80012d84:	0c 98       	mov	r8,r6
80012d86:	31 49       	mov	r9,20
80012d88:	12 9a       	mov	r10,r9
80012d8a:	0a 9b       	mov	r11,r5
80012d8c:	08 9c       	mov	r12,r4
80012d8e:	f0 1f 03 20 	mcall	80013a0c <MenuFiltros+0xd60>
		et024006_DrawFilledRect(20,50,80,20,WHITE);
80012d92:	0e 98       	mov	r8,r7
80012d94:	31 49       	mov	r9,20
80012d96:	35 0a       	mov	r10,80
80012d98:	33 2b       	mov	r11,50
80012d9a:	12 9c       	mov	r12,r9
80012d9c:	f0 1f 03 1a 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
80012da0:	1a d7       	st.w	--sp,r7
80012da2:	0c 98       	mov	r8,r6
80012da4:	33 29       	mov	r9,50
80012da6:	31 4a       	mov	r10,20
80012da8:	0a 9b       	mov	r11,r5
80012daa:	04 9c       	mov	r12,r2
80012dac:	f0 1f 03 18 	mcall	80013a0c <MenuFiltros+0xd60>
		et024006_DrawFilledRect(20,80,80,20,WHITE);
80012db0:	0e 98       	mov	r8,r7
80012db2:	31 49       	mov	r9,20
80012db4:	35 0a       	mov	r10,80
80012db6:	14 9b       	mov	r11,r10
80012db8:	12 9c       	mov	r12,r9
80012dba:	f0 1f 03 13 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
80012dbe:	1a d7       	st.w	--sp,r7
80012dc0:	0c 98       	mov	r8,r6
80012dc2:	35 09       	mov	r9,80
80012dc4:	31 4a       	mov	r10,20
80012dc6:	0a 9b       	mov	r11,r5
80012dc8:	06 9c       	mov	r12,r3
80012dca:	f0 1f 03 11 	mcall	80013a0c <MenuFiltros+0xd60>
		et024006_DrawFilledRect(20,110,80,20,WHITE);
80012dce:	0e 98       	mov	r8,r7
80012dd0:	31 49       	mov	r9,20
80012dd2:	35 0a       	mov	r10,80
80012dd4:	36 eb       	mov	r11,110
80012dd6:	12 9c       	mov	r12,r9
80012dd8:	f0 1f 03 0b 	mcall	80013a04 <MenuFiltros+0xd58>
		char AutoFiltro[]="AutoFiltro";
80012ddc:	fe f8 0c 34 	ld.w	r8,pc[3124]
80012de0:	fa cc ff d0 	sub	r12,sp,-48
80012de4:	f0 ea 00 00 	ld.d	r10,r8[0]
80012de8:	f8 eb 00 00 	st.d	r12[0],r10
80012dec:	f1 39 00 08 	ld.ub	r9,r8[8]
80012df0:	f9 69 00 08 	st.b	r12[8],r9
80012df4:	f1 39 00 09 	ld.ub	r9,r8[9]
80012df8:	f9 69 00 09 	st.b	r12[9],r9
80012dfc:	f1 38 00 0a 	ld.ub	r8,r8[10]
80012e00:	f9 68 00 0a 	st.b	r12[10],r8
		et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
80012e04:	1a d7       	st.w	--sp,r7
80012e06:	0c 98       	mov	r8,r6
80012e08:	36 e9       	mov	r9,110
80012e0a:	31 4a       	mov	r10,20
80012e0c:	0a 9b       	mov	r11,r5
80012e0e:	f0 1f 03 00 	mcall	80013a0c <MenuFiltros+0xd60>
		et024006_DrawFilledRect(20,140,80,20,WHITE);
80012e12:	0e 98       	mov	r8,r7
80012e14:	31 49       	mov	r9,20
80012e16:	35 0a       	mov	r10,80
80012e18:	e0 6b 00 8c 	mov	r11,140
80012e1c:	12 9c       	mov	r12,r9
80012e1e:	f0 1f 02 fa 	mcall	80013a04 <MenuFiltros+0xd58>
		char BlNes[]="Dilatar";
80012e22:	e0 68 72 00 	mov	r8,29184
80012e26:	ea 18 74 61 	orh	r8,0x7461
80012e2a:	e0 69 6c 61 	mov	r9,27745
80012e2e:	ea 19 44 69 	orh	r9,0x4469
80012e32:	fa e9 00 4c 	st.d	sp[76],r8
		et024006_PrintString(BlNes,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
80012e36:	1a d7       	st.w	--sp,r7
80012e38:	0c 98       	mov	r8,r6
80012e3a:	e0 69 00 8c 	mov	r9,140
80012e3e:	31 4a       	mov	r10,20
80012e40:	0a 9b       	mov	r11,r5
80012e42:	fa cc ff b0 	sub	r12,sp,-80
80012e46:	f0 1f 02 f2 	mcall	80013a0c <MenuFiltros+0xd60>
		et024006_DrawFilledRect(20,170,80,20,WHITE);
80012e4a:	2f 8d       	sub	sp,-32
80012e4c:	0e 98       	mov	r8,r7
80012e4e:	31 49       	mov	r9,20
80012e50:	35 0a       	mov	r10,80
80012e52:	e0 6b 00 aa 	mov	r11,170
80012e56:	12 9c       	mov	r12,r9
80012e58:	f0 1f 02 eb 	mcall	80013a04 <MenuFiltros+0xd58>
		char BlNs[]="Blur";
80012e5c:	fe f8 0b b8 	ld.w	r8,pc[3000]
80012e60:	fa cc ff b8 	sub	r12,sp,-72
80012e64:	70 09       	ld.w	r9,r8[0x0]
80012e66:	99 09       	st.w	r12[0x0],r9
80012e68:	11 c8       	ld.ub	r8,r8[0x4]
80012e6a:	b8 c8       	st.b	r12[0x4],r8
		et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
80012e6c:	1a d7       	st.w	--sp,r7
80012e6e:	0c 98       	mov	r8,r6
80012e70:	e0 69 00 aa 	mov	r9,170
80012e74:	31 4a       	mov	r10,20
80012e76:	0a 9b       	mov	r11,r5
80012e78:	f0 1f 02 e5 	mcall	80013a0c <MenuFiltros+0xd60>
		et024006_DrawFilledRect(20,200,80,20,WHITE);
80012e7c:	0e 98       	mov	r8,r7
80012e7e:	31 49       	mov	r9,20
80012e80:	35 0a       	mov	r10,80
80012e82:	e0 6b 00 c8 	mov	r11,200
80012e86:	12 9c       	mov	r12,r9
80012e88:	f0 1f 02 df 	mcall	80013a04 <MenuFiltros+0xd58>
		char Eros[]="Erosion";
80012e8c:	e0 68 6e 00 	mov	r8,28160
80012e90:	ea 18 69 6f 	orh	r8,0x696f
80012e94:	e0 69 6f 73 	mov	r9,28531
80012e98:	ea 19 45 72 	orh	r9,0x4572
80012e9c:	fa e9 00 2c 	st.d	sp[44],r8
		et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
80012ea0:	1a d7       	st.w	--sp,r7
80012ea2:	0c 98       	mov	r8,r6
80012ea4:	e0 69 00 c8 	mov	r9,200
80012ea8:	31 4a       	mov	r10,20
80012eaa:	0a 9b       	mov	r11,r5
80012eac:	fa cc ff d0 	sub	r12,sp,-48
80012eb0:	f0 1f 02 d7 	mcall	80013a0c <MenuFiltros+0xd60>
		char Exit[]="SALIR";
80012eb4:	fe f8 0b 64 	ld.w	r8,pc[2916]
80012eb8:	fa c4 ff b8 	sub	r4,sp,-72
80012ebc:	70 09       	ld.w	r9,r8[0x0]
80012ebe:	89 09       	st.w	r4[0x0],r9
80012ec0:	11 c9       	ld.ub	r9,r8[0x4]
80012ec2:	a8 c9       	st.b	r4[0x4],r9
80012ec4:	11 d8       	ld.ub	r8,r8[0x5]
80012ec6:	a8 d8       	st.b	r4[0x5],r8
		et024006_DrawFilledRect(240,0,80,40,WHITE);
80012ec8:	0e 98       	mov	r8,r7
80012eca:	32 89       	mov	r9,40
80012ecc:	35 0a       	mov	r10,80
80012ece:	0c 9b       	mov	r11,r6
80012ed0:	02 9c       	mov	r12,r1
80012ed2:	f0 1f 02 cd 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80012ed6:	1a d7       	st.w	--sp,r7
80012ed8:	0c 98       	mov	r8,r6
80012eda:	31 09       	mov	r9,16
80012edc:	e0 6a 01 04 	mov	r10,260
80012ee0:	0a 9b       	mov	r11,r5
80012ee2:	08 9c       	mov	r12,r4
80012ee4:	f0 1f 02 ca 	mcall	80013a0c <MenuFiltros+0xd60>
		step=2;
80012ee8:	30 29       	mov	r9,2
80012eea:	fe f8 0b 02 	ld.w	r8,pc[2818]
80012eee:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80012ef0:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80012ef4:	e0 6a e1 c0 	mov	r10,57792
80012ef8:	ea 1a 00 e4 	orh	r10,0xe4
80012efc:	f0 0a 00 0a 	add	r10,r8,r10
80012f00:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80012f02:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80012f06:	14 38       	cp.w	r8,r10
80012f08:	e0 88 00 09 	brls	80012f1a <MenuFiltros+0x26e>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80012f0c:	12 38       	cp.w	r8,r9
80012f0e:	fe 98 ff fa 	brls	80012f02 <MenuFiltros+0x256>
80012f12:	12 3a       	cp.w	r10,r9
80012f14:	e0 83 05 3a 	brlo	80013988 <MenuFiltros+0xcdc>
80012f18:	cf 5b       	rjmp	80012f02 <MenuFiltros+0x256>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80012f1a:	12 38       	cp.w	r8,r9
80012f1c:	e0 8b 05 36 	brhi	80013988 <MenuFiltros+0xcdc>
80012f20:	12 3a       	cp.w	r10,r9
80012f22:	e0 83 05 33 	brlo	80013988 <MenuFiltros+0xcdc>
80012f26:	ce eb       	rjmp	80012f02 <MenuFiltros+0x256>
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(X>200 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==1 && BrilloACT==false && NegACT==false && BNACT == false && AutoFiltroACT==false && blur==false && dilatar==false)
80012f28:	58 09       	cp.w	r9,0
80012f2a:	e0 8a 00 80 	brle	8001302a <MenuFiltros+0x37e>
80012f2e:	e0 49 00 28 	cp.w	r9,40
80012f32:	e0 89 00 7c 	brgt	8001302a <MenuFiltros+0x37e>
80012f36:	fe f9 0a ae 	ld.w	r9,pc[2734]
80012f3a:	72 09       	ld.w	r9,r9[0x0]
80012f3c:	58 29       	cp.w	r9,2
80012f3e:	e0 89 00 76 	brgt	8001302a <MenuFiltros+0x37e>
80012f42:	fe f9 0a a6 	ld.w	r9,pc[2726]
80012f46:	13 8a       	ld.ub	r10,r9[0x0]
80012f48:	30 09       	mov	r9,0
80012f4a:	f2 0a 18 00 	cp.b	r10,r9
80012f4e:	c6 e0       	breq	8001302a <MenuFiltros+0x37e>
80012f50:	fe f9 0a 9c 	ld.w	r9,pc[2716]
80012f54:	13 8a       	ld.ub	r10,r9[0x0]
80012f56:	30 19       	mov	r9,1
80012f58:	f2 0a 18 00 	cp.b	r10,r9
80012f5c:	c6 71       	brne	8001302a <MenuFiltros+0x37e>
80012f5e:	fe f9 0a be 	ld.w	r9,pc[2750]
80012f62:	13 8a       	ld.ub	r10,r9[0x0]
80012f64:	30 09       	mov	r9,0
80012f66:	f2 0a 18 00 	cp.b	r10,r9
80012f6a:	c6 01       	brne	8001302a <MenuFiltros+0x37e>
80012f6c:	fe f9 0a b4 	ld.w	r9,pc[2740]
80012f70:	13 8a       	ld.ub	r10,r9[0x0]
80012f72:	30 09       	mov	r9,0
80012f74:	f2 0a 18 00 	cp.b	r10,r9
80012f78:	c5 91       	brne	8001302a <MenuFiltros+0x37e>
80012f7a:	fe f9 0a aa 	ld.w	r9,pc[2730]
80012f7e:	13 8a       	ld.ub	r10,r9[0x0]
80012f80:	30 09       	mov	r9,0
80012f82:	f2 0a 18 00 	cp.b	r10,r9
80012f86:	c5 21       	brne	8001302a <MenuFiltros+0x37e>
80012f88:	fe f9 0a a0 	ld.w	r9,pc[2720]
80012f8c:	13 8a       	ld.ub	r10,r9[0x0]
80012f8e:	30 09       	mov	r9,0
80012f90:	f2 0a 18 00 	cp.b	r10,r9
80012f94:	c4 b1       	brne	8001302a <MenuFiltros+0x37e>
80012f96:	fe f9 0a 96 	ld.w	r9,pc[2710]
80012f9a:	13 8a       	ld.ub	r10,r9[0x0]
80012f9c:	30 09       	mov	r9,0
80012f9e:	f2 0a 18 00 	cp.b	r10,r9
80012fa2:	c4 41       	brne	8001302a <MenuFiltros+0x37e>
80012fa4:	fe f9 0a 8c 	ld.w	r9,pc[2700]
80012fa8:	13 8a       	ld.ub	r10,r9[0x0]
80012faa:	30 09       	mov	r9,0
80012fac:	f2 0a 18 00 	cp.b	r10,r9
80012fb0:	c3 d1       	brne	8001302a <MenuFiltros+0x37e>
	{
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80012fb2:	e0 68 00 f0 	mov	r8,240
80012fb6:	1a d8       	st.w	--sp,r8
80012fb8:	e0 6b 01 40 	mov	r11,320
80012fbc:	1a db       	st.w	--sp,r11
80012fbe:	30 07       	mov	r7,0
80012fc0:	1a d7       	st.w	--sp,r7
80012fc2:	0e 98       	mov	r8,r7
80012fc4:	0e 99       	mov	r9,r7
80012fc6:	0e 9a       	mov	r10,r7
80012fc8:	fe fc 0a 2c 	ld.w	r12,pc[2604]
80012fcc:	78 0c       	ld.w	r12,r12[0x0]
80012fce:	f0 1f 02 8b 	mcall	800139f8 <MenuFiltros+0xd4c>
		char save[]="Guardando";
80012fd2:	fe f8 0a 62 	ld.w	r8,pc[2658]
80012fd6:	fa cc ff f4 	sub	r12,sp,-12
80012fda:	f0 ea 00 00 	ld.d	r10,r8[0]
80012fde:	f8 eb 00 00 	st.d	r12[0],r10
80012fe2:	f1 39 00 08 	ld.ub	r9,r8[8]
80012fe6:	f9 69 00 08 	st.b	r12[8],r9
80012fea:	f1 38 00 09 	ld.ub	r8,r8[9]
80012fee:	f9 68 00 09 	st.b	r12[9],r8
		et024006_PrintString(save,(const unsigned char *)&FONT8x16,120,115,BLACK,WHITE);
80012ff2:	e0 68 ff ff 	mov	r8,65535
80012ff6:	1a d8       	st.w	--sp,r8
80012ff8:	0e 98       	mov	r8,r7
80012ffa:	37 39       	mov	r9,115
80012ffc:	37 8a       	mov	r10,120
80012ffe:	fe fb 0a 0a 	ld.w	r11,pc[2570]
80013002:	f0 1f 02 83 	mcall	80013a0c <MenuFiltros+0xd60>
		busy=false;
80013006:	fe f8 09 e2 	ld.w	r8,pc[2530]
8001300a:	b0 87       	st.b	r8[0x0],r7
		static char Imgnum [11]= {'O','u','t','p','u','t',49,'.','b','m','p'};
		Writefile(Imgnum);
8001300c:	fe f7 0a 2c 	ld.w	r7,pc[2604]
80013010:	0e 9c       	mov	r12,r7
80013012:	f0 1f 02 8b 	mcall	80013a3c <MenuFiltros+0xd90>
		Imgnum[6]+=1;
80013016:	0f e8       	ld.ub	r8,r7[0x6]
80013018:	2f f8       	sub	r8,-1
8001301a:	ae e8       	st.b	r7[0x6],r8
		InicializarFondo();
8001301c:	f0 1f 02 89 	mcall	80013a40 <MenuFiltros+0xd94>
		Desplegar();
80013020:	f0 1f 02 89 	mcall	80013a44 <MenuFiltros+0xd98>
		et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		step=2;
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(X>200 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==1 && BrilloACT==false && NegACT==false && BNACT == false && AutoFiltroACT==false && blur==false && dilatar==false)
80013024:	2f cd       	sub	sp,-16
80013026:	e0 8f 04 d7 	bral	800139d4 <MenuFiltros+0xd28>
		Writefile(Imgnum);
		Imgnum[6]+=1;
		InicializarFondo();
		Desplegar();
	}
	else if(X>240 && X<=320 && Y>40 && Y<=80 && xytot<filtro && busy==true && step==1 && BrilloACT==false && NegACT==false && BNACT == false && blur==false && dilatar==false && AutoFiltroACT==false)
8001302a:	f0 c9 00 f1 	sub	r9,r8,241
8001302e:	e0 49 00 4f 	cp.w	r9,79
80013032:	e0 8b 00 54 	brhi	800130da <MenuFiltros+0x42e>
80013036:	fe fa 09 aa 	ld.w	r10,pc[2474]
8001303a:	74 0a       	ld.w	r10,r10[0x0]
8001303c:	e0 4a 00 28 	cp.w	r10,40
80013040:	e0 8a 00 4d 	brle	800130da <MenuFiltros+0x42e>
80013044:	e0 4a 00 50 	cp.w	r10,80
80013048:	e0 89 00 49 	brgt	800130da <MenuFiltros+0x42e>
8001304c:	fe fa 09 98 	ld.w	r10,pc[2456]
80013050:	74 0a       	ld.w	r10,r10[0x0]
80013052:	58 2a       	cp.w	r10,2
80013054:	e0 89 00 43 	brgt	800130da <MenuFiltros+0x42e>
80013058:	fe fa 09 90 	ld.w	r10,pc[2448]
8001305c:	15 8b       	ld.ub	r11,r10[0x0]
8001305e:	30 0a       	mov	r10,0
80013060:	f4 0b 18 00 	cp.b	r11,r10
80013064:	c3 b0       	breq	800130da <MenuFiltros+0x42e>
80013066:	fe fa 09 86 	ld.w	r10,pc[2438]
8001306a:	15 8b       	ld.ub	r11,r10[0x0]
8001306c:	30 1a       	mov	r10,1
8001306e:	f4 0b 18 00 	cp.b	r11,r10
80013072:	c3 41       	brne	800130da <MenuFiltros+0x42e>
80013074:	fe fa 09 a8 	ld.w	r10,pc[2472]
80013078:	15 8b       	ld.ub	r11,r10[0x0]
8001307a:	30 0a       	mov	r10,0
8001307c:	f4 0b 18 00 	cp.b	r11,r10
80013080:	c2 d1       	brne	800130da <MenuFiltros+0x42e>
80013082:	fe fa 09 9e 	ld.w	r10,pc[2462]
80013086:	15 8b       	ld.ub	r11,r10[0x0]
80013088:	30 0a       	mov	r10,0
8001308a:	f4 0b 18 00 	cp.b	r11,r10
8001308e:	c2 61       	brne	800130da <MenuFiltros+0x42e>
80013090:	fe fa 09 94 	ld.w	r10,pc[2452]
80013094:	15 8b       	ld.ub	r11,r10[0x0]
80013096:	30 0a       	mov	r10,0
80013098:	f4 0b 18 00 	cp.b	r11,r10
8001309c:	c1 f1       	brne	800130da <MenuFiltros+0x42e>
8001309e:	fe fa 09 8e 	ld.w	r10,pc[2446]
800130a2:	15 8b       	ld.ub	r11,r10[0x0]
800130a4:	30 0a       	mov	r10,0
800130a6:	f4 0b 18 00 	cp.b	r11,r10
800130aa:	c1 81       	brne	800130da <MenuFiltros+0x42e>
800130ac:	fe fa 09 84 	ld.w	r10,pc[2436]
800130b0:	15 8b       	ld.ub	r11,r10[0x0]
800130b2:	30 0a       	mov	r10,0
800130b4:	f4 0b 18 00 	cp.b	r11,r10
800130b8:	c1 11       	brne	800130da <MenuFiltros+0x42e>
800130ba:	fe fa 09 6e 	ld.w	r10,pc[2414]
800130be:	15 8b       	ld.ub	r11,r10[0x0]
800130c0:	30 0a       	mov	r10,0
800130c2:	f4 0b 18 00 	cp.b	r11,r10
800130c6:	c0 a1       	brne	800130da <MenuFiltros+0x42e>
	{
		busy=false;
800130c8:	fe f8 09 20 	ld.w	r8,pc[2336]
800130cc:	b0 8a       	st.b	r8[0x0],r10
		InicializarFondo();
800130ce:	f0 1f 02 5d 	mcall	80013a40 <MenuFiltros+0xd94>
		Desplegar();
800130d2:	f0 1f 02 5d 	mcall	80013a44 <MenuFiltros+0xd98>
		Writefile(Imgnum);
		Imgnum[6]+=1;
		InicializarFondo();
		Desplegar();
	}
	else if(X>240 && X<=320 && Y>40 && Y<=80 && xytot<filtro && busy==true && step==1 && BrilloACT==false && NegACT==false && BNACT == false && blur==false && dilatar==false && AutoFiltroACT==false)
800130d6:	e0 8f 04 7f 	bral	800139d4 <MenuFiltros+0xd28>
		busy=false;
		InicializarFondo();
		Desplegar();
	}

	else if (X>20 && X<=120 && Y>110 && Y<=130 && xytot<filtro && busy==true && step==2)
800130da:	21 58       	sub	r8,21
800130dc:	e0 48 00 63 	cp.w	r8,99
800130e0:	e0 8b 03 a6 	brhi	8001382c <MenuFiltros+0xb80>
800130e4:	fe f8 08 fc 	ld.w	r8,pc[2300]
800130e8:	70 08       	ld.w	r8,r8[0x0]
800130ea:	e0 48 00 6e 	cp.w	r8,110
800130ee:	e0 8a 00 89 	brle	80013200 <MenuFiltros+0x554>
800130f2:	e0 48 00 82 	cp.w	r8,130
800130f6:	e0 89 00 85 	brgt	80013200 <MenuFiltros+0x554>
800130fa:	fe fa 08 ea 	ld.w	r10,pc[2282]
800130fe:	74 0a       	ld.w	r10,r10[0x0]
80013100:	58 2a       	cp.w	r10,2
80013102:	e0 89 00 7f 	brgt	80013200 <MenuFiltros+0x554>
80013106:	fe fa 08 e2 	ld.w	r10,pc[2274]
8001310a:	15 8b       	ld.ub	r11,r10[0x0]
8001310c:	30 0a       	mov	r10,0
8001310e:	f4 0b 18 00 	cp.b	r11,r10
80013112:	c7 70       	breq	80013200 <MenuFiltros+0x554>
80013114:	fe fa 08 d8 	ld.w	r10,pc[2264]
80013118:	15 8b       	ld.ub	r11,r10[0x0]
8001311a:	30 2a       	mov	r10,2
8001311c:	f4 0b 18 00 	cp.b	r11,r10
80013120:	c7 01       	brne	80013200 <MenuFiltros+0x554>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80013122:	33 bc       	mov	r12,59
80013124:	f0 1f 02 33 	mcall	800139f0 <MenuFiltros+0xd44>
		AutoFiltroACT = true;
80013128:	30 19       	mov	r9,1
8001312a:	fe f8 08 fe 	ld.w	r8,pc[2302]
8001312e:	b0 89       	st.b	r8[0x0],r9
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013130:	e0 64 00 f0 	mov	r4,240
80013134:	1a d4       	st.w	--sp,r4
80013136:	e0 6b 01 40 	mov	r11,320
8001313a:	1a db       	st.w	--sp,r11
8001313c:	30 07       	mov	r7,0
8001313e:	1a d7       	st.w	--sp,r7
80013140:	0e 98       	mov	r8,r7
80013142:	0e 99       	mov	r9,r7
80013144:	0e 9a       	mov	r10,r7
80013146:	fe fc 08 ae 	ld.w	r12,pc[2222]
8001314a:	78 0c       	ld.w	r12,r12[0x0]
8001314c:	f0 1f 02 2b 	mcall	800139f8 <MenuFiltros+0xd4c>
		char brillo[]="Auto Filtro Activado";
80013150:	fe f8 08 f8 	ld.w	r8,pc[2296]
80013154:	fa cc ff f4 	sub	r12,sp,-12
80013158:	f0 ea 00 00 	ld.d	r10,r8[0]
8001315c:	f8 eb 00 00 	st.d	r12[0],r10
80013160:	f0 ea 00 08 	ld.d	r10,r8[8]
80013164:	f8 eb 00 08 	st.d	r12[8],r10
80013168:	70 49       	ld.w	r9,r8[0x10]
8001316a:	99 49       	st.w	r12[0x10],r9
8001316c:	f1 38 00 14 	ld.ub	r8,r8[20]
80013170:	f9 68 00 14 	st.b	r12[20],r8
		et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
80013174:	fe f3 08 94 	ld.w	r3,pc[2196]
80013178:	e0 65 ff ff 	mov	r5,65535
8001317c:	1a d5       	st.w	--sp,r5
8001317e:	0e 98       	mov	r8,r7
80013180:	e0 69 00 dc 	mov	r9,220
80013184:	36 0a       	mov	r10,96
80013186:	06 9b       	mov	r11,r3
80013188:	f0 1f 02 21 	mcall	80013a0c <MenuFiltros+0xd60>
		char NEG2[]="AutoF";
8001318c:	fe f8 08 c0 	ld.w	r8,pc[2240]
80013190:	fa c6 ff b0 	sub	r6,sp,-80
80013194:	70 09       	ld.w	r9,r8[0x0]
80013196:	8d 09       	st.w	r6[0x0],r9
80013198:	11 c9       	ld.ub	r9,r8[0x4]
8001319a:	ac c9       	st.b	r6[0x4],r9
8001319c:	11 d8       	ld.ub	r8,r8[0x5]
8001319e:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,0,80,40,WHITE);
800131a0:	0a 98       	mov	r8,r5
800131a2:	32 89       	mov	r9,40
800131a4:	35 0a       	mov	r10,80
800131a6:	0e 9b       	mov	r11,r7
800131a8:	08 9c       	mov	r12,r4
800131aa:	f0 1f 02 17 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
800131ae:	1a d5       	st.w	--sp,r5
800131b0:	0e 98       	mov	r8,r7
800131b2:	31 09       	mov	r9,16
800131b4:	e0 6a 01 04 	mov	r10,260
800131b8:	06 9b       	mov	r11,r3
800131ba:	0c 9c       	mov	r12,r6
800131bc:	f0 1f 02 14 	mcall	80013a0c <MenuFiltros+0xd60>
		step=3;
800131c0:	30 39       	mov	r9,3
800131c2:	fe f8 08 2a 	ld.w	r8,pc[2090]
800131c6:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800131c8:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800131cc:	e0 6a e1 c0 	mov	r10,57792
800131d0:	ea 1a 00 e4 	orh	r10,0xe4
800131d4:	f0 0a 00 0a 	add	r10,r8,r10
800131d8:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800131da:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800131de:	14 38       	cp.w	r8,r10
800131e0:	e0 88 00 09 	brls	800131f2 <MenuFiltros+0x546>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800131e4:	12 38       	cp.w	r8,r9
800131e6:	fe 98 ff fa 	brls	800131da <MenuFiltros+0x52e>
800131ea:	12 3a       	cp.w	r10,r9
800131ec:	e0 83 03 d2 	brlo	80013990 <MenuFiltros+0xce4>
800131f0:	cf 5b       	rjmp	800131da <MenuFiltros+0x52e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800131f2:	12 38       	cp.w	r8,r9
800131f4:	e0 8b 03 ce 	brhi	80013990 <MenuFiltros+0xce4>
800131f8:	12 3a       	cp.w	r10,r9
800131fa:	e0 83 03 cb 	brlo	80013990 <MenuFiltros+0xce4>
800131fe:	ce eb       	rjmp	800131da <MenuFiltros+0x52e>
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
		else if (X>20 && X<=120 && Y>170 && Y<=190 && xytot<filtro && busy==true && step==2)
80013200:	e0 48 00 aa 	cp.w	r8,170
80013204:	e0 8a 00 87 	brle	80013312 <MenuFiltros+0x666>
80013208:	e0 48 00 be 	cp.w	r8,190
8001320c:	e0 89 00 83 	brgt	80013312 <MenuFiltros+0x666>
80013210:	fe fa 07 d4 	ld.w	r10,pc[2004]
80013214:	74 0a       	ld.w	r10,r10[0x0]
80013216:	58 2a       	cp.w	r10,2
80013218:	e0 89 00 7d 	brgt	80013312 <MenuFiltros+0x666>
8001321c:	fe fa 07 cc 	ld.w	r10,pc[1996]
80013220:	15 8b       	ld.ub	r11,r10[0x0]
80013222:	30 0a       	mov	r10,0
80013224:	f4 0b 18 00 	cp.b	r11,r10
80013228:	c7 50       	breq	80013312 <MenuFiltros+0x666>
8001322a:	fe fa 07 c2 	ld.w	r10,pc[1986]
8001322e:	15 8b       	ld.ub	r11,r10[0x0]
80013230:	30 2a       	mov	r10,2
80013232:	f4 0b 18 00 	cp.b	r11,r10
80013236:	c6 e1       	brne	80013312 <MenuFiltros+0x666>
		{
			gpio_clr_gpio_pin(LED0_GPIO);
80013238:	33 bc       	mov	r12,59
8001323a:	f0 1f 01 ee 	mcall	800139f0 <MenuFiltros+0xd44>
			blur= true;
8001323e:	30 19       	mov	r9,1
80013240:	fe f8 07 ec 	ld.w	r8,pc[2028]
80013244:	b0 89       	st.b	r8[0x0],r9
			et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013246:	e0 64 00 f0 	mov	r4,240
8001324a:	1a d4       	st.w	--sp,r4
8001324c:	e0 6b 01 40 	mov	r11,320
80013250:	1a db       	st.w	--sp,r11
80013252:	30 07       	mov	r7,0
80013254:	1a d7       	st.w	--sp,r7
80013256:	0e 98       	mov	r8,r7
80013258:	0e 99       	mov	r9,r7
8001325a:	0e 9a       	mov	r10,r7
8001325c:	fe fc 07 98 	ld.w	r12,pc[1944]
80013260:	78 0c       	ld.w	r12,r12[0x0]
80013262:	f0 1f 01 e6 	mcall	800139f8 <MenuFiltros+0xd4c>
			char brillo[]="Blur Activado";
80013266:	fe f8 07 ea 	ld.w	r8,pc[2026]
8001326a:	fa cc ff dc 	sub	r12,sp,-36
8001326e:	f0 ea 00 00 	ld.d	r10,r8[0]
80013272:	f8 eb 00 00 	st.d	r12[0],r10
80013276:	70 29       	ld.w	r9,r8[0x8]
80013278:	99 29       	st.w	r12[0x8],r9
8001327a:	f1 39 00 0c 	ld.ub	r9,r8[12]
8001327e:	f9 69 00 0c 	st.b	r12[12],r9
80013282:	f1 38 00 0d 	ld.ub	r8,r8[13]
80013286:	f9 68 00 0d 	st.b	r12[13],r8
			et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
8001328a:	fe f3 07 7e 	ld.w	r3,pc[1918]
8001328e:	e0 66 ff ff 	mov	r6,65535
80013292:	1a d6       	st.w	--sp,r6
80013294:	0e 98       	mov	r8,r7
80013296:	e0 69 00 dc 	mov	r9,220
8001329a:	35 aa       	mov	r10,90
8001329c:	06 9b       	mov	r11,r3
8001329e:	f0 1f 01 dc 	mcall	80013a0c <MenuFiltros+0xd60>
			char NEG2[]="Blur";
800132a2:	fe f8 07 72 	ld.w	r8,pc[1906]
800132a6:	fa c5 ff a8 	sub	r5,sp,-88
800132aa:	70 09       	ld.w	r9,r8[0x0]
800132ac:	8b 09       	st.w	r5[0x0],r9
800132ae:	11 c8       	ld.ub	r8,r8[0x4]
800132b0:	aa c8       	st.b	r5[0x4],r8
			et024006_DrawFilledRect(240,0,80,40,WHITE);
800132b2:	0c 98       	mov	r8,r6
800132b4:	32 89       	mov	r9,40
800132b6:	35 0a       	mov	r10,80
800132b8:	0e 9b       	mov	r11,r7
800132ba:	08 9c       	mov	r12,r4
800132bc:	f0 1f 01 d2 	mcall	80013a04 <MenuFiltros+0xd58>
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
800132c0:	1a d6       	st.w	--sp,r6
800132c2:	0e 98       	mov	r8,r7
800132c4:	31 09       	mov	r9,16
800132c6:	e0 6a 00 fa 	mov	r10,250
800132ca:	06 9b       	mov	r11,r3
800132cc:	0a 9c       	mov	r12,r5
800132ce:	f0 1f 01 d0 	mcall	80013a0c <MenuFiltros+0xd60>
			step=3;
800132d2:	30 39       	mov	r9,3
800132d4:	fe f8 07 18 	ld.w	r8,pc[1816]
800132d8:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800132da:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800132de:	e0 6a e1 c0 	mov	r10,57792
800132e2:	ea 1a 00 e4 	orh	r10,0xe4
800132e6:	f0 0a 00 0a 	add	r10,r8,r10
800132ea:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800132ec:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800132f0:	14 38       	cp.w	r8,r10
800132f2:	e0 88 00 09 	brls	80013304 <MenuFiltros+0x658>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800132f6:	12 38       	cp.w	r8,r9
800132f8:	fe 98 ff fa 	brls	800132ec <MenuFiltros+0x640>
800132fc:	12 3a       	cp.w	r10,r9
800132fe:	e0 83 03 4d 	brlo	80013998 <MenuFiltros+0xcec>
80013302:	cf 5b       	rjmp	800132ec <MenuFiltros+0x640>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80013304:	12 38       	cp.w	r8,r9
80013306:	e0 8b 03 49 	brhi	80013998 <MenuFiltros+0xcec>
8001330a:	12 3a       	cp.w	r10,r9
8001330c:	e0 83 03 46 	brlo	80013998 <MenuFiltros+0xcec>
80013310:	ce eb       	rjmp	800132ec <MenuFiltros+0x640>
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
		}
				else if (X>20 && X<=120 && Y>200 && Y<=220 && xytot<filtro && busy==true && step==2)
80013312:	e0 48 00 c8 	cp.w	r8,200
80013316:	e0 8a 00 88 	brle	80013426 <MenuFiltros+0x77a>
8001331a:	e0 48 00 dc 	cp.w	r8,220
8001331e:	e0 89 00 84 	brgt	80013426 <MenuFiltros+0x77a>
80013322:	fe fa 06 c2 	ld.w	r10,pc[1730]
80013326:	74 0a       	ld.w	r10,r10[0x0]
80013328:	58 2a       	cp.w	r10,2
8001332a:	e0 89 00 7e 	brgt	80013426 <MenuFiltros+0x77a>
8001332e:	fe fa 06 ba 	ld.w	r10,pc[1722]
80013332:	15 8b       	ld.ub	r11,r10[0x0]
80013334:	30 0a       	mov	r10,0
80013336:	f4 0b 18 00 	cp.b	r11,r10
8001333a:	c7 60       	breq	80013426 <MenuFiltros+0x77a>
8001333c:	fe fa 06 b0 	ld.w	r10,pc[1712]
80013340:	15 8b       	ld.ub	r11,r10[0x0]
80013342:	30 2a       	mov	r10,2
80013344:	f4 0b 18 00 	cp.b	r11,r10
80013348:	c6 f1       	brne	80013426 <MenuFiltros+0x77a>
				{
					gpio_clr_gpio_pin(LED0_GPIO);
8001334a:	33 bc       	mov	r12,59
8001334c:	f0 1f 01 a9 	mcall	800139f0 <MenuFiltros+0xd44>
					eros= true;
80013350:	30 19       	mov	r9,1
80013352:	fe f8 07 02 	ld.w	r8,pc[1794]
80013356:	b0 89       	st.b	r8[0x0],r9
					et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013358:	e0 65 00 f0 	mov	r5,240
8001335c:	1a d5       	st.w	--sp,r5
8001335e:	e0 6b 01 40 	mov	r11,320
80013362:	1a db       	st.w	--sp,r11
80013364:	30 07       	mov	r7,0
80013366:	1a d7       	st.w	--sp,r7
80013368:	0e 98       	mov	r8,r7
8001336a:	0e 99       	mov	r9,r7
8001336c:	0e 9a       	mov	r10,r7
8001336e:	fe fc 06 86 	ld.w	r12,pc[1670]
80013372:	78 0c       	ld.w	r12,r12[0x0]
80013374:	f0 1f 01 a1 	mcall	800139f8 <MenuFiltros+0xd4c>
					char brillo[]="Erosion Activado";
80013378:	fe f8 06 e0 	ld.w	r8,pc[1760]
8001337c:	fa cc ff f4 	sub	r12,sp,-12
80013380:	f0 ea 00 00 	ld.d	r10,r8[0]
80013384:	f8 eb 00 00 	st.d	r12[0],r10
80013388:	f0 ea 00 08 	ld.d	r10,r8[8]
8001338c:	f8 eb 00 08 	st.d	r12[8],r10
80013390:	f1 38 00 10 	ld.ub	r8,r8[16]
80013394:	f9 68 00 10 	st.b	r12[16],r8
					et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
80013398:	fe f4 06 70 	ld.w	r4,pc[1648]
8001339c:	e0 66 ff ff 	mov	r6,65535
800133a0:	1a d6       	st.w	--sp,r6
800133a2:	0e 98       	mov	r8,r7
800133a4:	e0 69 00 dc 	mov	r9,220
800133a8:	35 aa       	mov	r10,90
800133aa:	08 9b       	mov	r11,r4
800133ac:	f0 1f 01 98 	mcall	80013a0c <MenuFiltros+0xd60>
					char NEG2[]="Erosion";
800133b0:	e0 68 6e 00 	mov	r8,28160
800133b4:	ea 18 69 6f 	orh	r8,0x696f
800133b8:	e0 69 6f 73 	mov	r9,28531
800133bc:	ea 19 45 72 	orh	r9,0x4572
800133c0:	fa e9 00 38 	st.d	sp[56],r8
					et024006_DrawFilledRect(240,0,80,40,WHITE);
800133c4:	0c 98       	mov	r8,r6
800133c6:	32 89       	mov	r9,40
800133c8:	35 0a       	mov	r10,80
800133ca:	0e 9b       	mov	r11,r7
800133cc:	0a 9c       	mov	r12,r5
800133ce:	f0 1f 01 8e 	mcall	80013a04 <MenuFiltros+0xd58>
					et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
800133d2:	1a d6       	st.w	--sp,r6
800133d4:	0e 98       	mov	r8,r7
800133d6:	31 09       	mov	r9,16
800133d8:	e0 6a 00 fa 	mov	r10,250
800133dc:	08 9b       	mov	r11,r4
800133de:	fa cc ff c4 	sub	r12,sp,-60
800133e2:	f0 1f 01 8b 	mcall	80013a0c <MenuFiltros+0xd60>
					step=3;
800133e6:	30 39       	mov	r9,3
800133e8:	fe f8 06 04 	ld.w	r8,pc[1540]
800133ec:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800133ee:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800133f2:	e0 6a e1 c0 	mov	r10,57792
800133f6:	ea 1a 00 e4 	orh	r10,0xe4
800133fa:	f0 0a 00 0a 	add	r10,r8,r10
800133fe:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80013400:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80013404:	14 38       	cp.w	r8,r10
80013406:	e0 88 00 09 	brls	80013418 <MenuFiltros+0x76c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001340a:	12 38       	cp.w	r8,r9
8001340c:	fe 98 ff fa 	brls	80013400 <MenuFiltros+0x754>
80013410:	12 3a       	cp.w	r10,r9
80013412:	e0 83 02 c7 	brlo	800139a0 <MenuFiltros+0xcf4>
80013416:	cf 5b       	rjmp	80013400 <MenuFiltros+0x754>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80013418:	12 38       	cp.w	r8,r9
8001341a:	e0 8b 02 c3 	brhi	800139a0 <MenuFiltros+0xcf4>
8001341e:	12 3a       	cp.w	r10,r9
80013420:	e0 83 02 c0 	brlo	800139a0 <MenuFiltros+0xcf4>
80013424:	ce eb       	rjmp	80013400 <MenuFiltros+0x754>
					delay_ms(250);
					gpio_set_gpio_pin(LED0_GPIO);
				}
		else if (X>20 && X<=120 && Y>140 && Y<=160 && xytot<filtro && busy==true && step==2)
80013426:	e0 48 00 8c 	cp.w	r8,140
8001342a:	e0 8a 00 88 	brle	8001353a <MenuFiltros+0x88e>
8001342e:	e0 48 00 a0 	cp.w	r8,160
80013432:	e0 89 00 84 	brgt	8001353a <MenuFiltros+0x88e>
80013436:	fe fa 05 ae 	ld.w	r10,pc[1454]
8001343a:	74 0a       	ld.w	r10,r10[0x0]
8001343c:	58 2a       	cp.w	r10,2
8001343e:	e0 89 00 7e 	brgt	8001353a <MenuFiltros+0x88e>
80013442:	fe fa 05 a6 	ld.w	r10,pc[1446]
80013446:	15 8b       	ld.ub	r11,r10[0x0]
80013448:	30 0a       	mov	r10,0
8001344a:	f4 0b 18 00 	cp.b	r11,r10
8001344e:	c7 60       	breq	8001353a <MenuFiltros+0x88e>
80013450:	fe fa 05 9c 	ld.w	r10,pc[1436]
80013454:	15 8b       	ld.ub	r11,r10[0x0]
80013456:	30 2a       	mov	r10,2
80013458:	f4 0b 18 00 	cp.b	r11,r10
8001345c:	c6 f1       	brne	8001353a <MenuFiltros+0x88e>
		{
			gpio_clr_gpio_pin(LED0_GPIO);
8001345e:	33 bc       	mov	r12,59
80013460:	f0 1f 01 64 	mcall	800139f0 <MenuFiltros+0xd44>
			dilatar = true;
80013464:	30 19       	mov	r9,1
80013466:	fe f8 05 ca 	ld.w	r8,pc[1482]
8001346a:	b0 89       	st.b	r8[0x0],r9
			et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
8001346c:	e0 65 00 f0 	mov	r5,240
80013470:	1a d5       	st.w	--sp,r5
80013472:	e0 6b 01 40 	mov	r11,320
80013476:	1a db       	st.w	--sp,r11
80013478:	30 07       	mov	r7,0
8001347a:	1a d7       	st.w	--sp,r7
8001347c:	0e 98       	mov	r8,r7
8001347e:	0e 99       	mov	r9,r7
80013480:	0e 9a       	mov	r10,r7
80013482:	fe fc 05 72 	ld.w	r12,pc[1394]
80013486:	78 0c       	ld.w	r12,r12[0x0]
80013488:	f0 1f 01 5c 	mcall	800139f8 <MenuFiltros+0xd4c>
			char brillo[]="Dilatar Activado";
8001348c:	fe f8 05 d0 	ld.w	r8,pc[1488]
80013490:	fa cc ff f4 	sub	r12,sp,-12
80013494:	f0 ea 00 00 	ld.d	r10,r8[0]
80013498:	f8 eb 00 00 	st.d	r12[0],r10
8001349c:	f0 ea 00 08 	ld.d	r10,r8[8]
800134a0:	f8 eb 00 08 	st.d	r12[8],r10
800134a4:	f1 38 00 10 	ld.ub	r8,r8[16]
800134a8:	f9 68 00 10 	st.b	r12[16],r8
			et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,90,220,BLACK,WHITE);
800134ac:	fe f4 05 5c 	ld.w	r4,pc[1372]
800134b0:	e0 66 ff ff 	mov	r6,65535
800134b4:	1a d6       	st.w	--sp,r6
800134b6:	0e 98       	mov	r8,r7
800134b8:	e0 69 00 dc 	mov	r9,220
800134bc:	35 aa       	mov	r10,90
800134be:	08 9b       	mov	r11,r4
800134c0:	f0 1f 01 53 	mcall	80013a0c <MenuFiltros+0xd60>
			char NEG2[]="Dilatar";
800134c4:	e0 68 72 00 	mov	r8,29184
800134c8:	ea 18 74 61 	orh	r8,0x7461
800134cc:	e0 69 6c 61 	mov	r9,27745
800134d0:	ea 19 44 69 	orh	r9,0x4469
800134d4:	fa e9 00 38 	st.d	sp[56],r8
			et024006_DrawFilledRect(240,0,80,40,WHITE);
800134d8:	0c 98       	mov	r8,r6
800134da:	32 89       	mov	r9,40
800134dc:	35 0a       	mov	r10,80
800134de:	0e 9b       	mov	r11,r7
800134e0:	0a 9c       	mov	r12,r5
800134e2:	f0 1f 01 49 	mcall	80013a04 <MenuFiltros+0xd58>
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
800134e6:	1a d6       	st.w	--sp,r6
800134e8:	0e 98       	mov	r8,r7
800134ea:	31 09       	mov	r9,16
800134ec:	e0 6a 00 fa 	mov	r10,250
800134f0:	08 9b       	mov	r11,r4
800134f2:	fa cc ff c4 	sub	r12,sp,-60
800134f6:	f0 1f 01 46 	mcall	80013a0c <MenuFiltros+0xd60>
			step=3;
800134fa:	30 39       	mov	r9,3
800134fc:	fe f8 04 f0 	ld.w	r8,pc[1264]
80013500:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80013502:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80013506:	e0 6a e1 c0 	mov	r10,57792
8001350a:	ea 1a 00 e4 	orh	r10,0xe4
8001350e:	f0 0a 00 0a 	add	r10,r8,r10
80013512:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80013514:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80013518:	14 38       	cp.w	r8,r10
8001351a:	e0 88 00 09 	brls	8001352c <MenuFiltros+0x880>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001351e:	12 38       	cp.w	r8,r9
80013520:	fe 98 ff fa 	brls	80013514 <MenuFiltros+0x868>
80013524:	12 3a       	cp.w	r10,r9
80013526:	e0 83 02 41 	brlo	800139a8 <MenuFiltros+0xcfc>
8001352a:	cf 5b       	rjmp	80013514 <MenuFiltros+0x868>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001352c:	12 38       	cp.w	r8,r9
8001352e:	e0 8b 02 3d 	brhi	800139a8 <MenuFiltros+0xcfc>
80013532:	12 3a       	cp.w	r10,r9
80013534:	e0 83 02 3a 	brlo	800139a8 <MenuFiltros+0xcfc>
80013538:	ce eb       	rjmp	80013514 <MenuFiltros+0x868>
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
		}

	else if (X>20 && X<=120 && Y>10 && Y<=40 && xytot<filtro && busy==true && step==2)
8001353a:	58 a8       	cp.w	r8,10
8001353c:	e0 8a 00 68 	brle	8001360c <MenuFiltros+0x960>
80013540:	e0 48 00 28 	cp.w	r8,40
80013544:	e0 89 00 64 	brgt	8001360c <MenuFiltros+0x960>
80013548:	fe fa 04 9c 	ld.w	r10,pc[1180]
8001354c:	74 0a       	ld.w	r10,r10[0x0]
8001354e:	58 2a       	cp.w	r10,2
80013550:	e0 89 00 5e 	brgt	8001360c <MenuFiltros+0x960>
80013554:	fe fa 04 94 	ld.w	r10,pc[1172]
80013558:	15 8b       	ld.ub	r11,r10[0x0]
8001355a:	30 0a       	mov	r10,0
8001355c:	f4 0b 18 00 	cp.b	r11,r10
80013560:	c5 60       	breq	8001360c <MenuFiltros+0x960>
80013562:	fe fa 04 8a 	ld.w	r10,pc[1162]
80013566:	15 8b       	ld.ub	r11,r10[0x0]
80013568:	30 2a       	mov	r10,2
8001356a:	f4 0b 18 00 	cp.b	r11,r10
8001356e:	c4 f1       	brne	8001360c <MenuFiltros+0x960>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80013570:	33 bc       	mov	r12,59
80013572:	f0 1f 01 20 	mcall	800139f0 <MenuFiltros+0xd44>
		BrilloACT = true;
80013576:	30 19       	mov	r9,1
80013578:	fe f8 04 a4 	ld.w	r8,pc[1188]
8001357c:	b0 89       	st.b	r8[0x0],r9
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
8001357e:	e0 68 00 f0 	mov	r8,240
80013582:	1a d8       	st.w	--sp,r8
80013584:	e0 6b 01 40 	mov	r11,320
80013588:	1a db       	st.w	--sp,r11
8001358a:	30 07       	mov	r7,0
8001358c:	1a d7       	st.w	--sp,r7
8001358e:	0e 98       	mov	r8,r7
80013590:	0e 99       	mov	r9,r7
80013592:	0e 9a       	mov	r10,r7
80013594:	fe fc 04 60 	ld.w	r12,pc[1120]
80013598:	78 0c       	ld.w	r12,r12[0x0]
8001359a:	f0 1f 01 18 	mcall	800139f8 <MenuFiltros+0xd4c>
		char NEG[]="Brillo Activado";
8001359e:	fe f8 04 c2 	ld.w	r8,pc[1218]
800135a2:	fa cc ff f4 	sub	r12,sp,-12
800135a6:	f0 ea 00 00 	ld.d	r10,r8[0]
800135aa:	f8 eb 00 00 	st.d	r12[0],r10
800135ae:	f0 e8 00 08 	ld.d	r8,r8[8]
800135b2:	f8 e9 00 08 	st.d	r12[8],r8
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
800135b6:	e0 68 ff ff 	mov	r8,65535
800135ba:	1a d8       	st.w	--sp,r8
800135bc:	0e 98       	mov	r8,r7
800135be:	e0 69 00 dc 	mov	r9,220
800135c2:	36 0a       	mov	r10,96
800135c4:	fe fb 04 44 	ld.w	r11,pc[1092]
800135c8:	f0 1f 01 11 	mcall	80013a0c <MenuFiltros+0xd60>
		step=3;
800135cc:	30 39       	mov	r9,3
800135ce:	fe f8 04 1e 	ld.w	r8,pc[1054]
800135d2:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800135d4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800135d8:	e0 6a 1b 00 	mov	r10,6912
800135dc:	ea 1a 00 b7 	orh	r10,0xb7
800135e0:	f0 0a 00 0a 	add	r10,r8,r10
800135e4:	2f cd       	sub	sp,-16
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800135e6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800135ea:	14 38       	cp.w	r8,r10
800135ec:	e0 88 00 09 	brls	800135fe <MenuFiltros+0x952>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800135f0:	12 38       	cp.w	r8,r9
800135f2:	fe 98 ff fa 	brls	800135e6 <MenuFiltros+0x93a>
800135f6:	12 3a       	cp.w	r10,r9
800135f8:	e0 83 01 dc 	brlo	800139b0 <MenuFiltros+0xd04>
800135fc:	cf 5b       	rjmp	800135e6 <MenuFiltros+0x93a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800135fe:	12 38       	cp.w	r8,r9
80013600:	e0 8b 01 d8 	brhi	800139b0 <MenuFiltros+0xd04>
80013604:	12 3a       	cp.w	r10,r9
80013606:	e0 83 01 d5 	brlo	800139b0 <MenuFiltros+0xd04>
8001360a:	ce eb       	rjmp	800135e6 <MenuFiltros+0x93a>
		delay_ms(200);
		gpio_set_gpio_pin(LED0_GPIO);
	}

	else if (X>20 && X<=120 && Y>50 && Y<=70 && xytot<filtro && busy==true && step==2)
8001360c:	e0 48 00 32 	cp.w	r8,50
80013610:	e0 8a 00 8b 	brle	80013726 <MenuFiltros+0xa7a>
80013614:	e0 48 00 46 	cp.w	r8,70
80013618:	e0 89 00 87 	brgt	80013726 <MenuFiltros+0xa7a>
8001361c:	fe fa 03 c8 	ld.w	r10,pc[968]
80013620:	74 0a       	ld.w	r10,r10[0x0]
80013622:	58 2a       	cp.w	r10,2
80013624:	e0 89 00 81 	brgt	80013726 <MenuFiltros+0xa7a>
80013628:	fe fa 03 c0 	ld.w	r10,pc[960]
8001362c:	15 8b       	ld.ub	r11,r10[0x0]
8001362e:	30 0a       	mov	r10,0
80013630:	f4 0b 18 00 	cp.b	r11,r10
80013634:	c7 90       	breq	80013726 <MenuFiltros+0xa7a>
80013636:	fe fa 03 b6 	ld.w	r10,pc[950]
8001363a:	15 8b       	ld.ub	r11,r10[0x0]
8001363c:	30 2a       	mov	r10,2
8001363e:	f4 0b 18 00 	cp.b	r11,r10
80013642:	c7 21       	brne	80013726 <MenuFiltros+0xa7a>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80013644:	33 bc       	mov	r12,59
80013646:	f0 1f 00 eb 	mcall	800139f0 <MenuFiltros+0xd44>
		NegACT = true;
8001364a:	30 19       	mov	r9,1
8001364c:	fe f8 03 d4 	ld.w	r8,pc[980]
80013650:	b0 89       	st.b	r8[0x0],r9
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013652:	e0 64 00 f0 	mov	r4,240
80013656:	1a d4       	st.w	--sp,r4
80013658:	e0 6b 01 40 	mov	r11,320
8001365c:	1a db       	st.w	--sp,r11
8001365e:	30 07       	mov	r7,0
80013660:	1a d7       	st.w	--sp,r7
80013662:	0e 98       	mov	r8,r7
80013664:	0e 99       	mov	r9,r7
80013666:	0e 9a       	mov	r10,r7
80013668:	fe fc 03 8c 	ld.w	r12,pc[908]
8001366c:	78 0c       	ld.w	r12,r12[0x0]
8001366e:	f0 1f 00 e3 	mcall	800139f8 <MenuFiltros+0xd4c>
		char NEG[]="Negativo Activado";
80013672:	fe f8 03 f2 	ld.w	r8,pc[1010]
80013676:	fa cc ff f4 	sub	r12,sp,-12
8001367a:	f0 ea 00 00 	ld.d	r10,r8[0]
8001367e:	f8 eb 00 00 	st.d	r12[0],r10
80013682:	f0 ea 00 08 	ld.d	r10,r8[8]
80013686:	f8 eb 00 08 	st.d	r12[8],r10
8001368a:	f1 39 00 10 	ld.ub	r9,r8[16]
8001368e:	f9 69 00 10 	st.b	r12[16],r9
80013692:	f1 38 00 11 	ld.ub	r8,r8[17]
80013696:	f9 68 00 11 	st.b	r12[17],r8
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
8001369a:	fe f3 03 6e 	ld.w	r3,pc[878]
8001369e:	e0 65 ff ff 	mov	r5,65535
800136a2:	1a d5       	st.w	--sp,r5
800136a4:	0e 98       	mov	r8,r7
800136a6:	e0 69 00 dc 	mov	r9,220
800136aa:	36 0a       	mov	r10,96
800136ac:	06 9b       	mov	r11,r3
800136ae:	f0 1f 00 d8 	mcall	80013a0c <MenuFiltros+0xd60>
		char NEG2[]="NEGAR";
800136b2:	fe f8 03 b6 	ld.w	r8,pc[950]
800136b6:	fa c6 ff b0 	sub	r6,sp,-80
800136ba:	70 09       	ld.w	r9,r8[0x0]
800136bc:	8d 09       	st.w	r6[0x0],r9
800136be:	11 c9       	ld.ub	r9,r8[0x4]
800136c0:	ac c9       	st.b	r6[0x4],r9
800136c2:	11 d8       	ld.ub	r8,r8[0x5]
800136c4:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,0,80,40,WHITE);
800136c6:	0a 98       	mov	r8,r5
800136c8:	32 89       	mov	r9,40
800136ca:	35 0a       	mov	r10,80
800136cc:	0e 9b       	mov	r11,r7
800136ce:	08 9c       	mov	r12,r4
800136d0:	f0 1f 00 cd 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
800136d4:	1a d5       	st.w	--sp,r5
800136d6:	0e 98       	mov	r8,r7
800136d8:	31 09       	mov	r9,16
800136da:	e0 6a 01 04 	mov	r10,260
800136de:	06 9b       	mov	r11,r3
800136e0:	0c 9c       	mov	r12,r6
800136e2:	f0 1f 00 cb 	mcall	80013a0c <MenuFiltros+0xd60>
		step=3;
800136e6:	30 39       	mov	r9,3
800136e8:	fe f8 03 04 	ld.w	r8,pc[772]
800136ec:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800136ee:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800136f2:	e0 6a 1b 00 	mov	r10,6912
800136f6:	ea 1a 00 b7 	orh	r10,0xb7
800136fa:	f0 0a 00 0a 	add	r10,r8,r10
800136fe:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80013700:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80013704:	14 38       	cp.w	r8,r10
80013706:	e0 88 00 09 	brls	80013718 <MenuFiltros+0xa6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8001370a:	12 38       	cp.w	r8,r9
8001370c:	fe 98 ff fa 	brls	80013700 <MenuFiltros+0xa54>
80013710:	12 3a       	cp.w	r10,r9
80013712:	e0 83 01 53 	brlo	800139b8 <MenuFiltros+0xd0c>
80013716:	cf 5b       	rjmp	80013700 <MenuFiltros+0xa54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80013718:	12 38       	cp.w	r8,r9
8001371a:	e0 8b 01 4f 	brhi	800139b8 <MenuFiltros+0xd0c>
8001371e:	12 3a       	cp.w	r10,r9
80013720:	e0 83 01 4c 	brlo	800139b8 <MenuFiltros+0xd0c>
80013724:	ce eb       	rjmp	80013700 <MenuFiltros+0xa54>
		delay_ms(200);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if (X>20 && X<=120 && Y>80 && Y<=100 && xytot<filtro && busy==true && step==2)
80013726:	e0 48 00 50 	cp.w	r8,80
8001372a:	e0 8a 00 81 	brle	8001382c <MenuFiltros+0xb80>
8001372e:	e0 48 00 64 	cp.w	r8,100
80013732:	e0 89 00 7d 	brgt	8001382c <MenuFiltros+0xb80>
80013736:	fe f8 02 ae 	ld.w	r8,pc[686]
8001373a:	70 08       	ld.w	r8,r8[0x0]
8001373c:	58 28       	cp.w	r8,2
8001373e:	e0 89 00 77 	brgt	8001382c <MenuFiltros+0xb80>
80013742:	fe f8 02 a6 	ld.w	r8,pc[678]
80013746:	11 8a       	ld.ub	r10,r8[0x0]
80013748:	30 08       	mov	r8,0
8001374a:	f0 0a 18 00 	cp.b	r10,r8
8001374e:	c6 f0       	breq	8001382c <MenuFiltros+0xb80>
80013750:	fe f8 02 9c 	ld.w	r8,pc[668]
80013754:	11 8a       	ld.ub	r10,r8[0x0]
80013756:	30 28       	mov	r8,2
80013758:	f0 0a 18 00 	cp.b	r10,r8
8001375c:	c6 81       	brne	8001382c <MenuFiltros+0xb80>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
8001375e:	33 bc       	mov	r12,59
80013760:	f0 1f 00 a4 	mcall	800139f0 <MenuFiltros+0xd44>
		BNACT = true;
80013764:	30 19       	mov	r9,1
80013766:	fe f8 02 be 	ld.w	r8,pc[702]
8001376a:	b0 89       	st.b	r8[0x0],r9
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
8001376c:	e0 64 00 f0 	mov	r4,240
80013770:	1a d4       	st.w	--sp,r4
80013772:	e0 6b 01 40 	mov	r11,320
80013776:	1a db       	st.w	--sp,r11
80013778:	30 06       	mov	r6,0
8001377a:	1a d6       	st.w	--sp,r6
8001377c:	0c 98       	mov	r8,r6
8001377e:	0c 99       	mov	r9,r6
80013780:	0c 9a       	mov	r10,r6
80013782:	fe fc 02 72 	ld.w	r12,pc[626]
80013786:	78 0c       	ld.w	r12,r12[0x0]
80013788:	f0 1f 00 9c 	mcall	800139f8 <MenuFiltros+0xd4c>
		char BN[]="B/N Activado";
8001378c:	fe f8 02 e0 	ld.w	r8,pc[736]
80013790:	fa cc ff dc 	sub	r12,sp,-36
80013794:	f0 ea 00 00 	ld.d	r10,r8[0]
80013798:	f8 eb 00 00 	st.d	r12[0],r10
8001379c:	70 29       	ld.w	r9,r8[0x8]
8001379e:	99 29       	st.w	r12[0x8],r9
800137a0:	f1 38 00 0c 	ld.ub	r8,r8[12]
800137a4:	f9 68 00 0c 	st.b	r12[12],r8
		et024006_PrintString(BN,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
800137a8:	fe f3 02 60 	ld.w	r3,pc[608]
800137ac:	e0 65 ff ff 	mov	r5,65535
800137b0:	1a d5       	st.w	--sp,r5
800137b2:	0c 98       	mov	r8,r6
800137b4:	e0 69 00 dc 	mov	r9,220
800137b8:	36 0a       	mov	r10,96
800137ba:	06 9b       	mov	r11,r3
800137bc:	f0 1f 00 94 	mcall	80013a0c <MenuFiltros+0xd60>
		char BN2[]="B/N";
800137c0:	fa c7 ff 9c 	sub	r7,sp,-100
800137c4:	e0 68 4e 00 	mov	r8,19968
800137c8:	ea 18 42 2f 	orh	r8,0x422f
800137cc:	0e d8       	st.w	--r7,r8
		et024006_DrawFilledRect(240,0,80,40,WHITE);
800137ce:	0a 98       	mov	r8,r5
800137d0:	32 89       	mov	r9,40
800137d2:	35 0a       	mov	r10,80
800137d4:	0c 9b       	mov	r11,r6
800137d6:	08 9c       	mov	r12,r4
800137d8:	f0 1f 00 8b 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(BN2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
800137dc:	1a d5       	st.w	--sp,r5
800137de:	0c 98       	mov	r8,r6
800137e0:	31 09       	mov	r9,16
800137e2:	e0 6a 01 04 	mov	r10,260
800137e6:	06 9b       	mov	r11,r3
800137e8:	0e 9c       	mov	r12,r7
800137ea:	f0 1f 00 89 	mcall	80013a0c <MenuFiltros+0xd60>
		step=3;
800137ee:	30 39       	mov	r9,3
800137f0:	4f f8       	lddpc	r8,800139ec <MenuFiltros+0xd40>
800137f2:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800137f4:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800137f8:	e0 6a e1 c0 	mov	r10,57792
800137fc:	ea 1a 00 e4 	orh	r10,0xe4
80013800:	f0 0a 00 0a 	add	r10,r8,r10
80013804:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80013806:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001380a:	14 38       	cp.w	r8,r10
8001380c:	e0 88 00 09 	brls	8001381e <MenuFiltros+0xb72>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80013810:	12 38       	cp.w	r8,r9
80013812:	fe 98 ff fa 	brls	80013806 <MenuFiltros+0xb5a>
80013816:	12 3a       	cp.w	r10,r9
80013818:	e0 83 00 d4 	brlo	800139c0 <MenuFiltros+0xd14>
8001381c:	cf 5b       	rjmp	80013806 <MenuFiltros+0xb5a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001381e:	12 38       	cp.w	r8,r9
80013820:	e0 8b 00 d0 	brhi	800139c0 <MenuFiltros+0xd14>
80013824:	12 3a       	cp.w	r10,r9
80013826:	e0 83 00 cd 	brlo	800139c0 <MenuFiltros+0xd14>
8001382a:	ce eb       	rjmp	80013806 <MenuFiltros+0xb5a>
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==2)
8001382c:	e0 49 00 4f 	cp.w	r9,79
80013830:	e0 8b 00 d2 	brhi	800139d4 <MenuFiltros+0xd28>
80013834:	4e b8       	lddpc	r8,800139e0 <MenuFiltros+0xd34>
80013836:	70 08       	ld.w	r8,r8[0x0]
80013838:	58 08       	cp.w	r8,0
8001383a:	e0 8a 00 cd 	brle	800139d4 <MenuFiltros+0xd28>
8001383e:	e0 48 00 28 	cp.w	r8,40
80013842:	e0 89 00 c9 	brgt	800139d4 <MenuFiltros+0xd28>
80013846:	4e 88       	lddpc	r8,800139e4 <MenuFiltros+0xd38>
80013848:	70 08       	ld.w	r8,r8[0x0]
8001384a:	58 28       	cp.w	r8,2
8001384c:	e0 89 00 c4 	brgt	800139d4 <MenuFiltros+0xd28>
80013850:	4e 68       	lddpc	r8,800139e8 <MenuFiltros+0xd3c>
80013852:	11 89       	ld.ub	r9,r8[0x0]
80013854:	30 08       	mov	r8,0
80013856:	f0 09 18 00 	cp.b	r9,r8
8001385a:	e0 80 00 bd 	breq	800139d4 <MenuFiltros+0xd28>
8001385e:	4e 48       	lddpc	r8,800139ec <MenuFiltros+0xd40>
80013860:	11 89       	ld.ub	r9,r8[0x0]
80013862:	30 28       	mov	r8,2
80013864:	f0 09 18 00 	cp.b	r9,r8
80013868:	e0 81 00 b6 	brne	800139d4 <MenuFiltros+0xd28>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
8001386c:	33 bc       	mov	r12,59
8001386e:	f0 1f 00 61 	mcall	800139f0 <MenuFiltros+0xd44>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013872:	e0 63 00 f0 	mov	r3,240
80013876:	1a d3       	st.w	--sp,r3
80013878:	e0 6b 01 40 	mov	r11,320
8001387c:	1a db       	st.w	--sp,r11
8001387e:	30 07       	mov	r7,0
80013880:	1a d7       	st.w	--sp,r7
80013882:	0e 98       	mov	r8,r7
80013884:	0e 99       	mov	r9,r7
80013886:	0e 9a       	mov	r10,r7
80013888:	4d bc       	lddpc	r12,800139f4 <MenuFiltros+0xd48>
8001388a:	78 0c       	ld.w	r12,r12[0x0]
8001388c:	f0 1f 00 5b 	mcall	800139f8 <MenuFiltros+0xd4c>
		char menuTXT[]="Menu Filtros";
80013890:	4f 88       	lddpc	r8,80013a70 <MenuFiltros+0xdc4>
80013892:	fa c6 ff dc 	sub	r6,sp,-36
80013896:	f0 ea 00 00 	ld.d	r10,r8[0]
8001389a:	ec eb 00 00 	st.d	r6[0],r10
8001389e:	70 29       	ld.w	r9,r8[0x8]
800138a0:	8d 29       	st.w	r6[0x8],r9
800138a2:	f1 38 00 0c 	ld.ub	r8,r8[12]
800138a6:	ed 68 00 0c 	st.b	r6[12],r8
		et024006_DrawFilledRect(200,200,120,40,WHITE);
800138aa:	e0 68 ff ff 	mov	r8,65535
800138ae:	32 89       	mov	r9,40
800138b0:	37 8a       	mov	r10,120
800138b2:	e0 6b 00 c8 	mov	r11,200
800138b6:	16 9c       	mov	r12,r11
800138b8:	f0 1f 00 53 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(menuTXT,(const unsigned char *)&FONT8x16,210,210,BLACK,WHITE);
800138bc:	4d 34       	lddpc	r4,80013a08 <MenuFiltros+0xd5c>
800138be:	e0 65 ff ff 	mov	r5,65535
800138c2:	1a d5       	st.w	--sp,r5
800138c4:	0e 98       	mov	r8,r7
800138c6:	e0 69 00 d2 	mov	r9,210
800138ca:	12 9a       	mov	r10,r9
800138cc:	08 9b       	mov	r11,r4
800138ce:	0c 9c       	mov	r12,r6
800138d0:	f0 1f 00 4f 	mcall	80013a0c <MenuFiltros+0xd60>
		char Salir[]="Salir y Salvar";
800138d4:	4e 88       	lddpc	r8,80013a74 <MenuFiltros+0xdc8>
800138d6:	fa c6 ff f0 	sub	r6,sp,-16
800138da:	f0 ea 00 00 	ld.d	r10,r8[0]
800138de:	ec eb 00 00 	st.d	r6[0],r10
800138e2:	70 29       	ld.w	r9,r8[0x8]
800138e4:	8d 29       	st.w	r6[0x8],r9
800138e6:	f1 39 00 0c 	ld.ub	r9,r8[12]
800138ea:	ed 69 00 0c 	st.b	r6[12],r9
800138ee:	f1 39 00 0d 	ld.ub	r9,r8[13]
800138f2:	ed 69 00 0d 	st.b	r6[13],r9
800138f6:	f1 38 00 0e 	ld.ub	r8,r8[14]
800138fa:	ed 68 00 0e 	st.b	r6[14],r8
		et024006_DrawFilledRect(200,0,140,40,WHITE);
800138fe:	0a 98       	mov	r8,r5
80013900:	32 89       	mov	r9,40
80013902:	e0 6a 00 8c 	mov	r10,140
80013906:	0e 9b       	mov	r11,r7
80013908:	e0 6c 00 c8 	mov	r12,200
8001390c:	f0 1f 00 3e 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(Salir,(const unsigned char *)&FONT8x16,200,16,BLACK,WHITE);
80013910:	1a d5       	st.w	--sp,r5
80013912:	0e 98       	mov	r8,r7
80013914:	31 09       	mov	r9,16
80013916:	e0 6a 00 c8 	mov	r10,200
8001391a:	08 9b       	mov	r11,r4
8001391c:	0c 9c       	mov	r12,r6
8001391e:	f0 1f 00 3c 	mcall	80013a0c <MenuFiltros+0xd60>
		char Salirr[]="Salir";
80013922:	4d 68       	lddpc	r8,80013a78 <MenuFiltros+0xdcc>
80013924:	fa c6 ff ac 	sub	r6,sp,-84
80013928:	70 09       	ld.w	r9,r8[0x0]
8001392a:	8d 09       	st.w	r6[0x0],r9
8001392c:	11 c9       	ld.ub	r9,r8[0x4]
8001392e:	ac c9       	st.b	r6[0x4],r9
80013930:	11 d8       	ld.ub	r8,r8[0x5]
80013932:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,40,80,40,WHITE);
80013934:	0a 98       	mov	r8,r5
80013936:	32 89       	mov	r9,40
80013938:	35 0a       	mov	r10,80
8001393a:	12 9b       	mov	r11,r9
8001393c:	06 9c       	mov	r12,r3
8001393e:	f0 1f 00 32 	mcall	80013a04 <MenuFiltros+0xd58>
		et024006_PrintString(Salirr,(const unsigned char *)&FONT8x16,260,56,BLACK,WHITE);
80013942:	1a d5       	st.w	--sp,r5
80013944:	0e 98       	mov	r8,r7
80013946:	33 89       	mov	r9,56
80013948:	e0 6a 01 04 	mov	r10,260
8001394c:	08 9b       	mov	r11,r4
8001394e:	0c 9c       	mov	r12,r6
80013950:	f0 1f 00 2f 	mcall	80013a0c <MenuFiltros+0xd60>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80013954:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80013958:	e0 6a e1 c0 	mov	r10,57792
8001395c:	ea 1a 00 e4 	orh	r10,0xe4
80013960:	f0 0a 00 0a 	add	r10,r8,r10
80013964:	2f ad       	sub	sp,-24
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80013966:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001396a:	14 38       	cp.w	r8,r10
8001396c:	e0 88 00 08 	brls	8001397c <MenuFiltros+0xcd0>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80013970:	12 38       	cp.w	r8,r9
80013972:	fe 98 ff fa 	brls	80013966 <MenuFiltros+0xcba>
80013976:	12 3a       	cp.w	r10,r9
80013978:	c2 83       	brcs	800139c8 <MenuFiltros+0xd1c>
8001397a:	cf 6b       	rjmp	80013966 <MenuFiltros+0xcba>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8001397c:	12 38       	cp.w	r8,r9
8001397e:	e0 8b 00 25 	brhi	800139c8 <MenuFiltros+0xd1c>
80013982:	12 3a       	cp.w	r10,r9
80013984:	c2 23       	brcs	800139c8 <MenuFiltros+0xd1c>
80013986:	cf 0b       	rjmp	80013966 <MenuFiltros+0xcba>
		char Exit[]="SALIR";
		et024006_DrawFilledRect(240,0,80,40,WHITE);
		et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		step=2;
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
80013988:	33 bc       	mov	r12,59
8001398a:	f0 1f 00 3d 	mcall	80013a7c <MenuFiltros+0xdd0>
}

void MenuFiltros(void)
{

	if (X>200 && X<=320 && Y>200 && Y<=240 && xytot<filtro && busy==true && step==1)
8001398e:	c2 38       	rjmp	800139d4 <MenuFiltros+0xd28>
		char NEG2[]="AutoF";
		et024006_DrawFilledRect(240,0,80,40,WHITE);
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		step=3;
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
80013990:	33 bc       	mov	r12,59
80013992:	f0 1f 00 3b 	mcall	80013a7c <MenuFiltros+0xdd0>
		busy=false;
		InicializarFondo();
		Desplegar();
	}

	else if (X>20 && X<=120 && Y>110 && Y<=130 && xytot<filtro && busy==true && step==2)
80013996:	c1 f8       	rjmp	800139d4 <MenuFiltros+0xd28>
			char NEG2[]="Blur";
			et024006_DrawFilledRect(240,0,80,40,WHITE);
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
			step=3;
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
80013998:	33 bc       	mov	r12,59
8001399a:	f0 1f 00 39 	mcall	80013a7c <MenuFiltros+0xdd0>
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		step=3;
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
		else if (X>20 && X<=120 && Y>170 && Y<=190 && xytot<filtro && busy==true && step==2)
8001399e:	c1 b8       	rjmp	800139d4 <MenuFiltros+0xd28>
					char NEG2[]="Erosion";
					et024006_DrawFilledRect(240,0,80,40,WHITE);
					et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
					step=3;
					delay_ms(250);
					gpio_set_gpio_pin(LED0_GPIO);
800139a0:	33 bc       	mov	r12,59
800139a2:	f0 1f 00 37 	mcall	80013a7c <MenuFiltros+0xdd0>
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
			step=3;
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
		}
				else if (X>20 && X<=120 && Y>200 && Y<=220 && xytot<filtro && busy==true && step==2)
800139a6:	c1 78       	rjmp	800139d4 <MenuFiltros+0xd28>
			char NEG2[]="Dilatar";
			et024006_DrawFilledRect(240,0,80,40,WHITE);
			et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
			step=3;
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
800139a8:	33 bc       	mov	r12,59
800139aa:	f0 1f 00 35 	mcall	80013a7c <MenuFiltros+0xdd0>
					et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,250,16,BLACK,WHITE);
					step=3;
					delay_ms(250);
					gpio_set_gpio_pin(LED0_GPIO);
				}
		else if (X>20 && X<=120 && Y>140 && Y<=160 && xytot<filtro && busy==true && step==2)
800139ae:	c1 38       	rjmp	800139d4 <MenuFiltros+0xd28>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
		char NEG[]="Brillo Activado";
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
		step=3;
		delay_ms(200);
		gpio_set_gpio_pin(LED0_GPIO);
800139b0:	33 bc       	mov	r12,59
800139b2:	f0 1f 00 33 	mcall	80013a7c <MenuFiltros+0xdd0>
			step=3;
			delay_ms(250);
			gpio_set_gpio_pin(LED0_GPIO);
		}

	else if (X>20 && X<=120 && Y>10 && Y<=40 && xytot<filtro && busy==true && step==2)
800139b6:	c0 f8       	rjmp	800139d4 <MenuFiltros+0xd28>
		char NEG2[]="NEGAR";
		et024006_DrawFilledRect(240,0,80,40,WHITE);
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		step=3;
		delay_ms(200);
		gpio_set_gpio_pin(LED0_GPIO);
800139b8:	33 bc       	mov	r12,59
800139ba:	f0 1f 00 31 	mcall	80013a7c <MenuFiltros+0xdd0>
		step=3;
		delay_ms(200);
		gpio_set_gpio_pin(LED0_GPIO);
	}

	else if (X>20 && X<=120 && Y>50 && Y<=70 && xytot<filtro && busy==true && step==2)
800139be:	c0 b8       	rjmp	800139d4 <MenuFiltros+0xd28>
		char BN2[]="B/N";
		et024006_DrawFilledRect(240,0,80,40,WHITE);
		et024006_PrintString(BN2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		step=3;
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
800139c0:	33 bc       	mov	r12,59
800139c2:	f0 1f 00 2f 	mcall	80013a7c <MenuFiltros+0xdd0>
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		step=3;
		delay_ms(200);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if (X>20 && X<=120 && Y>80 && Y<=100 && xytot<filtro && busy==true && step==2)
800139c6:	c0 78       	rjmp	800139d4 <MenuFiltros+0xd28>
		et024006_PrintString(Salir,(const unsigned char *)&FONT8x16,200,16,BLACK,WHITE);
		char Salirr[]="Salir";
		et024006_DrawFilledRect(240,40,80,40,WHITE);
		et024006_PrintString(Salirr,(const unsigned char *)&FONT8x16,260,56,BLACK,WHITE);
		delay_ms(250);
		step=1;
800139c8:	30 19       	mov	r9,1
800139ca:	48 98       	lddpc	r8,800139ec <MenuFiltros+0xd40>
800139cc:	b0 89       	st.b	r8[0x0],r9
		gpio_set_gpio_pin(LED0_GPIO);
800139ce:	33 bc       	mov	r12,59
800139d0:	f0 1f 00 2b 	mcall	80013a7c <MenuFiltros+0xdd0>
	}
}
800139d4:	2e bd       	sub	sp,-84
800139d6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800139da:	00 00       	add	r0,r0
800139dc:	00 00       	add	r0,r0
800139de:	07 70       	ld.ub	r0,--r3
800139e0:	00 00       	add	r0,r0
800139e2:	07 74       	ld.ub	r4,--r3
800139e4:	00 00       	add	r0,r0
800139e6:	07 5c       	ld.sh	r12,--r3
800139e8:	00 00       	add	r0,r0
800139ea:	07 63       	ld.uh	r3,--r3
800139ec:	00 00       	add	r0,r0
800139ee:	07 60       	ld.uh	r0,--r3
800139f0:	80 00       	ld.sh	r0,r0[0x0]
800139f2:	6c 7e       	ld.w	lr,r6[0x1c]
800139f4:	00 00       	add	r0,r0
800139f6:	0d 28       	ld.uh	r8,r6++
800139f8:	80 00       	ld.sh	r0,r0[0x0]
800139fa:	63 3c       	ld.w	r12,r1[0x4c]
800139fc:	80 01       	ld.sh	r1,r0[0x0]
800139fe:	fe 70 80 01 	mov	r0,-32767
80013a02:	fe 78 80 00 	mov	r8,-32768
80013a06:	62 94       	ld.w	r4,r1[0x24]
80013a08:	80 01       	ld.sh	r1,r0[0x0]
80013a0a:	dc 90       	acall	0xc9
80013a0c:	80 00       	ld.sh	r0,r0[0x0]
80013a0e:	60 18       	ld.w	r8,r0[0x4]
80013a10:	80 01       	ld.sh	r1,r0[0x0]
80013a12:	fe 84 80 01 	brge	7ffe3a14 <__heap_size__+0x7dfe3a14>
80013a16:	fe 90 80 01 	breq	80003a18 <fat_cluster_val+0x68>
80013a1a:	fe 98 00 00 	brls	7fff3a1a <__heap_size__+0x7dff3a1a>
80013a1e:	06 88       	andn	r8,r3
80013a20:	00 00       	add	r0,r0
80013a22:	06 8b       	andn	r11,r3
80013a24:	00 00       	add	r0,r0
80013a26:	07 61       	ld.uh	r1,--r3
80013a28:	00 00       	add	r0,r0
80013a2a:	06 8a       	andn	r10,r3
80013a2c:	00 00       	add	r0,r0
80013a2e:	07 62       	ld.uh	r2,--r3
80013a30:	00 00       	add	r0,r0
80013a32:	06 d0       	st.w	--r3,r0
80013a34:	80 01       	ld.sh	r1,r0[0x0]
80013a36:	fe f0 00 00 	ld.w	r0,pc[0]
80013a3a:	00 10       	sub	r0,r0
80013a3c:	80 01       	ld.sh	r1,r0[0x0]
80013a3e:	05 98       	ld.ub	r8,r2[0x1]
80013a40:	80 01       	ld.sh	r1,r0[0x0]
80013a42:	06 f4       	st.b	--r3,r4
80013a44:	80 01       	ld.sh	r1,r0[0x0]
80013a46:	07 90       	ld.ub	r0,r3[0x1]
80013a48:	80 01       	ld.sh	r1,r0[0x0]
80013a4a:	fe fc 80 01 	ld.w	r12,pc[-32767]
80013a4e:	fe e8 80 01 	ld.d	r8,pc[-32767]
80013a52:	fe b0 00 00 	rcall	7fff3a52 <__heap_size__+0x7dff3a52>
80013a56:	06 b8       	st.h	r3++,r8
80013a58:	80 01       	ld.sh	r1,r0[0x0]
80013a5a:	fe c0 80 01 	sub	r0,pc,-32767
80013a5e:	fe 5c 80 01 	cp.w	r12,-32767
80013a62:	ff 14 80 01 	ld.uh	r4,pc[-32767]
80013a66:	ff 24 80 01 	ld.sb	r4,pc[-32767]
80013a6a:	ff 38 80 01 	ld.ub	r8,pc[-32767]
80013a6e:	fe a0 80 01 	rcall	7ffe3a70 <__heap_size__+0x7dfe3a70>
80013a72:	fe 34 80 01 	sub	r4,-32767
80013a76:	fe 44 80 01 	cp.w	r4,-98303
80013a7a:	fe 54 80 00 	cp.w	r4,-32768
80013a7e:	6c 62       	ld.w	r2,r6[0x18]

80013a80 <Brillo>:
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Brillo (void)
{
80013a80:	eb cd 40 fc 	pushm	r2-r7,lr
80013a84:	21 2d       	sub	sp,72
	if(BrilloACT== true && gpio_get_pin_value(Abajo)==1 && busy==true && step==3)
80013a86:	fe f8 04 46 	ld.w	r8,pc[1094]
80013a8a:	11 89       	ld.ub	r9,r8[0x0]
80013a8c:	30 08       	mov	r8,0
80013a8e:	f0 09 18 00 	cp.b	r9,r8
80013a92:	e0 80 02 19 	breq	80013ec4 <Brillo+0x444>
80013a96:	33 7c       	mov	r12,55
80013a98:	f0 1f 01 0e 	mcall	80013ed0 <Brillo+0x450>
80013a9c:	c6 30       	breq	80013b62 <Brillo+0xe2>
80013a9e:	fe f8 04 36 	ld.w	r8,pc[1078]
80013aa2:	11 89       	ld.ub	r9,r8[0x0]
80013aa4:	30 08       	mov	r8,0
80013aa6:	f0 09 18 00 	cp.b	r9,r8
80013aaa:	c5 c0       	breq	80013b62 <Brillo+0xe2>
80013aac:	fe f8 04 2c 	ld.w	r8,pc[1068]
80013ab0:	11 89       	ld.ub	r9,r8[0x0]
80013ab2:	30 38       	mov	r8,3
80013ab4:	f0 09 18 00 	cp.b	r9,r8
80013ab8:	c5 51       	brne	80013b62 <Brillo+0xe2>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80013aba:	33 bc       	mov	r12,59
80013abc:	f0 1f 01 08 	mcall	80013edc <Brillo+0x45c>
		while(gpio_get_pin_value(Abajo)==1);
80013ac0:	33 77       	mov	r7,55
80013ac2:	0e 9c       	mov	r12,r7
80013ac4:	f0 1f 01 03 	mcall	80013ed0 <Brillo+0x450>
80013ac8:	cf d1       	brne	80013ac2 <Brillo+0x42>
		int R1,G1,B1;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
80013aca:	fe f8 04 16 	ld.w	r8,pc[1046]
80013ace:	70 08       	ld.w	r8,r8[0x0]
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Brillo (void)
80013ad0:	e2 69 58 00 	mov	r9,153600
80013ad4:	f0 09 00 07 	add	r7,r8,r9
			B1-=1;
			if (B1<=0)
			{
				B1=0;
			}
			G1-=2;
80013ad8:	30 0a       	mov	r10,0
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
		{
			Value1=*puntero&0xFFFF;
80013ada:	90 89       	ld.uh	r9,r8[0x0]
			B1=Value1&BLUE;
80013adc:	f7 d9 c0 05 	bfextu	r11,r9,0x0,0x5
			G1=(Value1&GREEN)>>5;
80013ae0:	f9 d9 c0 a6 	bfextu	r12,r9,0x5,0x6
			R1=(Value1&RED)>>11;
80013ae4:	ab 99       	lsr	r9,0xb
			B1-=1;
80013ae6:	20 1b       	sub	r11,1
			if (B1<=0)
			{
				B1=0;
			}
			G1-=2;
80013ae8:	20 2c       	sub	r12,2
80013aea:	f8 0a 0c 4c 	max	r12,r12,r10
			if (G1<=0)
			{
				G1=0;
			}
			R1-=1;
80013aee:	20 19       	sub	r9,1
80013af0:	f2 0a 0c 49 	max	r9,r9,r10
			{
				R1=0;
			}
			G1=G1<<5;
			R1=R1<<11;
			*puntero=B1+G1+R1;
80013af4:	a5 7c       	lsl	r12,0x5
80013af6:	ab 79       	lsl	r9,0xb
80013af8:	f8 09 00 09 	add	r9,r12,r9
80013afc:	f6 0a 0c 4b 	max	r11,r11,r10
80013b00:	16 09       	add	r9,r11
80013b02:	10 b9       	st.h	r8++,r9
		while(gpio_get_pin_value(Abajo)==1);
		int R1,G1,B1;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
80013b04:	0e 38       	cp.w	r8,r7
80013b06:	ce a1       	brne	80013ada <Brillo+0x5a>
			G1=G1<<5;
			R1=R1<<11;
			*puntero=B1+G1+R1;
			puntero++;
		}
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013b08:	e0 68 00 f0 	mov	r8,240
80013b0c:	1a d8       	st.w	--sp,r8
80013b0e:	e0 6b 01 40 	mov	r11,320
80013b12:	1a db       	st.w	--sp,r11
80013b14:	30 07       	mov	r7,0
80013b16:	1a d7       	st.w	--sp,r7
80013b18:	0e 98       	mov	r8,r7
80013b1a:	0e 99       	mov	r9,r7
80013b1c:	0e 9a       	mov	r10,r7
80013b1e:	fe fc 03 c2 	ld.w	r12,pc[962]
80013b22:	78 0c       	ld.w	r12,r12[0x0]
80013b24:	f0 1f 00 f0 	mcall	80013ee4 <Brillo+0x464>
		char brillo[]="Brillo Activado";
80013b28:	fe f8 03 c0 	ld.w	r8,pc[960]
80013b2c:	fa cc ff f4 	sub	r12,sp,-12
80013b30:	f0 ea 00 00 	ld.d	r10,r8[0]
80013b34:	f8 eb 00 00 	st.d	r12[0],r10
80013b38:	f0 e8 00 08 	ld.d	r8,r8[8]
80013b3c:	f8 e9 00 08 	st.d	r12[8],r8
		et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
80013b40:	e0 68 ff ff 	mov	r8,65535
80013b44:	1a d8       	st.w	--sp,r8
80013b46:	0e 98       	mov	r8,r7
80013b48:	e0 69 00 dc 	mov	r9,220
80013b4c:	36 0a       	mov	r10,96
80013b4e:	fe fb 03 9e 	ld.w	r11,pc[926]
80013b52:	f0 1f 00 e8 	mcall	80013ef0 <Brillo+0x470>
		gpio_set_gpio_pin(LED0_GPIO);
80013b56:	33 bc       	mov	r12,59
80013b58:	f0 1f 00 e7 	mcall	80013ef4 <Brillo+0x474>
	}
}

void Brillo (void)
{
	if(BrilloACT== true && gpio_get_pin_value(Abajo)==1 && busy==true && step==3)
80013b5c:	2f cd       	sub	sp,-16
80013b5e:	e0 8f 01 b3 	bral	80013ec4 <Brillo+0x444>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
		char brillo[]="Brillo Activado";
		et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(BrilloACT== true && gpio_get_pin_value(Arriba)==1 && busy==true && step==3)
80013b62:	fe f8 03 6a 	ld.w	r8,pc[874]
80013b66:	11 89       	ld.ub	r9,r8[0x0]
80013b68:	30 08       	mov	r8,0
80013b6a:	f0 09 18 00 	cp.b	r9,r8
80013b6e:	e0 80 01 ab 	breq	80013ec4 <Brillo+0x444>
80013b72:	33 6c       	mov	r12,54
80013b74:	f0 1f 00 d7 	mcall	80013ed0 <Brillo+0x450>
80013b78:	c6 30       	breq	80013c3e <Brillo+0x1be>
80013b7a:	fe f8 03 5a 	ld.w	r8,pc[858]
80013b7e:	11 89       	ld.ub	r9,r8[0x0]
80013b80:	30 08       	mov	r8,0
80013b82:	f0 09 18 00 	cp.b	r9,r8
80013b86:	c5 c0       	breq	80013c3e <Brillo+0x1be>
80013b88:	fe f8 03 50 	ld.w	r8,pc[848]
80013b8c:	11 89       	ld.ub	r9,r8[0x0]
80013b8e:	30 38       	mov	r8,3
80013b90:	f0 09 18 00 	cp.b	r9,r8
80013b94:	c5 51       	brne	80013c3e <Brillo+0x1be>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80013b96:	33 bc       	mov	r12,59
80013b98:	f0 1f 00 d1 	mcall	80013edc <Brillo+0x45c>
		while(gpio_get_pin_value(Arriba)==1);
80013b9c:	33 67       	mov	r7,54
80013b9e:	0e 9c       	mov	r12,r7
80013ba0:	f0 1f 00 cc 	mcall	80013ed0 <Brillo+0x450>
80013ba4:	cf d1       	brne	80013b9e <Brillo+0x11e>
		int R1,G1,B1;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
80013ba6:	fe f8 03 3a 	ld.w	r8,pc[826]
80013baa:	70 08       	ld.w	r8,r8[0x0]
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
	}
}

void Brillo (void)
80013bac:	e2 69 58 00 	mov	r9,153600
80013bb0:	f0 09 00 06 	add	r6,r8,r9
			B1+=1;
			if (B1>=32)
			{
				B1=BLUE;
			}
			G1+=2;
80013bb4:	33 f7       	mov	r7,63
			if (G1>=64)
			{
				G1=63;
			}
			R1+=1;
80013bb6:	31 fa       	mov	r10,31
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
		{
			Value1=*puntero&0xFFFF;
80013bb8:	90 89       	ld.uh	r9,r8[0x0]
			B1=Value1&BLUE;
80013bba:	f7 d9 c0 05 	bfextu	r11,r9,0x0,0x5
			G1=(Value1&GREEN)>>5;
80013bbe:	f9 d9 c0 a6 	bfextu	r12,r9,0x5,0x6
			R1=(Value1&RED)>>11;
80013bc2:	ab 99       	lsr	r9,0xb
			B1+=1;
80013bc4:	2f fb       	sub	r11,-1
			if (B1>=32)
			{
				B1=BLUE;
			}
			G1+=2;
80013bc6:	2f ec       	sub	r12,-2
80013bc8:	f8 07 0d 4c 	min	r12,r12,r7
			if (G1>=64)
			{
				G1=63;
			}
			R1+=1;
80013bcc:	2f f9       	sub	r9,-1
80013bce:	f2 0a 0d 49 	min	r9,r9,r10
			{
				R1=31;
			}
			G1=G1<<5;
			R1=R1<<11;
			*puntero=B1+G1+R1;
80013bd2:	a5 7c       	lsl	r12,0x5
80013bd4:	ab 79       	lsl	r9,0xb
80013bd6:	f8 09 00 09 	add	r9,r12,r9
80013bda:	f6 0a 0d 4b 	min	r11,r11,r10
80013bde:	16 09       	add	r9,r11
80013be0:	10 b9       	st.h	r8++,r9
		while(gpio_get_pin_value(Arriba)==1);
		int R1,G1,B1;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
80013be2:	0c 38       	cp.w	r8,r6
80013be4:	ce a1       	brne	80013bb8 <Brillo+0x138>
			G1=G1<<5;
			R1=R1<<11;
			*puntero=B1+G1+R1;
			puntero++;
		}
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013be6:	e0 68 00 f0 	mov	r8,240
80013bea:	1a d8       	st.w	--sp,r8
80013bec:	e0 6b 01 40 	mov	r11,320
80013bf0:	1a db       	st.w	--sp,r11
80013bf2:	30 07       	mov	r7,0
80013bf4:	1a d7       	st.w	--sp,r7
80013bf6:	0e 98       	mov	r8,r7
80013bf8:	0e 99       	mov	r9,r7
80013bfa:	0e 9a       	mov	r10,r7
80013bfc:	fe fc 02 e4 	ld.w	r12,pc[740]
80013c00:	78 0c       	ld.w	r12,r12[0x0]
80013c02:	f0 1f 00 b9 	mcall	80013ee4 <Brillo+0x464>
		char brillo[]="Brillo Activado";
80013c06:	fe f8 02 e2 	ld.w	r8,pc[738]
80013c0a:	fa cc ff f4 	sub	r12,sp,-12
80013c0e:	f0 ea 00 00 	ld.d	r10,r8[0]
80013c12:	f8 eb 00 00 	st.d	r12[0],r10
80013c16:	f0 e8 00 08 	ld.d	r8,r8[8]
80013c1a:	f8 e9 00 08 	st.d	r12[8],r8
		et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
80013c1e:	e0 68 ff ff 	mov	r8,65535
80013c22:	1a d8       	st.w	--sp,r8
80013c24:	0e 98       	mov	r8,r7
80013c26:	e0 69 00 dc 	mov	r9,220
80013c2a:	36 0a       	mov	r10,96
80013c2c:	fe fb 02 c0 	ld.w	r11,pc[704]
80013c30:	f0 1f 00 b0 	mcall	80013ef0 <Brillo+0x470>
		gpio_set_gpio_pin(LED0_GPIO);
80013c34:	33 bc       	mov	r12,59
80013c36:	f0 1f 00 b0 	mcall	80013ef4 <Brillo+0x474>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
		char brillo[]="Brillo Activado";
		et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(BrilloACT== true && gpio_get_pin_value(Arriba)==1 && busy==true && step==3)
80013c3a:	2f cd       	sub	sp,-16
80013c3c:	c4 49       	rjmp	80013ec4 <Brillo+0x444>
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
		char brillo[]="Brillo Activado";
		et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(BrilloACT== true && X>96 && X<=232 && Y>220 && Y<=240 && xytot<filtro && busy==true && step==3)
80013c3e:	fe f8 02 8e 	ld.w	r8,pc[654]
80013c42:	11 89       	ld.ub	r9,r8[0x0]
80013c44:	30 08       	mov	r8,0
80013c46:	f0 09 18 00 	cp.b	r9,r8
80013c4a:	e0 80 01 3d 	breq	80013ec4 <Brillo+0x444>
80013c4e:	fe f8 02 aa 	ld.w	r8,pc[682]
80013c52:	70 08       	ld.w	r8,r8[0x0]
80013c54:	e0 48 00 60 	cp.w	r8,96
80013c58:	e0 8a 01 36 	brle	80013ec4 <Brillo+0x444>
80013c5c:	e0 48 00 e8 	cp.w	r8,232
80013c60:	e0 89 01 32 	brgt	80013ec4 <Brillo+0x444>
80013c64:	fe f8 02 98 	ld.w	r8,pc[664]
80013c68:	70 08       	ld.w	r8,r8[0x0]
80013c6a:	e0 48 00 dc 	cp.w	r8,220
80013c6e:	e0 8a 01 2b 	brle	80013ec4 <Brillo+0x444>
80013c72:	e0 48 00 f0 	cp.w	r8,240
80013c76:	e0 89 01 27 	brgt	80013ec4 <Brillo+0x444>
80013c7a:	fe f8 02 86 	ld.w	r8,pc[646]
80013c7e:	70 08       	ld.w	r8,r8[0x0]
80013c80:	58 28       	cp.w	r8,2
80013c82:	e0 89 01 21 	brgt	80013ec4 <Brillo+0x444>
80013c86:	fe f8 02 4e 	ld.w	r8,pc[590]
80013c8a:	11 89       	ld.ub	r9,r8[0x0]
80013c8c:	30 08       	mov	r8,0
80013c8e:	f0 09 18 00 	cp.b	r9,r8
80013c92:	e0 80 01 19 	breq	80013ec4 <Brillo+0x444>
80013c96:	fe f8 02 42 	ld.w	r8,pc[578]
80013c9a:	11 89       	ld.ub	r9,r8[0x0]
80013c9c:	30 38       	mov	r8,3
80013c9e:	f0 09 18 00 	cp.b	r9,r8
80013ca2:	e0 81 01 11 	brne	80013ec4 <Brillo+0x444>
	{
		BrilloACT=false;
80013ca6:	30 09       	mov	r9,0
80013ca8:	fe f8 02 24 	ld.w	r8,pc[548]
80013cac:	b0 89       	st.b	r8[0x0],r9
gpio_clr_gpio_pin(LED0_GPIO);
80013cae:	33 bc       	mov	r12,59
80013cb0:	f0 1f 00 8b 	mcall	80013edc <Brillo+0x45c>
et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013cb4:	e0 62 00 f0 	mov	r2,240
80013cb8:	1a d2       	st.w	--sp,r2
80013cba:	e0 6b 01 40 	mov	r11,320
80013cbe:	1a db       	st.w	--sp,r11
80013cc0:	30 06       	mov	r6,0
80013cc2:	1a d6       	st.w	--sp,r6
80013cc4:	0c 98       	mov	r8,r6
80013cc6:	0c 99       	mov	r9,r6
80013cc8:	0c 9a       	mov	r10,r6
80013cca:	fe fc 02 16 	ld.w	r12,pc[534]
80013cce:	78 0c       	ld.w	r12,r12[0x0]
80013cd0:	f0 1f 00 85 	mcall	80013ee4 <Brillo+0x464>
char brillo[]="Brillo";
80013cd4:	fe f8 02 30 	ld.w	r8,pc[560]
80013cd8:	fa c4 ff c8 	sub	r4,sp,-56
80013cdc:	70 09       	ld.w	r9,r8[0x0]
80013cde:	89 09       	st.w	r4[0x0],r9
80013ce0:	11 c9       	ld.ub	r9,r8[0x4]
80013ce2:	a8 c9       	st.b	r4[0x4],r9
80013ce4:	11 d9       	ld.ub	r9,r8[0x5]
80013ce6:	a8 d9       	st.b	r4[0x5],r9
80013ce8:	11 e8       	ld.ub	r8,r8[0x6]
80013cea:	a8 e8       	st.b	r4[0x6],r8
char Negativo[]="Negativo";
80013cec:	fe f8 02 1c 	ld.w	r8,pc[540]
80013cf0:	fa c3 ff e4 	sub	r3,sp,-28
80013cf4:	f0 ea 00 00 	ld.d	r10,r8[0]
80013cf8:	e6 eb 00 00 	st.d	r3[0],r10
80013cfc:	f1 38 00 08 	ld.ub	r8,r8[8]
80013d00:	e7 68 00 08 	st.b	r3[8],r8
char BlNe[]="B/N";
80013d04:	e0 68 4e 00 	mov	r8,19968
80013d08:	ea 18 42 2f 	orh	r8,0x422f
80013d0c:	51 48       	stdsp	sp[0x50],r8
char dila[]="Dilatar";
80013d0e:	e0 68 72 00 	mov	r8,29184
80013d12:	ea 18 74 61 	orh	r8,0x7461
80013d16:	e0 69 6c 61 	mov	r9,27745
80013d1a:	ea 19 44 69 	orh	r9,0x4469
80013d1e:	fa e9 00 30 	st.d	sp[48],r8
et024006_DrawFilledRect(20,20,80,20,WHITE);
80013d22:	e0 68 ff ff 	mov	r8,65535
80013d26:	31 49       	mov	r9,20
80013d28:	35 0a       	mov	r10,80
80013d2a:	12 9b       	mov	r11,r9
80013d2c:	12 9c       	mov	r12,r9
80013d2e:	f0 1f 00 78 	mcall	80013f0c <Brillo+0x48c>
et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
80013d32:	4e f5       	lddpc	r5,80013eec <Brillo+0x46c>
80013d34:	e0 67 ff ff 	mov	r7,65535
80013d38:	1a d7       	st.w	--sp,r7
80013d3a:	0c 98       	mov	r8,r6
80013d3c:	31 49       	mov	r9,20
80013d3e:	12 9a       	mov	r10,r9
80013d40:	0a 9b       	mov	r11,r5
80013d42:	08 9c       	mov	r12,r4
80013d44:	f0 1f 00 6b 	mcall	80013ef0 <Brillo+0x470>
et024006_DrawFilledRect(20,50,80,20,WHITE);
80013d48:	0e 98       	mov	r8,r7
80013d4a:	31 49       	mov	r9,20
80013d4c:	35 0a       	mov	r10,80
80013d4e:	33 2b       	mov	r11,50
80013d50:	12 9c       	mov	r12,r9
80013d52:	f0 1f 00 6f 	mcall	80013f0c <Brillo+0x48c>
et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
80013d56:	1a d7       	st.w	--sp,r7
80013d58:	0c 98       	mov	r8,r6
80013d5a:	33 29       	mov	r9,50
80013d5c:	31 4a       	mov	r10,20
80013d5e:	0a 9b       	mov	r11,r5
80013d60:	06 9c       	mov	r12,r3
80013d62:	f0 1f 00 64 	mcall	80013ef0 <Brillo+0x470>
et024006_DrawFilledRect(20,80,80,20,WHITE);
80013d66:	0e 98       	mov	r8,r7
80013d68:	31 49       	mov	r9,20
80013d6a:	35 0a       	mov	r10,80
80013d6c:	14 9b       	mov	r11,r10
80013d6e:	12 9c       	mov	r12,r9
80013d70:	f0 1f 00 67 	mcall	80013f0c <Brillo+0x48c>
et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
80013d74:	1a d7       	st.w	--sp,r7
80013d76:	0c 98       	mov	r8,r6
80013d78:	35 09       	mov	r9,80
80013d7a:	31 4a       	mov	r10,20
80013d7c:	0a 9b       	mov	r11,r5
80013d7e:	fa cc ff a4 	sub	r12,sp,-92
80013d82:	f0 1f 00 5c 	mcall	80013ef0 <Brillo+0x470>
et024006_DrawFilledRect(20,110,80,20,WHITE);
80013d86:	0e 98       	mov	r8,r7
80013d88:	31 49       	mov	r9,20
80013d8a:	35 0a       	mov	r10,80
80013d8c:	36 eb       	mov	r11,110
80013d8e:	12 9c       	mov	r12,r9
80013d90:	f0 1f 00 5f 	mcall	80013f0c <Brillo+0x48c>
char AutoFiltro[]="AutoFiltro";
80013d94:	4d f8       	lddpc	r8,80013f10 <Brillo+0x490>
80013d96:	fa cc ff e8 	sub	r12,sp,-24
80013d9a:	f0 ea 00 00 	ld.d	r10,r8[0]
80013d9e:	f8 eb 00 00 	st.d	r12[0],r10
80013da2:	f1 39 00 08 	ld.ub	r9,r8[8]
80013da6:	f9 69 00 08 	st.b	r12[8],r9
80013daa:	f1 39 00 09 	ld.ub	r9,r8[9]
80013dae:	f9 69 00 09 	st.b	r12[9],r9
80013db2:	f1 38 00 0a 	ld.ub	r8,r8[10]
80013db6:	f9 68 00 0a 	st.b	r12[10],r8
et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
80013dba:	1a d7       	st.w	--sp,r7
80013dbc:	0c 98       	mov	r8,r6
80013dbe:	36 e9       	mov	r9,110
80013dc0:	31 4a       	mov	r10,20
80013dc2:	0a 9b       	mov	r11,r5
80013dc4:	f0 1f 00 4b 	mcall	80013ef0 <Brillo+0x470>
et024006_DrawFilledRect(20,140,80,20,WHITE);
80013dc8:	0e 98       	mov	r8,r7
80013dca:	31 49       	mov	r9,20
80013dcc:	35 0a       	mov	r10,80
80013dce:	e0 6b 00 8c 	mov	r11,140
80013dd2:	12 9c       	mov	r12,r9
80013dd4:	f0 1f 00 4e 	mcall	80013f0c <Brillo+0x48c>
et024006_PrintString(dila,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
80013dd8:	1a d7       	st.w	--sp,r7
80013dda:	0c 98       	mov	r8,r6
80013ddc:	e0 69 00 8c 	mov	r9,140
80013de0:	31 4a       	mov	r10,20
80013de2:	0a 9b       	mov	r11,r5
80013de4:	fa cc ff bc 	sub	r12,sp,-68
80013de8:	f0 1f 00 42 	mcall	80013ef0 <Brillo+0x470>
et024006_DrawFilledRect(20,170,80,20,WHITE);
80013dec:	2f 8d       	sub	sp,-32
80013dee:	0e 98       	mov	r8,r7
80013df0:	31 49       	mov	r9,20
80013df2:	35 0a       	mov	r10,80
80013df4:	e0 6b 00 aa 	mov	r11,170
80013df8:	12 9c       	mov	r12,r9
80013dfa:	f0 1f 00 45 	mcall	80013f0c <Brillo+0x48c>
et024006_DrawFilledRect(20,200,80,20,WHITE);
80013dfe:	0e 98       	mov	r8,r7
80013e00:	31 49       	mov	r9,20
80013e02:	35 0a       	mov	r10,80
80013e04:	e0 6b 00 c8 	mov	r11,200
80013e08:	12 9c       	mov	r12,r9
80013e0a:	f0 1f 00 41 	mcall	80013f0c <Brillo+0x48c>
char Eros[]="Erosion";
80013e0e:	e0 68 6e 00 	mov	r8,28160
80013e12:	ea 18 69 6f 	orh	r8,0x696f
80013e16:	e0 69 6f 73 	mov	r9,28531
80013e1a:	ea 19 45 72 	orh	r9,0x4572
80013e1e:	fa e9 00 1c 	st.d	sp[28],r8
et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
80013e22:	1a d7       	st.w	--sp,r7
80013e24:	0c 98       	mov	r8,r6
80013e26:	e0 69 00 c8 	mov	r9,200
80013e2a:	31 4a       	mov	r10,20
80013e2c:	0a 9b       	mov	r11,r5
80013e2e:	fa cc ff e0 	sub	r12,sp,-32
80013e32:	f0 1f 00 30 	mcall	80013ef0 <Brillo+0x470>
char BlNs[]="Blur";
80013e36:	4b 88       	lddpc	r8,80013f14 <Brillo+0x494>
80013e38:	fa cc ff c0 	sub	r12,sp,-64
80013e3c:	70 09       	ld.w	r9,r8[0x0]
80013e3e:	99 09       	st.w	r12[0x0],r9
80013e40:	11 c8       	ld.ub	r8,r8[0x4]
80013e42:	b8 c8       	st.b	r12[0x4],r8
et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
80013e44:	1a d7       	st.w	--sp,r7
80013e46:	0c 98       	mov	r8,r6
80013e48:	e0 69 00 aa 	mov	r9,170
80013e4c:	31 4a       	mov	r10,20
80013e4e:	0a 9b       	mov	r11,r5
80013e50:	f0 1f 00 28 	mcall	80013ef0 <Brillo+0x470>
char Exit[]="SALIR";
80013e54:	4b 18       	lddpc	r8,80013f18 <Brillo+0x498>
80013e56:	fa c4 ff c4 	sub	r4,sp,-60
80013e5a:	70 09       	ld.w	r9,r8[0x0]
80013e5c:	89 09       	st.w	r4[0x0],r9
80013e5e:	11 c9       	ld.ub	r9,r8[0x4]
80013e60:	a8 c9       	st.b	r4[0x4],r9
80013e62:	11 d8       	ld.ub	r8,r8[0x5]
80013e64:	a8 d8       	st.b	r4[0x5],r8
et024006_DrawFilledRect(240,0,80,40,WHITE);
80013e66:	0e 98       	mov	r8,r7
80013e68:	32 89       	mov	r9,40
80013e6a:	35 0a       	mov	r10,80
80013e6c:	0c 9b       	mov	r11,r6
80013e6e:	04 9c       	mov	r12,r2
80013e70:	f0 1f 00 27 	mcall	80013f0c <Brillo+0x48c>
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80013e74:	1a d7       	st.w	--sp,r7
80013e76:	0c 98       	mov	r8,r6
80013e78:	31 09       	mov	r9,16
80013e7a:	e0 6a 01 04 	mov	r10,260
80013e7e:	0a 9b       	mov	r11,r5
80013e80:	08 9c       	mov	r12,r4
80013e82:	f0 1f 00 1c 	mcall	80013ef0 <Brillo+0x470>
step=2;
80013e86:	30 29       	mov	r9,2
80013e88:	49 48       	lddpc	r8,80013ed8 <Brillo+0x458>
80013e8a:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80013e8c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80013e90:	e0 6a e1 c0 	mov	r10,57792
80013e94:	ea 1a 00 e4 	orh	r10,0xe4
80013e98:	f0 0a 00 0a 	add	r10,r8,r10
80013e9c:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80013e9e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80013ea2:	14 38       	cp.w	r8,r10
80013ea4:	e0 88 00 08 	brls	80013eb4 <Brillo+0x434>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80013ea8:	12 38       	cp.w	r8,r9
80013eaa:	fe 98 ff fa 	brls	80013e9e <Brillo+0x41e>
80013eae:	12 3a       	cp.w	r10,r9
80013eb0:	c0 73       	brcs	80013ebe <Brillo+0x43e>
80013eb2:	cf 6b       	rjmp	80013e9e <Brillo+0x41e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80013eb4:	12 38       	cp.w	r8,r9
80013eb6:	e0 8b 00 04 	brhi	80013ebe <Brillo+0x43e>
80013eba:	12 3a       	cp.w	r10,r9
80013ebc:	cf 12       	brcc	80013e9e <Brillo+0x41e>
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
80013ebe:	33 bc       	mov	r12,59
80013ec0:	f0 1f 00 0d 	mcall	80013ef4 <Brillo+0x474>
	}
}
80013ec4:	2e ed       	sub	sp,-72
80013ec6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80013eca:	00 00       	add	r0,r0
80013ecc:	00 00       	add	r0,r0
80013ece:	06 88       	andn	r8,r3
80013ed0:	80 00       	ld.sh	r0,r0[0x0]
80013ed2:	6c 4c       	ld.w	r12,r6[0x10]
80013ed4:	00 00       	add	r0,r0
80013ed6:	07 63       	ld.uh	r3,--r3
80013ed8:	00 00       	add	r0,r0
80013eda:	07 60       	ld.uh	r0,--r3
80013edc:	80 00       	ld.sh	r0,r0[0x0]
80013ede:	6c 7e       	ld.w	lr,r6[0x1c]
80013ee0:	00 00       	add	r0,r0
80013ee2:	0d 28       	ld.uh	r8,r6++
80013ee4:	80 00       	ld.sh	r0,r0[0x0]
80013ee6:	63 3c       	ld.w	r12,r1[0x4c]
80013ee8:	80 01       	ld.sh	r1,r0[0x0]
80013eea:	ff 14 80 01 	ld.uh	r4,pc[-32767]
80013eee:	dc 90       	acall	0xc9
80013ef0:	80 00       	ld.sh	r0,r0[0x0]
80013ef2:	60 18       	ld.w	r8,r0[0x4]
80013ef4:	80 00       	ld.sh	r0,r0[0x0]
80013ef6:	6c 62       	ld.w	r2,r6[0x18]
80013ef8:	00 00       	add	r0,r0
80013efa:	07 70       	ld.ub	r0,--r3
80013efc:	00 00       	add	r0,r0
80013efe:	07 74       	ld.ub	r4,--r3
80013f00:	00 00       	add	r0,r0
80013f02:	07 5c       	ld.sh	r12,--r3
80013f04:	80 01       	ld.sh	r1,r0[0x0]
80013f06:	fe 70 80 01 	mov	r0,-32767
80013f0a:	fe 78 80 00 	mov	r8,-32768
80013f0e:	62 94       	ld.w	r4,r1[0x24]
80013f10:	80 01       	ld.sh	r1,r0[0x0]
80013f12:	fe 84 80 01 	brge	7ffe3f14 <__heap_size__+0x7dfe3f14>
80013f16:	fe 90 80 01 	breq	80003f18 <fat_read_dir+0x4c>
80013f1a:	fe 98 eb cd 	brls	800116b4 <Dilatar+0x338>

80013f1c <Negativos>:
	}
	
	
}
void Negativos (void)
{
80013f1c:	eb cd 40 fc 	pushm	r2-r7,lr
80013f20:	21 3d       	sub	sp,76
	if(NegACT == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
80013f22:	fe f8 03 f2 	ld.w	r8,pc[1010]
80013f26:	11 88       	ld.ub	r8,r8[0x0]
80013f28:	58 08       	cp.w	r8,0
80013f2a:	e0 80 01 f2 	breq	8001430e <Negativos+0x3f2>
80013f2e:	fe f9 03 ea 	ld.w	r9,pc[1002]
80013f32:	72 09       	ld.w	r9,r9[0x0]
80013f34:	e0 49 00 f0 	cp.w	r9,240
80013f38:	e0 8a 00 ab 	brle	8001408e <Negativos+0x172>
80013f3c:	e0 49 01 40 	cp.w	r9,320
80013f40:	e0 89 00 a7 	brgt	8001408e <Negativos+0x172>
80013f44:	fe fa 03 d8 	ld.w	r10,pc[984]
80013f48:	74 0a       	ld.w	r10,r10[0x0]
80013f4a:	58 0a       	cp.w	r10,0
80013f4c:	e0 8a 00 a1 	brle	8001408e <Negativos+0x172>
80013f50:	e0 4a 00 28 	cp.w	r10,40
80013f54:	e0 89 00 9d 	brgt	8001408e <Negativos+0x172>
80013f58:	fe fa 03 c8 	ld.w	r10,pc[968]
80013f5c:	74 0a       	ld.w	r10,r10[0x0]
80013f5e:	58 2a       	cp.w	r10,2
80013f60:	e0 89 00 97 	brgt	8001408e <Negativos+0x172>
80013f64:	fe fa 03 c0 	ld.w	r10,pc[960]
80013f68:	15 8b       	ld.ub	r11,r10[0x0]
80013f6a:	30 0a       	mov	r10,0
80013f6c:	f4 0b 18 00 	cp.b	r11,r10
80013f70:	e0 80 00 8f 	breq	8001408e <Negativos+0x172>
80013f74:	fe f8 03 b4 	ld.w	r8,pc[948]
80013f78:	11 8a       	ld.ub	r10,r8[0x0]
80013f7a:	30 38       	mov	r8,3
80013f7c:	f0 0a 18 00 	cp.b	r10,r8
80013f80:	e0 81 00 8a 	brne	80014094 <Negativos+0x178>
	{
		gpio_clr_gpio_pin(LED0_GPIO);
80013f84:	33 bc       	mov	r12,59
80013f86:	f0 1f 00 ea 	mcall	8001432c <Negativos+0x410>
		while(gpio_get_pin_value(Arriba)==1);
80013f8a:	33 67       	mov	r7,54
80013f8c:	0e 9c       	mov	r12,r7
80013f8e:	f0 1f 00 e9 	mcall	80014330 <Negativos+0x414>
80013f92:	cf d1       	brne	80013f8c <Negativos+0x70>
		int R1,G1,B1;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
80013f94:	fe f8 03 a0 	ld.w	r8,pc[928]
80013f98:	70 08       	ld.w	r8,r8[0x0]
gpio_set_gpio_pin(LED0_GPIO);
	}
	
	
}
void Negativos (void)
80013f9a:	e2 69 58 00 	mov	r9,153600
80013f9e:	f0 09 00 0c 	add	r12,r8,r9
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
		{
			Value1=*puntero&0xFFFF;
			B1=(~Value1)&BLUE;
80013fa2:	90 89       	ld.uh	r9,r8[0x0]
80013fa4:	5c d9       	com	r9
			G1=((~Value1)&GREEN);
			R1=((~Value1)&RED);
			*puntero=B1+G1+R1;
80013fa6:	12 9b       	mov	r11,r9
80013fa8:	e2 1b 07 e0 	andl	r11,0x7e0,COH
80013fac:	f5 d9 c0 05 	bfextu	r10,r9,0x0,0x5
80013fb0:	f6 0a 00 0a 	add	r10,r11,r10
80013fb4:	e2 19 f8 00 	andl	r9,0xf800,COH
80013fb8:	f4 09 00 09 	add	r9,r10,r9
80013fbc:	10 b9       	st.h	r8++,r9
		while(gpio_get_pin_value(Arriba)==1);
		int R1,G1,B1;
		int Value1;
		U16 *puntero;
		puntero = RawImg;
		for (int i=0; i<76800;i++)
80013fbe:	18 38       	cp.w	r8,r12
80013fc0:	cf 11       	brne	80013fa2 <Negativos+0x86>
			G1=((~Value1)&GREEN);
			R1=((~Value1)&RED);
			*puntero=B1+G1+R1;
			puntero++;
		}
		et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
80013fc2:	e0 64 00 f0 	mov	r4,240
80013fc6:	1a d4       	st.w	--sp,r4
80013fc8:	e0 6b 01 40 	mov	r11,320
80013fcc:	1a db       	st.w	--sp,r11
80013fce:	30 07       	mov	r7,0
80013fd0:	1a d7       	st.w	--sp,r7
80013fd2:	0e 98       	mov	r8,r7
80013fd4:	0e 99       	mov	r9,r7
80013fd6:	0e 9a       	mov	r10,r7
80013fd8:	fe fc 03 5c 	ld.w	r12,pc[860]
80013fdc:	78 0c       	ld.w	r12,r12[0x0]
80013fde:	f0 1f 00 d7 	mcall	80014338 <Negativos+0x41c>
		char NEG[]="Negativo Activado";
80013fe2:	fe f8 03 5a 	ld.w	r8,pc[858]
80013fe6:	fa cc ff f4 	sub	r12,sp,-12
80013fea:	f0 ea 00 00 	ld.d	r10,r8[0]
80013fee:	f8 eb 00 00 	st.d	r12[0],r10
80013ff2:	f0 ea 00 08 	ld.d	r10,r8[8]
80013ff6:	f8 eb 00 08 	st.d	r12[8],r10
80013ffa:	f1 39 00 10 	ld.ub	r9,r8[16]
80013ffe:	f9 69 00 10 	st.b	r12[16],r9
80014002:	f1 38 00 11 	ld.ub	r8,r8[17]
80014006:	f9 68 00 11 	st.b	r12[17],r8
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
8001400a:	fe f3 03 36 	ld.w	r3,pc[822]
8001400e:	e0 65 ff ff 	mov	r5,65535
80014012:	1a d5       	st.w	--sp,r5
80014014:	0e 98       	mov	r8,r7
80014016:	e0 69 00 dc 	mov	r9,220
8001401a:	36 0a       	mov	r10,96
8001401c:	06 9b       	mov	r11,r3
8001401e:	f0 1f 00 ca 	mcall	80014344 <Negativos+0x428>
		char NEG2[]="NEGAR";
80014022:	fe f8 03 26 	ld.w	r8,pc[806]
80014026:	fa c6 ff b0 	sub	r6,sp,-80
8001402a:	70 09       	ld.w	r9,r8[0x0]
8001402c:	8d 09       	st.w	r6[0x0],r9
8001402e:	11 c9       	ld.ub	r9,r8[0x4]
80014030:	ac c9       	st.b	r6[0x4],r9
80014032:	11 d8       	ld.ub	r8,r8[0x5]
80014034:	ac d8       	st.b	r6[0x5],r8
		et024006_DrawFilledRect(240,0,80,40,WHITE);
80014036:	0a 98       	mov	r8,r5
80014038:	32 89       	mov	r9,40
8001403a:	35 0a       	mov	r10,80
8001403c:	0e 9b       	mov	r11,r7
8001403e:	08 9c       	mov	r12,r4
80014040:	f0 1f 00 c3 	mcall	8001434c <Negativos+0x430>
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
80014044:	1a d5       	st.w	--sp,r5
80014046:	0e 98       	mov	r8,r7
80014048:	31 09       	mov	r9,16
8001404a:	e0 6a 01 04 	mov	r10,260
8001404e:	06 9b       	mov	r11,r3
80014050:	0c 9c       	mov	r12,r6
80014052:	f0 1f 00 bd 	mcall	80014344 <Negativos+0x428>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80014056:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8001405a:	e0 6a e1 c0 	mov	r10,57792
8001405e:	ea 1a 00 e4 	orh	r10,0xe4
80014062:	f0 0a 00 0a 	add	r10,r8,r10
80014066:	2f bd       	sub	sp,-20
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80014068:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8001406c:	14 38       	cp.w	r8,r10
8001406e:	e0 88 00 09 	brls	80014080 <Negativos+0x164>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80014072:	12 38       	cp.w	r8,r9
80014074:	fe 98 ff fa 	brls	80014068 <Negativos+0x14c>
80014078:	12 3a       	cp.w	r10,r9
8001407a:	e0 83 01 43 	brlo	80014300 <Negativos+0x3e4>
8001407e:	cf 5b       	rjmp	80014068 <Negativos+0x14c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80014080:	12 38       	cp.w	r8,r9
80014082:	e0 8b 01 3f 	brhi	80014300 <Negativos+0x3e4>
80014086:	12 3a       	cp.w	r10,r9
80014088:	e0 83 01 3c 	brlo	80014300 <Negativos+0x3e4>
8001408c:	ce eb       	rjmp	80014068 <Negativos+0x14c>
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
	}
	else if(NegACT== true && X>96 && X<=232 && Y>220 && Y<=240 && xytot<filtro && busy==true && step==3)
8001408e:	58 08       	cp.w	r8,0
80014090:	e0 80 01 3f 	breq	8001430e <Negativos+0x3f2>
80014094:	e0 49 00 60 	cp.w	r9,96
80014098:	e0 8a 01 3b 	brle	8001430e <Negativos+0x3f2>
8001409c:	e0 49 00 e8 	cp.w	r9,232
800140a0:	e0 89 01 37 	brgt	8001430e <Negativos+0x3f2>
800140a4:	fe f8 02 78 	ld.w	r8,pc[632]
800140a8:	70 08       	ld.w	r8,r8[0x0]
800140aa:	e0 48 00 dc 	cp.w	r8,220
800140ae:	e0 8a 01 30 	brle	8001430e <Negativos+0x3f2>
800140b2:	e0 48 00 f0 	cp.w	r8,240
800140b6:	e0 89 01 2c 	brgt	8001430e <Negativos+0x3f2>
800140ba:	fe f8 02 66 	ld.w	r8,pc[614]
800140be:	70 08       	ld.w	r8,r8[0x0]
800140c0:	58 28       	cp.w	r8,2
800140c2:	e0 89 01 26 	brgt	8001430e <Negativos+0x3f2>
800140c6:	fe f8 02 5e 	ld.w	r8,pc[606]
800140ca:	11 89       	ld.ub	r9,r8[0x0]
800140cc:	30 08       	mov	r8,0
800140ce:	f0 09 18 00 	cp.b	r9,r8
800140d2:	e0 80 01 1e 	breq	8001430e <Negativos+0x3f2>
800140d6:	fe f8 02 52 	ld.w	r8,pc[594]
800140da:	11 89       	ld.ub	r9,r8[0x0]
800140dc:	30 38       	mov	r8,3
800140de:	f0 09 18 00 	cp.b	r9,r8
800140e2:	e0 81 01 16 	brne	8001430e <Negativos+0x3f2>
	{
		NegACT=false;
800140e6:	30 09       	mov	r9,0
800140e8:	fe f8 02 2c 	ld.w	r8,pc[556]
800140ec:	b0 89       	st.b	r8[0x0],r9
gpio_clr_gpio_pin(LED0_GPIO);
800140ee:	33 bc       	mov	r12,59
800140f0:	f0 1f 00 8f 	mcall	8001432c <Negativos+0x410>
et024006_PutPixmap(RawImg, 320, 0, 0, 0,0, 320, 240);
800140f4:	e0 62 00 f0 	mov	r2,240
800140f8:	1a d2       	st.w	--sp,r2
800140fa:	e0 6b 01 40 	mov	r11,320
800140fe:	1a db       	st.w	--sp,r11
80014100:	30 06       	mov	r6,0
80014102:	1a d6       	st.w	--sp,r6
80014104:	0c 98       	mov	r8,r6
80014106:	0c 99       	mov	r9,r6
80014108:	0c 9a       	mov	r10,r6
8001410a:	fe fc 02 2a 	ld.w	r12,pc[554]
8001410e:	78 0c       	ld.w	r12,r12[0x0]
80014110:	f0 1f 00 8a 	mcall	80014338 <Negativos+0x41c>
char brillo[]="Brillo";
80014114:	fe f8 02 3c 	ld.w	r8,pc[572]
80014118:	fa c4 ff c4 	sub	r4,sp,-60
8001411c:	70 09       	ld.w	r9,r8[0x0]
8001411e:	89 09       	st.w	r4[0x0],r9
80014120:	11 c9       	ld.ub	r9,r8[0x4]
80014122:	a8 c9       	st.b	r4[0x4],r9
80014124:	11 d9       	ld.ub	r9,r8[0x5]
80014126:	a8 d9       	st.b	r4[0x5],r9
80014128:	11 e8       	ld.ub	r8,r8[0x6]
8001412a:	a8 e8       	st.b	r4[0x6],r8
char Negativo[]="Negativo";
8001412c:	fe f8 02 28 	ld.w	r8,pc[552]
80014130:	fa c3 ff e0 	sub	r3,sp,-32
80014134:	f0 ea 00 00 	ld.d	r10,r8[0]
80014138:	e6 eb 00 00 	st.d	r3[0],r10
8001413c:	f1 38 00 08 	ld.ub	r8,r8[8]
80014140:	e7 68 00 08 	st.b	r3[8],r8
char BlNe[]="B/N";
80014144:	e0 68 4e 00 	mov	r8,19968
80014148:	ea 18 42 2f 	orh	r8,0x422f
8001414c:	51 58       	stdsp	sp[0x54],r8
char dila[]="Dilatar";
8001414e:	e0 68 72 00 	mov	r8,29184
80014152:	ea 18 74 61 	orh	r8,0x7461
80014156:	e0 69 6c 61 	mov	r9,27745
8001415a:	ea 19 44 69 	orh	r9,0x4469
8001415e:	fa e9 00 34 	st.d	sp[52],r8
et024006_DrawFilledRect(20,20,80,20,WHITE);
80014162:	e0 68 ff ff 	mov	r8,65535
80014166:	31 49       	mov	r9,20
80014168:	35 0a       	mov	r10,80
8001416a:	12 9b       	mov	r11,r9
8001416c:	12 9c       	mov	r12,r9
8001416e:	f0 1f 00 78 	mcall	8001434c <Negativos+0x430>
et024006_PrintString(brillo,(const unsigned char *)&FONT8x16,20,20,BLACK,WHITE);
80014172:	4f 45       	lddpc	r5,80014340 <Negativos+0x424>
80014174:	e0 67 ff ff 	mov	r7,65535
80014178:	1a d7       	st.w	--sp,r7
8001417a:	0c 98       	mov	r8,r6
8001417c:	31 49       	mov	r9,20
8001417e:	12 9a       	mov	r10,r9
80014180:	0a 9b       	mov	r11,r5
80014182:	08 9c       	mov	r12,r4
80014184:	f0 1f 00 70 	mcall	80014344 <Negativos+0x428>
et024006_DrawFilledRect(20,50,80,20,WHITE);
80014188:	0e 98       	mov	r8,r7
8001418a:	31 49       	mov	r9,20
8001418c:	35 0a       	mov	r10,80
8001418e:	33 2b       	mov	r11,50
80014190:	12 9c       	mov	r12,r9
80014192:	f0 1f 00 6f 	mcall	8001434c <Negativos+0x430>
et024006_PrintString(Negativo,(const unsigned char *)&FONT8x16,20,50,BLACK,WHITE);
80014196:	1a d7       	st.w	--sp,r7
80014198:	0c 98       	mov	r8,r6
8001419a:	33 29       	mov	r9,50
8001419c:	31 4a       	mov	r10,20
8001419e:	0a 9b       	mov	r11,r5
800141a0:	06 9c       	mov	r12,r3
800141a2:	f0 1f 00 69 	mcall	80014344 <Negativos+0x428>
et024006_DrawFilledRect(20,80,80,20,WHITE);
800141a6:	0e 98       	mov	r8,r7
800141a8:	31 49       	mov	r9,20
800141aa:	35 0a       	mov	r10,80
800141ac:	14 9b       	mov	r11,r10
800141ae:	12 9c       	mov	r12,r9
800141b0:	f0 1f 00 67 	mcall	8001434c <Negativos+0x430>
et024006_PrintString(BlNe,(const unsigned char *)&FONT8x16,20,80,BLACK,WHITE);
800141b4:	1a d7       	st.w	--sp,r7
800141b6:	0c 98       	mov	r8,r6
800141b8:	35 09       	mov	r9,80
800141ba:	31 4a       	mov	r10,20
800141bc:	0a 9b       	mov	r11,r5
800141be:	fa cc ff a0 	sub	r12,sp,-96
800141c2:	f0 1f 00 61 	mcall	80014344 <Negativos+0x428>
et024006_DrawFilledRect(20,110,80,20,WHITE);
800141c6:	0e 98       	mov	r8,r7
800141c8:	31 49       	mov	r9,20
800141ca:	35 0a       	mov	r10,80
800141cc:	36 eb       	mov	r11,110
800141ce:	12 9c       	mov	r12,r9
800141d0:	f0 1f 00 5f 	mcall	8001434c <Negativos+0x430>
char AutoFiltro[]="AutoFiltro";
800141d4:	4e 18       	lddpc	r8,80014358 <Negativos+0x43c>
800141d6:	fa cc ff e8 	sub	r12,sp,-24
800141da:	f0 ea 00 00 	ld.d	r10,r8[0]
800141de:	f8 eb 00 00 	st.d	r12[0],r10
800141e2:	f1 39 00 08 	ld.ub	r9,r8[8]
800141e6:	f9 69 00 08 	st.b	r12[8],r9
800141ea:	f1 39 00 09 	ld.ub	r9,r8[9]
800141ee:	f9 69 00 09 	st.b	r12[9],r9
800141f2:	f1 38 00 0a 	ld.ub	r8,r8[10]
800141f6:	f9 68 00 0a 	st.b	r12[10],r8
et024006_PrintString(AutoFiltro,(const unsigned char *)&FONT8x16,20,110,BLACK,WHITE);
800141fa:	1a d7       	st.w	--sp,r7
800141fc:	0c 98       	mov	r8,r6
800141fe:	36 e9       	mov	r9,110
80014200:	31 4a       	mov	r10,20
80014202:	0a 9b       	mov	r11,r5
80014204:	f0 1f 00 50 	mcall	80014344 <Negativos+0x428>
et024006_DrawFilledRect(20,140,80,20,WHITE);
80014208:	0e 98       	mov	r8,r7
8001420a:	31 49       	mov	r9,20
8001420c:	35 0a       	mov	r10,80
8001420e:	e0 6b 00 8c 	mov	r11,140
80014212:	12 9c       	mov	r12,r9
80014214:	f0 1f 00 4e 	mcall	8001434c <Negativos+0x430>
et024006_PrintString(dila,(const unsigned char *)&FONT8x16,20,140,BLACK,WHITE);
80014218:	1a d7       	st.w	--sp,r7
8001421a:	0c 98       	mov	r8,r6
8001421c:	e0 69 00 8c 	mov	r9,140
80014220:	31 4a       	mov	r10,20
80014222:	0a 9b       	mov	r11,r5
80014224:	fa cc ff b8 	sub	r12,sp,-72
80014228:	f0 1f 00 47 	mcall	80014344 <Negativos+0x428>
et024006_DrawFilledRect(20,170,80,20,WHITE);
8001422c:	2f 8d       	sub	sp,-32
8001422e:	0e 98       	mov	r8,r7
80014230:	31 49       	mov	r9,20
80014232:	35 0a       	mov	r10,80
80014234:	e0 6b 00 aa 	mov	r11,170
80014238:	12 9c       	mov	r12,r9
8001423a:	f0 1f 00 45 	mcall	8001434c <Negativos+0x430>
et024006_DrawFilledRect(20,200,80,20,WHITE);
8001423e:	0e 98       	mov	r8,r7
80014240:	31 49       	mov	r9,20
80014242:	35 0a       	mov	r10,80
80014244:	e0 6b 00 c8 	mov	r11,200
80014248:	12 9c       	mov	r12,r9
8001424a:	f0 1f 00 41 	mcall	8001434c <Negativos+0x430>
char Eros[]="Erosion";
8001424e:	e0 68 6e 00 	mov	r8,28160
80014252:	ea 18 69 6f 	orh	r8,0x696f
80014256:	e0 69 6f 73 	mov	r9,28531
8001425a:	ea 19 45 72 	orh	r9,0x4572
8001425e:	fa e9 00 20 	st.d	sp[32],r8
et024006_PrintString(Eros,(const unsigned char *)&FONT8x16,20,200,BLACK,WHITE);
80014262:	1a d7       	st.w	--sp,r7
80014264:	0c 98       	mov	r8,r6
80014266:	e0 69 00 c8 	mov	r9,200
8001426a:	31 4a       	mov	r10,20
8001426c:	0a 9b       	mov	r11,r5
8001426e:	fa cc ff dc 	sub	r12,sp,-36
80014272:	f0 1f 00 35 	mcall	80014344 <Negativos+0x428>
char BlNs[]="Blur";
80014276:	4b a8       	lddpc	r8,8001435c <Negativos+0x440>
80014278:	fa cc ff bc 	sub	r12,sp,-68
8001427c:	70 09       	ld.w	r9,r8[0x0]
8001427e:	99 09       	st.w	r12[0x0],r9
80014280:	11 c8       	ld.ub	r8,r8[0x4]
80014282:	b8 c8       	st.b	r12[0x4],r8
et024006_PrintString(BlNs,(const unsigned char *)&FONT8x16,20,170,BLACK,WHITE);
80014284:	1a d7       	st.w	--sp,r7
80014286:	0c 98       	mov	r8,r6
80014288:	e0 69 00 aa 	mov	r9,170
8001428c:	31 4a       	mov	r10,20
8001428e:	0a 9b       	mov	r11,r5
80014290:	f0 1f 00 2d 	mcall	80014344 <Negativos+0x428>
char Exit[]="SALIR";
80014294:	4b 38       	lddpc	r8,80014360 <Negativos+0x444>
80014296:	fa c4 ff c0 	sub	r4,sp,-64
8001429a:	70 09       	ld.w	r9,r8[0x0]
8001429c:	89 09       	st.w	r4[0x0],r9
8001429e:	11 c9       	ld.ub	r9,r8[0x4]
800142a0:	a8 c9       	st.b	r4[0x4],r9
800142a2:	11 d8       	ld.ub	r8,r8[0x5]
800142a4:	a8 d8       	st.b	r4[0x5],r8
et024006_DrawFilledRect(240,0,80,40,WHITE);
800142a6:	0e 98       	mov	r8,r7
800142a8:	32 89       	mov	r9,40
800142aa:	35 0a       	mov	r10,80
800142ac:	0c 9b       	mov	r11,r6
800142ae:	04 9c       	mov	r12,r2
800142b0:	f0 1f 00 27 	mcall	8001434c <Negativos+0x430>
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
800142b4:	1a d7       	st.w	--sp,r7
800142b6:	0c 98       	mov	r8,r6
800142b8:	31 09       	mov	r9,16
800142ba:	e0 6a 01 04 	mov	r10,260
800142be:	0a 9b       	mov	r11,r5
800142c0:	08 9c       	mov	r12,r4
800142c2:	f0 1f 00 21 	mcall	80014344 <Negativos+0x428>
step=2;
800142c6:	30 29       	mov	r9,2
800142c8:	49 88       	lddpc	r8,80014328 <Negativos+0x40c>
800142ca:	b0 89       	st.b	r8[0x0],r9
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800142cc:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800142d0:	e0 6a e1 c0 	mov	r10,57792
800142d4:	ea 1a 00 e4 	orh	r10,0xe4
800142d8:	f0 0a 00 0a 	add	r10,r8,r10
800142dc:	2f dd       	sub	sp,-12
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800142de:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800142e2:	14 38       	cp.w	r8,r10
800142e4:	e0 88 00 08 	brls	800142f4 <Negativos+0x3d8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800142e8:	12 38       	cp.w	r8,r9
800142ea:	fe 98 ff fa 	brls	800142de <Negativos+0x3c2>
800142ee:	12 3a       	cp.w	r10,r9
800142f0:	c0 c3       	brcs	80014308 <Negativos+0x3ec>
800142f2:	cf 6b       	rjmp	800142de <Negativos+0x3c2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800142f4:	12 38       	cp.w	r8,r9
800142f6:	e0 8b 00 09 	brhi	80014308 <Negativos+0x3ec>
800142fa:	12 3a       	cp.w	r10,r9
800142fc:	c0 63       	brcs	80014308 <Negativos+0x3ec>
800142fe:	cf 0b       	rjmp	800142de <Negativos+0x3c2>
		et024006_PrintString(NEG,(const unsigned char *)&FONT8x16,96,220,BLACK,WHITE);
		char NEG2[]="NEGAR";
		et024006_DrawFilledRect(240,0,80,40,WHITE);
		et024006_PrintString(NEG2,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
		delay_ms(250);
		gpio_set_gpio_pin(LED0_GPIO);
80014300:	33 bc       	mov	r12,59
80014302:	f0 1f 00 19 	mcall	80014364 <Negativos+0x448>
	
	
}
void Negativos (void)
{
	if(NegACT == true && X>240 && X<=320 && Y>0 && Y<=40 && xytot<filtro && busy==true && step==3)
80014306:	c0 48       	rjmp	8001430e <Negativos+0x3f2>
char Exit[]="SALIR";
et024006_DrawFilledRect(240,0,80,40,WHITE);
et024006_PrintString(Exit,(const unsigned char *)&FONT8x16,260,16,BLACK,WHITE);
step=2;
delay_ms(250);
gpio_set_gpio_pin(LED0_GPIO);
80014308:	33 bc       	mov	r12,59
8001430a:	f0 1f 00 17 	mcall	80014364 <Negativos+0x448>
	}
}
8001430e:	2e dd       	sub	sp,-76
80014310:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80014314:	00 00       	add	r0,r0
80014316:	06 8b       	andn	r11,r3
80014318:	00 00       	add	r0,r0
8001431a:	07 70       	ld.ub	r0,--r3
8001431c:	00 00       	add	r0,r0
8001431e:	07 74       	ld.ub	r4,--r3
80014320:	00 00       	add	r0,r0
80014322:	07 5c       	ld.sh	r12,--r3
80014324:	00 00       	add	r0,r0
80014326:	07 63       	ld.uh	r3,--r3
80014328:	00 00       	add	r0,r0
8001432a:	07 60       	ld.uh	r0,--r3
8001432c:	80 00       	ld.sh	r0,r0[0x0]
8001432e:	6c 7e       	ld.w	lr,r6[0x1c]
80014330:	80 00       	ld.sh	r0,r0[0x0]
80014332:	6c 4c       	ld.w	r12,r6[0x10]
80014334:	00 00       	add	r0,r0
80014336:	0d 28       	ld.uh	r8,r6++
80014338:	80 00       	ld.sh	r0,r0[0x0]
8001433a:	63 3c       	ld.w	r12,r1[0x4c]
8001433c:	80 01       	ld.sh	r1,r0[0x0]
8001433e:	ff 24 80 01 	ld.sb	r4,pc[-32767]
80014342:	dc 90       	acall	0xc9
80014344:	80 00       	ld.sh	r0,r0[0x0]
80014346:	60 18       	ld.w	r8,r0[0x4]
80014348:	80 01       	ld.sh	r1,r0[0x0]
8001434a:	ff 38 80 00 	ld.ub	r8,pc[-32768]
8001434e:	62 94       	ld.w	r4,r1[0x24]
80014350:	80 01       	ld.sh	r1,r0[0x0]
80014352:	fe 70 80 01 	mov	r0,-32767
80014356:	fe 78 80 01 	mov	r8,-32767
8001435a:	fe 84 80 01 	brge	7ffe435c <__heap_size__+0x7dfe435c>
8001435e:	fe 90 80 01 	breq	80004360 <memory_2_ram+0x18>
80014362:	fe 98 80 00 	brls	80004362 <memory_2_ram+0x1a>
80014366:	6c 62       	ld.w	r2,r6[0x18]

80014368 <tc_irq>:
void Blur (void);
void Erosion (void);

__attribute__((__interrupt__))
static void tc_irq(void)
{
80014368:	d4 01       	pushm	lr
	get_XY();
8001436a:	f0 1f 00 10 	mcall	800143a8 <tc_irq+0x40>
	filtro_movil();
8001436e:	f0 1f 00 10 	mcall	800143ac <tc_irq+0x44>
	imgcheck1();
80014372:	f0 1f 00 10 	mcall	800143b0 <tc_irq+0x48>
	imgcheck2();
80014376:	f0 1f 00 10 	mcall	800143b4 <tc_irq+0x4c>
	imgcheck3();
8001437a:	f0 1f 00 10 	mcall	800143b8 <tc_irq+0x50>
	imgcheck4();
8001437e:	f0 1f 00 10 	mcall	800143bc <tc_irq+0x54>
	// Filtros Menu
	MenuFiltros();
80014382:	f0 1f 00 10 	mcall	800143c0 <tc_irq+0x58>
	// Filtros
	Brillo();
80014386:	f0 1f 00 10 	mcall	800143c4 <tc_irq+0x5c>
	Negativos();
8001438a:	f0 1f 00 10 	mcall	800143c8 <tc_irq+0x60>
	BlancoNegro();
8001438e:	f0 1f 00 10 	mcall	800143cc <tc_irq+0x64>
	Autofilto();
80014392:	f0 1f 00 10 	mcall	800143d0 <tc_irq+0x68>
	Dilatar();
80014396:	f0 1f 00 10 	mcall	800143d4 <tc_irq+0x6c>
	Blur();
8001439a:	f0 1f 00 10 	mcall	800143d8 <tc_irq+0x70>
	Erosion();
8001439e:	f0 1f 00 10 	mcall	800143dc <tc_irq+0x74>
}
800143a2:	d4 02       	popm	lr
800143a4:	d6 03       	rete
800143a6:	00 00       	add	r0,r0
800143a8:	80 01       	ld.sh	r1,r0[0x0]
800143aa:	01 d4       	ld.ub	r4,r0[0x5]
800143ac:	80 00       	ld.sh	r0,r0[0x0]
800143ae:	fd 7c 80 01 	stcond	lr[-32767],r12
800143b2:	10 cc       	st.b	r8++,r12
800143b4:	80 01       	ld.sh	r1,r0[0x0]
800143b6:	0e 14       	sub	r4,r7
800143b8:	80 01       	ld.sh	r1,r0[0x0]
800143ba:	0b 5c       	ld.sh	r12,--r5
800143bc:	80 01       	ld.sh	r1,r0[0x0]
800143be:	08 e4       	st.h	--r4,r4
800143c0:	80 01       	ld.sh	r1,r0[0x0]
800143c2:	2c ac       	sub	r12,-54
800143c4:	80 01       	ld.sh	r1,r0[0x0]
800143c6:	3a 80       	mov	r0,-88
800143c8:	80 01       	ld.sh	r1,r0[0x0]
800143ca:	3f 1c       	mov	r12,-15
800143cc:	80 01       	ld.sh	r1,r0[0x0]
800143ce:	19 04       	ld.w	r4,r12++
800143d0:	80 01       	ld.sh	r1,r0[0x0]
800143d2:	27 fc       	sub	r12,127
800143d4:	80 01       	ld.sh	r1,r0[0x0]
800143d6:	13 7c       	ld.ub	r12,--r9
800143d8:	80 01       	ld.sh	r1,r0[0x0]
800143da:	1d 40       	ld.w	r0,--lr
800143dc:	80 01       	ld.sh	r1,r0[0x0]
800143de:	22 9c       	sub	r12,41

800143e0 <main>:
	gpio_set_gpio_pin(LED0_GPIO);
}


int main(void)
{
800143e0:	eb cd 40 c0 	pushm	r6-r7,lr
800143e4:	20 4d       	sub	sp,16
	pcl_configure_clocks(&pcl_freq_param);
800143e6:	4c 47       	lddpc	r7,800144f4 <main+0x114>
800143e8:	0e 9c       	mov	r12,r7
800143ea:	f0 1f 00 44 	mcall	800144f8 <main+0x118>
	et024006_Init( pcl_freq_param.cpu_f, pcl_freq_param.cpu_f );
800143ee:	6e 0c       	ld.w	r12,r7[0x0]
800143f0:	18 9b       	mov	r11,r12
800143f2:	f0 1f 00 43 	mcall	800144fc <main+0x11c>
	gpio_enable_gpio_pin(LED0_GPIO);
800143f6:	33 bc       	mov	r12,59
800143f8:	f0 1f 00 42 	mcall	80014500 <main+0x120>
	gpio_enable_gpio_pin(LED1_GPIO);
800143fc:	33 cc       	mov	r12,60
800143fe:	f0 1f 00 41 	mcall	80014500 <main+0x120>
	gpio_enable_gpio_pin(LED2_GPIO);
80014402:	30 5c       	mov	r12,5
80014404:	f0 1f 00 3f 	mcall	80014500 <main+0x120>
	gpio_enable_gpio_pin(LED3_GPIO);
80014408:	30 6c       	mov	r12,6
8001440a:	f0 1f 00 3e 	mcall	80014500 <main+0x120>
	gpio_set_gpio_pin(LED0_GPIO);
8001440e:	33 bc       	mov	r12,59
80014410:	f0 1f 00 3d 	mcall	80014504 <main+0x124>
	gpio_set_gpio_pin(LED1_GPIO);
80014414:	33 cc       	mov	r12,60
80014416:	f0 1f 00 3c 	mcall	80014504 <main+0x124>
	gpio_set_gpio_pin(LED2_GPIO);
8001441a:	30 5c       	mov	r12,5
8001441c:	f0 1f 00 3a 	mcall	80014504 <main+0x124>
	gpio_set_gpio_pin(LED3_GPIO);
80014420:	30 6c       	mov	r12,6
80014422:	f0 1f 00 39 	mcall	80014504 <main+0x124>
	init_dbg_rs232(pcl_freq_param.pba_f);
80014426:	6e 1c       	ld.w	r12,r7[0x4]
80014428:	f0 1f 00 38 	mcall	80014508 <main+0x128>
	sdramc_init(pcl_freq_param.cpu_f);
8001442c:	6e 0c       	ld.w	r12,r7[0x0]
8001442e:	f0 1f 00 38 	mcall	8001450c <main+0x12c>
	gpio_enable_module(ADC_GPIO_MAP, sizeof(ADC_GPIO_MAP) / sizeof(ADC_GPIO_MAP[0]));
80014432:	30 2b       	mov	r11,2
80014434:	4b 7c       	lddpc	r12,80014510 <main+0x130>
80014436:	f0 1f 00 38 	mcall	80014514 <main+0x134>

	// SPI options.
	spi_options_t spiOptions =
	{
		.reg          = 1,
		.baudrate     = pcl_freq_param.pba_f,  // Defined in conf_sd_mmc_spi.h.
8001443a:	6e 19       	ld.w	r9,r7[0x4]
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8001443c:	30 18       	mov	r8,1
8001443e:	ba 88       	st.b	sp[0x0],r8
80014440:	50 19       	stdsp	sp[0x4],r9
80014442:	30 89       	mov	r9,8
80014444:	fb 69 00 08 	st.b	sp[8],r9
80014448:	30 09       	mov	r9,0
8001444a:	fb 69 00 09 	st.b	sp[9],r9
8001444e:	fb 69 00 0a 	st.b	sp[10],r9
80014452:	fb 68 00 0b 	st.b	sp[11],r8
80014456:	fb 69 00 0c 	st.b	sp[12],r9
8001445a:	fb 68 00 0d 	st.b	sp[13],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
8001445e:	30 4b       	mov	r11,4
80014460:	4a ec       	lddpc	r12,80014518 <main+0x138>
80014462:	f0 1f 00 2d 	mcall	80014514 <main+0x134>
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
80014466:	1a 96       	mov	r6,sp
80014468:	1a 9b       	mov	r11,sp
8001446a:	fe 7c 24 00 	mov	r12,-56320
8001446e:	f0 1f 00 2c 	mcall	8001451c <main+0x13c>

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
80014472:	30 09       	mov	r9,0
80014474:	12 9a       	mov	r10,r9
80014476:	12 9b       	mov	r11,r9
80014478:	fe 7c 24 00 	mov	r12,-56320
8001447c:	f0 1f 00 29 	mcall	80014520 <main+0x140>

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
80014480:	fe 7c 24 00 	mov	r12,-56320
80014484:	f0 1f 00 28 	mcall	80014524 <main+0x144>

	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, pcl_freq_param.pba_f);
80014488:	6e 1c       	ld.w	r12,r7[0x4]
8001448a:	20 4d       	sub	sp,16
8001448c:	ec e8 00 00 	ld.d	r8,r6[0]
80014490:	fa e9 00 00 	st.d	sp[0],r8
80014494:	ec e8 00 08 	ld.d	r8,r6[8]
80014498:	fa e9 00 08 	st.d	sp[8],r8
8001449c:	f0 1f 00 23 	mcall	80014528 <main+0x148>
800144a0:	2f cd       	sub	sp,-16
	gpio_set_gpio_pin(LED3_GPIO);
	init_dbg_rs232(pcl_freq_param.pba_f);
	sdramc_init(pcl_freq_param.cpu_f);
	gpio_enable_module(ADC_GPIO_MAP, sizeof(ADC_GPIO_MAP) / sizeof(ADC_GPIO_MAP[0]));
	sd_mmc_resources_init();
	while (!sd_mmc_spi_mem_check());
800144a2:	f0 1f 00 23 	mcall	8001452c <main+0x14c>
800144a6:	cf e0       	breq	800144a2 <main+0xc2>
	InicializarFiles();
800144a8:	f0 1f 00 22 	mcall	80014530 <main+0x150>
	InicializarFondo();
800144ac:	f0 1f 00 22 	mcall	80014534 <main+0x154>
	Pantalla();
800144b0:	f0 1f 00 22 	mcall	80014538 <main+0x158>
	Luces();
800144b4:	f0 1f 00 22 	mcall	8001453c <main+0x15c>
	Disable_global_interrupt();
800144b8:	d3 03       	ssrf	0x10
	// Habilitamos las interrupciones del
	INTC_init_interrupts();		
800144ba:	f0 1f 00 22 	mcall	80014540 <main+0x160>
	INTC_register_interrupt(&touch2,71, 1); 
800144be:	30 1a       	mov	r10,1
800144c0:	34 7b       	mov	r11,71
800144c2:	4a 1c       	lddpc	r12,80014544 <main+0x164>
800144c4:	f0 1f 00 21 	mcall	80014548 <main+0x168>
	INTC_register_interrupt(&tc_irq, AVR32_TC_IRQ0, AVR32_INTC_INT0);
800144c8:	30 0a       	mov	r10,0
800144ca:	e0 6b 01 c0 	mov	r11,448
800144ce:	4a 0c       	lddpc	r12,8001454c <main+0x16c>
800144d0:	f0 1f 00 1e 	mcall	80014548 <main+0x168>
	gpio_enable_pin_interrupt(Derecha,	GPIO_FALLING_EDGE);
800144d4:	30 2b       	mov	r11,2
800144d6:	33 8c       	mov	r12,56
800144d8:	f0 1f 00 1e 	mcall	80014550 <main+0x170>
	gpio_enable_pin_interrupt(Izquierda,GPIO_FALLING_EDGE);
800144dc:	30 2b       	mov	r11,2
800144de:	33 9c       	mov	r12,57
800144e0:	f0 1f 00 1c 	mcall	80014550 <main+0x170>
	gpio_enable_pin_interrupt(Enter,	GPIO_FALLING_EDGE);
800144e4:	30 2b       	mov	r11,2
800144e6:	33 ac       	mov	r12,58
800144e8:	f0 1f 00 1a 	mcall	80014550 <main+0x170>
	Timersetup();
800144ec:	f0 1f 00 1a 	mcall	80014554 <main+0x174>
	Enable_global_interrupt();
800144f0:	d5 03       	csrf	0x10
800144f2:	c0 08       	rjmp	800144f2 <main+0x112>
800144f4:	00 00       	add	r0,r0
800144f6:	00 1c       	sub	r12,r0
800144f8:	80 00       	ld.sh	r0,r0[0x0]
800144fa:	71 5c       	ld.w	r12,r8[0x54]
800144fc:	80 00       	ld.sh	r0,r0[0x0]
800144fe:	64 54       	ld.w	r4,r2[0x14]
80014500:	80 00       	ld.sh	r0,r0[0x0]
80014502:	6c 34       	ld.w	r4,r6[0xc]
80014504:	80 00       	ld.sh	r0,r0[0x0]
80014506:	6c 62       	ld.w	r2,r6[0x18]
80014508:	80 00       	ld.sh	r0,r0[0x0]
8001450a:	74 34       	ld.w	r4,r10[0xc]
8001450c:	80 00       	ld.sh	r0,r0[0x0]
8001450e:	69 1c       	ld.w	r12,r4[0x44]
80014510:	80 01       	ld.sh	r1,r0[0x0]
80014512:	fd fc 80 00 	ld.wls	r12,lr[0x0]
80014516:	6c 04       	ld.w	r4,r6[0x0]
80014518:	80 01       	ld.sh	r1,r0[0x0]
8001451a:	fd 98       	*unknown*
8001451c:	80 00       	ld.sh	r0,r0[0x0]
8001451e:	2b f8       	sub	r8,-65
80014520:	80 00       	ld.sh	r0,r0[0x0]
80014522:	2c 30       	sub	r0,-61
80014524:	80 00       	ld.sh	r0,r0[0x0]
80014526:	2d 88       	sub	r8,-40
80014528:	80 00       	ld.sh	r0,r0[0x0]
8001452a:	2b 10       	sub	r0,-79
8001452c:	80 00       	ld.sh	r0,r0[0x0]
8001452e:	2a e8       	sub	r8,-82
80014530:	80 01       	ld.sh	r1,r0[0x0]
80014532:	04 60       	and	r0,r2
80014534:	80 01       	ld.sh	r1,r0[0x0]
80014536:	06 f4       	st.b	--r3,r4
80014538:	80 01       	ld.sh	r1,r0[0x0]
8001453a:	04 e8       	st.h	--r2,r8
8001453c:	80 00       	ld.sh	r0,r0[0x0]
8001453e:	fe e8 80 00 	ld.d	r8,pc[-32768]
80014542:	6d ac       	ld.w	r12,r6[0x68]
80014544:	80 01       	ld.sh	r1,r0[0x0]
80014546:	45 58       	lddsp	r8,sp[0x154]
80014548:	80 00       	ld.sh	r0,r0[0x0]
8001454a:	6d 2c       	ld.w	r12,r6[0x48]
8001454c:	80 01       	ld.sh	r1,r0[0x0]
8001454e:	43 68       	lddsp	r8,sp[0xd8]
80014550:	80 00       	ld.sh	r0,r0[0x0]
80014552:	6c b6       	ld.w	r6,r6[0x2c]
80014554:	80 00       	ld.sh	r0,r0[0x0]
80014556:	fe bc       	*unknown*

80014558 <touch2>:
}

__attribute__ ((__interrupt__))

void touch2 (void)
{
80014558:	d4 01       	pushm	lr
	gpio_clr_gpio_pin(LED0_GPIO);
8001455a:	33 bc       	mov	r12,59
8001455c:	f0 1f 00 44 	mcall	8001466c <touch2+0x114>
	if(gpio_get_pin_interrupt_flag (Derecha)==1)
80014560:	33 8c       	mov	r12,56
80014562:	f0 1f 00 44 	mcall	80014670 <touch2+0x118>
80014566:	c2 10       	breq	800145a8 <touch2+0x50>
	{
		BrilloACT=false;
80014568:	30 08       	mov	r8,0
8001456a:	4c 39       	lddpc	r9,80014674 <touch2+0x11c>
8001456c:	b2 88       	st.b	r9[0x0],r8
		NegACT=false;
8001456e:	4c 39       	lddpc	r9,80014678 <touch2+0x120>
80014570:	b2 88       	st.b	r9[0x0],r8
		BNACT=false;
80014572:	4c 39       	lddpc	r9,8001467c <touch2+0x124>
80014574:	b2 88       	st.b	r9[0x0],r8
		AutoFiltroACT=false;
80014576:	4c 39       	lddpc	r9,80014680 <touch2+0x128>
80014578:	b2 88       	st.b	r9[0x0],r8
		dilatar=false;
8001457a:	4c 39       	lddpc	r9,80014684 <touch2+0x12c>
8001457c:	b2 88       	st.b	r9[0x0],r8
		eros=false;
8001457e:	4c 39       	lddpc	r9,80014688 <touch2+0x130>
80014580:	b2 88       	st.b	r9[0x0],r8
		blur=false;
80014582:	4c 39       	lddpc	r9,8001468c <touch2+0x134>
80014584:	b2 88       	st.b	r9[0x0],r8
		step=0;
80014586:	4c 39       	lddpc	r9,80014690 <touch2+0x138>
80014588:	b2 88       	st.b	r9[0x0],r8
		busy=false;
8001458a:	4c 39       	lddpc	r9,80014694 <touch2+0x13c>
8001458c:	b2 88       	st.b	r9[0x0],r8
	entrada=true;
8001458e:	30 19       	mov	r9,1
80014590:	4c 28       	lddpc	r8,80014698 <touch2+0x140>
80014592:	b0 89       	st.b	r8[0x0],r9
	forzada++;
80014594:	4c 29       	lddpc	r9,8001469c <touch2+0x144>
80014596:	72 08       	ld.w	r8,r9[0x0]
80014598:	2f f8       	sub	r8,-1
8001459a:	93 08       	st.w	r9[0x0],r8
	if (forzada>4)
8001459c:	58 48       	cp.w	r8,4
8001459e:	e0 8a 00 05 	brle	800145a8 <touch2+0x50>
	{
		forzada=1;
800145a2:	30 19       	mov	r9,1
800145a4:	4b e8       	lddpc	r8,8001469c <touch2+0x144>
800145a6:	91 09       	st.w	r8[0x0],r9
	}
	}
	gpio_clear_pin_interrupt_flag(Derecha);
800145a8:	33 8c       	mov	r12,56
800145aa:	f0 1f 00 3e 	mcall	800146a0 <touch2+0x148>
	if(gpio_get_pin_interrupt_flag (Izquierda)==1)
800145ae:	33 9c       	mov	r12,57
800145b0:	f0 1f 00 30 	mcall	80014670 <touch2+0x118>
800145b4:	c2 10       	breq	800145f6 <touch2+0x9e>
	{
		entrada=true;
800145b6:	30 19       	mov	r9,1
800145b8:	4b 88       	lddpc	r8,80014698 <touch2+0x140>
800145ba:	b0 89       	st.b	r8[0x0],r9
		BrilloACT=false;
800145bc:	30 08       	mov	r8,0
800145be:	4a e9       	lddpc	r9,80014674 <touch2+0x11c>
800145c0:	b2 88       	st.b	r9[0x0],r8
		NegACT=false;
800145c2:	4a e9       	lddpc	r9,80014678 <touch2+0x120>
800145c4:	b2 88       	st.b	r9[0x0],r8
		BNACT=false;
800145c6:	4a e9       	lddpc	r9,8001467c <touch2+0x124>
800145c8:	b2 88       	st.b	r9[0x0],r8
		AutoFiltroACT=false;
800145ca:	4a e9       	lddpc	r9,80014680 <touch2+0x128>
800145cc:	b2 88       	st.b	r9[0x0],r8
		dilatar=false;
800145ce:	4a e9       	lddpc	r9,80014684 <touch2+0x12c>
800145d0:	b2 88       	st.b	r9[0x0],r8
		eros=false;
800145d2:	4a e9       	lddpc	r9,80014688 <touch2+0x130>
800145d4:	b2 88       	st.b	r9[0x0],r8
		blur=false;
800145d6:	4a e9       	lddpc	r9,8001468c <touch2+0x134>
800145d8:	b2 88       	st.b	r9[0x0],r8
		step=0;
800145da:	4a e9       	lddpc	r9,80014690 <touch2+0x138>
800145dc:	b2 88       	st.b	r9[0x0],r8
		busy=false;
800145de:	4a e9       	lddpc	r9,80014694 <touch2+0x13c>
800145e0:	b2 88       	st.b	r9[0x0],r8
		forzada--;
800145e2:	4a f9       	lddpc	r9,8001469c <touch2+0x144>
800145e4:	72 08       	ld.w	r8,r9[0x0]
800145e6:	20 18       	sub	r8,1
800145e8:	93 08       	st.w	r9[0x0],r8
		if (forzada<1)
800145ea:	58 08       	cp.w	r8,0
800145ec:	e0 89 00 05 	brgt	800145f6 <touch2+0x9e>
		{
			forzada=4;
800145f0:	30 49       	mov	r9,4
800145f2:	4a b8       	lddpc	r8,8001469c <touch2+0x144>
800145f4:	91 09       	st.w	r8[0x0],r9
		}	
	}
	gpio_clear_pin_interrupt_flag(Izquierda);
800145f6:	33 9c       	mov	r12,57
800145f8:	f0 1f 00 2a 	mcall	800146a0 <touch2+0x148>
	if(gpio_get_pin_interrupt_flag (Enter)==1)
800145fc:	33 ac       	mov	r12,58
800145fe:	f0 1f 00 1d 	mcall	80014670 <touch2+0x118>
80014602:	c2 d0       	breq	8001465c <touch2+0x104>
	{
	if (reset==false)
80014604:	4a 88       	lddpc	r8,800146a4 <touch2+0x14c>
80014606:	11 89       	ld.ub	r9,r8[0x0]
80014608:	30 08       	mov	r8,0
8001460a:	f0 09 18 00 	cp.b	r9,r8
8001460e:	c1 01       	brne	8001462e <touch2+0xd6>
	{
		reset=true;
80014610:	30 19       	mov	r9,1
80014612:	4a 58       	lddpc	r8,800146a4 <touch2+0x14c>
80014614:	b0 89       	st.b	r8[0x0],r9
		adc_configure(&AVR32_ADC);
80014616:	fe 7c 3c 00 	mov	r12,-50176
8001461a:	f0 1f 00 24 	mcall	800146a8 <touch2+0x150>
		Desplegar();
8001461e:	f0 1f 00 24 	mcall	800146ac <touch2+0x154>
		tc_start(&AVR32_TC,0);
80014622:	30 0b       	mov	r11,0
80014624:	fe 7c 38 00 	mov	r12,-51200
80014628:	f0 1f 00 22 	mcall	800146b0 <touch2+0x158>
8001462c:	c1 88       	rjmp	8001465c <touch2+0x104>
	}
	else 
	{
	InicializarFondo();
8001462e:	f0 1f 00 22 	mcall	800146b4 <touch2+0x15c>
	Desplegar();
80014632:	f0 1f 00 1f 	mcall	800146ac <touch2+0x154>
	BrilloACT=false;
80014636:	30 08       	mov	r8,0
80014638:	48 f9       	lddpc	r9,80014674 <touch2+0x11c>
8001463a:	b2 88       	st.b	r9[0x0],r8
	NegACT=false;
8001463c:	48 f9       	lddpc	r9,80014678 <touch2+0x120>
8001463e:	b2 88       	st.b	r9[0x0],r8
	BNACT=false;
80014640:	48 f9       	lddpc	r9,8001467c <touch2+0x124>
80014642:	b2 88       	st.b	r9[0x0],r8
	AutoFiltroACT=false;
80014644:	48 f9       	lddpc	r9,80014680 <touch2+0x128>
80014646:	b2 88       	st.b	r9[0x0],r8
	dilatar=false;
80014648:	48 f9       	lddpc	r9,80014684 <touch2+0x12c>
8001464a:	b2 88       	st.b	r9[0x0],r8
	eros=false;
8001464c:	48 f9       	lddpc	r9,80014688 <touch2+0x130>
8001464e:	b2 88       	st.b	r9[0x0],r8
	blur=false;
80014650:	48 f9       	lddpc	r9,8001468c <touch2+0x134>
80014652:	b2 88       	st.b	r9[0x0],r8
	step=0;
80014654:	48 f9       	lddpc	r9,80014690 <touch2+0x138>
80014656:	b2 88       	st.b	r9[0x0],r8
	busy=false;
80014658:	48 f9       	lddpc	r9,80014694 <touch2+0x13c>
8001465a:	b2 88       	st.b	r9[0x0],r8
	}
	}
	gpio_clear_pin_interrupt_flag(Enter);
8001465c:	33 ac       	mov	r12,58
8001465e:	f0 1f 00 11 	mcall	800146a0 <touch2+0x148>
	gpio_set_gpio_pin(LED0_GPIO);
80014662:	33 bc       	mov	r12,59
80014664:	f0 1f 00 15 	mcall	800146b8 <touch2+0x160>
}
80014668:	d4 02       	popm	lr
8001466a:	d6 03       	rete
8001466c:	80 00       	ld.sh	r0,r0[0x0]
8001466e:	6c 7e       	ld.w	lr,r6[0x1c]
80014670:	80 00       	ld.sh	r0,r0[0x0]
80014672:	6c fc       	ld.w	r12,r6[0x3c]
80014674:	00 00       	add	r0,r0
80014676:	06 88       	andn	r8,r3
80014678:	00 00       	add	r0,r0
8001467a:	06 8b       	andn	r11,r3
8001467c:	00 00       	add	r0,r0
8001467e:	07 61       	ld.uh	r1,--r3
80014680:	00 00       	add	r0,r0
80014682:	06 8a       	andn	r10,r3
80014684:	00 00       	add	r0,r0
80014686:	06 d0       	st.w	--r3,r0
80014688:	00 00       	add	r0,r0
8001468a:	06 b8       	st.h	r3++,r8
8001468c:	00 00       	add	r0,r0
8001468e:	07 62       	ld.uh	r2,--r3
80014690:	00 00       	add	r0,r0
80014692:	07 60       	ld.uh	r0,--r3
80014694:	00 00       	add	r0,r0
80014696:	07 63       	ld.uh	r3,--r3
80014698:	00 00       	add	r0,r0
8001469a:	06 d8       	st.w	--r3,r8
8001469c:	00 00       	add	r0,r0
8001469e:	06 8c       	andn	r12,r3
800146a0:	80 00       	ld.sh	r0,r0[0x0]
800146a2:	6d 14       	ld.w	r4,r6[0x44]
800146a4:	00 00       	add	r0,r0
800146a6:	06 b9       	st.h	r3++,r9
800146a8:	80 00       	ld.sh	r0,r0[0x0]
800146aa:	2b 44       	sub	r4,-76
800146ac:	80 01       	ld.sh	r1,r0[0x0]
800146ae:	07 90       	ld.ub	r0,r3[0x1]
800146b0:	80 00       	ld.sh	r0,r0[0x0]
800146b2:	2e 66       	sub	r6,-26
800146b4:	80 01       	ld.sh	r1,r0[0x0]
800146b6:	06 f4       	st.b	--r3,r4
800146b8:	80 00       	ld.sh	r0,r0[0x0]
800146ba:	6c 62       	ld.w	r2,r6[0x18]

800146bc <stream_open>:
extern U16 stream_src_size;
static size_t stream_offset;

void stream_open(void)
{
  stream_offset = 0;
800146bc:	30 09       	mov	r9,0
800146be:	48 28       	lddpc	r8,800146c4 <stream_open+0x8>
800146c0:	91 09       	st.w	r8[0x0],r9
}
800146c2:	5e fc       	retal	r12
800146c4:	00 00       	add	r0,r0
800146c6:	07 7c       	ld.ub	r12,--r3

800146c8 <stream_seek>:
{
}

void stream_seek(int offset)
{ // assume offset is always > 0 and inside the JPEG stream buffer
	stream_offset += offset;
800146c8:	48 38       	lddpc	r8,800146d4 <stream_seek+0xc>
800146ca:	70 09       	ld.w	r9,r8[0x0]
800146cc:	f8 09 00 09 	add	r9,r12,r9
800146d0:	91 09       	st.w	r8[0x0],r9
}
800146d2:	5e fc       	retal	r12
800146d4:	00 00       	add	r0,r0
800146d6:	07 7c       	ld.ub	r12,--r3

800146d8 <init_source>:

  /* We reset the empty-input-file flag for each image,
   * but we don't clear the input buffer.
   * This is correct behavior for reading a series of images from one source.
   */
  src->start_of_file = TRUE;
800146d8:	78 68       	ld.w	r8,r12[0x18]
800146da:	30 19       	mov	r9,1
800146dc:	91 99       	st.w	r8[0x24],r9
}
800146de:	5e fc       	retal	r12

800146e0 <term_source>:
/* JPEG library callback to do cleanup work after processing the input data.
 */
static void term_source (j_decompress_ptr cinfo)
{
  /* no work necessary here */
}
800146e0:	5e fc       	retal	r12
800146e2:	d7 03       	nop

800146e4 <jpeg_stdio_src>:

/* JPEG library callback to initialize this module.
 */
void jpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)
{
800146e4:	eb cd 40 e0 	pushm	r5-r7,lr
800146e8:	18 97       	mov	r7,r12
800146ea:	16 96       	mov	r6,r11
   * only before the first one.  (If we discarded the buffer at the end of
   * one image, we'd likely lose the start of the next one.)
   * This makes it unsafe to use this manager and a different source
   * manager serially with the same JPEG object.  Caveat programmer.
   */
  if (cinfo->src == NULL) {     /* first time for this JPEG object? */
800146ec:	78 68       	ld.w	r8,r12[0x18]
800146ee:	58 08       	cp.w	r8,0
800146f0:	c1 01       	brne	80014710 <jpeg_stdio_src+0x2c>
    cinfo->src = (struct jpeg_source_mgr *)
800146f2:	78 18       	ld.w	r8,r12[0x4]
800146f4:	70 08       	ld.w	r8,r8[0x0]
800146f6:	32 8a       	mov	r10,40
800146f8:	30 0b       	mov	r11,0
800146fa:	5d 18       	icall	r8
800146fc:	18 95       	mov	r5,r12
800146fe:	8f 6c       	st.w	r7[0x18],r12
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
                                  SIZEOF(my_source_mgr));
    src = (my_src_ptr) cinfo->src;
    // allocate input buffer
    src->buffer = (JOCTET *)
80014700:	6e 18       	ld.w	r8,r7[0x4]
80014702:	70 08       	ld.w	r8,r8[0x0]
80014704:	e0 6a 04 00 	mov	r10,1024
80014708:	30 0b       	mov	r11,0
8001470a:	0e 9c       	mov	r12,r7
8001470c:	5d 18       	icall	r8
8001470e:	8b 8c       	st.w	r5[0x20],r12
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
                                  JPEG_INPUT_BUF_SIZE * SIZEOF(JOCTET));
  }

  src = (my_src_ptr) cinfo->src;
80014710:	6e 68       	ld.w	r8,r7[0x18]
  src->pub.init_source = init_source;
80014712:	48 99       	lddpc	r9,80014734 <jpeg_stdio_src+0x50>
80014714:	91 29       	st.w	r8[0x8],r9
  src->pub.fill_input_buffer = fill_input_buffer;
80014716:	48 99       	lddpc	r9,80014738 <jpeg_stdio_src+0x54>
80014718:	91 39       	st.w	r8[0xc],r9
  src->pub.skip_input_data = skip_input_data;
8001471a:	48 99       	lddpc	r9,8001473c <jpeg_stdio_src+0x58>
8001471c:	91 49       	st.w	r8[0x10],r9
  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
8001471e:	48 99       	lddpc	r9,80014740 <jpeg_stdio_src+0x5c>
80014720:	91 59       	st.w	r8[0x14],r9
  src->pub.term_source = term_source;
80014722:	48 99       	lddpc	r9,80014744 <jpeg_stdio_src+0x60>
80014724:	91 69       	st.w	r8[0x18],r9
  src->infile = infile;
80014726:	91 76       	st.w	r8[0x1c],r6
  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
80014728:	30 09       	mov	r9,0
8001472a:	91 19       	st.w	r8[0x4],r9
  src->pub.next_input_byte = NULL; /* until buffer loaded */
8001472c:	91 09       	st.w	r8[0x0],r9
}
8001472e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80014732:	00 00       	add	r0,r0
80014734:	80 01       	ld.sh	r1,r0[0x0]
80014736:	46 d8       	lddsp	r8,sp[0x1b4]
80014738:	80 01       	ld.sh	r1,r0[0x0]
8001473a:	49 e4       	lddpc	r4,800147b0 <jpeg_lib_init+0x28>
8001473c:	80 01       	ld.sh	r1,r0[0x0]
8001473e:	4a 20       	lddpc	r0,800147c4 <jpeg_lib_init+0x3c>
80014740:	80 00       	ld.sh	r0,r0[0x0]
80014742:	a6 40       	st.h	r3[0x8],r0
80014744:	80 01       	ld.sh	r1,r0[0x0]
80014746:	46 e0       	lddsp	r0,sp[0x1b8]

80014748 <jpeg_lib_exit>:

	return true;
}

void jpeg_lib_exit(void)
{
80014748:	d4 01       	pushm	lr
	if(jpeg_lib_data.output_image)
8001474a:	48 d8       	lddpc	r8,8001477c <jpeg_lib_exit+0x34>
8001474c:	70 0c       	ld.w	r12,r8[0x0]
8001474e:	58 0c       	cp.w	r12,0
80014750:	c0 30       	breq	80014756 <jpeg_lib_exit+0xe>
		free(jpeg_lib_data.output_image);
80014752:	f0 1f 00 0c 	mcall	80014780 <jpeg_lib_exit+0x38>

	if(jpeg_lib_data.cinfo->err)
80014756:	48 a8       	lddpc	r8,8001477c <jpeg_lib_exit+0x34>
80014758:	70 18       	ld.w	r8,r8[0x4]
8001475a:	70 0c       	ld.w	r12,r8[0x0]
8001475c:	58 0c       	cp.w	r12,0
8001475e:	c0 30       	breq	80014764 <jpeg_lib_exit+0x1c>
		free(jpeg_lib_data.cinfo->err);
80014760:	f0 1f 00 08 	mcall	80014780 <jpeg_lib_exit+0x38>

	if(jpeg_lib_data.cinfo)
80014764:	48 68       	lddpc	r8,8001477c <jpeg_lib_exit+0x34>
80014766:	70 1c       	ld.w	r12,r8[0x4]
80014768:	58 0c       	cp.w	r12,0
8001476a:	c0 70       	breq	80014778 <jpeg_lib_exit+0x30>
	{
		// release internal memory
		jpeg_destroy_decompress(jpeg_lib_data.cinfo);
8001476c:	f0 1f 00 06 	mcall	80014784 <jpeg_lib_exit+0x3c>
		free(jpeg_lib_data.cinfo);
80014770:	48 38       	lddpc	r8,8001477c <jpeg_lib_exit+0x34>
80014772:	70 1c       	ld.w	r12,r8[0x4]
80014774:	f0 1f 00 03 	mcall	80014780 <jpeg_lib_exit+0x38>
80014778:	d8 02       	popm	pc
8001477a:	00 00       	add	r0,r0
8001477c:	00 00       	add	r0,r0
8001477e:	07 80       	ld.ub	r0,r3[0x0]
80014780:	80 01       	ld.sh	r1,r0[0x0]
80014782:	50 48       	stdsp	sp[0x10],r8
80014784:	80 00       	ld.sh	r0,r0[0x0]
80014786:	77 c4       	ld.w	r4,r11[0x70]

80014788 <jpeg_lib_init>:
}

/* Call once before the start of any decompression
 */
bool jpeg_lib_init(void)
{
80014788:	eb cd 40 80 	pushm	r7,lr
	// allocate the decompression structure
	jpeg_lib_data.cinfo = malloc(sizeof(struct jpeg_decompress_struct ));
8001478c:	e0 6c 01 d0 	mov	r12,464
80014790:	f0 1f 00 1d 	mcall	80014804 <jpeg_lib_init+0x7c>
80014794:	18 97       	mov	r7,r12
80014796:	49 d8       	lddpc	r8,80014808 <jpeg_lib_init+0x80>
80014798:	91 1c       	st.w	r8[0x4],r12

	if(!jpeg_lib_data.cinfo)
8001479a:	58 0c       	cp.w	r12,0
8001479c:	c0 31       	brne	800147a2 <jpeg_lib_init+0x1a>
8001479e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		return false;

	jpeg_lib_data.cinfo->err = (struct jpeg_error_mgr *) malloc(sizeof(struct extended_error_mgr));
800147a2:	e0 6c 00 ac 	mov	r12,172
800147a6:	f0 1f 00 18 	mcall	80014804 <jpeg_lib_init+0x7c>
800147aa:	8f 0c       	st.w	r7[0x0],r12

	if(!jpeg_lib_data.cinfo->err)
800147ac:	49 78       	lddpc	r8,80014808 <jpeg_lib_init+0x80>
800147ae:	70 1c       	ld.w	r12,r8[0x4]
800147b0:	78 08       	ld.w	r8,r12[0x0]
800147b2:	58 08       	cp.w	r8,0
800147b4:	c0 51       	brne	800147be <jpeg_lib_init+0x36>
	{
		free(jpeg_lib_data.cinfo);
800147b6:	f0 1f 00 16 	mcall	8001480c <jpeg_lib_init+0x84>
800147ba:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		return false;
	}
	// allocate the buffer for the decompressed image
	jpeg_lib_data.output_image = malloc(
800147be:	e2 6c 58 00 	mov	r12,153600
800147c2:	f0 1f 00 11 	mcall	80014804 <jpeg_lib_init+0x7c>
800147c6:	49 18       	lddpc	r8,80014808 <jpeg_lib_init+0x80>
800147c8:	91 0c       	st.w	r8[0x0],r12
		JPEG_DECODER_MAX_IMAGE_WIDTH * JPEG_DECODER_MAX_IMAGE_HEIGHT * JPEG_DECODER_PIXEL_SIZE_IN_BYTES);

	if(!jpeg_lib_data.output_image)
800147ca:	58 0c       	cp.w	r12,0
800147cc:	c0 b1       	brne	800147e2 <jpeg_lib_init+0x5a>
	{
		free(jpeg_lib_data.cinfo->err);
800147ce:	10 97       	mov	r7,r8
800147d0:	70 18       	ld.w	r8,r8[0x4]
800147d2:	70 0c       	ld.w	r12,r8[0x0]
800147d4:	f0 1f 00 0e 	mcall	8001480c <jpeg_lib_init+0x84>
		free(jpeg_lib_data.cinfo);
800147d8:	6e 1c       	ld.w	r12,r7[0x4]
800147da:	f0 1f 00 0d 	mcall	8001480c <jpeg_lib_init+0x84>
800147de:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		return false;
	}
	// initialize error handler
	jpeg_std_error(jpeg_lib_data.cinfo->err);
800147e2:	48 a7       	lddpc	r7,80014808 <jpeg_lib_init+0x80>
800147e4:	6e 18       	ld.w	r8,r7[0x4]
800147e6:	70 0c       	ld.w	r12,r8[0x0]
800147e8:	f0 1f 00 0a 	mcall	80014810 <jpeg_lib_init+0x88>
	jpeg_lib_data.cinfo->err->error_exit = extended_error_exit;
800147ec:	6e 1c       	ld.w	r12,r7[0x4]
800147ee:	78 08       	ld.w	r8,r12[0x0]
800147f0:	48 99       	lddpc	r9,80014814 <jpeg_lib_init+0x8c>
800147f2:	91 09       	st.w	r8[0x0],r9

	// initialize the decompression struct
	jpeg_create_decompress(jpeg_lib_data.cinfo);
800147f4:	e0 6a 01 d0 	mov	r10,464
800147f8:	33 eb       	mov	r11,62
800147fa:	f0 1f 00 08 	mcall	80014818 <jpeg_lib_init+0x90>
800147fe:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80014802:	00 00       	add	r0,r0
80014804:	80 01       	ld.sh	r1,r0[0x0]
80014806:	50 58       	stdsp	sp[0x14],r8
80014808:	00 00       	add	r0,r0
8001480a:	07 80       	ld.ub	r0,r3[0x0]
8001480c:	80 01       	ld.sh	r1,r0[0x0]
8001480e:	50 48       	stdsp	sp[0x10],r8
80014810:	80 00       	ld.sh	r0,r0[0x0]
80014812:	cd 7c       	rcall	800149c0 <stream_read+0x20>
80014814:	80 01       	ld.sh	r1,r0[0x0]
80014816:	48 1c       	lddpc	r12,80014818 <jpeg_lib_init+0x90>
80014818:	80 00       	ld.sh	r0,r0[0x0]
8001481a:	77 d0       	ld.w	r0,r11[0x74]

8001481c <extended_error_exit>:
 * Here's the routine that will replace the standard error_exit method:
 */

METHODDEF(void)
extended_error_exit (j_common_ptr cinfo)
{
8001481c:	eb cd 40 80 	pushm	r7,lr
  /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
  extended_error_ptr extended_err = (extended_error_ptr) cinfo->err;
80014820:	78 07       	ld.w	r7,r12[0x0]

  /* Always display the message. */
  /* We could postpone this until after returning, if we chose. */
  (*cinfo->err->output_message) (cinfo);
80014822:	6e 28       	ld.w	r8,r7[0x8]
80014824:	5d 18       	icall	r8

  /* Return control to the setjmp point */
  longjmp(extended_err->setjmp_buffer, 1);
80014826:	30 1b       	mov	r11,1
80014828:	ee cc ff 7c 	sub	r12,r7,-132
8001482c:	f0 1f 00 01 	mcall	80014830 <extended_error_exit+0x14>
80014830:	80 01       	ld.sh	r1,r0[0x0]
80014832:	56 3a       	stdsp	sp[0x18c],r10

80014834 <jpeg_lib_decode>:

  return (void *) jpeg_lib_data.output_image;
}

bool  jpeg_lib_decode(int offset)
{
80014834:	eb cd 40 c0 	pushm	r6-r7,lr
80014838:	20 3d       	sub	sp,12
8001483a:	18 97       	mov	r7,r12
	struct jpeg_decompress_struct *cinfo = (struct jpeg_decompress_struct *) jpeg_lib_data.cinfo;
8001483c:	4c 08       	lddpc	r8,8001493c <jpeg_lib_decode+0x108>
8001483e:	70 1e       	ld.w	lr,r8[0x4]
80014840:	50 0e       	stdsp	sp[0x0],lr
	struct extended_error_mgr *jerr = (struct extended_error_mgr *) cinfo->err;
80014842:	7c 06       	ld.w	r6,lr[0x0]
	uint16_t max_lines = 1;
	uint16_t scale_denom;
	uint16_t max_width, max_height;

	max_width = cinfo->output_width;
80014844:	fd 0a 00 72 	ld.sh	r10,lr[114]
80014848:	50 2a       	stdsp	sp[0x8],r10
    max_height = cinfo->output_height;
8001484a:	fd 09 00 76 	ld.sh	r9,lr[118]
8001484e:	50 19       	stdsp	sp[0x4],r9

	// set output image position for the JPEG library
	jpeg_out_buffer_pos = (uint16_t *) jpeg_lib_data.output_image;
80014850:	70 09       	ld.w	r9,r8[0x0]
80014852:	4b c8       	lddpc	r8,80014940 <jpeg_lib_decode+0x10c>
80014854:	91 09       	st.w	r8[0x0],r9

	//file_ptr = 0;
	stream_open();				//	file_open(FOPEN_MODE_R);
80014856:	f0 1f 00 3c 	mcall	80014944 <jpeg_lib_decode+0x110>
	if(offset)
8001485a:	58 07       	cp.w	r7,0
8001485c:	c0 40       	breq	80014864 <jpeg_lib_decode+0x30>
		stream_seek(offset);	//	file_seek(offset, FS_SEEK_SET);
8001485e:	0e 9c       	mov	r12,r7
80014860:	f0 1f 00 3a 	mcall	80014948 <jpeg_lib_decode+0x114>

	// set file to read from
	jpeg_stdio_src(cinfo, 0);
80014864:	30 0b       	mov	r11,0
80014866:	40 0c       	lddsp	r12,sp[0x0]
80014868:	f0 1f 00 39 	mcall	8001494c <jpeg_lib_decode+0x118>

	/* Establish the setjmp return context for my_error_exit to use. */
	if (setjmp(jerr->setjmp_buffer))
8001486c:	ec cc ff 7c 	sub	r12,r6,-132
80014870:	f0 1f 00 38 	mcall	80014950 <jpeg_lib_decode+0x11c>
80014874:	c0 60       	breq	80014880 <jpeg_lib_decode+0x4c>
	{
		/* If we get here, the JPEG code has signaled an error.
		 * We need to clean up the JPEG object, close the input file, and return.
		 */
		jpeg_abort_decompress(cinfo);
80014876:	40 0c       	lddsp	r12,sp[0x0]
80014878:	f0 1f 00 37 	mcall	80014954 <jpeg_lib_decode+0x120>
8001487c:	30 0c       	mov	r12,0
		stream_close();		//	file_close();
		return false;
8001487e:	c5 b8       	rjmp	80014934 <jpeg_lib_decode+0x100>
	}
	// read the file header
	if(JPEG_HEADER_OK != jpeg_read_header(cinfo, TRUE))
80014880:	30 1b       	mov	r11,1
80014882:	40 0c       	lddsp	r12,sp[0x0]
80014884:	f0 1f 00 35 	mcall	80014958 <jpeg_lib_decode+0x124>
80014888:	58 1c       	cp.w	r12,1
8001488a:	c0 91       	brne	8001489c <jpeg_lib_decode+0x68>

	// set decompression configuration
	scale_denom = 0;

	// set correct scaling to fit the reserved space
	while(((cinfo->image_width >> scale_denom) > max_width)
8001488c:	40 08       	lddsp	r8,sp[0x0]
8001488e:	70 7c       	ld.w	r12,r8[0x1c]
80014890:	30 08       	mov	r8,0
80014892:	40 2b       	lddsp	r11,sp[0x8]
80014894:	5c 7b       	castu.h	r11
		|| ((cinfo->image_height >> scale_denom) > max_height))
80014896:	40 17       	lddsp	r7,sp[0x4]
80014898:	5c 77       	castu.h	r7
8001489a:	c0 88       	rjmp	800148aa <jpeg_lib_decode+0x76>
		return false;
	}
	// read the file header
	if(JPEG_HEADER_OK != jpeg_read_header(cinfo, TRUE))
	{
		jpeg_abort_decompress(cinfo);
8001489c:	40 0c       	lddsp	r12,sp[0x0]
8001489e:	f0 1f 00 2e 	mcall	80014954 <jpeg_lib_decode+0x120>
800148a2:	30 0c       	mov	r12,0
		stream_close();		//	file_close();
		return false;
800148a4:	c4 88       	rjmp	80014934 <jpeg_lib_decode+0x100>

	// set correct scaling to fit the reserved space
	while(((cinfo->image_width >> scale_denom) > max_width)
		|| ((cinfo->image_height >> scale_denom) > max_height))
	{
		scale_denom++;
800148a6:	2f f8       	sub	r8,-1
800148a8:	5c 88       	casts.h	r8

	// set decompression configuration
	scale_denom = 0;

	// set correct scaling to fit the reserved space
	while(((cinfo->image_width >> scale_denom) > max_width)
800148aa:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800148ae:	f8 09 0a 4a 	lsr	r10,r12,r9
800148b2:	16 3a       	cp.w	r10,r11
800148b4:	fe 9b ff f9 	brhi	800148a6 <jpeg_lib_decode+0x72>
		|| ((cinfo->image_height >> scale_denom) > max_height))
800148b8:	40 0e       	lddsp	lr,sp[0x0]
800148ba:	7c 8a       	ld.w	r10,lr[0x20]
800148bc:	f4 09 0a 4a 	lsr	r10,r10,r9
800148c0:	0e 3a       	cp.w	r10,r7
800148c2:	fe 9b ff f2 	brhi	800148a6 <jpeg_lib_decode+0x72>
	{
		scale_denom++;
	}
	scale_denom = 1 << scale_denom;
800148c6:	30 18       	mov	r8,1
800148c8:	f0 09 09 49 	lsl	r9,r8,r9
800148cc:	5c 89       	casts.h	r9
	// any scaling above 1/8 is not possible
	if(scale_denom > 8)
800148ce:	30 88       	mov	r8,8
800148d0:	f0 09 19 00 	cp.h	r9,r8
800148d4:	e0 88 00 04 	brls	800148dc <jpeg_lib_decode+0xa8>
800148d8:	30 0c       	mov	r12,0
800148da:	c2 d8       	rjmp	80014934 <jpeg_lib_decode+0x100>
	{
		stream_close();		//	file_close();
		return false;
	}

	cinfo->scale_denom = scale_denom;
800148dc:	5c 79       	castu.h	r9
800148de:	40 0a       	lddsp	r10,sp[0x0]
800148e0:	95 d9       	st.w	r10[0x34],r9


	cinfo->dct_method = JDCT_FASTEST;
800148e2:	30 18       	mov	r8,1
800148e4:	f5 48 00 48 	st.w	r10[72],r8
	cinfo->do_fancy_upsampling = false;
800148e8:	30 08       	mov	r8,0
800148ea:	f5 48 00 4c 	st.w	r10[76],r8
	cinfo->out_color_space = JCS_RGB565;
800148ee:	30 68       	mov	r8,6
800148f0:	95 b8       	st.w	r10[0x2c],r8

	// submit the requested decompression parameters
	// this call will also adjust invalid settings
	if( jpeg_start_decompress(cinfo) == false)
800148f2:	40 0c       	lddsp	r12,sp[0x0]
800148f4:	f0 1f 00 1a 	mcall	8001495c <jpeg_lib_decode+0x128>
800148f8:	c0 80       	breq	80014908 <jpeg_lib_decode+0xd4>
		return false;
	}

	// read scanlines
	//
	while(cinfo->output_scanline < cinfo->output_height)
800148fa:	40 08       	lddsp	r8,sp[0x0]
800148fc:	f0 f9 00 8c 	ld.w	r9,r8[140]
80014900:	71 d8       	ld.w	r8,r8[0x74]
80014902:	10 39       	cp.w	r9,r8
80014904:	c0 73       	brcs	80014912 <jpeg_lib_decode+0xde>
80014906:	c1 38       	rjmp	8001492c <jpeg_lib_decode+0xf8>

	// submit the requested decompression parameters
	// this call will also adjust invalid settings
	if( jpeg_start_decompress(cinfo) == false)
	{
		jpeg_abort_decompress(cinfo);
80014908:	40 0c       	lddsp	r12,sp[0x0]
8001490a:	f0 1f 00 13 	mcall	80014954 <jpeg_lib_decode+0x120>
8001490e:	30 0c       	mov	r12,0
		stream_close();		//	file_close();
		return false;
80014910:	c1 28       	rjmp	80014934 <jpeg_lib_decode+0x100>
	// read scanlines
	//
	while(cinfo->output_scanline < cinfo->output_height)
	{
		// get decoded scanlines
		jpeg_read_scanlines(cinfo, NULL, max_lines);
80014912:	30 17       	mov	r7,1
80014914:	30 06       	mov	r6,0
80014916:	0e 9a       	mov	r10,r7
80014918:	0c 9b       	mov	r11,r6
8001491a:	40 0c       	lddsp	r12,sp[0x0]
8001491c:	f0 1f 00 11 	mcall	80014960 <jpeg_lib_decode+0x12c>
		return false;
	}

	// read scanlines
	//
	while(cinfo->output_scanline < cinfo->output_height)
80014920:	40 0e       	lddsp	lr,sp[0x0]
80014922:	fc f9 00 8c 	ld.w	r9,lr[140]
80014926:	7d d8       	ld.w	r8,lr[0x74]
80014928:	10 39       	cp.w	r9,r8
8001492a:	cf 63       	brcs	80014916 <jpeg_lib_decode+0xe2>
	{
		// get decoded scanlines
		jpeg_read_scanlines(cinfo, NULL, max_lines);
	}

	jpeg_finish_decompress(cinfo);
8001492c:	40 0c       	lddsp	r12,sp[0x0]
8001492e:	f0 1f 00 0e 	mcall	80014964 <jpeg_lib_decode+0x130>
80014932:	30 1c       	mov	r12,1

	stream_close();		//	file_close();
	return true;
}
80014934:	2f dd       	sub	sp,-12
80014936:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8001493a:	00 00       	add	r0,r0
8001493c:	00 00       	add	r0,r0
8001493e:	07 80       	ld.ub	r0,r3[0x0]
80014940:	00 00       	add	r0,r0
80014942:	0d 34       	ld.ub	r4,r6++
80014944:	80 01       	ld.sh	r1,r0[0x0]
80014946:	46 bc       	lddsp	r12,sp[0x1ac]
80014948:	80 01       	ld.sh	r1,r0[0x0]
8001494a:	46 c8       	lddsp	r8,sp[0x1b0]
8001494c:	80 01       	ld.sh	r1,r0[0x0]
8001494e:	46 e4       	lddsp	r4,sp[0x1b8]
80014950:	80 01       	ld.sh	r1,r0[0x0]
80014952:	56 34       	stdsp	sp[0x18c],r4
80014954:	80 00       	ld.sh	r0,r0[0x0]
80014956:	77 b8       	ld.w	r8,r11[0x6c]
80014958:	80 00       	ld.sh	r0,r0[0x0]
8001495a:	77 60       	ld.w	r0,r11[0x58]
8001495c:	80 00       	ld.sh	r0,r0[0x0]
8001495e:	79 bc       	ld.w	r12,r12[0x6c]
80014960:	80 00       	ld.sh	r0,r0[0x0]
80014962:	79 36       	ld.w	r6,r12[0x4c]
80014964:	80 00       	ld.sh	r0,r0[0x0]
80014966:	76 cc       	ld.w	r12,r11[0x30]

80014968 <jpeg_lib_decode_ex>:
/*----------------------------------------------------------------------*/

uint16_t *jpeg_out_buffer_pos;

void *jpeg_lib_decode_ex(int offset, U16 *width, U16 *height)
{
80014968:	eb cd 40 e0 	pushm	r5-r7,lr
8001496c:	16 96       	mov	r6,r11
8001496e:	14 95       	mov	r5,r10
  struct jpeg_decompress_struct *cinfo = (struct jpeg_decompress_struct *)
    jpeg_lib_data.cinfo;
80014970:	48 a8       	lddpc	r8,80014998 <jpeg_lib_decode_ex+0x30>
80014972:	70 17       	ld.w	r7,r8[0x4]

  cinfo->output_width = *width;
80014974:	96 88       	ld.uh	r8,r11[0x0]
80014976:	ef 48 00 70 	st.w	r7[112],r8
  cinfo->output_height = *height;
8001497a:	94 88       	ld.uh	r8,r10[0x0]
8001497c:	ef 48 00 74 	st.w	r7[116],r8

  if (!jpeg_lib_decode(offset))
80014980:	f0 1f 00 07 	mcall	8001499c <jpeg_lib_decode_ex+0x34>
80014984:	c0 70       	breq	80014992 <jpeg_lib_decode_ex+0x2a>
    return NULL;

  *width = cinfo->output_width;
80014986:	6f c8       	ld.w	r8,r7[0x70]
80014988:	ac 08       	st.h	r6[0x0],r8
  *height = cinfo->output_height;
8001498a:	6f d8       	ld.w	r8,r7[0x74]
8001498c:	aa 08       	st.h	r5[0x0],r8

  return (void *) jpeg_lib_data.output_image;
8001498e:	48 38       	lddpc	r8,80014998 <jpeg_lib_decode_ex+0x30>
80014990:	70 0c       	ld.w	r12,r8[0x0]
}
80014992:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80014996:	00 00       	add	r0,r0
80014998:	00 00       	add	r0,r0
8001499a:	07 80       	ld.ub	r0,r3[0x0]
8001499c:	80 01       	ld.sh	r1,r0[0x0]
8001499e:	48 34       	lddpc	r4,800149a8 <stream_read+0x8>

800149a0 <stream_read>:
{
  stream_offset = 0;
}

size_t stream_read(JOCTET * buffer, size_t nb_byte)
{ // assume nb_byte never goes beyond the stream buffer size
800149a0:	eb cd 40 80 	pushm	r7,lr
800149a4:	16 97       	mov	r7,r11
	if ((stream_offset+nb_byte) > (size_t)stream_src_size)
800149a6:	48 c8       	lddpc	r8,800149d4 <stream_read+0x34>
800149a8:	70 08       	ld.w	r8,r8[0x0]
800149aa:	48 c9       	lddpc	r9,800149d8 <stream_read+0x38>
800149ac:	92 89       	ld.uh	r9,r9[0x0]
800149ae:	f6 08 00 0a 	add	r10,r11,r8
	{
		nb_byte = (size_t)stream_src_size - stream_offset;
800149b2:	12 3a       	cp.w	r10,r9
800149b4:	f3 d8 eb 17 	subhi	r7,r9,r8
	}
	memcpy (buffer, (stream_jpeg_src_ptr + stream_offset), nb_byte);
800149b8:	48 99       	lddpc	r9,800149dc <stream_read+0x3c>
800149ba:	72 0b       	ld.w	r11,r9[0x0]
800149bc:	0e 9a       	mov	r10,r7
800149be:	10 0b       	add	r11,r8
800149c0:	f0 1f 00 08 	mcall	800149e0 <stream_read+0x40>
	stream_offset += nb_byte;
800149c4:	48 48       	lddpc	r8,800149d4 <stream_read+0x34>
800149c6:	70 09       	ld.w	r9,r8[0x0]
800149c8:	ee 09 00 09 	add	r9,r7,r9
800149cc:	91 09       	st.w	r8[0x0],r9
	return nb_byte;
}
800149ce:	0e 9c       	mov	r12,r7
800149d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800149d4:	00 00       	add	r0,r0
800149d6:	07 7c       	ld.ub	r12,--r3
800149d8:	00 00       	add	r0,r0
800149da:	0d 30       	ld.ub	r0,r6++
800149dc:	00 00       	add	r0,r0
800149de:	0d 2c       	ld.uh	r12,r6++
800149e0:	80 01       	ld.sh	r1,r0[0x0]
800149e2:	54 ba       	stdsp	sp[0x12c],r10

800149e4 <fill_input_buffer>:
}

/* Callback function of the JPEG library in order to fill the input buffer.
 */
static boolean fill_input_buffer(j_decompress_ptr cinfo)
{
800149e4:	eb cd 40 80 	pushm	r7,lr
	my_src_ptr src = (my_src_ptr) cinfo->src;
800149e8:	78 67       	ld.w	r7,r12[0x18]
	size_t nbytes;

	nbytes = stream_read(src->buffer, JPEG_INPUT_BUF_SIZE);		//	nbytes = file_read_buf(src->buffer, JPEG_INPUT_BUF_SIZE);
800149ea:	e0 6b 04 00 	mov	r11,1024
800149ee:	6e 8c       	ld.w	r12,r7[0x20]
800149f0:	f0 1f 00 0b 	mcall	80014a1c <fill_input_buffer+0x38>

	if(nbytes <= 0)
800149f4:	c0 b1       	brne	80014a0a <fill_input_buffer+0x26>
	{
		if (src->start_of_file)
800149f6:	6e 98       	ld.w	r8,r7[0x24]
800149f8:	58 08       	cp.w	r8,0
800149fa:	c0 e1       	brne	80014a16 <fill_input_buffer+0x32>
		{ /* Treat empty input file as fatal error */
			return FALSE;//ERREXIT(cinfo, JERR_INPUT_EMPTY);
		}
		//WARNMS(cinfo, JWRN_JPEG_EOF);
		src->buffer[0] = (JOCTET) 0xFF;
800149fc:	6e 88       	ld.w	r8,r7[0x20]
800149fe:	3f f9       	mov	r9,-1
80014a00:	b0 89       	st.b	r8[0x0],r9
		src->buffer[1] = (JOCTET) JPEG_EOI;
80014a02:	6e 88       	ld.w	r8,r7[0x20]
80014a04:	3d 99       	mov	r9,-39
80014a06:	b0 99       	st.b	r8[0x1],r9
80014a08:	30 2c       	mov	r12,2
		nbytes = 2;
	}
	src->pub.next_input_byte = src->buffer;
80014a0a:	6e 88       	ld.w	r8,r7[0x20]
80014a0c:	8f 08       	st.w	r7[0x0],r8
	src->pub.bytes_in_buffer = nbytes;
80014a0e:	8f 1c       	st.w	r7[0x4],r12
	src->start_of_file = FALSE;
80014a10:	30 08       	mov	r8,0
80014a12:	8f 98       	st.w	r7[0x24],r8
80014a14:	30 1c       	mov	r12,1

	return TRUE;
}
80014a16:	e3 cd 80 80 	ldm	sp++,r7,pc
80014a1a:	00 00       	add	r0,r0
80014a1c:	80 01       	ld.sh	r1,r0[0x0]
80014a1e:	49 a0       	lddpc	r0,80014a84 <__avr32_f64_mul+0x28>

80014a20 <skip_input_data>:

/* Callback function of the JPEG library to skip data.
 */
static void skip_input_data (j_decompress_ptr cinfo, long num_bytes)
{
80014a20:	eb cd 40 e0 	pushm	r5-r7,lr
80014a24:	18 95       	mov	r5,r12
80014a26:	16 97       	mov	r7,r11
  my_src_ptr src = (my_src_ptr) cinfo->src;
80014a28:	78 66       	ld.w	r6,r12[0x18]

  /* Just a dumb implementation for now.  Could use fseek() except
   * it doesn't work on pipes.  Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0) {
80014a2a:	58 0b       	cp.w	r11,0
80014a2c:	e0 8a 00 13 	brle	80014a52 <skip_input_data+0x32>
    while (num_bytes > (long) src->pub.bytes_in_buffer) {
80014a30:	6c 18       	ld.w	r8,r6[0x4]
80014a32:	10 3b       	cp.w	r11,r8
80014a34:	e0 8a 00 09 	brle	80014a46 <skip_input_data+0x26>
      num_bytes -= (long) src->pub.bytes_in_buffer;
80014a38:	10 17       	sub	r7,r8
      (void) fill_input_buffer(cinfo);
80014a3a:	0a 9c       	mov	r12,r5
80014a3c:	f0 1f 00 07 	mcall	80014a58 <skip_input_data+0x38>
  /* Just a dumb implementation for now.  Could use fseek() except
   * it doesn't work on pipes.  Not clear that being smart is worth
   * any trouble anyway --- large skips are infrequent.
   */
  if (num_bytes > 0) {
    while (num_bytes > (long) src->pub.bytes_in_buffer) {
80014a40:	6c 18       	ld.w	r8,r6[0x4]
80014a42:	0e 38       	cp.w	r8,r7
80014a44:	cf a5       	brlt	80014a38 <skip_input_data+0x18>
      (void) fill_input_buffer(cinfo);
      /* note we assume that fill_input_buffer will never return FALSE,
       * so suspension need not be handled.
       */
    }
    src->pub.next_input_byte += (size_t) num_bytes;
80014a46:	6c 08       	ld.w	r8,r6[0x0]
80014a48:	0e 08       	add	r8,r7
80014a4a:	8d 08       	st.w	r6[0x0],r8
    src->pub.bytes_in_buffer -= (size_t) num_bytes;
80014a4c:	6c 18       	ld.w	r8,r6[0x4]
80014a4e:	0e 18       	sub	r8,r7
80014a50:	8d 18       	st.w	r6[0x4],r8
80014a52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80014a56:	00 00       	add	r0,r0
80014a58:	80 01       	ld.sh	r1,r0[0x0]
80014a5a:	49 e4       	lddpc	r4,80014ad0 <__avr32_f64_mul+0x74>

80014a5c <__avr32_f64_mul>:
80014a5c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
80014a60:	e0 80 00 dc 	breq	80014c18 <__avr32_f64_mul_op1_zero>
80014a64:	d4 21       	pushm	r4-r7,lr
80014a66:	f7 e9 20 0e 	eor	lr,r11,r9
80014a6a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80014a6e:	30 15       	mov	r5,1
80014a70:	c4 30       	breq	80014af6 <__avr32_f64_mul_op1_subnormal>
80014a72:	ab 6b       	lsl	r11,0xa
80014a74:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80014a78:	ab 6a       	lsl	r10,0xa
80014a7a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80014a7e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80014a82:	c5 c0       	breq	80014b3a <__avr32_f64_mul_op2_subnormal>
80014a84:	a1 78       	lsl	r8,0x1
80014a86:	5c f9       	rol	r9
80014a88:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
80014a8c:	e0 47 07 ff 	cp.w	r7,2047
80014a90:	c7 70       	breq	80014b7e <__avr32_f64_mul_op_nan_or_inf>
80014a92:	e0 46 07 ff 	cp.w	r6,2047
80014a96:	c7 40       	breq	80014b7e <__avr32_f64_mul_op_nan_or_inf>
80014a98:	ee 06 00 0c 	add	r12,r7,r6
80014a9c:	e0 2c 03 fe 	sub	r12,1022
80014aa0:	f6 08 06 44 	mulu.d	r4,r11,r8
80014aa4:	f4 09 07 44 	macu.d	r4,r10,r9
80014aa8:	f4 08 06 46 	mulu.d	r6,r10,r8
80014aac:	f6 09 06 4a 	mulu.d	r10,r11,r9
80014ab0:	08 07       	add	r7,r4
80014ab2:	f4 05 00 4a 	adc	r10,r10,r5
80014ab6:	5c 0b       	acr	r11
80014ab8:	ed bb 00 14 	bld	r11,0x14
80014abc:	c0 50       	breq	80014ac6 <__avr32_f64_mul+0x6a>
80014abe:	a1 77       	lsl	r7,0x1
80014ac0:	5c fa       	rol	r10
80014ac2:	5c fb       	rol	r11
80014ac4:	20 1c       	sub	r12,1
80014ac6:	58 0c       	cp.w	r12,0
80014ac8:	e0 8a 00 6f 	brle	80014ba6 <__avr32_f64_mul_res_subnormal>
80014acc:	e0 4c 07 ff 	cp.w	r12,2047
80014ad0:	e0 84 00 9c 	brge	80014c08 <__avr32_f64_mul_res_inf>
80014ad4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
80014ad8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
80014adc:	ef e6 12 17 	or	r7,r7,r6>>0x1
80014ae0:	ee 17 80 00 	eorh	r7,0x8000
80014ae4:	f1 b7 04 20 	satu	r7,0x1
80014ae8:	0e 0a       	add	r10,r7
80014aea:	5c 0b       	acr	r11
80014aec:	ed be 00 1f 	bld	lr,0x1f
80014af0:	ef bb 00 1f 	bst	r11,0x1f
80014af4:	d8 22       	popm	r4-r7,pc

80014af6 <__avr32_f64_mul_op1_subnormal>:
80014af6:	e4 1b 00 0f 	andh	r11,0xf
80014afa:	f4 0c 12 00 	clz	r12,r10
80014afe:	f6 06 12 00 	clz	r6,r11
80014b02:	f7 bc 03 e1 	sublo	r12,-31
80014b06:	f8 06 17 30 	movlo	r6,r12
80014b0a:	f7 b6 02 01 	subhs	r6,1
80014b0e:	e0 46 00 20 	cp.w	r6,32
80014b12:	c0 d4       	brge	80014b2c <__avr32_f64_mul_op1_subnormal+0x36>
80014b14:	ec 0c 11 20 	rsub	r12,r6,32
80014b18:	f6 06 09 4b 	lsl	r11,r11,r6
80014b1c:	f4 0c 0a 4c 	lsr	r12,r10,r12
80014b20:	18 4b       	or	r11,r12
80014b22:	f4 06 09 4a 	lsl	r10,r10,r6
80014b26:	20 b6       	sub	r6,11
80014b28:	0c 17       	sub	r7,r6
80014b2a:	ca ab       	rjmp	80014a7e <__avr32_f64_mul+0x22>
80014b2c:	f4 06 09 4b 	lsl	r11,r10,r6
80014b30:	c6 40       	breq	80014bf8 <__avr32_f64_mul_res_zero>
80014b32:	30 0a       	mov	r10,0
80014b34:	20 b6       	sub	r6,11
80014b36:	0c 17       	sub	r7,r6
80014b38:	ca 3b       	rjmp	80014a7e <__avr32_f64_mul+0x22>

80014b3a <__avr32_f64_mul_op2_subnormal>:
80014b3a:	e4 19 00 0f 	andh	r9,0xf
80014b3e:	f0 0c 12 00 	clz	r12,r8
80014b42:	f2 05 12 00 	clz	r5,r9
80014b46:	f7 bc 03 ea 	sublo	r12,-22
80014b4a:	f8 05 17 30 	movlo	r5,r12
80014b4e:	f7 b5 02 0a 	subhs	r5,10
80014b52:	e0 45 00 20 	cp.w	r5,32
80014b56:	c0 d4       	brge	80014b70 <__avr32_f64_mul_op2_subnormal+0x36>
80014b58:	ea 0c 11 20 	rsub	r12,r5,32
80014b5c:	f2 05 09 49 	lsl	r9,r9,r5
80014b60:	f0 0c 0a 4c 	lsr	r12,r8,r12
80014b64:	18 49       	or	r9,r12
80014b66:	f0 05 09 48 	lsl	r8,r8,r5
80014b6a:	20 25       	sub	r5,2
80014b6c:	0a 16       	sub	r6,r5
80014b6e:	c8 fb       	rjmp	80014a8c <__avr32_f64_mul+0x30>
80014b70:	f0 05 09 49 	lsl	r9,r8,r5
80014b74:	c4 20       	breq	80014bf8 <__avr32_f64_mul_res_zero>
80014b76:	30 08       	mov	r8,0
80014b78:	20 25       	sub	r5,2
80014b7a:	0a 16       	sub	r6,r5
80014b7c:	c8 8b       	rjmp	80014a8c <__avr32_f64_mul+0x30>

80014b7e <__avr32_f64_mul_op_nan_or_inf>:
80014b7e:	e4 19 00 0f 	andh	r9,0xf
80014b82:	e4 1b 00 0f 	andh	r11,0xf
80014b86:	14 4b       	or	r11,r10
80014b88:	10 49       	or	r9,r8
80014b8a:	e0 47 07 ff 	cp.w	r7,2047
80014b8e:	c0 91       	brne	80014ba0 <__avr32_f64_mul_op1_not_naninf>
80014b90:	58 0b       	cp.w	r11,0
80014b92:	c3 81       	brne	80014c02 <__avr32_f64_mul_res_nan>
80014b94:	e0 46 07 ff 	cp.w	r6,2047
80014b98:	c3 81       	brne	80014c08 <__avr32_f64_mul_res_inf>
80014b9a:	58 09       	cp.w	r9,0
80014b9c:	c3 60       	breq	80014c08 <__avr32_f64_mul_res_inf>
80014b9e:	c3 28       	rjmp	80014c02 <__avr32_f64_mul_res_nan>

80014ba0 <__avr32_f64_mul_op1_not_naninf>:
80014ba0:	58 09       	cp.w	r9,0
80014ba2:	c3 30       	breq	80014c08 <__avr32_f64_mul_res_inf>
80014ba4:	c2 f8       	rjmp	80014c02 <__avr32_f64_mul_res_nan>

80014ba6 <__avr32_f64_mul_res_subnormal>:
80014ba6:	5c 3c       	neg	r12
80014ba8:	2f fc       	sub	r12,-1
80014baa:	f1 bc 04 c0 	satu	r12,0x6
80014bae:	e0 4c 00 20 	cp.w	r12,32
80014bb2:	c1 14       	brge	80014bd4 <__avr32_f64_mul_res_subnormal+0x2e>
80014bb4:	f8 08 11 20 	rsub	r8,r12,32
80014bb8:	0e 46       	or	r6,r7
80014bba:	ee 0c 0a 47 	lsr	r7,r7,r12
80014bbe:	f4 08 09 49 	lsl	r9,r10,r8
80014bc2:	12 47       	or	r7,r9
80014bc4:	f4 0c 0a 4a 	lsr	r10,r10,r12
80014bc8:	f6 08 09 49 	lsl	r9,r11,r8
80014bcc:	12 4a       	or	r10,r9
80014bce:	f6 0c 0a 4b 	lsr	r11,r11,r12
80014bd2:	c8 3b       	rjmp	80014ad8 <__avr32_f64_mul+0x7c>
80014bd4:	f8 08 11 20 	rsub	r8,r12,32
80014bd8:	f9 b9 00 00 	moveq	r9,0
80014bdc:	c0 30       	breq	80014be2 <__avr32_f64_mul_res_subnormal+0x3c>
80014bde:	f6 08 09 49 	lsl	r9,r11,r8
80014be2:	0e 46       	or	r6,r7
80014be4:	ed ea 10 16 	or	r6,r6,r10<<0x1
80014be8:	f4 0c 0a 4a 	lsr	r10,r10,r12
80014bec:	f3 ea 10 07 	or	r7,r9,r10
80014bf0:	f6 0c 0a 4a 	lsr	r10,r11,r12
80014bf4:	30 0b       	mov	r11,0
80014bf6:	c7 1b       	rjmp	80014ad8 <__avr32_f64_mul+0x7c>

80014bf8 <__avr32_f64_mul_res_zero>:
80014bf8:	1c 9b       	mov	r11,lr
80014bfa:	e6 1b 80 00 	andh	r11,0x8000,COH
80014bfe:	30 0a       	mov	r10,0
80014c00:	d8 22       	popm	r4-r7,pc

80014c02 <__avr32_f64_mul_res_nan>:
80014c02:	3f fb       	mov	r11,-1
80014c04:	3f fa       	mov	r10,-1
80014c06:	d8 22       	popm	r4-r7,pc

80014c08 <__avr32_f64_mul_res_inf>:
80014c08:	f0 6b 00 00 	mov	r11,-1048576
80014c0c:	ed be 00 1f 	bld	lr,0x1f
80014c10:	ef bb 00 1f 	bst	r11,0x1f
80014c14:	30 0a       	mov	r10,0
80014c16:	d8 22       	popm	r4-r7,pc

80014c18 <__avr32_f64_mul_op1_zero>:
80014c18:	f7 e9 20 0b 	eor	r11,r11,r9
80014c1c:	e6 1b 80 00 	andh	r11,0x8000,COH
80014c20:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
80014c24:	e0 4c 07 ff 	cp.w	r12,2047
80014c28:	5e 1c       	retne	r12
80014c2a:	3f fa       	mov	r10,-1
80014c2c:	3f fb       	mov	r11,-1
80014c2e:	5e fc       	retal	r12

80014c30 <__avr32_f64_to_u32>:
80014c30:	58 0b       	cp.w	r11,0
80014c32:	5e 6d       	retmi	0

80014c34 <__avr32_f64_to_s32>:
80014c34:	f6 0c 15 01 	lsl	r12,r11,0x1
80014c38:	b5 9c       	lsr	r12,0x15
80014c3a:	e0 2c 03 ff 	sub	r12,1023
80014c3e:	5e 3d       	retlo	0
80014c40:	f8 0c 11 1f 	rsub	r12,r12,31
80014c44:	16 99       	mov	r9,r11
80014c46:	ab 7b       	lsl	r11,0xb
80014c48:	bf bb       	sbr	r11,0x1f
80014c4a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80014c4e:	f6 0c 0a 4b 	lsr	r11,r11,r12
80014c52:	a1 79       	lsl	r9,0x1
80014c54:	5e 2b       	reths	r11
80014c56:	5c 3b       	neg	r11
80014c58:	5e fb       	retal	r11

80014c5a <__avr32_u32_to_f64>:
80014c5a:	f8 cb 00 00 	sub	r11,r12,0
80014c5e:	30 0c       	mov	r12,0
80014c60:	c0 38       	rjmp	80014c66 <__avr32_s32_to_f64+0x4>

80014c62 <__avr32_s32_to_f64>:
80014c62:	18 9b       	mov	r11,r12
80014c64:	5c 4b       	abs	r11
80014c66:	30 0a       	mov	r10,0
80014c68:	5e 0b       	reteq	r11
80014c6a:	d4 01       	pushm	lr
80014c6c:	e0 69 04 1e 	mov	r9,1054
80014c70:	f6 08 12 00 	clz	r8,r11
80014c74:	c1 70       	breq	80014ca2 <__avr32_s32_to_f64+0x40>
80014c76:	c0 c3       	brcs	80014c8e <__avr32_s32_to_f64+0x2c>
80014c78:	f0 0e 11 20 	rsub	lr,r8,32
80014c7c:	f6 08 09 4b 	lsl	r11,r11,r8
80014c80:	f4 0e 0a 4e 	lsr	lr,r10,lr
80014c84:	1c 4b       	or	r11,lr
80014c86:	f4 08 09 4a 	lsl	r10,r10,r8
80014c8a:	10 19       	sub	r9,r8
80014c8c:	c0 b8       	rjmp	80014ca2 <__avr32_s32_to_f64+0x40>
80014c8e:	f4 08 12 00 	clz	r8,r10
80014c92:	f9 b8 03 00 	movlo	r8,0
80014c96:	f7 b8 02 e0 	subhs	r8,-32
80014c9a:	f4 08 09 4b 	lsl	r11,r10,r8
80014c9e:	30 0a       	mov	r10,0
80014ca0:	10 19       	sub	r9,r8
80014ca2:	58 09       	cp.w	r9,0
80014ca4:	e0 89 00 30 	brgt	80014d04 <__avr32_s32_to_f64+0xa2>
80014ca8:	5c 39       	neg	r9
80014caa:	2f f9       	sub	r9,-1
80014cac:	e0 49 00 36 	cp.w	r9,54
80014cb0:	c0 43       	brcs	80014cb8 <__avr32_s32_to_f64+0x56>
80014cb2:	30 0b       	mov	r11,0
80014cb4:	30 0a       	mov	r10,0
80014cb6:	c2 68       	rjmp	80014d02 <__avr32_s32_to_f64+0xa0>
80014cb8:	2f 69       	sub	r9,-10
80014cba:	f2 08 11 20 	rsub	r8,r9,32
80014cbe:	e0 49 00 20 	cp.w	r9,32
80014cc2:	c0 b2       	brcc	80014cd8 <__avr32_s32_to_f64+0x76>
80014cc4:	f4 08 09 4e 	lsl	lr,r10,r8
80014cc8:	f6 08 09 48 	lsl	r8,r11,r8
80014ccc:	f4 09 0a 4a 	lsr	r10,r10,r9
80014cd0:	f6 09 0a 4b 	lsr	r11,r11,r9
80014cd4:	10 4b       	or	r11,r8
80014cd6:	c0 88       	rjmp	80014ce6 <__avr32_s32_to_f64+0x84>
80014cd8:	f6 08 09 4e 	lsl	lr,r11,r8
80014cdc:	14 4e       	or	lr,r10
80014cde:	16 9a       	mov	r10,r11
80014ce0:	30 0b       	mov	r11,0
80014ce2:	f4 09 0a 4a 	lsr	r10,r10,r9
80014ce6:	ed ba 00 00 	bld	r10,0x0
80014cea:	c0 92       	brcc	80014cfc <__avr32_s32_to_f64+0x9a>
80014cec:	1c 7e       	tst	lr,lr
80014cee:	c0 41       	brne	80014cf6 <__avr32_s32_to_f64+0x94>
80014cf0:	ed ba 00 01 	bld	r10,0x1
80014cf4:	c0 42       	brcc	80014cfc <__avr32_s32_to_f64+0x9a>
80014cf6:	2f fa       	sub	r10,-1
80014cf8:	f7 bb 02 ff 	subhs	r11,-1
80014cfc:	5c fc       	rol	r12
80014cfe:	5d 0b       	ror	r11
80014d00:	5d 0a       	ror	r10
80014d02:	d8 02       	popm	pc
80014d04:	e0 68 03 ff 	mov	r8,1023
80014d08:	ed ba 00 0b 	bld	r10,0xb
80014d0c:	f7 b8 00 ff 	subeq	r8,-1
80014d10:	10 0a       	add	r10,r8
80014d12:	5c 0b       	acr	r11
80014d14:	f7 b9 03 fe 	sublo	r9,-2
80014d18:	e0 49 07 ff 	cp.w	r9,2047
80014d1c:	c0 55       	brlt	80014d26 <__avr32_s32_to_f64+0xc4>
80014d1e:	30 0a       	mov	r10,0
80014d20:	fc 1b ff e0 	movh	r11,0xffe0
80014d24:	c0 c8       	rjmp	80014d3c <__floatsidf_return_op1>
80014d26:	ed bb 00 1f 	bld	r11,0x1f
80014d2a:	f7 b9 01 01 	subne	r9,1
80014d2e:	ab 9a       	lsr	r10,0xb
80014d30:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80014d34:	a1 7b       	lsl	r11,0x1
80014d36:	ab 9b       	lsr	r11,0xb
80014d38:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80014d3c <__floatsidf_return_op1>:
80014d3c:	a1 7c       	lsl	r12,0x1
80014d3e:	5d 0b       	ror	r11
80014d40:	d8 02       	popm	pc

80014d42 <__avr32_udiv64>:
80014d42:	d4 31       	pushm	r0-r7,lr
80014d44:	1a 97       	mov	r7,sp
80014d46:	20 3d       	sub	sp,12
80014d48:	10 9c       	mov	r12,r8
80014d4a:	12 9e       	mov	lr,r9
80014d4c:	14 93       	mov	r3,r10
80014d4e:	58 09       	cp.w	r9,0
80014d50:	e0 81 00 bd 	brne	80014eca <__avr32_udiv64+0x188>
80014d54:	16 38       	cp.w	r8,r11
80014d56:	e0 88 00 40 	brls	80014dd6 <__avr32_udiv64+0x94>
80014d5a:	f0 08 12 00 	clz	r8,r8
80014d5e:	c0 d0       	breq	80014d78 <__avr32_udiv64+0x36>
80014d60:	f6 08 09 4b 	lsl	r11,r11,r8
80014d64:	f0 09 11 20 	rsub	r9,r8,32
80014d68:	f8 08 09 4c 	lsl	r12,r12,r8
80014d6c:	f4 09 0a 49 	lsr	r9,r10,r9
80014d70:	f4 08 09 43 	lsl	r3,r10,r8
80014d74:	f3 eb 10 0b 	or	r11,r9,r11
80014d78:	f8 0e 16 10 	lsr	lr,r12,0x10
80014d7c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80014d80:	f6 0e 0d 00 	divu	r0,r11,lr
80014d84:	e6 0b 16 10 	lsr	r11,r3,0x10
80014d88:	00 99       	mov	r9,r0
80014d8a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80014d8e:	e0 0a 02 48 	mul	r8,r0,r10
80014d92:	10 3b       	cp.w	r11,r8
80014d94:	c0 a2       	brcc	80014da8 <__avr32_udiv64+0x66>
80014d96:	20 19       	sub	r9,1
80014d98:	18 0b       	add	r11,r12
80014d9a:	18 3b       	cp.w	r11,r12
80014d9c:	c0 63       	brcs	80014da8 <__avr32_udiv64+0x66>
80014d9e:	10 3b       	cp.w	r11,r8
80014da0:	f7 b9 03 01 	sublo	r9,1
80014da4:	f7 dc e3 0b 	addcs	r11,r11,r12
80014da8:	f6 08 01 01 	sub	r1,r11,r8
80014dac:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80014db0:	e2 0e 0d 00 	divu	r0,r1,lr
80014db4:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80014db8:	00 98       	mov	r8,r0
80014dba:	e0 0a 02 4a 	mul	r10,r0,r10
80014dbe:	14 33       	cp.w	r3,r10
80014dc0:	c0 82       	brcc	80014dd0 <__avr32_udiv64+0x8e>
80014dc2:	20 18       	sub	r8,1
80014dc4:	18 03       	add	r3,r12
80014dc6:	18 33       	cp.w	r3,r12
80014dc8:	c0 43       	brcs	80014dd0 <__avr32_udiv64+0x8e>
80014dca:	14 33       	cp.w	r3,r10
80014dcc:	f7 b8 03 01 	sublo	r8,1
80014dd0:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80014dd4:	cd f8       	rjmp	80014f92 <__avr32_udiv64+0x250>
80014dd6:	58 08       	cp.w	r8,0
80014dd8:	c0 51       	brne	80014de2 <__avr32_udiv64+0xa0>
80014dda:	30 19       	mov	r9,1
80014ddc:	f2 08 0d 08 	divu	r8,r9,r8
80014de0:	10 9c       	mov	r12,r8
80014de2:	f8 06 12 00 	clz	r6,r12
80014de6:	c0 41       	brne	80014dee <__avr32_udiv64+0xac>
80014de8:	18 1b       	sub	r11,r12
80014dea:	30 19       	mov	r9,1
80014dec:	c4 08       	rjmp	80014e6c <__avr32_udiv64+0x12a>
80014dee:	ec 01 11 20 	rsub	r1,r6,32
80014df2:	f4 01 0a 49 	lsr	r9,r10,r1
80014df6:	f8 06 09 4c 	lsl	r12,r12,r6
80014dfa:	f6 06 09 48 	lsl	r8,r11,r6
80014dfe:	f6 01 0a 41 	lsr	r1,r11,r1
80014e02:	f3 e8 10 08 	or	r8,r9,r8
80014e06:	f8 03 16 10 	lsr	r3,r12,0x10
80014e0a:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80014e0e:	e2 03 0d 00 	divu	r0,r1,r3
80014e12:	f0 0b 16 10 	lsr	r11,r8,0x10
80014e16:	00 9e       	mov	lr,r0
80014e18:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80014e1c:	e0 05 02 49 	mul	r9,r0,r5
80014e20:	12 3b       	cp.w	r11,r9
80014e22:	c0 a2       	brcc	80014e36 <__avr32_udiv64+0xf4>
80014e24:	20 1e       	sub	lr,1
80014e26:	18 0b       	add	r11,r12
80014e28:	18 3b       	cp.w	r11,r12
80014e2a:	c0 63       	brcs	80014e36 <__avr32_udiv64+0xf4>
80014e2c:	12 3b       	cp.w	r11,r9
80014e2e:	f7 be 03 01 	sublo	lr,1
80014e32:	f7 dc e3 0b 	addcs	r11,r11,r12
80014e36:	12 1b       	sub	r11,r9
80014e38:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80014e3c:	f6 03 0d 02 	divu	r2,r11,r3
80014e40:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80014e44:	04 99       	mov	r9,r2
80014e46:	e4 05 02 4b 	mul	r11,r2,r5
80014e4a:	16 38       	cp.w	r8,r11
80014e4c:	c0 a2       	brcc	80014e60 <__avr32_udiv64+0x11e>
80014e4e:	20 19       	sub	r9,1
80014e50:	18 08       	add	r8,r12
80014e52:	18 38       	cp.w	r8,r12
80014e54:	c0 63       	brcs	80014e60 <__avr32_udiv64+0x11e>
80014e56:	16 38       	cp.w	r8,r11
80014e58:	f7 b9 03 01 	sublo	r9,1
80014e5c:	f1 dc e3 08 	addcs	r8,r8,r12
80014e60:	f4 06 09 43 	lsl	r3,r10,r6
80014e64:	f0 0b 01 0b 	sub	r11,r8,r11
80014e68:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80014e6c:	f8 06 16 10 	lsr	r6,r12,0x10
80014e70:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80014e74:	f6 06 0d 00 	divu	r0,r11,r6
80014e78:	e6 0b 16 10 	lsr	r11,r3,0x10
80014e7c:	00 9a       	mov	r10,r0
80014e7e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80014e82:	e0 0e 02 48 	mul	r8,r0,lr
80014e86:	10 3b       	cp.w	r11,r8
80014e88:	c0 a2       	brcc	80014e9c <__avr32_udiv64+0x15a>
80014e8a:	20 1a       	sub	r10,1
80014e8c:	18 0b       	add	r11,r12
80014e8e:	18 3b       	cp.w	r11,r12
80014e90:	c0 63       	brcs	80014e9c <__avr32_udiv64+0x15a>
80014e92:	10 3b       	cp.w	r11,r8
80014e94:	f7 ba 03 01 	sublo	r10,1
80014e98:	f7 dc e3 0b 	addcs	r11,r11,r12
80014e9c:	f6 08 01 01 	sub	r1,r11,r8
80014ea0:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80014ea4:	e2 06 0d 00 	divu	r0,r1,r6
80014ea8:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80014eac:	00 98       	mov	r8,r0
80014eae:	e0 0e 02 4b 	mul	r11,r0,lr
80014eb2:	16 33       	cp.w	r3,r11
80014eb4:	c0 82       	brcc	80014ec4 <__avr32_udiv64+0x182>
80014eb6:	20 18       	sub	r8,1
80014eb8:	18 03       	add	r3,r12
80014eba:	18 33       	cp.w	r3,r12
80014ebc:	c0 43       	brcs	80014ec4 <__avr32_udiv64+0x182>
80014ebe:	16 33       	cp.w	r3,r11
80014ec0:	f7 b8 03 01 	sublo	r8,1
80014ec4:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80014ec8:	c6 98       	rjmp	80014f9a <__avr32_udiv64+0x258>
80014eca:	16 39       	cp.w	r9,r11
80014ecc:	e0 8b 00 65 	brhi	80014f96 <__avr32_udiv64+0x254>
80014ed0:	f2 09 12 00 	clz	r9,r9
80014ed4:	c0 b1       	brne	80014eea <__avr32_udiv64+0x1a8>
80014ed6:	10 3a       	cp.w	r10,r8
80014ed8:	5f 2a       	srhs	r10
80014eda:	1c 3b       	cp.w	r11,lr
80014edc:	5f b8       	srhi	r8
80014ede:	10 4a       	or	r10,r8
80014ee0:	f2 0a 18 00 	cp.b	r10,r9
80014ee4:	c5 90       	breq	80014f96 <__avr32_udiv64+0x254>
80014ee6:	30 18       	mov	r8,1
80014ee8:	c5 98       	rjmp	80014f9a <__avr32_udiv64+0x258>
80014eea:	f0 09 09 46 	lsl	r6,r8,r9
80014eee:	f2 03 11 20 	rsub	r3,r9,32
80014ef2:	fc 09 09 4e 	lsl	lr,lr,r9
80014ef6:	f0 03 0a 48 	lsr	r8,r8,r3
80014efa:	f6 09 09 4c 	lsl	r12,r11,r9
80014efe:	f4 03 0a 42 	lsr	r2,r10,r3
80014f02:	ef 46 ff f4 	st.w	r7[-12],r6
80014f06:	f6 03 0a 43 	lsr	r3,r11,r3
80014f0a:	18 42       	or	r2,r12
80014f0c:	f1 ee 10 0c 	or	r12,r8,lr
80014f10:	f8 01 16 10 	lsr	r1,r12,0x10
80014f14:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80014f18:	e6 01 0d 04 	divu	r4,r3,r1
80014f1c:	e4 03 16 10 	lsr	r3,r2,0x10
80014f20:	08 9e       	mov	lr,r4
80014f22:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80014f26:	e8 06 02 48 	mul	r8,r4,r6
80014f2a:	10 33       	cp.w	r3,r8
80014f2c:	c0 a2       	brcc	80014f40 <__avr32_udiv64+0x1fe>
80014f2e:	20 1e       	sub	lr,1
80014f30:	18 03       	add	r3,r12
80014f32:	18 33       	cp.w	r3,r12
80014f34:	c0 63       	brcs	80014f40 <__avr32_udiv64+0x1fe>
80014f36:	10 33       	cp.w	r3,r8
80014f38:	f7 be 03 01 	sublo	lr,1
80014f3c:	e7 dc e3 03 	addcs	r3,r3,r12
80014f40:	10 13       	sub	r3,r8
80014f42:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80014f46:	e6 01 0d 00 	divu	r0,r3,r1
80014f4a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80014f4e:	00 98       	mov	r8,r0
80014f50:	e0 06 02 46 	mul	r6,r0,r6
80014f54:	0c 3b       	cp.w	r11,r6
80014f56:	c0 a2       	brcc	80014f6a <__avr32_udiv64+0x228>
80014f58:	20 18       	sub	r8,1
80014f5a:	18 0b       	add	r11,r12
80014f5c:	18 3b       	cp.w	r11,r12
80014f5e:	c0 63       	brcs	80014f6a <__avr32_udiv64+0x228>
80014f60:	0c 3b       	cp.w	r11,r6
80014f62:	f7 dc e3 0b 	addcs	r11,r11,r12
80014f66:	f7 b8 03 01 	sublo	r8,1
80014f6a:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80014f6e:	ee f4 ff f4 	ld.w	r4,r7[-12]
80014f72:	0c 1b       	sub	r11,r6
80014f74:	f0 04 06 42 	mulu.d	r2,r8,r4
80014f78:	06 95       	mov	r5,r3
80014f7a:	16 35       	cp.w	r5,r11
80014f7c:	e0 8b 00 0a 	brhi	80014f90 <__avr32_udiv64+0x24e>
80014f80:	5f 0b       	sreq	r11
80014f82:	f4 09 09 49 	lsl	r9,r10,r9
80014f86:	12 32       	cp.w	r2,r9
80014f88:	5f b9       	srhi	r9
80014f8a:	f7 e9 00 09 	and	r9,r11,r9
80014f8e:	c0 60       	breq	80014f9a <__avr32_udiv64+0x258>
80014f90:	20 18       	sub	r8,1
80014f92:	30 09       	mov	r9,0
80014f94:	c0 38       	rjmp	80014f9a <__avr32_udiv64+0x258>
80014f96:	30 09       	mov	r9,0
80014f98:	12 98       	mov	r8,r9
80014f9a:	10 9a       	mov	r10,r8
80014f9c:	12 93       	mov	r3,r9
80014f9e:	10 92       	mov	r2,r8
80014fa0:	12 9b       	mov	r11,r9
80014fa2:	2f dd       	sub	sp,-12
80014fa4:	d8 32       	popm	r0-r7,pc
80014fa6:	d7 03       	nop

80014fa8 <getenv>:
80014fa8:	d4 01       	pushm	lr
80014faa:	20 1d       	sub	sp,4
80014fac:	e0 68 01 20 	mov	r8,288
80014fb0:	18 9b       	mov	r11,r12
80014fb2:	1a 9a       	mov	r10,sp
80014fb4:	70 0c       	ld.w	r12,r8[0x0]
80014fb6:	c0 3c       	rcall	80014fbc <_findenv_r>
80014fb8:	2f fd       	sub	sp,-4
80014fba:	d8 02       	popm	pc

80014fbc <_findenv_r>:
80014fbc:	d4 31       	pushm	r0-r7,lr
80014fbe:	16 94       	mov	r4,r11
80014fc0:	14 92       	mov	r2,r10
80014fc2:	18 95       	mov	r5,r12
80014fc4:	e0 a0 26 b6 	rcall	80019d30 <__env_lock>
80014fc8:	e0 68 05 34 	mov	r8,1332
80014fcc:	70 07       	ld.w	r7,r8[0x0]
80014fce:	58 07       	cp.w	r7,0
80014fd0:	c0 50       	breq	80014fda <_findenv_r+0x1e>
80014fd2:	30 06       	mov	r6,0
80014fd4:	33 da       	mov	r10,61
80014fd6:	0c 98       	mov	r8,r6
80014fd8:	c0 78       	rjmp	80014fe6 <_findenv_r+0x2a>
80014fda:	0a 9c       	mov	r12,r5
80014fdc:	e0 a0 26 ab 	rcall	80019d32 <__env_unlock>
80014fe0:	0e 9c       	mov	r12,r7
80014fe2:	d8 32       	popm	r0-r7,pc
80014fe4:	2f f6       	sub	r6,-1
80014fe6:	e8 06 07 09 	ld.ub	r9,r4[r6]
80014fea:	f0 09 18 00 	cp.b	r9,r8
80014fee:	5f 1b       	srne	r11
80014ff0:	f4 09 18 00 	cp.b	r9,r10
80014ff4:	5f 19       	srne	r9
80014ff6:	16 69       	and	r9,r11
80014ff8:	f0 09 18 00 	cp.b	r9,r8
80014ffc:	cf 41       	brne	80014fe4 <_findenv_r+0x28>
80014ffe:	c1 b8       	rjmp	80015034 <_findenv_r+0x78>
80015000:	02 9c       	mov	r12,r1
80015002:	0c 9a       	mov	r10,r6
80015004:	08 9b       	mov	r11,r4
80015006:	e0 a0 03 68 	rcall	800156d6 <strncmp>
8001500a:	c1 31       	brne	80015030 <_findenv_r+0x74>
8001500c:	6e 01       	ld.w	r1,r7[0x0]
8001500e:	0c 01       	add	r1,r6
80015010:	03 88       	ld.ub	r8,r1[0x0]
80015012:	e6 08 18 00 	cp.b	r8,r3
80015016:	c0 d1       	brne	80015030 <_findenv_r+0x74>
80015018:	e0 68 05 34 	mov	r8,1332
8001501c:	70 08       	ld.w	r8,r8[0x0]
8001501e:	0a 9c       	mov	r12,r5
80015020:	10 17       	sub	r7,r8
80015022:	a3 47       	asr	r7,0x2
80015024:	85 07       	st.w	r2[0x0],r7
80015026:	e0 a0 26 86 	rcall	80019d32 <__env_unlock>
8001502a:	e2 cc ff ff 	sub	r12,r1,-1
8001502e:	d8 32       	popm	r0-r7,pc
80015030:	2f c7       	sub	r7,-4
80015032:	c0 28       	rjmp	80015036 <_findenv_r+0x7a>
80015034:	33 d3       	mov	r3,61
80015036:	6e 01       	ld.w	r1,r7[0x0]
80015038:	58 01       	cp.w	r1,0
8001503a:	ce 31       	brne	80015000 <_findenv_r+0x44>
8001503c:	0a 9c       	mov	r12,r5
8001503e:	e0 a0 26 7a 	rcall	80019d32 <__env_unlock>
80015042:	02 9c       	mov	r12,r1
80015044:	d8 32       	popm	r0-r7,pc
80015046:	d7 03       	nop

80015048 <free>:
80015048:	d4 01       	pushm	lr
8001504a:	e0 68 01 20 	mov	r8,288
8001504e:	18 9b       	mov	r11,r12
80015050:	70 0c       	ld.w	r12,r8[0x0]
80015052:	e0 a0 28 55 	rcall	8001a0fc <_free_r>
80015056:	d8 02       	popm	pc

80015058 <malloc>:
80015058:	d4 01       	pushm	lr
8001505a:	e0 68 01 20 	mov	r8,288
8001505e:	18 9b       	mov	r11,r12
80015060:	70 0c       	ld.w	r12,r8[0x0]
80015062:	c0 3c       	rcall	80015068 <_malloc_r>
80015064:	d8 02       	popm	pc
80015066:	d7 03       	nop

80015068 <_malloc_r>:
80015068:	d4 31       	pushm	r0-r7,lr
8001506a:	f6 c8 ff f5 	sub	r8,r11,-11
8001506e:	18 95       	mov	r5,r12
80015070:	10 97       	mov	r7,r8
80015072:	e0 17 ff f8 	andl	r7,0xfff8
80015076:	59 68       	cp.w	r8,22
80015078:	f9 b7 08 10 	movls	r7,16
8001507c:	16 37       	cp.w	r7,r11
8001507e:	5f 38       	srlo	r8
80015080:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80015084:	c0 50       	breq	8001508e <_malloc_r+0x26>
80015086:	30 c8       	mov	r8,12
80015088:	99 38       	st.w	r12[0xc],r8
8001508a:	e0 8f 01 f5 	bral	80015474 <_malloc_r+0x40c>
8001508e:	e0 a0 02 c1 	rcall	80015610 <__malloc_lock>
80015092:	e0 47 01 f7 	cp.w	r7,503
80015096:	e0 8b 00 1d 	brhi	800150d0 <_malloc_r+0x68>
8001509a:	ee 03 16 03 	lsr	r3,r7,0x3
8001509e:	e0 68 01 24 	mov	r8,292
800150a2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800150a6:	70 36       	ld.w	r6,r8[0xc]
800150a8:	10 36       	cp.w	r6,r8
800150aa:	c0 61       	brne	800150b6 <_malloc_r+0x4e>
800150ac:	ec c8 ff f8 	sub	r8,r6,-8
800150b0:	70 36       	ld.w	r6,r8[0xc]
800150b2:	10 36       	cp.w	r6,r8
800150b4:	c0 c0       	breq	800150cc <_malloc_r+0x64>
800150b6:	6c 18       	ld.w	r8,r6[0x4]
800150b8:	e0 18 ff fc 	andl	r8,0xfffc
800150bc:	6c 3a       	ld.w	r10,r6[0xc]
800150be:	ec 08 00 09 	add	r9,r6,r8
800150c2:	0a 9c       	mov	r12,r5
800150c4:	6c 28       	ld.w	r8,r6[0x8]
800150c6:	95 28       	st.w	r10[0x8],r8
800150c8:	91 3a       	st.w	r8[0xc],r10
800150ca:	c4 78       	rjmp	80015158 <_malloc_r+0xf0>
800150cc:	2f e3       	sub	r3,-2
800150ce:	c4 d8       	rjmp	80015168 <_malloc_r+0x100>
800150d0:	ee 03 16 09 	lsr	r3,r7,0x9
800150d4:	c0 41       	brne	800150dc <_malloc_r+0x74>
800150d6:	ee 03 16 03 	lsr	r3,r7,0x3
800150da:	c2 68       	rjmp	80015126 <_malloc_r+0xbe>
800150dc:	58 43       	cp.w	r3,4
800150de:	e0 8b 00 06 	brhi	800150ea <_malloc_r+0x82>
800150e2:	ee 03 16 06 	lsr	r3,r7,0x6
800150e6:	2c 83       	sub	r3,-56
800150e8:	c1 f8       	rjmp	80015126 <_malloc_r+0xbe>
800150ea:	59 43       	cp.w	r3,20
800150ec:	e0 8b 00 04 	brhi	800150f4 <_malloc_r+0x8c>
800150f0:	2a 53       	sub	r3,-91
800150f2:	c1 a8       	rjmp	80015126 <_malloc_r+0xbe>
800150f4:	e0 43 00 54 	cp.w	r3,84
800150f8:	e0 8b 00 06 	brhi	80015104 <_malloc_r+0x9c>
800150fc:	ee 03 16 0c 	lsr	r3,r7,0xc
80015100:	29 23       	sub	r3,-110
80015102:	c1 28       	rjmp	80015126 <_malloc_r+0xbe>
80015104:	e0 43 01 54 	cp.w	r3,340
80015108:	e0 8b 00 06 	brhi	80015114 <_malloc_r+0xac>
8001510c:	ee 03 16 0f 	lsr	r3,r7,0xf
80015110:	28 93       	sub	r3,-119
80015112:	c0 a8       	rjmp	80015126 <_malloc_r+0xbe>
80015114:	e0 43 05 54 	cp.w	r3,1364
80015118:	e0 88 00 04 	brls	80015120 <_malloc_r+0xb8>
8001511c:	37 e3       	mov	r3,126
8001511e:	c0 48       	rjmp	80015126 <_malloc_r+0xbe>
80015120:	ee 03 16 12 	lsr	r3,r7,0x12
80015124:	28 43       	sub	r3,-124
80015126:	e0 6a 01 24 	mov	r10,292
8001512a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8001512e:	74 36       	ld.w	r6,r10[0xc]
80015130:	c1 98       	rjmp	80015162 <_malloc_r+0xfa>
80015132:	6c 19       	ld.w	r9,r6[0x4]
80015134:	e0 19 ff fc 	andl	r9,0xfffc
80015138:	f2 07 01 0b 	sub	r11,r9,r7
8001513c:	58 fb       	cp.w	r11,15
8001513e:	e0 8a 00 04 	brle	80015146 <_malloc_r+0xde>
80015142:	20 13       	sub	r3,1
80015144:	c1 18       	rjmp	80015166 <_malloc_r+0xfe>
80015146:	6c 38       	ld.w	r8,r6[0xc]
80015148:	58 0b       	cp.w	r11,0
8001514a:	c0 b5       	brlt	80015160 <_malloc_r+0xf8>
8001514c:	6c 2a       	ld.w	r10,r6[0x8]
8001514e:	ec 09 00 09 	add	r9,r6,r9
80015152:	0a 9c       	mov	r12,r5
80015154:	91 2a       	st.w	r8[0x8],r10
80015156:	95 38       	st.w	r10[0xc],r8
80015158:	72 18       	ld.w	r8,r9[0x4]
8001515a:	a1 a8       	sbr	r8,0x0
8001515c:	93 18       	st.w	r9[0x4],r8
8001515e:	cb c8       	rjmp	800152d6 <_malloc_r+0x26e>
80015160:	10 96       	mov	r6,r8
80015162:	14 36       	cp.w	r6,r10
80015164:	ce 71       	brne	80015132 <_malloc_r+0xca>
80015166:	2f f3       	sub	r3,-1
80015168:	e0 6a 01 24 	mov	r10,292
8001516c:	f4 cc ff f8 	sub	r12,r10,-8
80015170:	78 26       	ld.w	r6,r12[0x8]
80015172:	18 36       	cp.w	r6,r12
80015174:	c6 c0       	breq	8001524c <_malloc_r+0x1e4>
80015176:	6c 19       	ld.w	r9,r6[0x4]
80015178:	e0 19 ff fc 	andl	r9,0xfffc
8001517c:	f2 07 01 08 	sub	r8,r9,r7
80015180:	58 f8       	cp.w	r8,15
80015182:	e0 89 00 8f 	brgt	800152a0 <_malloc_r+0x238>
80015186:	99 3c       	st.w	r12[0xc],r12
80015188:	99 2c       	st.w	r12[0x8],r12
8001518a:	58 08       	cp.w	r8,0
8001518c:	c0 55       	brlt	80015196 <_malloc_r+0x12e>
8001518e:	ec 09 00 09 	add	r9,r6,r9
80015192:	0a 9c       	mov	r12,r5
80015194:	ce 2b       	rjmp	80015158 <_malloc_r+0xf0>
80015196:	e0 49 01 ff 	cp.w	r9,511
8001519a:	e0 8b 00 13 	brhi	800151c0 <_malloc_r+0x158>
8001519e:	a3 99       	lsr	r9,0x3
800151a0:	f4 09 00 38 	add	r8,r10,r9<<0x3
800151a4:	70 2b       	ld.w	r11,r8[0x8]
800151a6:	8d 38       	st.w	r6[0xc],r8
800151a8:	8d 2b       	st.w	r6[0x8],r11
800151aa:	97 36       	st.w	r11[0xc],r6
800151ac:	91 26       	st.w	r8[0x8],r6
800151ae:	a3 49       	asr	r9,0x2
800151b0:	74 18       	ld.w	r8,r10[0x4]
800151b2:	30 1b       	mov	r11,1
800151b4:	f6 09 09 49 	lsl	r9,r11,r9
800151b8:	f1 e9 10 09 	or	r9,r8,r9
800151bc:	95 19       	st.w	r10[0x4],r9
800151be:	c4 78       	rjmp	8001524c <_malloc_r+0x1e4>
800151c0:	f2 0a 16 09 	lsr	r10,r9,0x9
800151c4:	58 4a       	cp.w	r10,4
800151c6:	e0 8b 00 07 	brhi	800151d4 <_malloc_r+0x16c>
800151ca:	f2 0a 16 06 	lsr	r10,r9,0x6
800151ce:	2c 8a       	sub	r10,-56
800151d0:	c2 08       	rjmp	80015210 <_malloc_r+0x1a8>
800151d2:	d7 03       	nop
800151d4:	59 4a       	cp.w	r10,20
800151d6:	e0 8b 00 04 	brhi	800151de <_malloc_r+0x176>
800151da:	2a 5a       	sub	r10,-91
800151dc:	c1 a8       	rjmp	80015210 <_malloc_r+0x1a8>
800151de:	e0 4a 00 54 	cp.w	r10,84
800151e2:	e0 8b 00 06 	brhi	800151ee <_malloc_r+0x186>
800151e6:	f2 0a 16 0c 	lsr	r10,r9,0xc
800151ea:	29 2a       	sub	r10,-110
800151ec:	c1 28       	rjmp	80015210 <_malloc_r+0x1a8>
800151ee:	e0 4a 01 54 	cp.w	r10,340
800151f2:	e0 8b 00 06 	brhi	800151fe <_malloc_r+0x196>
800151f6:	f2 0a 16 0f 	lsr	r10,r9,0xf
800151fa:	28 9a       	sub	r10,-119
800151fc:	c0 a8       	rjmp	80015210 <_malloc_r+0x1a8>
800151fe:	e0 4a 05 54 	cp.w	r10,1364
80015202:	e0 88 00 04 	brls	8001520a <_malloc_r+0x1a2>
80015206:	37 ea       	mov	r10,126
80015208:	c0 48       	rjmp	80015210 <_malloc_r+0x1a8>
8001520a:	f2 0a 16 12 	lsr	r10,r9,0x12
8001520e:	28 4a       	sub	r10,-124
80015210:	e0 6b 01 24 	mov	r11,292
80015214:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80015218:	68 28       	ld.w	r8,r4[0x8]
8001521a:	08 38       	cp.w	r8,r4
8001521c:	c0 e1       	brne	80015238 <_malloc_r+0x1d0>
8001521e:	76 19       	ld.w	r9,r11[0x4]
80015220:	a3 4a       	asr	r10,0x2
80015222:	30 1e       	mov	lr,1
80015224:	fc 0a 09 4a 	lsl	r10,lr,r10
80015228:	f3 ea 10 0a 	or	r10,r9,r10
8001522c:	10 99       	mov	r9,r8
8001522e:	97 1a       	st.w	r11[0x4],r10
80015230:	c0 a8       	rjmp	80015244 <_malloc_r+0x1dc>
80015232:	70 28       	ld.w	r8,r8[0x8]
80015234:	08 38       	cp.w	r8,r4
80015236:	c0 60       	breq	80015242 <_malloc_r+0x1da>
80015238:	70 1a       	ld.w	r10,r8[0x4]
8001523a:	e0 1a ff fc 	andl	r10,0xfffc
8001523e:	14 39       	cp.w	r9,r10
80015240:	cf 93       	brcs	80015232 <_malloc_r+0x1ca>
80015242:	70 39       	ld.w	r9,r8[0xc]
80015244:	8d 39       	st.w	r6[0xc],r9
80015246:	8d 28       	st.w	r6[0x8],r8
80015248:	91 36       	st.w	r8[0xc],r6
8001524a:	93 26       	st.w	r9[0x8],r6
8001524c:	e6 08 14 02 	asr	r8,r3,0x2
80015250:	30 1b       	mov	r11,1
80015252:	e0 64 01 24 	mov	r4,292
80015256:	f6 08 09 4b 	lsl	r11,r11,r8
8001525a:	68 18       	ld.w	r8,r4[0x4]
8001525c:	10 3b       	cp.w	r11,r8
8001525e:	e0 8b 00 69 	brhi	80015330 <_malloc_r+0x2c8>
80015262:	f7 e8 00 09 	and	r9,r11,r8
80015266:	c0 b1       	brne	8001527c <_malloc_r+0x214>
80015268:	e0 13 ff fc 	andl	r3,0xfffc
8001526c:	a1 7b       	lsl	r11,0x1
8001526e:	2f c3       	sub	r3,-4
80015270:	c0 38       	rjmp	80015276 <_malloc_r+0x20e>
80015272:	2f c3       	sub	r3,-4
80015274:	a1 7b       	lsl	r11,0x1
80015276:	f7 e8 00 09 	and	r9,r11,r8
8001527a:	cf c0       	breq	80015272 <_malloc_r+0x20a>
8001527c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80015280:	06 92       	mov	r2,r3
80015282:	1c 91       	mov	r1,lr
80015284:	62 36       	ld.w	r6,r1[0xc]
80015286:	c2 d8       	rjmp	800152e0 <_malloc_r+0x278>
80015288:	6c 1a       	ld.w	r10,r6[0x4]
8001528a:	e0 1a ff fc 	andl	r10,0xfffc
8001528e:	f4 07 01 08 	sub	r8,r10,r7
80015292:	58 f8       	cp.w	r8,15
80015294:	e0 8a 00 15 	brle	800152be <_malloc_r+0x256>
80015298:	6c 3a       	ld.w	r10,r6[0xc]
8001529a:	6c 29       	ld.w	r9,r6[0x8]
8001529c:	95 29       	st.w	r10[0x8],r9
8001529e:	93 3a       	st.w	r9[0xc],r10
800152a0:	0e 99       	mov	r9,r7
800152a2:	ec 07 00 07 	add	r7,r6,r7
800152a6:	a1 a9       	sbr	r9,0x0
800152a8:	99 37       	st.w	r12[0xc],r7
800152aa:	99 27       	st.w	r12[0x8],r7
800152ac:	8d 19       	st.w	r6[0x4],r9
800152ae:	ee 08 09 08 	st.w	r7[r8],r8
800152b2:	8f 2c       	st.w	r7[0x8],r12
800152b4:	8f 3c       	st.w	r7[0xc],r12
800152b6:	a1 a8       	sbr	r8,0x0
800152b8:	0a 9c       	mov	r12,r5
800152ba:	8f 18       	st.w	r7[0x4],r8
800152bc:	c0 d8       	rjmp	800152d6 <_malloc_r+0x26e>
800152be:	6c 39       	ld.w	r9,r6[0xc]
800152c0:	58 08       	cp.w	r8,0
800152c2:	c0 e5       	brlt	800152de <_malloc_r+0x276>
800152c4:	ec 0a 00 0a 	add	r10,r6,r10
800152c8:	74 18       	ld.w	r8,r10[0x4]
800152ca:	a1 a8       	sbr	r8,0x0
800152cc:	0a 9c       	mov	r12,r5
800152ce:	95 18       	st.w	r10[0x4],r8
800152d0:	6c 28       	ld.w	r8,r6[0x8]
800152d2:	93 28       	st.w	r9[0x8],r8
800152d4:	91 39       	st.w	r8[0xc],r9
800152d6:	c9 ed       	rcall	80015612 <__malloc_unlock>
800152d8:	ec cc ff f8 	sub	r12,r6,-8
800152dc:	d8 32       	popm	r0-r7,pc
800152de:	12 96       	mov	r6,r9
800152e0:	02 36       	cp.w	r6,r1
800152e2:	cd 31       	brne	80015288 <_malloc_r+0x220>
800152e4:	2f f2       	sub	r2,-1
800152e6:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800152ea:	c0 30       	breq	800152f0 <_malloc_r+0x288>
800152ec:	2f 81       	sub	r1,-8
800152ee:	cc bb       	rjmp	80015284 <_malloc_r+0x21c>
800152f0:	1c 98       	mov	r8,lr
800152f2:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800152f6:	c0 81       	brne	80015306 <_malloc_r+0x29e>
800152f8:	68 19       	ld.w	r9,r4[0x4]
800152fa:	f6 08 11 ff 	rsub	r8,r11,-1
800152fe:	f3 e8 00 08 	and	r8,r9,r8
80015302:	89 18       	st.w	r4[0x4],r8
80015304:	c0 78       	rjmp	80015312 <_malloc_r+0x2aa>
80015306:	f0 c9 00 08 	sub	r9,r8,8
8001530a:	20 13       	sub	r3,1
8001530c:	70 08       	ld.w	r8,r8[0x0]
8001530e:	12 38       	cp.w	r8,r9
80015310:	cf 10       	breq	800152f2 <_malloc_r+0x28a>
80015312:	a1 7b       	lsl	r11,0x1
80015314:	68 18       	ld.w	r8,r4[0x4]
80015316:	10 3b       	cp.w	r11,r8
80015318:	e0 8b 00 0c 	brhi	80015330 <_malloc_r+0x2c8>
8001531c:	58 0b       	cp.w	r11,0
8001531e:	c0 90       	breq	80015330 <_malloc_r+0x2c8>
80015320:	04 93       	mov	r3,r2
80015322:	c0 38       	rjmp	80015328 <_malloc_r+0x2c0>
80015324:	2f c3       	sub	r3,-4
80015326:	a1 7b       	lsl	r11,0x1
80015328:	f7 e8 00 09 	and	r9,r11,r8
8001532c:	ca 81       	brne	8001527c <_malloc_r+0x214>
8001532e:	cf bb       	rjmp	80015324 <_malloc_r+0x2bc>
80015330:	68 23       	ld.w	r3,r4[0x8]
80015332:	66 12       	ld.w	r2,r3[0x4]
80015334:	e0 12 ff fc 	andl	r2,0xfffc
80015338:	0e 32       	cp.w	r2,r7
8001533a:	5f 39       	srlo	r9
8001533c:	e4 07 01 08 	sub	r8,r2,r7
80015340:	58 f8       	cp.w	r8,15
80015342:	5f aa       	srle	r10
80015344:	f5 e9 10 09 	or	r9,r10,r9
80015348:	e0 80 00 98 	breq	80015478 <_malloc_r+0x410>
8001534c:	e0 68 07 90 	mov	r8,1936
80015350:	70 01       	ld.w	r1,r8[0x0]
80015352:	e0 68 05 30 	mov	r8,1328
80015356:	2f 01       	sub	r1,-16
80015358:	70 08       	ld.w	r8,r8[0x0]
8001535a:	0e 01       	add	r1,r7
8001535c:	5b f8       	cp.w	r8,-1
8001535e:	c0 40       	breq	80015366 <_malloc_r+0x2fe>
80015360:	28 11       	sub	r1,-127
80015362:	e0 11 ff 80 	andl	r1,0xff80
80015366:	02 9b       	mov	r11,r1
80015368:	0a 9c       	mov	r12,r5
8001536a:	c5 5d       	rcall	80015614 <_sbrk_r>
8001536c:	18 96       	mov	r6,r12
8001536e:	5b fc       	cp.w	r12,-1
80015370:	c7 40       	breq	80015458 <_malloc_r+0x3f0>
80015372:	e6 02 00 08 	add	r8,r3,r2
80015376:	10 3c       	cp.w	r12,r8
80015378:	c0 32       	brcc	8001537e <_malloc_r+0x316>
8001537a:	08 33       	cp.w	r3,r4
8001537c:	c6 e1       	brne	80015458 <_malloc_r+0x3f0>
8001537e:	e0 6a 07 94 	mov	r10,1940
80015382:	74 09       	ld.w	r9,r10[0x0]
80015384:	e2 09 00 09 	add	r9,r1,r9
80015388:	95 09       	st.w	r10[0x0],r9
8001538a:	10 36       	cp.w	r6,r8
8001538c:	c0 a1       	brne	800153a0 <_malloc_r+0x338>
8001538e:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80015392:	c0 71       	brne	800153a0 <_malloc_r+0x338>
80015394:	e2 02 00 02 	add	r2,r1,r2
80015398:	68 28       	ld.w	r8,r4[0x8]
8001539a:	a1 a2       	sbr	r2,0x0
8001539c:	91 12       	st.w	r8[0x4],r2
8001539e:	c4 e8       	rjmp	8001543a <_malloc_r+0x3d2>
800153a0:	e0 6a 05 30 	mov	r10,1328
800153a4:	74 0b       	ld.w	r11,r10[0x0]
800153a6:	5b fb       	cp.w	r11,-1
800153a8:	c0 31       	brne	800153ae <_malloc_r+0x346>
800153aa:	95 06       	st.w	r10[0x0],r6
800153ac:	c0 78       	rjmp	800153ba <_malloc_r+0x352>
800153ae:	ec 09 00 09 	add	r9,r6,r9
800153b2:	e0 6a 07 94 	mov	r10,1940
800153b6:	10 19       	sub	r9,r8
800153b8:	95 09       	st.w	r10[0x0],r9
800153ba:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800153be:	f0 09 11 08 	rsub	r9,r8,8
800153c2:	58 08       	cp.w	r8,0
800153c4:	f2 08 17 10 	movne	r8,r9
800153c8:	ed d8 e1 06 	addne	r6,r6,r8
800153cc:	28 08       	sub	r8,-128
800153ce:	ec 01 00 01 	add	r1,r6,r1
800153d2:	0a 9c       	mov	r12,r5
800153d4:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800153d8:	f0 01 01 01 	sub	r1,r8,r1
800153dc:	02 9b       	mov	r11,r1
800153de:	c1 bd       	rcall	80015614 <_sbrk_r>
800153e0:	e0 68 07 94 	mov	r8,1940
800153e4:	5b fc       	cp.w	r12,-1
800153e6:	ec 0c 17 00 	moveq	r12,r6
800153ea:	f9 b1 00 00 	moveq	r1,0
800153ee:	70 09       	ld.w	r9,r8[0x0]
800153f0:	0c 1c       	sub	r12,r6
800153f2:	89 26       	st.w	r4[0x8],r6
800153f4:	02 0c       	add	r12,r1
800153f6:	12 01       	add	r1,r9
800153f8:	a1 ac       	sbr	r12,0x0
800153fa:	91 01       	st.w	r8[0x0],r1
800153fc:	8d 1c       	st.w	r6[0x4],r12
800153fe:	08 33       	cp.w	r3,r4
80015400:	c1 d0       	breq	8001543a <_malloc_r+0x3d2>
80015402:	58 f2       	cp.w	r2,15
80015404:	e0 8b 00 05 	brhi	8001540e <_malloc_r+0x3a6>
80015408:	30 18       	mov	r8,1
8001540a:	8d 18       	st.w	r6[0x4],r8
8001540c:	c2 68       	rjmp	80015458 <_malloc_r+0x3f0>
8001540e:	30 59       	mov	r9,5
80015410:	20 c2       	sub	r2,12
80015412:	e0 12 ff f8 	andl	r2,0xfff8
80015416:	e6 02 00 08 	add	r8,r3,r2
8001541a:	91 29       	st.w	r8[0x8],r9
8001541c:	91 19       	st.w	r8[0x4],r9
8001541e:	66 18       	ld.w	r8,r3[0x4]
80015420:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80015424:	e5 e8 10 08 	or	r8,r2,r8
80015428:	87 18       	st.w	r3[0x4],r8
8001542a:	58 f2       	cp.w	r2,15
8001542c:	e0 88 00 07 	brls	8001543a <_malloc_r+0x3d2>
80015430:	e6 cb ff f8 	sub	r11,r3,-8
80015434:	0a 9c       	mov	r12,r5
80015436:	e0 a0 26 63 	rcall	8001a0fc <_free_r>
8001543a:	e0 69 07 8c 	mov	r9,1932
8001543e:	72 0a       	ld.w	r10,r9[0x0]
80015440:	e0 68 07 94 	mov	r8,1940
80015444:	70 08       	ld.w	r8,r8[0x0]
80015446:	14 38       	cp.w	r8,r10
80015448:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8001544c:	e0 69 07 88 	mov	r9,1928
80015450:	72 0a       	ld.w	r10,r9[0x0]
80015452:	14 38       	cp.w	r8,r10
80015454:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80015458:	68 28       	ld.w	r8,r4[0x8]
8001545a:	70 18       	ld.w	r8,r8[0x4]
8001545c:	e0 18 ff fc 	andl	r8,0xfffc
80015460:	0e 38       	cp.w	r8,r7
80015462:	5f 39       	srlo	r9
80015464:	0e 18       	sub	r8,r7
80015466:	58 f8       	cp.w	r8,15
80015468:	5f aa       	srle	r10
8001546a:	f5 e9 10 09 	or	r9,r10,r9
8001546e:	c0 50       	breq	80015478 <_malloc_r+0x410>
80015470:	0a 9c       	mov	r12,r5
80015472:	cd 0c       	rcall	80015612 <__malloc_unlock>
80015474:	d8 3a       	popm	r0-r7,pc,r12=0
80015476:	d7 03       	nop
80015478:	68 26       	ld.w	r6,r4[0x8]
8001547a:	a1 a8       	sbr	r8,0x0
8001547c:	0e 99       	mov	r9,r7
8001547e:	a1 a9       	sbr	r9,0x0
80015480:	8d 19       	st.w	r6[0x4],r9
80015482:	ec 07 00 07 	add	r7,r6,r7
80015486:	0a 9c       	mov	r12,r5
80015488:	89 27       	st.w	r4[0x8],r7
8001548a:	8f 18       	st.w	r7[0x4],r8
8001548c:	cc 3c       	rcall	80015612 <__malloc_unlock>
8001548e:	ec cc ff f8 	sub	r12,r6,-8
80015492:	d8 32       	popm	r0-r7,pc

80015494 <memcmp>:
80015494:	d4 01       	pushm	lr
80015496:	30 08       	mov	r8,0
80015498:	c0 d8       	rjmp	800154b2 <memcmp+0x1e>
8001549a:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8001549e:	f6 08 07 09 	ld.ub	r9,r11[r8]
800154a2:	20 1a       	sub	r10,1
800154a4:	2f f8       	sub	r8,-1
800154a6:	f2 0e 18 00 	cp.b	lr,r9
800154aa:	c0 40       	breq	800154b2 <memcmp+0x1e>
800154ac:	fc 09 01 0c 	sub	r12,lr,r9
800154b0:	d8 02       	popm	pc
800154b2:	58 0a       	cp.w	r10,0
800154b4:	cf 31       	brne	8001549a <memcmp+0x6>
800154b6:	14 9c       	mov	r12,r10
800154b8:	d8 02       	popm	pc

800154ba <memcpy>:
800154ba:	58 8a       	cp.w	r10,8
800154bc:	c2 f5       	brlt	8001551a <memcpy+0x60>
800154be:	f9 eb 10 09 	or	r9,r12,r11
800154c2:	e2 19 00 03 	andl	r9,0x3,COH
800154c6:	e0 81 00 97 	brne	800155f4 <memcpy+0x13a>
800154ca:	e0 4a 00 20 	cp.w	r10,32
800154ce:	c3 b4       	brge	80015544 <memcpy+0x8a>
800154d0:	f4 08 14 02 	asr	r8,r10,0x2
800154d4:	f0 09 11 08 	rsub	r9,r8,8
800154d8:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800154dc:	76 69       	ld.w	r9,r11[0x18]
800154de:	99 69       	st.w	r12[0x18],r9
800154e0:	76 59       	ld.w	r9,r11[0x14]
800154e2:	99 59       	st.w	r12[0x14],r9
800154e4:	76 49       	ld.w	r9,r11[0x10]
800154e6:	99 49       	st.w	r12[0x10],r9
800154e8:	76 39       	ld.w	r9,r11[0xc]
800154ea:	99 39       	st.w	r12[0xc],r9
800154ec:	76 29       	ld.w	r9,r11[0x8]
800154ee:	99 29       	st.w	r12[0x8],r9
800154f0:	76 19       	ld.w	r9,r11[0x4]
800154f2:	99 19       	st.w	r12[0x4],r9
800154f4:	76 09       	ld.w	r9,r11[0x0]
800154f6:	99 09       	st.w	r12[0x0],r9
800154f8:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800154fc:	f8 08 00 28 	add	r8,r12,r8<<0x2
80015500:	e0 1a 00 03 	andl	r10,0x3
80015504:	f4 0a 11 04 	rsub	r10,r10,4
80015508:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8001550c:	17 a9       	ld.ub	r9,r11[0x2]
8001550e:	b0 a9       	st.b	r8[0x2],r9
80015510:	17 99       	ld.ub	r9,r11[0x1]
80015512:	b0 99       	st.b	r8[0x1],r9
80015514:	17 89       	ld.ub	r9,r11[0x0]
80015516:	b0 89       	st.b	r8[0x0],r9
80015518:	5e fc       	retal	r12
8001551a:	f4 0a 11 09 	rsub	r10,r10,9
8001551e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80015522:	17 f9       	ld.ub	r9,r11[0x7]
80015524:	b8 f9       	st.b	r12[0x7],r9
80015526:	17 e9       	ld.ub	r9,r11[0x6]
80015528:	b8 e9       	st.b	r12[0x6],r9
8001552a:	17 d9       	ld.ub	r9,r11[0x5]
8001552c:	b8 d9       	st.b	r12[0x5],r9
8001552e:	17 c9       	ld.ub	r9,r11[0x4]
80015530:	b8 c9       	st.b	r12[0x4],r9
80015532:	17 b9       	ld.ub	r9,r11[0x3]
80015534:	b8 b9       	st.b	r12[0x3],r9
80015536:	17 a9       	ld.ub	r9,r11[0x2]
80015538:	b8 a9       	st.b	r12[0x2],r9
8001553a:	17 99       	ld.ub	r9,r11[0x1]
8001553c:	b8 99       	st.b	r12[0x1],r9
8001553e:	17 89       	ld.ub	r9,r11[0x0]
80015540:	b8 89       	st.b	r12[0x0],r9
80015542:	5e fc       	retal	r12
80015544:	eb cd 40 c0 	pushm	r6-r7,lr
80015548:	18 99       	mov	r9,r12
8001554a:	22 0a       	sub	r10,32
8001554c:	b7 07       	ld.d	r6,r11++
8001554e:	b3 26       	st.d	r9++,r6
80015550:	b7 07       	ld.d	r6,r11++
80015552:	b3 26       	st.d	r9++,r6
80015554:	b7 07       	ld.d	r6,r11++
80015556:	b3 26       	st.d	r9++,r6
80015558:	b7 07       	ld.d	r6,r11++
8001555a:	b3 26       	st.d	r9++,r6
8001555c:	22 0a       	sub	r10,32
8001555e:	cf 74       	brge	8001554c <memcpy+0x92>
80015560:	2f 0a       	sub	r10,-16
80015562:	c0 65       	brlt	8001556e <memcpy+0xb4>
80015564:	b7 07       	ld.d	r6,r11++
80015566:	b3 26       	st.d	r9++,r6
80015568:	b7 07       	ld.d	r6,r11++
8001556a:	b3 26       	st.d	r9++,r6
8001556c:	21 0a       	sub	r10,16
8001556e:	5c 3a       	neg	r10
80015570:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80015574:	d7 03       	nop
80015576:	d7 03       	nop
80015578:	f7 36 00 0e 	ld.ub	r6,r11[14]
8001557c:	f3 66 00 0e 	st.b	r9[14],r6
80015580:	f7 36 00 0d 	ld.ub	r6,r11[13]
80015584:	f3 66 00 0d 	st.b	r9[13],r6
80015588:	f7 36 00 0c 	ld.ub	r6,r11[12]
8001558c:	f3 66 00 0c 	st.b	r9[12],r6
80015590:	f7 36 00 0b 	ld.ub	r6,r11[11]
80015594:	f3 66 00 0b 	st.b	r9[11],r6
80015598:	f7 36 00 0a 	ld.ub	r6,r11[10]
8001559c:	f3 66 00 0a 	st.b	r9[10],r6
800155a0:	f7 36 00 09 	ld.ub	r6,r11[9]
800155a4:	f3 66 00 09 	st.b	r9[9],r6
800155a8:	f7 36 00 08 	ld.ub	r6,r11[8]
800155ac:	f3 66 00 08 	st.b	r9[8],r6
800155b0:	f7 36 00 07 	ld.ub	r6,r11[7]
800155b4:	f3 66 00 07 	st.b	r9[7],r6
800155b8:	f7 36 00 06 	ld.ub	r6,r11[6]
800155bc:	f3 66 00 06 	st.b	r9[6],r6
800155c0:	f7 36 00 05 	ld.ub	r6,r11[5]
800155c4:	f3 66 00 05 	st.b	r9[5],r6
800155c8:	f7 36 00 04 	ld.ub	r6,r11[4]
800155cc:	f3 66 00 04 	st.b	r9[4],r6
800155d0:	f7 36 00 03 	ld.ub	r6,r11[3]
800155d4:	f3 66 00 03 	st.b	r9[3],r6
800155d8:	f7 36 00 02 	ld.ub	r6,r11[2]
800155dc:	f3 66 00 02 	st.b	r9[2],r6
800155e0:	f7 36 00 01 	ld.ub	r6,r11[1]
800155e4:	f3 66 00 01 	st.b	r9[1],r6
800155e8:	f7 36 00 00 	ld.ub	r6,r11[0]
800155ec:	f3 66 00 00 	st.b	r9[0],r6
800155f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800155f4:	20 1a       	sub	r10,1
800155f6:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800155fa:	f8 0a 0b 09 	st.b	r12[r10],r9
800155fe:	cf b1       	brne	800155f4 <memcpy+0x13a>
80015600:	5e fc       	retal	r12

80015602 <memset>:
80015602:	18 98       	mov	r8,r12
80015604:	c0 38       	rjmp	8001560a <memset+0x8>
80015606:	10 cb       	st.b	r8++,r11
80015608:	20 1a       	sub	r10,1
8001560a:	58 0a       	cp.w	r10,0
8001560c:	cf d1       	brne	80015606 <memset+0x4>
8001560e:	5e fc       	retal	r12

80015610 <__malloc_lock>:
80015610:	5e fc       	retal	r12

80015612 <__malloc_unlock>:
80015612:	5e fc       	retal	r12

80015614 <_sbrk_r>:
80015614:	d4 21       	pushm	r4-r7,lr
80015616:	30 08       	mov	r8,0
80015618:	18 97       	mov	r7,r12
8001561a:	e0 66 0d 38 	mov	r6,3384
8001561e:	16 9c       	mov	r12,r11
80015620:	8d 08       	st.w	r6[0x0],r8
80015622:	cd 1c       	rcall	800157c4 <_sbrk>
80015624:	5b fc       	cp.w	r12,-1
80015626:	c0 51       	brne	80015630 <_sbrk_r+0x1c>
80015628:	6c 08       	ld.w	r8,r6[0x0]
8001562a:	58 08       	cp.w	r8,0
8001562c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80015630:	d8 22       	popm	r4-r7,pc
80015632:	d7 03       	nop

80015634 <setjmp>:
80015634:	e9 cc 60 ff 	stm	r12,r0-r7,sp-lr
80015638:	5e fd       	retal	0

8001563a <longjmp>:
8001563a:	e1 cc 60 ff 	ldm	r12,r0-r7,sp-lr
8001563e:	58 0b       	cp.w	r11,0
80015640:	5e 0f       	reteq	1
80015642:	5e fb       	retal	r11

80015644 <sprintf>:
80015644:	d4 01       	pushm	lr
80015646:	21 7d       	sub	sp,92
80015648:	e0 68 ff ff 	mov	r8,65535
8001564c:	ea 18 7f ff 	orh	r8,0x7fff
80015650:	50 58       	stdsp	sp[0x14],r8
80015652:	50 28       	stdsp	sp[0x8],r8
80015654:	e0 68 02 08 	mov	r8,520
80015658:	ba 68       	st.h	sp[0xc],r8
8001565a:	3f f8       	mov	r8,-1
8001565c:	ba 78       	st.h	sp[0xe],r8
8001565e:	e0 68 01 20 	mov	r8,288
80015662:	50 4c       	stdsp	sp[0x10],r12
80015664:	16 9a       	mov	r10,r11
80015666:	50 0c       	stdsp	sp[0x0],r12
80015668:	fa c9 ff a0 	sub	r9,sp,-96
8001566c:	70 0c       	ld.w	r12,r8[0x0]
8001566e:	1a 9b       	mov	r11,sp
80015670:	e0 a0 02 66 	rcall	80015b3c <_vfprintf_r>
80015674:	30 09       	mov	r9,0
80015676:	40 08       	lddsp	r8,sp[0x0]
80015678:	b0 89       	st.b	r8[0x0],r9
8001567a:	2e 9d       	sub	sp,-92
8001567c:	d8 02       	popm	pc
8001567e:	d7 03       	nop

80015680 <eofread>:
80015680:	5e fd       	retal	0
80015682:	d7 03       	nop

80015684 <sscanf>:
80015684:	d4 21       	pushm	r4-r7,lr
80015686:	21 7d       	sub	sp,92
80015688:	e0 68 02 04 	mov	r8,516
8001568c:	16 97       	mov	r7,r11
8001568e:	ba 68       	st.h	sp[0xc],r8
80015690:	50 4c       	stdsp	sp[0x10],r12
80015692:	50 0c       	stdsp	sp[0x0],r12
80015694:	c1 6c       	rcall	800156c0 <strlen>
80015696:	30 08       	mov	r8,0
80015698:	51 28       	stdsp	sp[0x48],r8
8001569a:	50 d8       	stdsp	sp[0x34],r8
8001569c:	fe c8 00 1c 	sub	r8,pc,28
800156a0:	50 98       	stdsp	sp[0x24],r8
800156a2:	3f f8       	mov	r8,-1
800156a4:	ba 78       	st.h	sp[0xe],r8
800156a6:	e0 68 01 20 	mov	r8,288
800156aa:	50 5c       	stdsp	sp[0x14],r12
800156ac:	50 1c       	stdsp	sp[0x4],r12
800156ae:	fa c9 ff 90 	sub	r9,sp,-112
800156b2:	0e 9a       	mov	r10,r7
800156b4:	70 0c       	ld.w	r12,r8[0x0]
800156b6:	1a 9b       	mov	r11,sp
800156b8:	e0 a0 11 d8 	rcall	80017a68 <__svfscanf_r>
800156bc:	2e 9d       	sub	sp,-92
800156be:	d8 22       	popm	r4-r7,pc

800156c0 <strlen>:
800156c0:	30 09       	mov	r9,0
800156c2:	18 98       	mov	r8,r12
800156c4:	c0 28       	rjmp	800156c8 <strlen+0x8>
800156c6:	2f f8       	sub	r8,-1
800156c8:	11 8a       	ld.ub	r10,r8[0x0]
800156ca:	f2 0a 18 00 	cp.b	r10,r9
800156ce:	cf c1       	brne	800156c6 <strlen+0x6>
800156d0:	f0 0c 01 0c 	sub	r12,r8,r12
800156d4:	5e fc       	retal	r12

800156d6 <strncmp>:
800156d6:	58 0a       	cp.w	r10,0
800156d8:	c0 81       	brne	800156e8 <strncmp+0x12>
800156da:	5e fa       	retal	r10
800156dc:	58 0a       	cp.w	r10,0
800156de:	c0 b0       	breq	800156f4 <strncmp+0x1e>
800156e0:	58 08       	cp.w	r8,0
800156e2:	c0 90       	breq	800156f4 <strncmp+0x1e>
800156e4:	2f fc       	sub	r12,-1
800156e6:	2f fb       	sub	r11,-1
800156e8:	20 1a       	sub	r10,1
800156ea:	19 88       	ld.ub	r8,r12[0x0]
800156ec:	17 89       	ld.ub	r9,r11[0x0]
800156ee:	f0 09 18 00 	cp.b	r9,r8
800156f2:	cf 50       	breq	800156dc <strncmp+0x6>
800156f4:	19 8c       	ld.ub	r12,r12[0x0]
800156f6:	17 88       	ld.ub	r8,r11[0x0]
800156f8:	10 1c       	sub	r12,r8
800156fa:	5e fc       	retal	r12

800156fc <_init_startup>:
800156fc:	5e fd       	retal	0
800156fe:	d7 03       	nop

80015700 <_close>:
80015700:	30 28       	mov	r8,2
80015702:	d6 73       	breakpoint
80015704:	3f fc       	mov	r12,-1
80015706:	35 8b       	mov	r11,88
80015708:	58 0c       	cp.w	r12,0
8001570a:	5e 4c       	retge	r12
8001570c:	e0 6a 0d 38 	mov	r10,3384
80015710:	95 0b       	st.w	r10[0x0],r11
80015712:	5e fc       	retal	r12

80015714 <_lseek>:
80015714:	30 58       	mov	r8,5
80015716:	d6 73       	breakpoint
80015718:	3f fc       	mov	r12,-1
8001571a:	35 8b       	mov	r11,88
8001571c:	58 0c       	cp.w	r12,0
8001571e:	5e 4c       	retge	r12
80015720:	e0 6a 0d 38 	mov	r10,3384
80015724:	95 0b       	st.w	r10[0x0],r11
80015726:	5e fc       	retal	r12

80015728 <_read>:
80015728:	30 38       	mov	r8,3
8001572a:	d6 73       	breakpoint
8001572c:	3f fc       	mov	r12,-1
8001572e:	35 8b       	mov	r11,88
80015730:	58 0c       	cp.w	r12,0
80015732:	5e 4c       	retge	r12
80015734:	e0 6a 0d 38 	mov	r10,3384
80015738:	95 0b       	st.w	r10[0x0],r11
8001573a:	5e fc       	retal	r12

8001573c <_write>:
8001573c:	30 48       	mov	r8,4
8001573e:	d6 73       	breakpoint
80015740:	3f fc       	mov	r12,-1
80015742:	35 8b       	mov	r11,88
80015744:	58 0c       	cp.w	r12,0
80015746:	5e 4c       	retge	r12
80015748:	e0 6a 0d 38 	mov	r10,3384
8001574c:	95 0b       	st.w	r10[0x0],r11
8001574e:	5e fc       	retal	r12

80015750 <isatty>:
80015750:	30 b8       	mov	r8,11
80015752:	d6 73       	breakpoint
80015754:	3f fc       	mov	r12,-1
80015756:	35 8b       	mov	r11,88
80015758:	58 0c       	cp.w	r12,0
8001575a:	5e 4c       	retge	r12
8001575c:	e0 6a 0d 38 	mov	r10,3384
80015760:	95 0b       	st.w	r10[0x0],r11
80015762:	5e fc       	retal	r12

80015764 <_fstat_host>:
80015764:	30 98       	mov	r8,9
80015766:	d6 73       	breakpoint
80015768:	3f fc       	mov	r12,-1
8001576a:	35 8b       	mov	r11,88
8001576c:	58 0c       	cp.w	r12,0
8001576e:	5e 4c       	retge	r12
80015770:	e0 6a 0d 38 	mov	r10,3384
80015774:	95 0b       	st.w	r10[0x0],r11
80015776:	5e fc       	retal	r12

80015778 <_fstat>:
80015778:	d4 21       	pushm	r4-r7,lr
8001577a:	21 0d       	sub	sp,64
8001577c:	16 97       	mov	r7,r11
8001577e:	1a 9b       	mov	r11,sp
80015780:	cf 2f       	rcall	80015764 <_fstat_host>
80015782:	c0 34       	brge	80015788 <_fstat+0x10>
80015784:	3f fc       	mov	r12,-1
80015786:	c1 c8       	rjmp	800157be <_fstat+0x46>
80015788:	40 08       	lddsp	r8,sp[0x0]
8001578a:	ae 08       	st.h	r7[0x0],r8
8001578c:	40 18       	lddsp	r8,sp[0x4]
8001578e:	ae 18       	st.h	r7[0x2],r8
80015790:	40 28       	lddsp	r8,sp[0x8]
80015792:	8f 18       	st.w	r7[0x4],r8
80015794:	40 38       	lddsp	r8,sp[0xc]
80015796:	ae 48       	st.h	r7[0x8],r8
80015798:	40 48       	lddsp	r8,sp[0x10]
8001579a:	ae 58       	st.h	r7[0xa],r8
8001579c:	40 58       	lddsp	r8,sp[0x14]
8001579e:	ae 68       	st.h	r7[0xc],r8
800157a0:	40 68       	lddsp	r8,sp[0x18]
800157a2:	ae 78       	st.h	r7[0xe],r8
800157a4:	40 88       	lddsp	r8,sp[0x20]
800157a6:	8f 48       	st.w	r7[0x10],r8
800157a8:	40 a8       	lddsp	r8,sp[0x28]
800157aa:	8f b8       	st.w	r7[0x2c],r8
800157ac:	40 c8       	lddsp	r8,sp[0x30]
800157ae:	8f c8       	st.w	r7[0x30],r8
800157b0:	40 d8       	lddsp	r8,sp[0x34]
800157b2:	8f 58       	st.w	r7[0x14],r8
800157b4:	40 e8       	lddsp	r8,sp[0x38]
800157b6:	30 0c       	mov	r12,0
800157b8:	8f 78       	st.w	r7[0x1c],r8
800157ba:	40 f8       	lddsp	r8,sp[0x3c]
800157bc:	8f 98       	st.w	r7[0x24],r8
800157be:	2f 0d       	sub	sp,-64
800157c0:	d8 22       	popm	r4-r7,pc
800157c2:	d7 03       	nop

800157c4 <_sbrk>:
800157c4:	d4 01       	pushm	lr
800157c6:	e0 68 07 bc 	mov	r8,1980
800157ca:	70 09       	ld.w	r9,r8[0x0]
800157cc:	58 09       	cp.w	r9,0
800157ce:	c0 31       	brne	800157d4 <_sbrk+0x10>
800157d0:	48 a9       	lddpc	r9,800157f8 <_sbrk+0x34>
800157d2:	91 09       	st.w	r8[0x0],r9
800157d4:	e0 69 07 bc 	mov	r9,1980
800157d8:	48 9a       	lddpc	r10,800157fc <_sbrk+0x38>
800157da:	72 08       	ld.w	r8,r9[0x0]
800157dc:	f0 0c 00 0c 	add	r12,r8,r12
800157e0:	14 3c       	cp.w	r12,r10
800157e2:	e0 8b 00 04 	brhi	800157ea <_sbrk+0x26>
800157e6:	93 0c       	st.w	r9[0x0],r12
800157e8:	c0 68       	rjmp	800157f4 <_sbrk+0x30>
800157ea:	e0 a0 22 a5 	rcall	80019d34 <__errno>
800157ee:	30 c8       	mov	r8,12
800157f0:	99 08       	st.w	r12[0x0],r8
800157f2:	3f f8       	mov	r8,-1
800157f4:	10 9c       	mov	r12,r8
800157f6:	d8 02       	popm	pc
800157f8:	d0 00       	acall	0x0
800157fa:	00 00       	add	r0,r0
800157fc:	d2 00       	acall	0x20
	...

80015800 <get_arg>:
80015800:	d4 31       	pushm	r0-r7,lr
80015802:	20 8d       	sub	sp,32
80015804:	fa c4 ff bc 	sub	r4,sp,-68
80015808:	50 4b       	stdsp	sp[0x10],r11
8001580a:	68 2e       	ld.w	lr,r4[0x8]
8001580c:	50 58       	stdsp	sp[0x14],r8
8001580e:	12 96       	mov	r6,r9
80015810:	7c 0b       	ld.w	r11,lr[0x0]
80015812:	70 05       	ld.w	r5,r8[0x0]
80015814:	50 6e       	stdsp	sp[0x18],lr
80015816:	58 0b       	cp.w	r11,0
80015818:	f4 0b 17 00 	moveq	r11,r10
8001581c:	68 03       	ld.w	r3,r4[0x0]
8001581e:	68 11       	ld.w	r1,r4[0x4]
80015820:	40 49       	lddsp	r9,sp[0x10]
80015822:	30 08       	mov	r8,0
80015824:	c2 d9       	rjmp	80015a7e <get_arg+0x27e>
80015826:	2f fb       	sub	r11,-1
80015828:	32 5c       	mov	r12,37
8001582a:	17 8a       	ld.ub	r10,r11[0x0]
8001582c:	f8 0a 18 00 	cp.b	r10,r12
80015830:	5f 1e       	srne	lr
80015832:	f0 0a 18 00 	cp.b	r10,r8
80015836:	5f 1c       	srne	r12
80015838:	fd ec 00 0c 	and	r12,lr,r12
8001583c:	f0 0c 18 00 	cp.b	r12,r8
80015840:	cf 31       	brne	80015826 <get_arg+0x26>
80015842:	58 0a       	cp.w	r10,0
80015844:	e0 80 01 2a 	breq	80015a98 <get_arg+0x298>
80015848:	30 0c       	mov	r12,0
8001584a:	3f fa       	mov	r10,-1
8001584c:	18 90       	mov	r0,r12
8001584e:	50 3a       	stdsp	sp[0xc],r10
80015850:	18 94       	mov	r4,r12
80015852:	18 92       	mov	r2,r12
80015854:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80015858:	16 97       	mov	r7,r11
8001585a:	50 7c       	stdsp	sp[0x1c],r12
8001585c:	4c ec       	lddpc	r12,80015994 <get_arg+0x194>
8001585e:	0f 3a       	ld.ub	r10,r7++
80015860:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80015864:	40 7c       	lddsp	r12,sp[0x1c]
80015866:	1c 0c       	add	r12,lr
80015868:	4c ce       	lddpc	lr,80015998 <get_arg+0x198>
8001586a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8001586e:	20 1e       	sub	lr,1
80015870:	50 0e       	stdsp	sp[0x0],lr
80015872:	4c be       	lddpc	lr,8001599c <get_arg+0x19c>
80015874:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80015878:	50 7c       	stdsp	sp[0x1c],r12
8001587a:	40 0c       	lddsp	r12,sp[0x0]
8001587c:	58 7c       	cp.w	r12,7
8001587e:	e0 8b 00 f9 	brhi	80015a70 <get_arg+0x270>
80015882:	4c 8e       	lddpc	lr,800159a0 <get_arg+0x1a0>
80015884:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80015888:	36 8b       	mov	r11,104
8001588a:	f6 0a 18 00 	cp.b	r10,r11
8001588e:	e0 80 00 f1 	breq	80015a70 <get_arg+0x270>
80015892:	37 1b       	mov	r11,113
80015894:	f6 0a 18 00 	cp.b	r10,r11
80015898:	c0 70       	breq	800158a6 <get_arg+0xa6>
8001589a:	34 cb       	mov	r11,76
8001589c:	f6 0a 18 00 	cp.b	r10,r11
800158a0:	c0 51       	brne	800158aa <get_arg+0xaa>
800158a2:	a3 b4       	sbr	r4,0x3
800158a4:	ce 68       	rjmp	80015a70 <get_arg+0x270>
800158a6:	a5 b4       	sbr	r4,0x5
800158a8:	ce 48       	rjmp	80015a70 <get_arg+0x270>
800158aa:	08 9a       	mov	r10,r4
800158ac:	0e 9b       	mov	r11,r7
800158ae:	a5 aa       	sbr	r10,0x4
800158b0:	17 3c       	ld.ub	r12,r11++
800158b2:	a5 b4       	sbr	r4,0x5
800158b4:	36 ce       	mov	lr,108
800158b6:	fc 0c 18 00 	cp.b	r12,lr
800158ba:	e0 80 00 dc 	breq	80015a72 <get_arg+0x272>
800158be:	14 94       	mov	r4,r10
800158c0:	cd 88       	rjmp	80015a70 <get_arg+0x270>
800158c2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800158c6:	36 7c       	mov	r12,103
800158c8:	f8 0a 18 00 	cp.b	r10,r12
800158cc:	e0 8b 00 27 	brhi	8001591a <get_arg+0x11a>
800158d0:	36 5b       	mov	r11,101
800158d2:	f6 0a 18 00 	cp.b	r10,r11
800158d6:	c4 82       	brcc	80015966 <get_arg+0x166>
800158d8:	34 fb       	mov	r11,79
800158da:	f6 0a 18 00 	cp.b	r10,r11
800158de:	c4 80       	breq	8001596e <get_arg+0x16e>
800158e0:	e0 8b 00 0c 	brhi	800158f8 <get_arg+0xf8>
800158e4:	34 5b       	mov	r11,69
800158e6:	f6 0a 18 00 	cp.b	r10,r11
800158ea:	c3 e0       	breq	80015966 <get_arg+0x166>
800158ec:	34 7b       	mov	r11,71
800158ee:	f6 0a 18 00 	cp.b	r10,r11
800158f2:	c3 a0       	breq	80015966 <get_arg+0x166>
800158f4:	34 4b       	mov	r11,68
800158f6:	c0 88       	rjmp	80015906 <get_arg+0x106>
800158f8:	35 8b       	mov	r11,88
800158fa:	f6 0a 18 00 	cp.b	r10,r11
800158fe:	c2 c0       	breq	80015956 <get_arg+0x156>
80015900:	e0 8b 00 07 	brhi	8001590e <get_arg+0x10e>
80015904:	35 5b       	mov	r11,85
80015906:	f6 0a 18 00 	cp.b	r10,r11
8001590a:	c3 51       	brne	80015974 <get_arg+0x174>
8001590c:	c3 18       	rjmp	8001596e <get_arg+0x16e>
8001590e:	36 3b       	mov	r11,99
80015910:	f6 0a 18 00 	cp.b	r10,r11
80015914:	c2 f0       	breq	80015972 <get_arg+0x172>
80015916:	36 4b       	mov	r11,100
80015918:	c0 e8       	rjmp	80015934 <get_arg+0x134>
8001591a:	37 0b       	mov	r11,112
8001591c:	f6 0a 18 00 	cp.b	r10,r11
80015920:	c2 50       	breq	8001596a <get_arg+0x16a>
80015922:	e0 8b 00 0d 	brhi	8001593c <get_arg+0x13c>
80015926:	36 eb       	mov	r11,110
80015928:	f6 0a 18 00 	cp.b	r10,r11
8001592c:	c1 f0       	breq	8001596a <get_arg+0x16a>
8001592e:	e0 8b 00 14 	brhi	80015956 <get_arg+0x156>
80015932:	36 9b       	mov	r11,105
80015934:	f6 0a 18 00 	cp.b	r10,r11
80015938:	c1 e1       	brne	80015974 <get_arg+0x174>
8001593a:	c0 e8       	rjmp	80015956 <get_arg+0x156>
8001593c:	37 5b       	mov	r11,117
8001593e:	f6 0a 18 00 	cp.b	r10,r11
80015942:	c0 a0       	breq	80015956 <get_arg+0x156>
80015944:	37 8b       	mov	r11,120
80015946:	f6 0a 18 00 	cp.b	r10,r11
8001594a:	c0 60       	breq	80015956 <get_arg+0x156>
8001594c:	37 3b       	mov	r11,115
8001594e:	f6 0a 18 00 	cp.b	r10,r11
80015952:	c1 11       	brne	80015974 <get_arg+0x174>
80015954:	c0 b8       	rjmp	8001596a <get_arg+0x16a>
80015956:	ed b4 00 04 	bld	r4,0x4
8001595a:	c0 a0       	breq	8001596e <get_arg+0x16e>
8001595c:	ed b4 00 05 	bld	r4,0x5
80015960:	c0 91       	brne	80015972 <get_arg+0x172>
80015962:	30 20       	mov	r0,2
80015964:	c0 88       	rjmp	80015974 <get_arg+0x174>
80015966:	30 40       	mov	r0,4
80015968:	c0 68       	rjmp	80015974 <get_arg+0x174>
8001596a:	30 30       	mov	r0,3
8001596c:	c0 48       	rjmp	80015974 <get_arg+0x174>
8001596e:	30 10       	mov	r0,1
80015970:	c0 28       	rjmp	80015974 <get_arg+0x174>
80015972:	30 00       	mov	r0,0
80015974:	40 3b       	lddsp	r11,sp[0xc]
80015976:	5b fb       	cp.w	r11,-1
80015978:	c0 40       	breq	80015980 <get_arg+0x180>
8001597a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8001597e:	c7 98       	rjmp	80015a70 <get_arg+0x270>
80015980:	58 60       	cp.w	r0,6
80015982:	e0 8b 00 77 	brhi	80015a70 <get_arg+0x270>
80015986:	6c 0a       	ld.w	r10,r6[0x0]
80015988:	ea cc ff ff 	sub	r12,r5,-1
8001598c:	48 6e       	lddpc	lr,800159a4 <get_arg+0x1a4>
8001598e:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80015992:	d7 03       	nop
80015994:	80 02       	ld.sh	r2,r0[0x0]
80015996:	03 20       	ld.uh	r0,r1++
80015998:	80 02       	ld.sh	r2,r0[0x0]
8001599a:	02 58       	eor	r8,r1
8001599c:	80 02       	ld.sh	r2,r0[0x0]
8001599e:	01 ec       	ld.ub	r12,r0[0x6]
800159a0:	80 02       	ld.sh	r2,r0[0x0]
800159a2:	00 4c       	or	r12,r0
800159a4:	80 02       	ld.sh	r2,r0[0x0]
800159a6:	00 6c       	and	r12,r0
800159a8:	f4 cb ff f8 	sub	r11,r10,-8
800159ac:	8d 0b       	st.w	r6[0x0],r11
800159ae:	f4 ea 00 00 	ld.d	r10,r10[0]
800159b2:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800159b6:	c0 f8       	rjmp	800159d4 <get_arg+0x1d4>
800159b8:	f4 cb ff fc 	sub	r11,r10,-4
800159bc:	8d 0b       	st.w	r6[0x0],r11
800159be:	74 0a       	ld.w	r10,r10[0x0]
800159c0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800159c4:	c0 88       	rjmp	800159d4 <get_arg+0x1d4>
800159c6:	f4 cb ff f8 	sub	r11,r10,-8
800159ca:	8d 0b       	st.w	r6[0x0],r11
800159cc:	f4 ea 00 00 	ld.d	r10,r10[0]
800159d0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800159d4:	0e 9b       	mov	r11,r7
800159d6:	18 95       	mov	r5,r12
800159d8:	c4 d8       	rjmp	80015a72 <get_arg+0x272>
800159da:	62 0a       	ld.w	r10,r1[0x0]
800159dc:	5b fa       	cp.w	r10,-1
800159de:	c0 a1       	brne	800159f2 <get_arg+0x1f2>
800159e0:	50 19       	stdsp	sp[0x4],r9
800159e2:	50 28       	stdsp	sp[0x8],r8
800159e4:	e0 6a 00 80 	mov	r10,128
800159e8:	30 0b       	mov	r11,0
800159ea:	02 9c       	mov	r12,r1
800159ec:	c0 be       	rcall	80015602 <memset>
800159ee:	40 28       	lddsp	r8,sp[0x8]
800159f0:	40 19       	lddsp	r9,sp[0x4]
800159f2:	e4 cc 00 01 	sub	r12,r2,1
800159f6:	0e 9b       	mov	r11,r7
800159f8:	50 3c       	stdsp	sp[0xc],r12
800159fa:	f2 0c 0c 49 	max	r9,r9,r12
800159fe:	c3 a8       	rjmp	80015a72 <get_arg+0x272>
80015a00:	62 0a       	ld.w	r10,r1[0x0]
80015a02:	5b fa       	cp.w	r10,-1
80015a04:	c0 b1       	brne	80015a1a <get_arg+0x21a>
80015a06:	50 19       	stdsp	sp[0x4],r9
80015a08:	50 28       	stdsp	sp[0x8],r8
80015a0a:	e0 6a 00 80 	mov	r10,128
80015a0e:	30 0b       	mov	r11,0
80015a10:	02 9c       	mov	r12,r1
80015a12:	fe b0 fd f8 	rcall	80015602 <memset>
80015a16:	40 28       	lddsp	r8,sp[0x8]
80015a18:	40 19       	lddsp	r9,sp[0x4]
80015a1a:	20 12       	sub	r2,1
80015a1c:	30 0a       	mov	r10,0
80015a1e:	0e 9b       	mov	r11,r7
80015a20:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80015a24:	f2 02 0c 49 	max	r9,r9,r2
80015a28:	c2 58       	rjmp	80015a72 <get_arg+0x272>
80015a2a:	16 97       	mov	r7,r11
80015a2c:	6c 0a       	ld.w	r10,r6[0x0]
80015a2e:	f4 cb ff fc 	sub	r11,r10,-4
80015a32:	8d 0b       	st.w	r6[0x0],r11
80015a34:	74 0a       	ld.w	r10,r10[0x0]
80015a36:	0e 9b       	mov	r11,r7
80015a38:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80015a3c:	2f f5       	sub	r5,-1
80015a3e:	c1 a8       	rjmp	80015a72 <get_arg+0x272>
80015a40:	f4 c2 00 30 	sub	r2,r10,48
80015a44:	c0 68       	rjmp	80015a50 <get_arg+0x250>
80015a46:	e4 02 00 22 	add	r2,r2,r2<<0x2
80015a4a:	2f f7       	sub	r7,-1
80015a4c:	f4 02 00 12 	add	r2,r10,r2<<0x1
80015a50:	0f 8a       	ld.ub	r10,r7[0x0]
80015a52:	58 0a       	cp.w	r10,0
80015a54:	c0 e0       	breq	80015a70 <get_arg+0x270>
80015a56:	23 0a       	sub	r10,48
80015a58:	58 9a       	cp.w	r10,9
80015a5a:	fe 98 ff f6 	brls	80015a46 <get_arg+0x246>
80015a5e:	c0 98       	rjmp	80015a70 <get_arg+0x270>
80015a60:	2f f7       	sub	r7,-1
80015a62:	0f 8a       	ld.ub	r10,r7[0x0]
80015a64:	58 0a       	cp.w	r10,0
80015a66:	c0 50       	breq	80015a70 <get_arg+0x270>
80015a68:	23 0a       	sub	r10,48
80015a6a:	58 9a       	cp.w	r10,9
80015a6c:	fe 98 ff fa 	brls	80015a60 <get_arg+0x260>
80015a70:	0e 9b       	mov	r11,r7
80015a72:	40 7c       	lddsp	r12,sp[0x1c]
80015a74:	30 ba       	mov	r10,11
80015a76:	f4 0c 18 00 	cp.b	r12,r10
80015a7a:	fe 91 fe ed 	brne	80015854 <get_arg+0x54>
80015a7e:	40 42       	lddsp	r2,sp[0x10]
80015a80:	17 8c       	ld.ub	r12,r11[0x0]
80015a82:	0a 32       	cp.w	r2,r5
80015a84:	5f 4a       	srge	r10
80015a86:	f0 0c 18 00 	cp.b	r12,r8
80015a8a:	5f 1c       	srne	r12
80015a8c:	f9 ea 00 0a 	and	r10,r12,r10
80015a90:	f0 0a 18 00 	cp.b	r10,r8
80015a94:	fe 91 fe ca 	brne	80015828 <get_arg+0x28>
80015a98:	30 08       	mov	r8,0
80015a9a:	40 4e       	lddsp	lr,sp[0x10]
80015a9c:	17 8a       	ld.ub	r10,r11[0x0]
80015a9e:	e2 05 00 21 	add	r1,r1,r5<<0x2
80015aa2:	f0 0a 18 00 	cp.b	r10,r8
80015aa6:	fc 09 17 10 	movne	r9,lr
80015aaa:	e6 05 00 38 	add	r8,r3,r5<<0x3
80015aae:	06 9e       	mov	lr,r3
80015ab0:	c2 a8       	rjmp	80015b04 <get_arg+0x304>
80015ab2:	62 0a       	ld.w	r10,r1[0x0]
80015ab4:	58 3a       	cp.w	r10,3
80015ab6:	c1 e0       	breq	80015af2 <get_arg+0x2f2>
80015ab8:	e0 89 00 07 	brgt	80015ac6 <get_arg+0x2c6>
80015abc:	58 1a       	cp.w	r10,1
80015abe:	c1 a0       	breq	80015af2 <get_arg+0x2f2>
80015ac0:	58 2a       	cp.w	r10,2
80015ac2:	c1 81       	brne	80015af2 <get_arg+0x2f2>
80015ac4:	c0 58       	rjmp	80015ace <get_arg+0x2ce>
80015ac6:	58 5a       	cp.w	r10,5
80015ac8:	c0 c0       	breq	80015ae0 <get_arg+0x2e0>
80015aca:	c0 b5       	brlt	80015ae0 <get_arg+0x2e0>
80015acc:	c1 38       	rjmp	80015af2 <get_arg+0x2f2>
80015ace:	6c 0a       	ld.w	r10,r6[0x0]
80015ad0:	f4 cc ff f8 	sub	r12,r10,-8
80015ad4:	8d 0c       	st.w	r6[0x0],r12
80015ad6:	f4 e2 00 00 	ld.d	r2,r10[0]
80015ada:	f0 e3 00 00 	st.d	r8[0],r2
80015ade:	c1 08       	rjmp	80015afe <get_arg+0x2fe>
80015ae0:	6c 0a       	ld.w	r10,r6[0x0]
80015ae2:	f4 cc ff f8 	sub	r12,r10,-8
80015ae6:	8d 0c       	st.w	r6[0x0],r12
80015ae8:	f4 e2 00 00 	ld.d	r2,r10[0]
80015aec:	f0 e3 00 00 	st.d	r8[0],r2
80015af0:	c0 78       	rjmp	80015afe <get_arg+0x2fe>
80015af2:	6c 0a       	ld.w	r10,r6[0x0]
80015af4:	f4 cc ff fc 	sub	r12,r10,-4
80015af8:	8d 0c       	st.w	r6[0x0],r12
80015afa:	74 0a       	ld.w	r10,r10[0x0]
80015afc:	91 0a       	st.w	r8[0x0],r10
80015afe:	2f f5       	sub	r5,-1
80015b00:	2f 88       	sub	r8,-8
80015b02:	2f c1       	sub	r1,-4
80015b04:	12 35       	cp.w	r5,r9
80015b06:	fe 9a ff d6 	brle	80015ab2 <get_arg+0x2b2>
80015b0a:	1c 93       	mov	r3,lr
80015b0c:	40 52       	lddsp	r2,sp[0x14]
80015b0e:	40 6e       	lddsp	lr,sp[0x18]
80015b10:	85 05       	st.w	r2[0x0],r5
80015b12:	9d 0b       	st.w	lr[0x0],r11
80015b14:	40 4b       	lddsp	r11,sp[0x10]
80015b16:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80015b1a:	2f 8d       	sub	sp,-32
80015b1c:	d8 32       	popm	r0-r7,pc
80015b1e:	d7 03       	nop

80015b20 <__sprint_r>:
80015b20:	d4 21       	pushm	r4-r7,lr
80015b22:	14 97       	mov	r7,r10
80015b24:	74 28       	ld.w	r8,r10[0x8]
80015b26:	58 08       	cp.w	r8,0
80015b28:	c0 41       	brne	80015b30 <__sprint_r+0x10>
80015b2a:	95 18       	st.w	r10[0x4],r8
80015b2c:	10 9c       	mov	r12,r8
80015b2e:	d8 22       	popm	r4-r7,pc
80015b30:	e0 a0 23 ac 	rcall	8001a288 <__sfvwrite_r>
80015b34:	30 08       	mov	r8,0
80015b36:	8f 18       	st.w	r7[0x4],r8
80015b38:	8f 28       	st.w	r7[0x8],r8
80015b3a:	d8 22       	popm	r4-r7,pc

80015b3c <_vfprintf_r>:
80015b3c:	d4 31       	pushm	r0-r7,lr
80015b3e:	fa cd 06 bc 	sub	sp,sp,1724
80015b42:	51 09       	stdsp	sp[0x40],r9
80015b44:	16 91       	mov	r1,r11
80015b46:	14 97       	mov	r7,r10
80015b48:	18 95       	mov	r5,r12
80015b4a:	e0 a0 25 43 	rcall	8001a5d0 <_localeconv_r>
80015b4e:	78 0c       	ld.w	r12,r12[0x0]
80015b50:	50 cc       	stdsp	sp[0x30],r12
80015b52:	58 05       	cp.w	r5,0
80015b54:	c0 70       	breq	80015b62 <_vfprintf_r+0x26>
80015b56:	6a 68       	ld.w	r8,r5[0x18]
80015b58:	58 08       	cp.w	r8,0
80015b5a:	c0 41       	brne	80015b62 <_vfprintf_r+0x26>
80015b5c:	0a 9c       	mov	r12,r5
80015b5e:	e0 a0 21 db 	rcall	80019f14 <__sinit>
80015b62:	4d 08       	lddpc	r8,80015ca0 <_vfprintf_r+0x164>
80015b64:	10 31       	cp.w	r1,r8
80015b66:	c0 31       	brne	80015b6c <_vfprintf_r+0x30>
80015b68:	6a 01       	ld.w	r1,r5[0x0]
80015b6a:	c0 a8       	rjmp	80015b7e <_vfprintf_r+0x42>
80015b6c:	4c e8       	lddpc	r8,80015ca4 <_vfprintf_r+0x168>
80015b6e:	10 31       	cp.w	r1,r8
80015b70:	c0 31       	brne	80015b76 <_vfprintf_r+0x3a>
80015b72:	6a 11       	ld.w	r1,r5[0x4]
80015b74:	c0 58       	rjmp	80015b7e <_vfprintf_r+0x42>
80015b76:	4c d8       	lddpc	r8,80015ca8 <_vfprintf_r+0x16c>
80015b78:	10 31       	cp.w	r1,r8
80015b7a:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80015b7e:	82 68       	ld.sh	r8,r1[0xc]
80015b80:	ed b8 00 03 	bld	r8,0x3
80015b84:	c0 41       	brne	80015b8c <_vfprintf_r+0x50>
80015b86:	62 48       	ld.w	r8,r1[0x10]
80015b88:	58 08       	cp.w	r8,0
80015b8a:	c0 71       	brne	80015b98 <_vfprintf_r+0x5c>
80015b8c:	02 9b       	mov	r11,r1
80015b8e:	0a 9c       	mov	r12,r5
80015b90:	e0 a0 19 e4 	rcall	80018f58 <__swsetup_r>
80015b94:	e0 81 0f 63 	brne	80017a5a <_vfprintf_r+0x1f1e>
80015b98:	82 68       	ld.sh	r8,r1[0xc]
80015b9a:	10 99       	mov	r9,r8
80015b9c:	e2 19 00 1a 	andl	r9,0x1a,COH
80015ba0:	58 a9       	cp.w	r9,10
80015ba2:	c3 c1       	brne	80015c1a <_vfprintf_r+0xde>
80015ba4:	82 79       	ld.sh	r9,r1[0xe]
80015ba6:	30 0a       	mov	r10,0
80015ba8:	f4 09 19 00 	cp.h	r9,r10
80015bac:	c3 75       	brlt	80015c1a <_vfprintf_r+0xde>
80015bae:	a1 d8       	cbr	r8,0x1
80015bb0:	fb 58 05 d0 	st.h	sp[1488],r8
80015bb4:	62 88       	ld.w	r8,r1[0x20]
80015bb6:	fb 48 05 e4 	st.w	sp[1508],r8
80015bba:	62 a8       	ld.w	r8,r1[0x28]
80015bbc:	fb 48 05 ec 	st.w	sp[1516],r8
80015bc0:	fa c8 ff bc 	sub	r8,sp,-68
80015bc4:	fb 48 05 d4 	st.w	sp[1492],r8
80015bc8:	fb 48 05 c4 	st.w	sp[1476],r8
80015bcc:	e0 68 04 00 	mov	r8,1024
80015bd0:	fb 48 05 d8 	st.w	sp[1496],r8
80015bd4:	fb 48 05 cc 	st.w	sp[1484],r8
80015bd8:	30 08       	mov	r8,0
80015bda:	fb 59 05 d2 	st.h	sp[1490],r9
80015bde:	0e 9a       	mov	r10,r7
80015be0:	41 09       	lddsp	r9,sp[0x40]
80015be2:	fa c7 fa 3c 	sub	r7,sp,-1476
80015be6:	fb 48 05 dc 	st.w	sp[1500],r8
80015bea:	0a 9c       	mov	r12,r5
80015bec:	0e 9b       	mov	r11,r7
80015bee:	ca 7f       	rcall	80015b3c <_vfprintf_r>
80015bf0:	50 bc       	stdsp	sp[0x2c],r12
80015bf2:	c0 95       	brlt	80015c04 <_vfprintf_r+0xc8>
80015bf4:	0e 9b       	mov	r11,r7
80015bf6:	0a 9c       	mov	r12,r5
80015bf8:	e0 a0 20 a4 	rcall	80019d40 <_fflush_r>
80015bfc:	40 be       	lddsp	lr,sp[0x2c]
80015bfe:	f9 be 01 ff 	movne	lr,-1
80015c02:	50 be       	stdsp	sp[0x2c],lr
80015c04:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80015c08:	ed b8 00 06 	bld	r8,0x6
80015c0c:	e0 81 0f 29 	brne	80017a5e <_vfprintf_r+0x1f22>
80015c10:	82 68       	ld.sh	r8,r1[0xc]
80015c12:	a7 a8       	sbr	r8,0x6
80015c14:	a2 68       	st.h	r1[0xc],r8
80015c16:	e0 8f 0f 24 	bral	80017a5e <_vfprintf_r+0x1f22>
80015c1a:	30 08       	mov	r8,0
80015c1c:	fb 48 06 b4 	st.w	sp[1716],r8
80015c20:	fb 48 06 90 	st.w	sp[1680],r8
80015c24:	fb 48 06 8c 	st.w	sp[1676],r8
80015c28:	fb 48 06 b0 	st.w	sp[1712],r8
80015c2c:	30 08       	mov	r8,0
80015c2e:	30 09       	mov	r9,0
80015c30:	50 a7       	stdsp	sp[0x28],r7
80015c32:	50 78       	stdsp	sp[0x1c],r8
80015c34:	fa c3 f9 e0 	sub	r3,sp,-1568
80015c38:	3f f8       	mov	r8,-1
80015c3a:	50 59       	stdsp	sp[0x14],r9
80015c3c:	fb 43 06 88 	st.w	sp[1672],r3
80015c40:	fb 48 05 44 	st.w	sp[1348],r8
80015c44:	12 9c       	mov	r12,r9
80015c46:	50 69       	stdsp	sp[0x18],r9
80015c48:	50 d9       	stdsp	sp[0x34],r9
80015c4a:	50 e9       	stdsp	sp[0x38],r9
80015c4c:	50 b9       	stdsp	sp[0x2c],r9
80015c4e:	12 97       	mov	r7,r9
80015c50:	0a 94       	mov	r4,r5
80015c52:	40 a2       	lddsp	r2,sp[0x28]
80015c54:	32 5a       	mov	r10,37
80015c56:	30 08       	mov	r8,0
80015c58:	c0 28       	rjmp	80015c5c <_vfprintf_r+0x120>
80015c5a:	2f f2       	sub	r2,-1
80015c5c:	05 89       	ld.ub	r9,r2[0x0]
80015c5e:	f0 09 18 00 	cp.b	r9,r8
80015c62:	5f 1b       	srne	r11
80015c64:	f4 09 18 00 	cp.b	r9,r10
80015c68:	5f 19       	srne	r9
80015c6a:	f3 eb 00 0b 	and	r11,r9,r11
80015c6e:	f0 0b 18 00 	cp.b	r11,r8
80015c72:	cf 41       	brne	80015c5a <_vfprintf_r+0x11e>
80015c74:	40 ab       	lddsp	r11,sp[0x28]
80015c76:	e4 0b 01 06 	sub	r6,r2,r11
80015c7a:	c2 50       	breq	80015cc4 <_vfprintf_r+0x188>
80015c7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80015c80:	0c 08       	add	r8,r6
80015c82:	87 0b       	st.w	r3[0x0],r11
80015c84:	fb 48 06 90 	st.w	sp[1680],r8
80015c88:	87 16       	st.w	r3[0x4],r6
80015c8a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80015c8e:	2f f8       	sub	r8,-1
80015c90:	fb 48 06 8c 	st.w	sp[1676],r8
80015c94:	58 78       	cp.w	r8,7
80015c96:	e0 89 00 0b 	brgt	80015cac <_vfprintf_r+0x170>
80015c9a:	2f 83       	sub	r3,-8
80015c9c:	c1 18       	rjmp	80015cbe <_vfprintf_r+0x182>
80015c9e:	d7 03       	nop
80015ca0:	80 02       	ld.sh	r2,r0[0x0]
80015ca2:	04 5c       	eor	r12,r2
80015ca4:	80 02       	ld.sh	r2,r0[0x0]
80015ca6:	04 7c       	tst	r12,r2
80015ca8:	80 02       	ld.sh	r2,r0[0x0]
80015caa:	04 9c       	mov	r12,r2
80015cac:	fa ca f9 78 	sub	r10,sp,-1672
80015cb0:	02 9b       	mov	r11,r1
80015cb2:	08 9c       	mov	r12,r4
80015cb4:	c3 6f       	rcall	80015b20 <__sprint_r>
80015cb6:	e0 81 0e ce 	brne	80017a52 <_vfprintf_r+0x1f16>
80015cba:	fa c3 f9 e0 	sub	r3,sp,-1568
80015cbe:	40 ba       	lddsp	r10,sp[0x2c]
80015cc0:	0c 0a       	add	r10,r6
80015cc2:	50 ba       	stdsp	sp[0x2c],r10
80015cc4:	05 89       	ld.ub	r9,r2[0x0]
80015cc6:	30 08       	mov	r8,0
80015cc8:	f0 09 18 00 	cp.b	r9,r8
80015ccc:	e0 80 0e b2 	breq	80017a30 <_vfprintf_r+0x1ef4>
80015cd0:	30 09       	mov	r9,0
80015cd2:	fb 68 06 bb 	st.b	sp[1723],r8
80015cd6:	0e 96       	mov	r6,r7
80015cd8:	e4 c8 ff ff 	sub	r8,r2,-1
80015cdc:	3f fe       	mov	lr,-1
80015cde:	50 93       	stdsp	sp[0x24],r3
80015ce0:	50 41       	stdsp	sp[0x10],r1
80015ce2:	0e 93       	mov	r3,r7
80015ce4:	04 91       	mov	r1,r2
80015ce6:	50 89       	stdsp	sp[0x20],r9
80015ce8:	50 a8       	stdsp	sp[0x28],r8
80015cea:	50 2e       	stdsp	sp[0x8],lr
80015cec:	50 39       	stdsp	sp[0xc],r9
80015cee:	12 95       	mov	r5,r9
80015cf0:	12 90       	mov	r0,r9
80015cf2:	10 97       	mov	r7,r8
80015cf4:	08 92       	mov	r2,r4
80015cf6:	c0 78       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015cf8:	3f fc       	mov	r12,-1
80015cfa:	08 97       	mov	r7,r4
80015cfc:	50 2c       	stdsp	sp[0x8],r12
80015cfe:	c0 38       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015d00:	30 0b       	mov	r11,0
80015d02:	50 3b       	stdsp	sp[0xc],r11
80015d04:	0f 38       	ld.ub	r8,r7++
80015d06:	c0 28       	rjmp	80015d0a <_vfprintf_r+0x1ce>
80015d08:	12 90       	mov	r0,r9
80015d0a:	f0 c9 00 20 	sub	r9,r8,32
80015d0e:	e0 49 00 58 	cp.w	r9,88
80015d12:	e0 8b 0a 36 	brhi	8001717e <_vfprintf_r+0x1642>
80015d16:	4d 9a       	lddpc	r10,80015e78 <_vfprintf_r+0x33c>
80015d18:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80015d1c:	50 a7       	stdsp	sp[0x28],r7
80015d1e:	50 80       	stdsp	sp[0x20],r0
80015d20:	0c 97       	mov	r7,r6
80015d22:	04 94       	mov	r4,r2
80015d24:	06 96       	mov	r6,r3
80015d26:	02 92       	mov	r2,r1
80015d28:	4d 59       	lddpc	r9,80015e7c <_vfprintf_r+0x340>
80015d2a:	40 93       	lddsp	r3,sp[0x24]
80015d2c:	10 90       	mov	r0,r8
80015d2e:	40 41       	lddsp	r1,sp[0x10]
80015d30:	50 d9       	stdsp	sp[0x34],r9
80015d32:	e0 8f 08 95 	bral	80016e5c <_vfprintf_r+0x1320>
80015d36:	30 08       	mov	r8,0
80015d38:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80015d3c:	f0 09 18 00 	cp.b	r9,r8
80015d40:	ce 21       	brne	80015d04 <_vfprintf_r+0x1c8>
80015d42:	32 08       	mov	r8,32
80015d44:	c6 e8       	rjmp	80015e20 <_vfprintf_r+0x2e4>
80015d46:	a1 a5       	sbr	r5,0x0
80015d48:	cd eb       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015d4a:	0f 89       	ld.ub	r9,r7[0x0]
80015d4c:	f2 c8 00 30 	sub	r8,r9,48
80015d50:	58 98       	cp.w	r8,9
80015d52:	e0 8b 00 1d 	brhi	80015d8c <_vfprintf_r+0x250>
80015d56:	ee c8 ff ff 	sub	r8,r7,-1
80015d5a:	30 0b       	mov	r11,0
80015d5c:	23 09       	sub	r9,48
80015d5e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80015d62:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80015d66:	11 39       	ld.ub	r9,r8++
80015d68:	f2 ca 00 30 	sub	r10,r9,48
80015d6c:	58 9a       	cp.w	r10,9
80015d6e:	fe 98 ff f7 	brls	80015d5c <_vfprintf_r+0x220>
80015d72:	e0 49 00 24 	cp.w	r9,36
80015d76:	cc 51       	brne	80015d00 <_vfprintf_r+0x1c4>
80015d78:	e0 4b 00 20 	cp.w	r11,32
80015d7c:	e0 89 0e 6a 	brgt	80017a50 <_vfprintf_r+0x1f14>
80015d80:	20 1b       	sub	r11,1
80015d82:	fa f9 06 b4 	ld.w	r9,sp[1716]
80015d86:	12 3b       	cp.w	r11,r9
80015d88:	c0 95       	brlt	80015d9a <_vfprintf_r+0x25e>
80015d8a:	c1 08       	rjmp	80015daa <_vfprintf_r+0x26e>
80015d8c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80015d90:	ec ca ff ff 	sub	r10,r6,-1
80015d94:	12 36       	cp.w	r6,r9
80015d96:	c1 f5       	brlt	80015dd4 <_vfprintf_r+0x298>
80015d98:	c2 68       	rjmp	80015de4 <_vfprintf_r+0x2a8>
80015d9a:	fa ce f9 44 	sub	lr,sp,-1724
80015d9e:	10 97       	mov	r7,r8
80015da0:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80015da4:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80015da8:	c3 58       	rjmp	80015e12 <_vfprintf_r+0x2d6>
80015daa:	10 97       	mov	r7,r8
80015dac:	fa c8 f9 50 	sub	r8,sp,-1712
80015db0:	1a d8       	st.w	--sp,r8
80015db2:	fa c8 fa b8 	sub	r8,sp,-1352
80015db6:	1a d8       	st.w	--sp,r8
80015db8:	fa c8 fb b4 	sub	r8,sp,-1100
80015dbc:	02 9a       	mov	r10,r1
80015dbe:	1a d8       	st.w	--sp,r8
80015dc0:	04 9c       	mov	r12,r2
80015dc2:	fa c8 f9 40 	sub	r8,sp,-1728
80015dc6:	fa c9 ff b4 	sub	r9,sp,-76
80015dca:	fe b0 fd 1b 	rcall	80015800 <get_arg>
80015dce:	2f dd       	sub	sp,-12
80015dd0:	78 00       	ld.w	r0,r12[0x0]
80015dd2:	c2 08       	rjmp	80015e12 <_vfprintf_r+0x2d6>
80015dd4:	fa cc f9 44 	sub	r12,sp,-1724
80015dd8:	14 96       	mov	r6,r10
80015dda:	f8 03 00 38 	add	r8,r12,r3<<0x3
80015dde:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80015de2:	c1 88       	rjmp	80015e12 <_vfprintf_r+0x2d6>
80015de4:	41 08       	lddsp	r8,sp[0x40]
80015de6:	59 f9       	cp.w	r9,31
80015de8:	e0 89 00 11 	brgt	80015e0a <_vfprintf_r+0x2ce>
80015dec:	f0 cb ff fc 	sub	r11,r8,-4
80015df0:	51 0b       	stdsp	sp[0x40],r11
80015df2:	70 00       	ld.w	r0,r8[0x0]
80015df4:	fa cb f9 44 	sub	r11,sp,-1724
80015df8:	f6 09 00 38 	add	r8,r11,r9<<0x3
80015dfc:	f1 40 fd 88 	st.w	r8[-632],r0
80015e00:	2f f9       	sub	r9,-1
80015e02:	14 96       	mov	r6,r10
80015e04:	fb 49 06 b4 	st.w	sp[1716],r9
80015e08:	c0 58       	rjmp	80015e12 <_vfprintf_r+0x2d6>
80015e0a:	70 00       	ld.w	r0,r8[0x0]
80015e0c:	14 96       	mov	r6,r10
80015e0e:	2f c8       	sub	r8,-4
80015e10:	51 08       	stdsp	sp[0x40],r8
80015e12:	58 00       	cp.w	r0,0
80015e14:	fe 94 ff 78 	brge	80015d04 <_vfprintf_r+0x1c8>
80015e18:	5c 30       	neg	r0
80015e1a:	a3 a5       	sbr	r5,0x2
80015e1c:	c7 4b       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015e1e:	32 b8       	mov	r8,43
80015e20:	fb 68 06 bb 	st.b	sp[1723],r8
80015e24:	c7 0b       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015e26:	0f 38       	ld.ub	r8,r7++
80015e28:	e0 48 00 2a 	cp.w	r8,42
80015e2c:	c0 30       	breq	80015e32 <_vfprintf_r+0x2f6>
80015e2e:	30 09       	mov	r9,0
80015e30:	c7 d8       	rjmp	80015f2a <_vfprintf_r+0x3ee>
80015e32:	0f 88       	ld.ub	r8,r7[0x0]
80015e34:	f0 c9 00 30 	sub	r9,r8,48
80015e38:	58 99       	cp.w	r9,9
80015e3a:	e0 8b 00 23 	brhi	80015e80 <_vfprintf_r+0x344>
80015e3e:	ee c4 ff ff 	sub	r4,r7,-1
80015e42:	30 0b       	mov	r11,0
80015e44:	23 08       	sub	r8,48
80015e46:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80015e4a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80015e4e:	09 38       	ld.ub	r8,r4++
80015e50:	f0 c9 00 30 	sub	r9,r8,48
80015e54:	58 99       	cp.w	r9,9
80015e56:	fe 98 ff f7 	brls	80015e44 <_vfprintf_r+0x308>
80015e5a:	e0 48 00 24 	cp.w	r8,36
80015e5e:	fe 91 ff 51 	brne	80015d00 <_vfprintf_r+0x1c4>
80015e62:	e0 4b 00 20 	cp.w	r11,32
80015e66:	e0 89 0d f5 	brgt	80017a50 <_vfprintf_r+0x1f14>
80015e6a:	20 1b       	sub	r11,1
80015e6c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80015e70:	10 3b       	cp.w	r11,r8
80015e72:	c0 e5       	brlt	80015e8e <_vfprintf_r+0x352>
80015e74:	c1 58       	rjmp	80015e9e <_vfprintf_r+0x362>
80015e76:	d7 03       	nop
80015e78:	80 02       	ld.sh	r2,r0[0x0]
80015e7a:	00 88       	andn	r8,r0
80015e7c:	80 02       	ld.sh	r2,r0[0x0]
80015e7e:	02 c4       	st.b	r1++,r4
80015e80:	fa fa 06 b4 	ld.w	r10,sp[1716]
80015e84:	ec c9 ff ff 	sub	r9,r6,-1
80015e88:	14 36       	cp.w	r6,r10
80015e8a:	c1 f5       	brlt	80015ec8 <_vfprintf_r+0x38c>
80015e8c:	c2 88       	rjmp	80015edc <_vfprintf_r+0x3a0>
80015e8e:	fa ca f9 44 	sub	r10,sp,-1724
80015e92:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80015e96:	f6 fb fd 88 	ld.w	r11,r11[-632]
80015e9a:	50 2b       	stdsp	sp[0x8],r11
80015e9c:	c3 c8       	rjmp	80015f14 <_vfprintf_r+0x3d8>
80015e9e:	fa c8 f9 50 	sub	r8,sp,-1712
80015ea2:	1a d8       	st.w	--sp,r8
80015ea4:	fa c8 fa b8 	sub	r8,sp,-1352
80015ea8:	1a d8       	st.w	--sp,r8
80015eaa:	fa c8 fb b4 	sub	r8,sp,-1100
80015eae:	02 9a       	mov	r10,r1
80015eb0:	1a d8       	st.w	--sp,r8
80015eb2:	04 9c       	mov	r12,r2
80015eb4:	fa c8 f9 40 	sub	r8,sp,-1728
80015eb8:	fa c9 ff b4 	sub	r9,sp,-76
80015ebc:	fe b0 fc a2 	rcall	80015800 <get_arg>
80015ec0:	2f dd       	sub	sp,-12
80015ec2:	78 0c       	ld.w	r12,r12[0x0]
80015ec4:	50 2c       	stdsp	sp[0x8],r12
80015ec6:	c2 78       	rjmp	80015f14 <_vfprintf_r+0x3d8>
80015ec8:	12 96       	mov	r6,r9
80015eca:	0e 94       	mov	r4,r7
80015ecc:	fa c9 f9 44 	sub	r9,sp,-1724
80015ed0:	f2 03 00 38 	add	r8,r9,r3<<0x3
80015ed4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80015ed8:	50 28       	stdsp	sp[0x8],r8
80015eda:	c1 d8       	rjmp	80015f14 <_vfprintf_r+0x3d8>
80015edc:	41 08       	lddsp	r8,sp[0x40]
80015ede:	59 fa       	cp.w	r10,31
80015ee0:	e0 89 00 14 	brgt	80015f08 <_vfprintf_r+0x3cc>
80015ee4:	f0 cb ff fc 	sub	r11,r8,-4
80015ee8:	70 08       	ld.w	r8,r8[0x0]
80015eea:	51 0b       	stdsp	sp[0x40],r11
80015eec:	50 28       	stdsp	sp[0x8],r8
80015eee:	fa c6 f9 44 	sub	r6,sp,-1724
80015ef2:	40 2e       	lddsp	lr,sp[0x8]
80015ef4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80015ef8:	f1 4e fd 88 	st.w	r8[-632],lr
80015efc:	2f fa       	sub	r10,-1
80015efe:	0e 94       	mov	r4,r7
80015f00:	fb 4a 06 b4 	st.w	sp[1716],r10
80015f04:	12 96       	mov	r6,r9
80015f06:	c0 78       	rjmp	80015f14 <_vfprintf_r+0x3d8>
80015f08:	70 0c       	ld.w	r12,r8[0x0]
80015f0a:	0e 94       	mov	r4,r7
80015f0c:	2f c8       	sub	r8,-4
80015f0e:	50 2c       	stdsp	sp[0x8],r12
80015f10:	12 96       	mov	r6,r9
80015f12:	51 08       	stdsp	sp[0x40],r8
80015f14:	40 2b       	lddsp	r11,sp[0x8]
80015f16:	58 0b       	cp.w	r11,0
80015f18:	fe 95 fe f0 	brlt	80015cf8 <_vfprintf_r+0x1bc>
80015f1c:	08 97       	mov	r7,r4
80015f1e:	cf 3a       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015f20:	f2 09 00 29 	add	r9,r9,r9<<0x2
80015f24:	0f 38       	ld.ub	r8,r7++
80015f26:	f4 09 00 19 	add	r9,r10,r9<<0x1
80015f2a:	f0 ca 00 30 	sub	r10,r8,48
80015f2e:	58 9a       	cp.w	r10,9
80015f30:	fe 98 ff f8 	brls	80015f20 <_vfprintf_r+0x3e4>
80015f34:	3f fa       	mov	r10,-1
80015f36:	f2 0a 0c 49 	max	r9,r9,r10
80015f3a:	50 29       	stdsp	sp[0x8],r9
80015f3c:	ce 7a       	rjmp	80015d0a <_vfprintf_r+0x1ce>
80015f3e:	a7 b5       	sbr	r5,0x7
80015f40:	ce 2a       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015f42:	30 09       	mov	r9,0
80015f44:	23 08       	sub	r8,48
80015f46:	f2 09 00 29 	add	r9,r9,r9<<0x2
80015f4a:	f0 09 00 19 	add	r9,r8,r9<<0x1
80015f4e:	0f 38       	ld.ub	r8,r7++
80015f50:	f0 ca 00 30 	sub	r10,r8,48
80015f54:	58 9a       	cp.w	r10,9
80015f56:	fe 98 ff f7 	brls	80015f44 <_vfprintf_r+0x408>
80015f5a:	e0 48 00 24 	cp.w	r8,36
80015f5e:	fe 91 fe d5 	brne	80015d08 <_vfprintf_r+0x1cc>
80015f62:	e0 49 00 20 	cp.w	r9,32
80015f66:	e0 89 0d 75 	brgt	80017a50 <_vfprintf_r+0x1f14>
80015f6a:	f2 c3 00 01 	sub	r3,r9,1
80015f6e:	30 19       	mov	r9,1
80015f70:	50 39       	stdsp	sp[0xc],r9
80015f72:	cc 9a       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015f74:	a3 b5       	sbr	r5,0x3
80015f76:	cc 7a       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015f78:	a7 a5       	sbr	r5,0x6
80015f7a:	cc 5a       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015f7c:	0a 98       	mov	r8,r5
80015f7e:	a5 b5       	sbr	r5,0x5
80015f80:	a5 a8       	sbr	r8,0x4
80015f82:	0f 89       	ld.ub	r9,r7[0x0]
80015f84:	36 ce       	mov	lr,108
80015f86:	fc 09 18 00 	cp.b	r9,lr
80015f8a:	f7 b7 00 ff 	subeq	r7,-1
80015f8e:	f0 05 17 10 	movne	r5,r8
80015f92:	cb 9a       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015f94:	a5 b5       	sbr	r5,0x5
80015f96:	cb 7a       	rjmp	80015d04 <_vfprintf_r+0x1c8>
80015f98:	50 a7       	stdsp	sp[0x28],r7
80015f9a:	50 80       	stdsp	sp[0x20],r0
80015f9c:	0c 97       	mov	r7,r6
80015f9e:	10 90       	mov	r0,r8
80015fa0:	06 96       	mov	r6,r3
80015fa2:	04 94       	mov	r4,r2
80015fa4:	40 93       	lddsp	r3,sp[0x24]
80015fa6:	02 92       	mov	r2,r1
80015fa8:	0e 99       	mov	r9,r7
80015faa:	40 41       	lddsp	r1,sp[0x10]
80015fac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80015fb0:	40 3c       	lddsp	r12,sp[0xc]
80015fb2:	58 0c       	cp.w	r12,0
80015fb4:	c1 d0       	breq	80015fee <_vfprintf_r+0x4b2>
80015fb6:	10 36       	cp.w	r6,r8
80015fb8:	c0 64       	brge	80015fc4 <_vfprintf_r+0x488>
80015fba:	fa cb f9 44 	sub	r11,sp,-1724
80015fbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80015fc2:	c1 d8       	rjmp	80015ffc <_vfprintf_r+0x4c0>
80015fc4:	fa c8 f9 50 	sub	r8,sp,-1712
80015fc8:	1a d8       	st.w	--sp,r8
80015fca:	fa c8 fa b8 	sub	r8,sp,-1352
80015fce:	1a d8       	st.w	--sp,r8
80015fd0:	fa c8 fb b4 	sub	r8,sp,-1100
80015fd4:	1a d8       	st.w	--sp,r8
80015fd6:	fa c8 f9 40 	sub	r8,sp,-1728
80015fda:	fa c9 ff b4 	sub	r9,sp,-76
80015fde:	04 9a       	mov	r10,r2
80015fe0:	0c 9b       	mov	r11,r6
80015fe2:	08 9c       	mov	r12,r4
80015fe4:	fe b0 fc 0e 	rcall	80015800 <get_arg>
80015fe8:	2f dd       	sub	sp,-12
80015fea:	19 b8       	ld.ub	r8,r12[0x3]
80015fec:	c2 28       	rjmp	80016030 <_vfprintf_r+0x4f4>
80015fee:	2f f7       	sub	r7,-1
80015ff0:	10 39       	cp.w	r9,r8
80015ff2:	c0 84       	brge	80016002 <_vfprintf_r+0x4c6>
80015ff4:	fa ca f9 44 	sub	r10,sp,-1724
80015ff8:	f4 06 00 36 	add	r6,r10,r6<<0x3
80015ffc:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80016000:	c1 88       	rjmp	80016030 <_vfprintf_r+0x4f4>
80016002:	41 09       	lddsp	r9,sp[0x40]
80016004:	59 f8       	cp.w	r8,31
80016006:	e0 89 00 12 	brgt	8001602a <_vfprintf_r+0x4ee>
8001600a:	f2 ca ff fc 	sub	r10,r9,-4
8001600e:	51 0a       	stdsp	sp[0x40],r10
80016010:	72 09       	ld.w	r9,r9[0x0]
80016012:	fa c6 f9 44 	sub	r6,sp,-1724
80016016:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8001601a:	2f f8       	sub	r8,-1
8001601c:	f5 49 fd 88 	st.w	r10[-632],r9
80016020:	fb 48 06 b4 	st.w	sp[1716],r8
80016024:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80016028:	c0 48       	rjmp	80016030 <_vfprintf_r+0x4f4>
8001602a:	13 b8       	ld.ub	r8,r9[0x3]
8001602c:	2f c9       	sub	r9,-4
8001602e:	51 09       	stdsp	sp[0x40],r9
80016030:	fb 68 06 60 	st.b	sp[1632],r8
80016034:	30 0e       	mov	lr,0
80016036:	30 08       	mov	r8,0
80016038:	30 12       	mov	r2,1
8001603a:	fb 68 06 bb 	st.b	sp[1723],r8
8001603e:	50 2e       	stdsp	sp[0x8],lr
80016040:	e0 8f 08 b1 	bral	800171a2 <_vfprintf_r+0x1666>
80016044:	50 a7       	stdsp	sp[0x28],r7
80016046:	50 80       	stdsp	sp[0x20],r0
80016048:	0c 97       	mov	r7,r6
8001604a:	04 94       	mov	r4,r2
8001604c:	06 96       	mov	r6,r3
8001604e:	02 92       	mov	r2,r1
80016050:	40 93       	lddsp	r3,sp[0x24]
80016052:	10 90       	mov	r0,r8
80016054:	40 41       	lddsp	r1,sp[0x10]
80016056:	a5 a5       	sbr	r5,0x4
80016058:	c0 a8       	rjmp	8001606c <_vfprintf_r+0x530>
8001605a:	50 a7       	stdsp	sp[0x28],r7
8001605c:	50 80       	stdsp	sp[0x20],r0
8001605e:	0c 97       	mov	r7,r6
80016060:	04 94       	mov	r4,r2
80016062:	06 96       	mov	r6,r3
80016064:	02 92       	mov	r2,r1
80016066:	40 93       	lddsp	r3,sp[0x24]
80016068:	10 90       	mov	r0,r8
8001606a:	40 41       	lddsp	r1,sp[0x10]
8001606c:	ed b5 00 05 	bld	r5,0x5
80016070:	c5 11       	brne	80016112 <_vfprintf_r+0x5d6>
80016072:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016076:	40 3c       	lddsp	r12,sp[0xc]
80016078:	58 0c       	cp.w	r12,0
8001607a:	c1 e0       	breq	800160b6 <_vfprintf_r+0x57a>
8001607c:	10 36       	cp.w	r6,r8
8001607e:	c0 64       	brge	8001608a <_vfprintf_r+0x54e>
80016080:	fa cb f9 44 	sub	r11,sp,-1724
80016084:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016088:	c2 08       	rjmp	800160c8 <_vfprintf_r+0x58c>
8001608a:	fa c8 f9 50 	sub	r8,sp,-1712
8001608e:	1a d8       	st.w	--sp,r8
80016090:	fa c8 fa b8 	sub	r8,sp,-1352
80016094:	0c 9b       	mov	r11,r6
80016096:	1a d8       	st.w	--sp,r8
80016098:	fa c8 fb b4 	sub	r8,sp,-1100
8001609c:	1a d8       	st.w	--sp,r8
8001609e:	fa c9 ff b4 	sub	r9,sp,-76
800160a2:	fa c8 f9 40 	sub	r8,sp,-1728
800160a6:	04 9a       	mov	r10,r2
800160a8:	08 9c       	mov	r12,r4
800160aa:	fe b0 fb ab 	rcall	80015800 <get_arg>
800160ae:	2f dd       	sub	sp,-12
800160b0:	78 1b       	ld.w	r11,r12[0x4]
800160b2:	78 09       	ld.w	r9,r12[0x0]
800160b4:	c2 b8       	rjmp	8001610a <_vfprintf_r+0x5ce>
800160b6:	ee ca ff ff 	sub	r10,r7,-1
800160ba:	10 37       	cp.w	r7,r8
800160bc:	c0 b4       	brge	800160d2 <_vfprintf_r+0x596>
800160be:	fa c9 f9 44 	sub	r9,sp,-1724
800160c2:	14 97       	mov	r7,r10
800160c4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800160c8:	ec fb fd 8c 	ld.w	r11,r6[-628]
800160cc:	ec f9 fd 88 	ld.w	r9,r6[-632]
800160d0:	c1 d8       	rjmp	8001610a <_vfprintf_r+0x5ce>
800160d2:	41 09       	lddsp	r9,sp[0x40]
800160d4:	59 f8       	cp.w	r8,31
800160d6:	e0 89 00 14 	brgt	800160fe <_vfprintf_r+0x5c2>
800160da:	f2 cb ff f8 	sub	r11,r9,-8
800160de:	51 0b       	stdsp	sp[0x40],r11
800160e0:	fa c6 f9 44 	sub	r6,sp,-1724
800160e4:	72 1b       	ld.w	r11,r9[0x4]
800160e6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800160ea:	72 09       	ld.w	r9,r9[0x0]
800160ec:	f9 4b fd 8c 	st.w	r12[-628],r11
800160f0:	f9 49 fd 88 	st.w	r12[-632],r9
800160f4:	2f f8       	sub	r8,-1
800160f6:	14 97       	mov	r7,r10
800160f8:	fb 48 06 b4 	st.w	sp[1716],r8
800160fc:	c0 78       	rjmp	8001610a <_vfprintf_r+0x5ce>
800160fe:	f2 c8 ff f8 	sub	r8,r9,-8
80016102:	72 1b       	ld.w	r11,r9[0x4]
80016104:	14 97       	mov	r7,r10
80016106:	51 08       	stdsp	sp[0x40],r8
80016108:	72 09       	ld.w	r9,r9[0x0]
8001610a:	16 98       	mov	r8,r11
8001610c:	fa e9 00 00 	st.d	sp[0],r8
80016110:	ca e8       	rjmp	8001626c <_vfprintf_r+0x730>
80016112:	ed b5 00 04 	bld	r5,0x4
80016116:	c1 71       	brne	80016144 <_vfprintf_r+0x608>
80016118:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001611c:	40 3e       	lddsp	lr,sp[0xc]
8001611e:	58 0e       	cp.w	lr,0
80016120:	c0 80       	breq	80016130 <_vfprintf_r+0x5f4>
80016122:	10 36       	cp.w	r6,r8
80016124:	c6 94       	brge	800161f6 <_vfprintf_r+0x6ba>
80016126:	fa cc f9 44 	sub	r12,sp,-1724
8001612a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8001612e:	c8 28       	rjmp	80016232 <_vfprintf_r+0x6f6>
80016130:	ee ca ff ff 	sub	r10,r7,-1
80016134:	10 37       	cp.w	r7,r8
80016136:	e0 84 00 81 	brge	80016238 <_vfprintf_r+0x6fc>
8001613a:	fa cb f9 44 	sub	r11,sp,-1724
8001613e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016142:	c7 78       	rjmp	80016230 <_vfprintf_r+0x6f4>
80016144:	ed b5 00 06 	bld	r5,0x6
80016148:	c4 b1       	brne	800161de <_vfprintf_r+0x6a2>
8001614a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001614e:	40 3c       	lddsp	r12,sp[0xc]
80016150:	58 0c       	cp.w	r12,0
80016152:	c1 d0       	breq	8001618c <_vfprintf_r+0x650>
80016154:	10 36       	cp.w	r6,r8
80016156:	c0 64       	brge	80016162 <_vfprintf_r+0x626>
80016158:	fa cb f9 44 	sub	r11,sp,-1724
8001615c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016160:	c1 f8       	rjmp	8001619e <_vfprintf_r+0x662>
80016162:	fa c8 f9 50 	sub	r8,sp,-1712
80016166:	1a d8       	st.w	--sp,r8
80016168:	fa c8 fa b8 	sub	r8,sp,-1352
8001616c:	1a d8       	st.w	--sp,r8
8001616e:	fa c8 fb b4 	sub	r8,sp,-1100
80016172:	1a d8       	st.w	--sp,r8
80016174:	fa c8 f9 40 	sub	r8,sp,-1728
80016178:	fa c9 ff b4 	sub	r9,sp,-76
8001617c:	04 9a       	mov	r10,r2
8001617e:	0c 9b       	mov	r11,r6
80016180:	08 9c       	mov	r12,r4
80016182:	fe b0 fb 3f 	rcall	80015800 <get_arg>
80016186:	2f dd       	sub	sp,-12
80016188:	98 18       	ld.sh	r8,r12[0x2]
8001618a:	c2 68       	rjmp	800161d6 <_vfprintf_r+0x69a>
8001618c:	ee ca ff ff 	sub	r10,r7,-1
80016190:	10 37       	cp.w	r7,r8
80016192:	c0 94       	brge	800161a4 <_vfprintf_r+0x668>
80016194:	fa c9 f9 44 	sub	r9,sp,-1724
80016198:	14 97       	mov	r7,r10
8001619a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001619e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800161a2:	c1 a8       	rjmp	800161d6 <_vfprintf_r+0x69a>
800161a4:	41 09       	lddsp	r9,sp[0x40]
800161a6:	59 f8       	cp.w	r8,31
800161a8:	e0 89 00 13 	brgt	800161ce <_vfprintf_r+0x692>
800161ac:	f2 cb ff fc 	sub	r11,r9,-4
800161b0:	51 0b       	stdsp	sp[0x40],r11
800161b2:	72 09       	ld.w	r9,r9[0x0]
800161b4:	fa c6 f9 44 	sub	r6,sp,-1724
800161b8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800161bc:	2f f8       	sub	r8,-1
800161be:	f7 49 fd 88 	st.w	r11[-632],r9
800161c2:	fb 48 06 b4 	st.w	sp[1716],r8
800161c6:	14 97       	mov	r7,r10
800161c8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800161cc:	c0 58       	rjmp	800161d6 <_vfprintf_r+0x69a>
800161ce:	92 18       	ld.sh	r8,r9[0x2]
800161d0:	14 97       	mov	r7,r10
800161d2:	2f c9       	sub	r9,-4
800161d4:	51 09       	stdsp	sp[0x40],r9
800161d6:	50 18       	stdsp	sp[0x4],r8
800161d8:	bf 58       	asr	r8,0x1f
800161da:	50 08       	stdsp	sp[0x0],r8
800161dc:	c4 88       	rjmp	8001626c <_vfprintf_r+0x730>
800161de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800161e2:	40 3c       	lddsp	r12,sp[0xc]
800161e4:	58 0c       	cp.w	r12,0
800161e6:	c1 d0       	breq	80016220 <_vfprintf_r+0x6e4>
800161e8:	10 36       	cp.w	r6,r8
800161ea:	c0 64       	brge	800161f6 <_vfprintf_r+0x6ba>
800161ec:	fa cb f9 44 	sub	r11,sp,-1724
800161f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800161f4:	c1 f8       	rjmp	80016232 <_vfprintf_r+0x6f6>
800161f6:	fa c8 f9 50 	sub	r8,sp,-1712
800161fa:	1a d8       	st.w	--sp,r8
800161fc:	fa c8 fa b8 	sub	r8,sp,-1352
80016200:	0c 9b       	mov	r11,r6
80016202:	1a d8       	st.w	--sp,r8
80016204:	fa c8 fb b4 	sub	r8,sp,-1100
80016208:	04 9a       	mov	r10,r2
8001620a:	1a d8       	st.w	--sp,r8
8001620c:	08 9c       	mov	r12,r4
8001620e:	fa c8 f9 40 	sub	r8,sp,-1728
80016212:	fa c9 ff b4 	sub	r9,sp,-76
80016216:	fe b0 fa f5 	rcall	80015800 <get_arg>
8001621a:	2f dd       	sub	sp,-12
8001621c:	78 0b       	ld.w	r11,r12[0x0]
8001621e:	c2 48       	rjmp	80016266 <_vfprintf_r+0x72a>
80016220:	ee ca ff ff 	sub	r10,r7,-1
80016224:	10 37       	cp.w	r7,r8
80016226:	c0 94       	brge	80016238 <_vfprintf_r+0x6fc>
80016228:	fa c9 f9 44 	sub	r9,sp,-1724
8001622c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80016230:	14 97       	mov	r7,r10
80016232:	ec fb fd 88 	ld.w	r11,r6[-632]
80016236:	c1 88       	rjmp	80016266 <_vfprintf_r+0x72a>
80016238:	41 09       	lddsp	r9,sp[0x40]
8001623a:	59 f8       	cp.w	r8,31
8001623c:	e0 89 00 11 	brgt	8001625e <_vfprintf_r+0x722>
80016240:	f2 cb ff fc 	sub	r11,r9,-4
80016244:	51 0b       	stdsp	sp[0x40],r11
80016246:	fa c6 f9 44 	sub	r6,sp,-1724
8001624a:	72 0b       	ld.w	r11,r9[0x0]
8001624c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80016250:	f3 4b fd 88 	st.w	r9[-632],r11
80016254:	2f f8       	sub	r8,-1
80016256:	14 97       	mov	r7,r10
80016258:	fb 48 06 b4 	st.w	sp[1716],r8
8001625c:	c0 58       	rjmp	80016266 <_vfprintf_r+0x72a>
8001625e:	72 0b       	ld.w	r11,r9[0x0]
80016260:	14 97       	mov	r7,r10
80016262:	2f c9       	sub	r9,-4
80016264:	51 09       	stdsp	sp[0x40],r9
80016266:	50 1b       	stdsp	sp[0x4],r11
80016268:	bf 5b       	asr	r11,0x1f
8001626a:	50 0b       	stdsp	sp[0x0],r11
8001626c:	fa ea 00 00 	ld.d	r10,sp[0]
80016270:	58 0a       	cp.w	r10,0
80016272:	5c 2b       	cpc	r11
80016274:	c0 e4       	brge	80016290 <_vfprintf_r+0x754>
80016276:	30 08       	mov	r8,0
80016278:	fa ea 00 00 	ld.d	r10,sp[0]
8001627c:	30 09       	mov	r9,0
8001627e:	f0 0a 01 0a 	sub	r10,r8,r10
80016282:	f2 0b 01 4b 	sbc	r11,r9,r11
80016286:	32 d8       	mov	r8,45
80016288:	fa eb 00 00 	st.d	sp[0],r10
8001628c:	fb 68 06 bb 	st.b	sp[1723],r8
80016290:	30 18       	mov	r8,1
80016292:	e0 8f 06 fe 	bral	8001708e <_vfprintf_r+0x1552>
80016296:	50 a7       	stdsp	sp[0x28],r7
80016298:	50 80       	stdsp	sp[0x20],r0
8001629a:	0c 97       	mov	r7,r6
8001629c:	04 94       	mov	r4,r2
8001629e:	06 96       	mov	r6,r3
800162a0:	02 92       	mov	r2,r1
800162a2:	40 93       	lddsp	r3,sp[0x24]
800162a4:	10 90       	mov	r0,r8
800162a6:	40 41       	lddsp	r1,sp[0x10]
800162a8:	0e 99       	mov	r9,r7
800162aa:	ed b5 00 03 	bld	r5,0x3
800162ae:	c4 11       	brne	80016330 <_vfprintf_r+0x7f4>
800162b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800162b4:	40 3a       	lddsp	r10,sp[0xc]
800162b6:	58 0a       	cp.w	r10,0
800162b8:	c1 90       	breq	800162ea <_vfprintf_r+0x7ae>
800162ba:	10 36       	cp.w	r6,r8
800162bc:	c6 45       	brlt	80016384 <_vfprintf_r+0x848>
800162be:	fa c8 f9 50 	sub	r8,sp,-1712
800162c2:	1a d8       	st.w	--sp,r8
800162c4:	fa c8 fa b8 	sub	r8,sp,-1352
800162c8:	1a d8       	st.w	--sp,r8
800162ca:	fa c8 fb b4 	sub	r8,sp,-1100
800162ce:	0c 9b       	mov	r11,r6
800162d0:	1a d8       	st.w	--sp,r8
800162d2:	04 9a       	mov	r10,r2
800162d4:	fa c8 f9 40 	sub	r8,sp,-1728
800162d8:	fa c9 ff b4 	sub	r9,sp,-76
800162dc:	08 9c       	mov	r12,r4
800162de:	fe b0 fa 91 	rcall	80015800 <get_arg>
800162e2:	2f dd       	sub	sp,-12
800162e4:	78 16       	ld.w	r6,r12[0x4]
800162e6:	50 76       	stdsp	sp[0x1c],r6
800162e8:	c4 88       	rjmp	80016378 <_vfprintf_r+0x83c>
800162ea:	2f f7       	sub	r7,-1
800162ec:	10 39       	cp.w	r9,r8
800162ee:	c0 c4       	brge	80016306 <_vfprintf_r+0x7ca>
800162f0:	fa ce f9 44 	sub	lr,sp,-1724
800162f4:	fc 06 00 36 	add	r6,lr,r6<<0x3
800162f8:	ec fc fd 8c 	ld.w	r12,r6[-628]
800162fc:	50 7c       	stdsp	sp[0x1c],r12
800162fe:	ec f6 fd 88 	ld.w	r6,r6[-632]
80016302:	50 56       	stdsp	sp[0x14],r6
80016304:	c6 68       	rjmp	800163d0 <_vfprintf_r+0x894>
80016306:	41 09       	lddsp	r9,sp[0x40]
80016308:	59 f8       	cp.w	r8,31
8001630a:	e0 89 00 10 	brgt	8001632a <_vfprintf_r+0x7ee>
8001630e:	f2 ca ff f8 	sub	r10,r9,-8
80016312:	72 1b       	ld.w	r11,r9[0x4]
80016314:	51 0a       	stdsp	sp[0x40],r10
80016316:	72 09       	ld.w	r9,r9[0x0]
80016318:	fa ca f9 44 	sub	r10,sp,-1724
8001631c:	50 7b       	stdsp	sp[0x1c],r11
8001631e:	50 59       	stdsp	sp[0x14],r9
80016320:	f4 08 00 39 	add	r9,r10,r8<<0x3
80016324:	40 5b       	lddsp	r11,sp[0x14]
80016326:	40 7a       	lddsp	r10,sp[0x1c]
80016328:	c4 78       	rjmp	800163b6 <_vfprintf_r+0x87a>
8001632a:	72 18       	ld.w	r8,r9[0x4]
8001632c:	50 78       	stdsp	sp[0x1c],r8
8001632e:	c4 c8       	rjmp	800163c6 <_vfprintf_r+0x88a>
80016330:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016334:	40 3e       	lddsp	lr,sp[0xc]
80016336:	58 0e       	cp.w	lr,0
80016338:	c2 30       	breq	8001637e <_vfprintf_r+0x842>
8001633a:	10 36       	cp.w	r6,r8
8001633c:	c0 94       	brge	8001634e <_vfprintf_r+0x812>
8001633e:	fa cc f9 44 	sub	r12,sp,-1724
80016342:	f8 06 00 36 	add	r6,r12,r6<<0x3
80016346:	ec fb fd 8c 	ld.w	r11,r6[-628]
8001634a:	50 7b       	stdsp	sp[0x1c],r11
8001634c:	cd 9b       	rjmp	800162fe <_vfprintf_r+0x7c2>
8001634e:	fa c8 f9 50 	sub	r8,sp,-1712
80016352:	1a d8       	st.w	--sp,r8
80016354:	fa c8 fa b8 	sub	r8,sp,-1352
80016358:	04 9a       	mov	r10,r2
8001635a:	1a d8       	st.w	--sp,r8
8001635c:	fa c8 fb b4 	sub	r8,sp,-1100
80016360:	0c 9b       	mov	r11,r6
80016362:	1a d8       	st.w	--sp,r8
80016364:	08 9c       	mov	r12,r4
80016366:	fa c8 f9 40 	sub	r8,sp,-1728
8001636a:	fa c9 ff b4 	sub	r9,sp,-76
8001636e:	fe b0 fa 49 	rcall	80015800 <get_arg>
80016372:	2f dd       	sub	sp,-12
80016374:	78 1a       	ld.w	r10,r12[0x4]
80016376:	50 7a       	stdsp	sp[0x1c],r10
80016378:	78 0c       	ld.w	r12,r12[0x0]
8001637a:	50 5c       	stdsp	sp[0x14],r12
8001637c:	c2 a8       	rjmp	800163d0 <_vfprintf_r+0x894>
8001637e:	2f f7       	sub	r7,-1
80016380:	10 39       	cp.w	r9,r8
80016382:	c0 94       	brge	80016394 <_vfprintf_r+0x858>
80016384:	fa c9 f9 44 	sub	r9,sp,-1724
80016388:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001638c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80016390:	50 78       	stdsp	sp[0x1c],r8
80016392:	cb 6b       	rjmp	800162fe <_vfprintf_r+0x7c2>
80016394:	41 09       	lddsp	r9,sp[0x40]
80016396:	59 f8       	cp.w	r8,31
80016398:	e0 89 00 15 	brgt	800163c2 <_vfprintf_r+0x886>
8001639c:	f2 ca ff f8 	sub	r10,r9,-8
800163a0:	72 16       	ld.w	r6,r9[0x4]
800163a2:	72 09       	ld.w	r9,r9[0x0]
800163a4:	51 0a       	stdsp	sp[0x40],r10
800163a6:	50 59       	stdsp	sp[0x14],r9
800163a8:	fa ce f9 44 	sub	lr,sp,-1724
800163ac:	50 76       	stdsp	sp[0x1c],r6
800163ae:	fc 08 00 39 	add	r9,lr,r8<<0x3
800163b2:	40 5b       	lddsp	r11,sp[0x14]
800163b4:	0c 9a       	mov	r10,r6
800163b6:	f2 eb fd 88 	st.d	r9[-632],r10
800163ba:	2f f8       	sub	r8,-1
800163bc:	fb 48 06 b4 	st.w	sp[1716],r8
800163c0:	c0 88       	rjmp	800163d0 <_vfprintf_r+0x894>
800163c2:	72 1c       	ld.w	r12,r9[0x4]
800163c4:	50 7c       	stdsp	sp[0x1c],r12
800163c6:	f2 c8 ff f8 	sub	r8,r9,-8
800163ca:	51 08       	stdsp	sp[0x40],r8
800163cc:	72 09       	ld.w	r9,r9[0x0]
800163ce:	50 59       	stdsp	sp[0x14],r9
800163d0:	40 5b       	lddsp	r11,sp[0x14]
800163d2:	40 7a       	lddsp	r10,sp[0x1c]
800163d4:	e0 a0 27 9c 	rcall	8001b30c <__isinfd>
800163d8:	18 96       	mov	r6,r12
800163da:	c1 50       	breq	80016404 <_vfprintf_r+0x8c8>
800163dc:	30 08       	mov	r8,0
800163de:	30 09       	mov	r9,0
800163e0:	40 5b       	lddsp	r11,sp[0x14]
800163e2:	40 7a       	lddsp	r10,sp[0x1c]
800163e4:	e0 a0 37 85 	rcall	8001d2ee <__avr32_f64_cmp_lt>
800163e8:	c0 40       	breq	800163f0 <_vfprintf_r+0x8b4>
800163ea:	32 d8       	mov	r8,45
800163ec:	fb 68 06 bb 	st.b	sp[1723],r8
800163f0:	4d 18       	lddpc	r8,80016534 <_vfprintf_r+0x9f8>
800163f2:	4d 26       	lddpc	r6,80016538 <_vfprintf_r+0x9fc>
800163f4:	a7 d5       	cbr	r5,0x7
800163f6:	e0 40 00 47 	cp.w	r0,71
800163fa:	f0 06 17 a0 	movle	r6,r8
800163fe:	30 32       	mov	r2,3
80016400:	e0 8f 06 d4 	bral	800171a8 <_vfprintf_r+0x166c>
80016404:	40 5b       	lddsp	r11,sp[0x14]
80016406:	40 7a       	lddsp	r10,sp[0x1c]
80016408:	e0 a0 27 97 	rcall	8001b336 <__isnand>
8001640c:	c0 c0       	breq	80016424 <_vfprintf_r+0x8e8>
8001640e:	50 26       	stdsp	sp[0x8],r6
80016410:	4c b8       	lddpc	r8,8001653c <_vfprintf_r+0xa00>
80016412:	4c c6       	lddpc	r6,80016540 <_vfprintf_r+0xa04>
80016414:	a7 d5       	cbr	r5,0x7
80016416:	e0 40 00 47 	cp.w	r0,71
8001641a:	f0 06 17 a0 	movle	r6,r8
8001641e:	30 32       	mov	r2,3
80016420:	e0 8f 06 ca 	bral	800171b4 <_vfprintf_r+0x1678>
80016424:	40 2a       	lddsp	r10,sp[0x8]
80016426:	5b fa       	cp.w	r10,-1
80016428:	c0 41       	brne	80016430 <_vfprintf_r+0x8f4>
8001642a:	30 69       	mov	r9,6
8001642c:	50 29       	stdsp	sp[0x8],r9
8001642e:	c1 18       	rjmp	80016450 <_vfprintf_r+0x914>
80016430:	e0 40 00 47 	cp.w	r0,71
80016434:	5f 09       	sreq	r9
80016436:	e0 40 00 67 	cp.w	r0,103
8001643a:	5f 08       	sreq	r8
8001643c:	f3 e8 10 08 	or	r8,r9,r8
80016440:	f8 08 18 00 	cp.b	r8,r12
80016444:	c0 60       	breq	80016450 <_vfprintf_r+0x914>
80016446:	40 28       	lddsp	r8,sp[0x8]
80016448:	58 08       	cp.w	r8,0
8001644a:	f9 b8 00 01 	moveq	r8,1
8001644e:	50 28       	stdsp	sp[0x8],r8
80016450:	40 78       	lddsp	r8,sp[0x1c]
80016452:	40 59       	lddsp	r9,sp[0x14]
80016454:	fa e9 06 94 	st.d	sp[1684],r8
80016458:	a9 a5       	sbr	r5,0x8
8001645a:	fa f8 06 94 	ld.w	r8,sp[1684]
8001645e:	58 08       	cp.w	r8,0
80016460:	c0 65       	brlt	8001646c <_vfprintf_r+0x930>
80016462:	40 5e       	lddsp	lr,sp[0x14]
80016464:	30 0c       	mov	r12,0
80016466:	50 6e       	stdsp	sp[0x18],lr
80016468:	50 9c       	stdsp	sp[0x24],r12
8001646a:	c0 78       	rjmp	80016478 <_vfprintf_r+0x93c>
8001646c:	40 5b       	lddsp	r11,sp[0x14]
8001646e:	32 da       	mov	r10,45
80016470:	ee 1b 80 00 	eorh	r11,0x8000
80016474:	50 9a       	stdsp	sp[0x24],r10
80016476:	50 6b       	stdsp	sp[0x18],r11
80016478:	e0 40 00 46 	cp.w	r0,70
8001647c:	5f 09       	sreq	r9
8001647e:	e0 40 00 66 	cp.w	r0,102
80016482:	5f 08       	sreq	r8
80016484:	f3 e8 10 08 	or	r8,r9,r8
80016488:	50 48       	stdsp	sp[0x10],r8
8001648a:	c0 40       	breq	80016492 <_vfprintf_r+0x956>
8001648c:	40 22       	lddsp	r2,sp[0x8]
8001648e:	30 39       	mov	r9,3
80016490:	c1 08       	rjmp	800164b0 <_vfprintf_r+0x974>
80016492:	e0 40 00 45 	cp.w	r0,69
80016496:	5f 09       	sreq	r9
80016498:	e0 40 00 65 	cp.w	r0,101
8001649c:	5f 08       	sreq	r8
8001649e:	40 22       	lddsp	r2,sp[0x8]
800164a0:	10 49       	or	r9,r8
800164a2:	2f f2       	sub	r2,-1
800164a4:	40 46       	lddsp	r6,sp[0x10]
800164a6:	ec 09 18 00 	cp.b	r9,r6
800164aa:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800164ae:	30 29       	mov	r9,2
800164b0:	fa c8 f9 5c 	sub	r8,sp,-1700
800164b4:	1a d8       	st.w	--sp,r8
800164b6:	fa c8 f9 54 	sub	r8,sp,-1708
800164ba:	1a d8       	st.w	--sp,r8
800164bc:	fa c8 f9 4c 	sub	r8,sp,-1716
800164c0:	08 9c       	mov	r12,r4
800164c2:	1a d8       	st.w	--sp,r8
800164c4:	04 98       	mov	r8,r2
800164c6:	40 9b       	lddsp	r11,sp[0x24]
800164c8:	40 aa       	lddsp	r10,sp[0x28]
800164ca:	e0 a0 16 45 	rcall	80019154 <_dtoa_r>
800164ce:	e0 40 00 47 	cp.w	r0,71
800164d2:	5f 19       	srne	r9
800164d4:	e0 40 00 67 	cp.w	r0,103
800164d8:	5f 18       	srne	r8
800164da:	18 96       	mov	r6,r12
800164dc:	2f dd       	sub	sp,-12
800164de:	f3 e8 00 08 	and	r8,r9,r8
800164e2:	c0 41       	brne	800164ea <_vfprintf_r+0x9ae>
800164e4:	ed b5 00 00 	bld	r5,0x0
800164e8:	c3 81       	brne	80016558 <_vfprintf_r+0xa1c>
800164ea:	ec 02 00 0e 	add	lr,r6,r2
800164ee:	50 3e       	stdsp	sp[0xc],lr
800164f0:	40 4c       	lddsp	r12,sp[0x10]
800164f2:	58 0c       	cp.w	r12,0
800164f4:	c1 50       	breq	8001651e <_vfprintf_r+0x9e2>
800164f6:	0d 89       	ld.ub	r9,r6[0x0]
800164f8:	33 08       	mov	r8,48
800164fa:	f0 09 18 00 	cp.b	r9,r8
800164fe:	c0 b1       	brne	80016514 <_vfprintf_r+0x9d8>
80016500:	30 08       	mov	r8,0
80016502:	30 09       	mov	r9,0
80016504:	40 6b       	lddsp	r11,sp[0x18]
80016506:	40 7a       	lddsp	r10,sp[0x1c]
80016508:	e0 a0 36 ac 	rcall	8001d260 <__avr32_f64_cmp_eq>
8001650c:	fb b2 00 01 	rsubeq	r2,1
80016510:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80016514:	40 3b       	lddsp	r11,sp[0xc]
80016516:	fa f8 06 ac 	ld.w	r8,sp[1708]
8001651a:	10 0b       	add	r11,r8
8001651c:	50 3b       	stdsp	sp[0xc],r11
8001651e:	40 6b       	lddsp	r11,sp[0x18]
80016520:	30 08       	mov	r8,0
80016522:	30 09       	mov	r9,0
80016524:	40 7a       	lddsp	r10,sp[0x1c]
80016526:	e0 a0 36 9d 	rcall	8001d260 <__avr32_f64_cmp_eq>
8001652a:	c1 10       	breq	8001654c <_vfprintf_r+0xa10>
8001652c:	40 3a       	lddsp	r10,sp[0xc]
8001652e:	fb 4a 06 a4 	st.w	sp[1700],r10
80016532:	c0 d8       	rjmp	8001654c <_vfprintf_r+0xa10>
80016534:	80 02       	ld.sh	r2,r0[0x0]
80016536:	02 d8       	st.w	--r1,r8
80016538:	80 02       	ld.sh	r2,r0[0x0]
8001653a:	02 dc       	st.w	--r1,r12
8001653c:	80 02       	ld.sh	r2,r0[0x0]
8001653e:	02 e0       	st.h	--r1,r0
80016540:	80 02       	ld.sh	r2,r0[0x0]
80016542:	02 e4       	st.h	--r1,r4
80016544:	10 c9       	st.b	r8++,r9
80016546:	fb 48 06 a4 	st.w	sp[1700],r8
8001654a:	c0 28       	rjmp	8001654e <_vfprintf_r+0xa12>
8001654c:	33 09       	mov	r9,48
8001654e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80016552:	40 3e       	lddsp	lr,sp[0xc]
80016554:	1c 38       	cp.w	r8,lr
80016556:	cf 73       	brcs	80016544 <_vfprintf_r+0xa08>
80016558:	e0 40 00 47 	cp.w	r0,71
8001655c:	5f 09       	sreq	r9
8001655e:	e0 40 00 67 	cp.w	r0,103
80016562:	5f 08       	sreq	r8
80016564:	f3 e8 10 08 	or	r8,r9,r8
80016568:	fa f9 06 a4 	ld.w	r9,sp[1700]
8001656c:	0c 19       	sub	r9,r6
8001656e:	50 69       	stdsp	sp[0x18],r9
80016570:	58 08       	cp.w	r8,0
80016572:	c0 b0       	breq	80016588 <_vfprintf_r+0xa4c>
80016574:	fa f8 06 ac 	ld.w	r8,sp[1708]
80016578:	5b d8       	cp.w	r8,-3
8001657a:	c0 55       	brlt	80016584 <_vfprintf_r+0xa48>
8001657c:	40 2c       	lddsp	r12,sp[0x8]
8001657e:	18 38       	cp.w	r8,r12
80016580:	e0 8a 00 6a 	brle	80016654 <_vfprintf_r+0xb18>
80016584:	20 20       	sub	r0,2
80016586:	c0 58       	rjmp	80016590 <_vfprintf_r+0xa54>
80016588:	e0 40 00 65 	cp.w	r0,101
8001658c:	e0 89 00 46 	brgt	80016618 <_vfprintf_r+0xadc>
80016590:	fa fb 06 ac 	ld.w	r11,sp[1708]
80016594:	fb 60 06 9c 	st.b	sp[1692],r0
80016598:	20 1b       	sub	r11,1
8001659a:	fb 4b 06 ac 	st.w	sp[1708],r11
8001659e:	c0 47       	brpl	800165a6 <_vfprintf_r+0xa6a>
800165a0:	5c 3b       	neg	r11
800165a2:	32 d8       	mov	r8,45
800165a4:	c0 28       	rjmp	800165a8 <_vfprintf_r+0xa6c>
800165a6:	32 b8       	mov	r8,43
800165a8:	fb 68 06 9d 	st.b	sp[1693],r8
800165ac:	58 9b       	cp.w	r11,9
800165ae:	e0 8a 00 1d 	brle	800165e8 <_vfprintf_r+0xaac>
800165b2:	fa c9 fa 35 	sub	r9,sp,-1483
800165b6:	30 aa       	mov	r10,10
800165b8:	12 98       	mov	r8,r9
800165ba:	0e 9c       	mov	r12,r7
800165bc:	0c 92       	mov	r2,r6
800165be:	f6 0a 0c 06 	divs	r6,r11,r10
800165c2:	0e 9b       	mov	r11,r7
800165c4:	2d 0b       	sub	r11,-48
800165c6:	10 fb       	st.b	--r8,r11
800165c8:	0c 9b       	mov	r11,r6
800165ca:	58 96       	cp.w	r6,9
800165cc:	fe 99 ff f9 	brgt	800165be <_vfprintf_r+0xa82>
800165d0:	2d 0b       	sub	r11,-48
800165d2:	18 97       	mov	r7,r12
800165d4:	04 96       	mov	r6,r2
800165d6:	10 fb       	st.b	--r8,r11
800165d8:	fa ca f9 62 	sub	r10,sp,-1694
800165dc:	c0 38       	rjmp	800165e2 <_vfprintf_r+0xaa6>
800165de:	11 3b       	ld.ub	r11,r8++
800165e0:	14 cb       	st.b	r10++,r11
800165e2:	12 38       	cp.w	r8,r9
800165e4:	cf d3       	brcs	800165de <_vfprintf_r+0xaa2>
800165e6:	c0 98       	rjmp	800165f8 <_vfprintf_r+0xabc>
800165e8:	2d 0b       	sub	r11,-48
800165ea:	33 08       	mov	r8,48
800165ec:	fb 6b 06 9f 	st.b	sp[1695],r11
800165f0:	fb 68 06 9e 	st.b	sp[1694],r8
800165f4:	fa ca f9 60 	sub	r10,sp,-1696
800165f8:	fa c8 f9 64 	sub	r8,sp,-1692
800165fc:	f4 08 01 08 	sub	r8,r10,r8
80016600:	50 e8       	stdsp	sp[0x38],r8
80016602:	10 92       	mov	r2,r8
80016604:	40 6b       	lddsp	r11,sp[0x18]
80016606:	16 02       	add	r2,r11
80016608:	58 1b       	cp.w	r11,1
8001660a:	e0 89 00 05 	brgt	80016614 <_vfprintf_r+0xad8>
8001660e:	ed b5 00 00 	bld	r5,0x0
80016612:	c3 51       	brne	8001667c <_vfprintf_r+0xb40>
80016614:	2f f2       	sub	r2,-1
80016616:	c3 38       	rjmp	8001667c <_vfprintf_r+0xb40>
80016618:	e0 40 00 66 	cp.w	r0,102
8001661c:	c1 c1       	brne	80016654 <_vfprintf_r+0xb18>
8001661e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80016622:	58 02       	cp.w	r2,0
80016624:	e0 8a 00 0c 	brle	8001663c <_vfprintf_r+0xb00>
80016628:	40 2a       	lddsp	r10,sp[0x8]
8001662a:	58 0a       	cp.w	r10,0
8001662c:	c0 41       	brne	80016634 <_vfprintf_r+0xaf8>
8001662e:	ed b5 00 00 	bld	r5,0x0
80016632:	c2 51       	brne	8001667c <_vfprintf_r+0xb40>
80016634:	2f f2       	sub	r2,-1
80016636:	40 29       	lddsp	r9,sp[0x8]
80016638:	12 02       	add	r2,r9
8001663a:	c0 b8       	rjmp	80016650 <_vfprintf_r+0xb14>
8001663c:	40 28       	lddsp	r8,sp[0x8]
8001663e:	58 08       	cp.w	r8,0
80016640:	c0 61       	brne	8001664c <_vfprintf_r+0xb10>
80016642:	ed b5 00 00 	bld	r5,0x0
80016646:	c0 30       	breq	8001664c <_vfprintf_r+0xb10>
80016648:	30 12       	mov	r2,1
8001664a:	c1 98       	rjmp	8001667c <_vfprintf_r+0xb40>
8001664c:	40 22       	lddsp	r2,sp[0x8]
8001664e:	2f e2       	sub	r2,-2
80016650:	36 60       	mov	r0,102
80016652:	c1 58       	rjmp	8001667c <_vfprintf_r+0xb40>
80016654:	fa f2 06 ac 	ld.w	r2,sp[1708]
80016658:	40 6e       	lddsp	lr,sp[0x18]
8001665a:	1c 32       	cp.w	r2,lr
8001665c:	c0 65       	brlt	80016668 <_vfprintf_r+0xb2c>
8001665e:	ed b5 00 00 	bld	r5,0x0
80016662:	f7 b2 00 ff 	subeq	r2,-1
80016666:	c0 a8       	rjmp	8001667a <_vfprintf_r+0xb3e>
80016668:	e4 08 11 02 	rsub	r8,r2,2
8001666c:	40 6c       	lddsp	r12,sp[0x18]
8001666e:	58 02       	cp.w	r2,0
80016670:	f0 02 17 a0 	movle	r2,r8
80016674:	f9 b2 09 01 	movgt	r2,1
80016678:	18 02       	add	r2,r12
8001667a:	36 70       	mov	r0,103
8001667c:	40 9b       	lddsp	r11,sp[0x24]
8001667e:	58 0b       	cp.w	r11,0
80016680:	e0 80 05 94 	breq	800171a8 <_vfprintf_r+0x166c>
80016684:	32 d8       	mov	r8,45
80016686:	fb 68 06 bb 	st.b	sp[1723],r8
8001668a:	e0 8f 05 93 	bral	800171b0 <_vfprintf_r+0x1674>
8001668e:	50 a7       	stdsp	sp[0x28],r7
80016690:	04 94       	mov	r4,r2
80016692:	0c 97       	mov	r7,r6
80016694:	02 92       	mov	r2,r1
80016696:	06 96       	mov	r6,r3
80016698:	40 41       	lddsp	r1,sp[0x10]
8001669a:	40 93       	lddsp	r3,sp[0x24]
8001669c:	0e 99       	mov	r9,r7
8001669e:	ed b5 00 05 	bld	r5,0x5
800166a2:	c4 81       	brne	80016732 <_vfprintf_r+0xbf6>
800166a4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800166a8:	40 3e       	lddsp	lr,sp[0xc]
800166aa:	58 0e       	cp.w	lr,0
800166ac:	c1 d0       	breq	800166e6 <_vfprintf_r+0xbaa>
800166ae:	10 36       	cp.w	r6,r8
800166b0:	c0 64       	brge	800166bc <_vfprintf_r+0xb80>
800166b2:	fa cc f9 44 	sub	r12,sp,-1724
800166b6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800166ba:	c1 d8       	rjmp	800166f4 <_vfprintf_r+0xbb8>
800166bc:	fa c8 f9 50 	sub	r8,sp,-1712
800166c0:	1a d8       	st.w	--sp,r8
800166c2:	fa c8 fa b8 	sub	r8,sp,-1352
800166c6:	04 9a       	mov	r10,r2
800166c8:	1a d8       	st.w	--sp,r8
800166ca:	fa c8 fb b4 	sub	r8,sp,-1100
800166ce:	0c 9b       	mov	r11,r6
800166d0:	1a d8       	st.w	--sp,r8
800166d2:	08 9c       	mov	r12,r4
800166d4:	fa c8 f9 40 	sub	r8,sp,-1728
800166d8:	fa c9 ff b4 	sub	r9,sp,-76
800166dc:	fe b0 f8 92 	rcall	80015800 <get_arg>
800166e0:	2f dd       	sub	sp,-12
800166e2:	78 0a       	ld.w	r10,r12[0x0]
800166e4:	c2 08       	rjmp	80016724 <_vfprintf_r+0xbe8>
800166e6:	2f f7       	sub	r7,-1
800166e8:	10 39       	cp.w	r9,r8
800166ea:	c0 84       	brge	800166fa <_vfprintf_r+0xbbe>
800166ec:	fa cb f9 44 	sub	r11,sp,-1724
800166f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800166f4:	ec fa fd 88 	ld.w	r10,r6[-632]
800166f8:	c1 68       	rjmp	80016724 <_vfprintf_r+0xbe8>
800166fa:	41 09       	lddsp	r9,sp[0x40]
800166fc:	59 f8       	cp.w	r8,31
800166fe:	e0 89 00 10 	brgt	8001671e <_vfprintf_r+0xbe2>
80016702:	f2 ca ff fc 	sub	r10,r9,-4
80016706:	51 0a       	stdsp	sp[0x40],r10
80016708:	fa c6 f9 44 	sub	r6,sp,-1724
8001670c:	72 0a       	ld.w	r10,r9[0x0]
8001670e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80016712:	f3 4a fd 88 	st.w	r9[-632],r10
80016716:	2f f8       	sub	r8,-1
80016718:	fb 48 06 b4 	st.w	sp[1716],r8
8001671c:	c0 48       	rjmp	80016724 <_vfprintf_r+0xbe8>
8001671e:	72 0a       	ld.w	r10,r9[0x0]
80016720:	2f c9       	sub	r9,-4
80016722:	51 09       	stdsp	sp[0x40],r9
80016724:	40 be       	lddsp	lr,sp[0x2c]
80016726:	1c 98       	mov	r8,lr
80016728:	95 1e       	st.w	r10[0x4],lr
8001672a:	bf 58       	asr	r8,0x1f
8001672c:	95 08       	st.w	r10[0x0],r8
8001672e:	fe 9f fa 92 	bral	80015c52 <_vfprintf_r+0x116>
80016732:	ed b5 00 04 	bld	r5,0x4
80016736:	c4 80       	breq	800167c6 <_vfprintf_r+0xc8a>
80016738:	e2 15 00 40 	andl	r5,0x40,COH
8001673c:	c4 50       	breq	800167c6 <_vfprintf_r+0xc8a>
8001673e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016742:	40 3c       	lddsp	r12,sp[0xc]
80016744:	58 0c       	cp.w	r12,0
80016746:	c1 d0       	breq	80016780 <_vfprintf_r+0xc44>
80016748:	10 36       	cp.w	r6,r8
8001674a:	c0 64       	brge	80016756 <_vfprintf_r+0xc1a>
8001674c:	fa cb f9 44 	sub	r11,sp,-1724
80016750:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016754:	c1 d8       	rjmp	8001678e <_vfprintf_r+0xc52>
80016756:	fa c8 f9 50 	sub	r8,sp,-1712
8001675a:	1a d8       	st.w	--sp,r8
8001675c:	fa c8 fa b8 	sub	r8,sp,-1352
80016760:	04 9a       	mov	r10,r2
80016762:	1a d8       	st.w	--sp,r8
80016764:	fa c8 fb b4 	sub	r8,sp,-1100
80016768:	0c 9b       	mov	r11,r6
8001676a:	1a d8       	st.w	--sp,r8
8001676c:	08 9c       	mov	r12,r4
8001676e:	fa c8 f9 40 	sub	r8,sp,-1728
80016772:	fa c9 ff b4 	sub	r9,sp,-76
80016776:	fe b0 f8 45 	rcall	80015800 <get_arg>
8001677a:	2f dd       	sub	sp,-12
8001677c:	78 0a       	ld.w	r10,r12[0x0]
8001677e:	c2 08       	rjmp	800167be <_vfprintf_r+0xc82>
80016780:	2f f7       	sub	r7,-1
80016782:	10 39       	cp.w	r9,r8
80016784:	c0 84       	brge	80016794 <_vfprintf_r+0xc58>
80016786:	fa ca f9 44 	sub	r10,sp,-1724
8001678a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8001678e:	ec fa fd 88 	ld.w	r10,r6[-632]
80016792:	c1 68       	rjmp	800167be <_vfprintf_r+0xc82>
80016794:	41 09       	lddsp	r9,sp[0x40]
80016796:	59 f8       	cp.w	r8,31
80016798:	e0 89 00 10 	brgt	800167b8 <_vfprintf_r+0xc7c>
8001679c:	f2 ca ff fc 	sub	r10,r9,-4
800167a0:	51 0a       	stdsp	sp[0x40],r10
800167a2:	fa c6 f9 44 	sub	r6,sp,-1724
800167a6:	72 0a       	ld.w	r10,r9[0x0]
800167a8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800167ac:	f3 4a fd 88 	st.w	r9[-632],r10
800167b0:	2f f8       	sub	r8,-1
800167b2:	fb 48 06 b4 	st.w	sp[1716],r8
800167b6:	c0 48       	rjmp	800167be <_vfprintf_r+0xc82>
800167b8:	72 0a       	ld.w	r10,r9[0x0]
800167ba:	2f c9       	sub	r9,-4
800167bc:	51 09       	stdsp	sp[0x40],r9
800167be:	40 be       	lddsp	lr,sp[0x2c]
800167c0:	b4 0e       	st.h	r10[0x0],lr
800167c2:	fe 9f fa 48 	bral	80015c52 <_vfprintf_r+0x116>
800167c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800167ca:	40 3c       	lddsp	r12,sp[0xc]
800167cc:	58 0c       	cp.w	r12,0
800167ce:	c1 d0       	breq	80016808 <_vfprintf_r+0xccc>
800167d0:	10 36       	cp.w	r6,r8
800167d2:	c0 64       	brge	800167de <_vfprintf_r+0xca2>
800167d4:	fa cb f9 44 	sub	r11,sp,-1724
800167d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800167dc:	c1 d8       	rjmp	80016816 <_vfprintf_r+0xcda>
800167de:	fa c8 f9 50 	sub	r8,sp,-1712
800167e2:	1a d8       	st.w	--sp,r8
800167e4:	fa c8 fa b8 	sub	r8,sp,-1352
800167e8:	04 9a       	mov	r10,r2
800167ea:	1a d8       	st.w	--sp,r8
800167ec:	fa c8 fb b4 	sub	r8,sp,-1100
800167f0:	0c 9b       	mov	r11,r6
800167f2:	1a d8       	st.w	--sp,r8
800167f4:	08 9c       	mov	r12,r4
800167f6:	fa c8 f9 40 	sub	r8,sp,-1728
800167fa:	fa c9 ff b4 	sub	r9,sp,-76
800167fe:	fe b0 f8 01 	rcall	80015800 <get_arg>
80016802:	2f dd       	sub	sp,-12
80016804:	78 0a       	ld.w	r10,r12[0x0]
80016806:	c2 08       	rjmp	80016846 <_vfprintf_r+0xd0a>
80016808:	2f f7       	sub	r7,-1
8001680a:	10 39       	cp.w	r9,r8
8001680c:	c0 84       	brge	8001681c <_vfprintf_r+0xce0>
8001680e:	fa ca f9 44 	sub	r10,sp,-1724
80016812:	f4 06 00 36 	add	r6,r10,r6<<0x3
80016816:	ec fa fd 88 	ld.w	r10,r6[-632]
8001681a:	c1 68       	rjmp	80016846 <_vfprintf_r+0xd0a>
8001681c:	41 09       	lddsp	r9,sp[0x40]
8001681e:	59 f8       	cp.w	r8,31
80016820:	e0 89 00 10 	brgt	80016840 <_vfprintf_r+0xd04>
80016824:	f2 ca ff fc 	sub	r10,r9,-4
80016828:	51 0a       	stdsp	sp[0x40],r10
8001682a:	fa c6 f9 44 	sub	r6,sp,-1724
8001682e:	72 0a       	ld.w	r10,r9[0x0]
80016830:	ec 08 00 39 	add	r9,r6,r8<<0x3
80016834:	f3 4a fd 88 	st.w	r9[-632],r10
80016838:	2f f8       	sub	r8,-1
8001683a:	fb 48 06 b4 	st.w	sp[1716],r8
8001683e:	c0 48       	rjmp	80016846 <_vfprintf_r+0xd0a>
80016840:	72 0a       	ld.w	r10,r9[0x0]
80016842:	2f c9       	sub	r9,-4
80016844:	51 09       	stdsp	sp[0x40],r9
80016846:	40 be       	lddsp	lr,sp[0x2c]
80016848:	95 0e       	st.w	r10[0x0],lr
8001684a:	fe 9f fa 04 	bral	80015c52 <_vfprintf_r+0x116>
8001684e:	50 a7       	stdsp	sp[0x28],r7
80016850:	50 80       	stdsp	sp[0x20],r0
80016852:	0c 97       	mov	r7,r6
80016854:	04 94       	mov	r4,r2
80016856:	06 96       	mov	r6,r3
80016858:	02 92       	mov	r2,r1
8001685a:	40 93       	lddsp	r3,sp[0x24]
8001685c:	10 90       	mov	r0,r8
8001685e:	40 41       	lddsp	r1,sp[0x10]
80016860:	a5 a5       	sbr	r5,0x4
80016862:	c0 a8       	rjmp	80016876 <_vfprintf_r+0xd3a>
80016864:	50 a7       	stdsp	sp[0x28],r7
80016866:	50 80       	stdsp	sp[0x20],r0
80016868:	0c 97       	mov	r7,r6
8001686a:	04 94       	mov	r4,r2
8001686c:	06 96       	mov	r6,r3
8001686e:	02 92       	mov	r2,r1
80016870:	40 93       	lddsp	r3,sp[0x24]
80016872:	10 90       	mov	r0,r8
80016874:	40 41       	lddsp	r1,sp[0x10]
80016876:	ed b5 00 05 	bld	r5,0x5
8001687a:	c5 d1       	brne	80016934 <_vfprintf_r+0xdf8>
8001687c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016880:	40 3c       	lddsp	r12,sp[0xc]
80016882:	58 0c       	cp.w	r12,0
80016884:	c2 60       	breq	800168d0 <_vfprintf_r+0xd94>
80016886:	10 36       	cp.w	r6,r8
80016888:	c0 a4       	brge	8001689c <_vfprintf_r+0xd60>
8001688a:	fa cb f9 44 	sub	r11,sp,-1724
8001688e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016892:	ec e8 fd 88 	ld.d	r8,r6[-632]
80016896:	fa e9 00 00 	st.d	sp[0],r8
8001689a:	c1 88       	rjmp	800168ca <_vfprintf_r+0xd8e>
8001689c:	fa c8 f9 50 	sub	r8,sp,-1712
800168a0:	1a d8       	st.w	--sp,r8
800168a2:	fa c8 fa b8 	sub	r8,sp,-1352
800168a6:	04 9a       	mov	r10,r2
800168a8:	1a d8       	st.w	--sp,r8
800168aa:	0c 9b       	mov	r11,r6
800168ac:	fa c8 fb b4 	sub	r8,sp,-1100
800168b0:	08 9c       	mov	r12,r4
800168b2:	1a d8       	st.w	--sp,r8
800168b4:	fa c8 f9 40 	sub	r8,sp,-1728
800168b8:	fa c9 ff b4 	sub	r9,sp,-76
800168bc:	fe b0 f7 a2 	rcall	80015800 <get_arg>
800168c0:	2f dd       	sub	sp,-12
800168c2:	f8 ea 00 00 	ld.d	r10,r12[0]
800168c6:	fa eb 00 00 	st.d	sp[0],r10
800168ca:	30 08       	mov	r8,0
800168cc:	e0 8f 03 de 	bral	80017088 <_vfprintf_r+0x154c>
800168d0:	ee ca ff ff 	sub	r10,r7,-1
800168d4:	10 37       	cp.w	r7,r8
800168d6:	c0 b4       	brge	800168ec <_vfprintf_r+0xdb0>
800168d8:	fa c9 f9 44 	sub	r9,sp,-1724
800168dc:	14 97       	mov	r7,r10
800168de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800168e2:	ec ea fd 88 	ld.d	r10,r6[-632]
800168e6:	fa eb 00 00 	st.d	sp[0],r10
800168ea:	c1 88       	rjmp	8001691a <_vfprintf_r+0xdde>
800168ec:	41 09       	lddsp	r9,sp[0x40]
800168ee:	59 f8       	cp.w	r8,31
800168f0:	e0 89 00 18 	brgt	80016920 <_vfprintf_r+0xde4>
800168f4:	f2 e6 00 00 	ld.d	r6,r9[0]
800168f8:	f2 cb ff f8 	sub	r11,r9,-8
800168fc:	fa e7 00 00 	st.d	sp[0],r6
80016900:	51 0b       	stdsp	sp[0x40],r11
80016902:	fa c6 f9 44 	sub	r6,sp,-1724
80016906:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001690a:	fa e6 00 00 	ld.d	r6,sp[0]
8001690e:	f2 e7 fd 88 	st.d	r9[-632],r6
80016912:	2f f8       	sub	r8,-1
80016914:	14 97       	mov	r7,r10
80016916:	fb 48 06 b4 	st.w	sp[1716],r8
8001691a:	40 38       	lddsp	r8,sp[0xc]
8001691c:	e0 8f 03 b6 	bral	80017088 <_vfprintf_r+0x154c>
80016920:	f2 e6 00 00 	ld.d	r6,r9[0]
80016924:	40 38       	lddsp	r8,sp[0xc]
80016926:	fa e7 00 00 	st.d	sp[0],r6
8001692a:	2f 89       	sub	r9,-8
8001692c:	14 97       	mov	r7,r10
8001692e:	51 09       	stdsp	sp[0x40],r9
80016930:	e0 8f 03 ac 	bral	80017088 <_vfprintf_r+0x154c>
80016934:	ed b5 00 04 	bld	r5,0x4
80016938:	c1 61       	brne	80016964 <_vfprintf_r+0xe28>
8001693a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001693e:	40 3e       	lddsp	lr,sp[0xc]
80016940:	58 0e       	cp.w	lr,0
80016942:	c0 80       	breq	80016952 <_vfprintf_r+0xe16>
80016944:	10 36       	cp.w	r6,r8
80016946:	c6 74       	brge	80016a14 <_vfprintf_r+0xed8>
80016948:	fa cc f9 44 	sub	r12,sp,-1724
8001694c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80016950:	c8 08       	rjmp	80016a50 <_vfprintf_r+0xf14>
80016952:	ee ca ff ff 	sub	r10,r7,-1
80016956:	10 37       	cp.w	r7,r8
80016958:	c7 f4       	brge	80016a56 <_vfprintf_r+0xf1a>
8001695a:	fa cb f9 44 	sub	r11,sp,-1724
8001695e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016962:	c7 68       	rjmp	80016a4e <_vfprintf_r+0xf12>
80016964:	ed b5 00 06 	bld	r5,0x6
80016968:	c4 a1       	brne	800169fc <_vfprintf_r+0xec0>
8001696a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8001696e:	40 3c       	lddsp	r12,sp[0xc]
80016970:	58 0c       	cp.w	r12,0
80016972:	c1 d0       	breq	800169ac <_vfprintf_r+0xe70>
80016974:	10 36       	cp.w	r6,r8
80016976:	c0 64       	brge	80016982 <_vfprintf_r+0xe46>
80016978:	fa cb f9 44 	sub	r11,sp,-1724
8001697c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016980:	c1 f8       	rjmp	800169be <_vfprintf_r+0xe82>
80016982:	fa c8 f9 50 	sub	r8,sp,-1712
80016986:	1a d8       	st.w	--sp,r8
80016988:	fa c8 fa b8 	sub	r8,sp,-1352
8001698c:	1a d8       	st.w	--sp,r8
8001698e:	fa c8 fb b4 	sub	r8,sp,-1100
80016992:	1a d8       	st.w	--sp,r8
80016994:	fa c8 f9 40 	sub	r8,sp,-1728
80016998:	fa c9 ff b4 	sub	r9,sp,-76
8001699c:	04 9a       	mov	r10,r2
8001699e:	0c 9b       	mov	r11,r6
800169a0:	08 9c       	mov	r12,r4
800169a2:	fe b0 f7 2f 	rcall	80015800 <get_arg>
800169a6:	2f dd       	sub	sp,-12
800169a8:	98 18       	ld.sh	r8,r12[0x2]
800169aa:	c2 68       	rjmp	800169f6 <_vfprintf_r+0xeba>
800169ac:	ee ca ff ff 	sub	r10,r7,-1
800169b0:	10 37       	cp.w	r7,r8
800169b2:	c0 94       	brge	800169c4 <_vfprintf_r+0xe88>
800169b4:	fa c9 f9 44 	sub	r9,sp,-1724
800169b8:	14 97       	mov	r7,r10
800169ba:	f2 06 00 36 	add	r6,r9,r6<<0x3
800169be:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800169c2:	c1 a8       	rjmp	800169f6 <_vfprintf_r+0xeba>
800169c4:	41 09       	lddsp	r9,sp[0x40]
800169c6:	59 f8       	cp.w	r8,31
800169c8:	e0 89 00 13 	brgt	800169ee <_vfprintf_r+0xeb2>
800169cc:	f2 cb ff fc 	sub	r11,r9,-4
800169d0:	51 0b       	stdsp	sp[0x40],r11
800169d2:	72 09       	ld.w	r9,r9[0x0]
800169d4:	fa c6 f9 44 	sub	r6,sp,-1724
800169d8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800169dc:	2f f8       	sub	r8,-1
800169de:	f7 49 fd 88 	st.w	r11[-632],r9
800169e2:	fb 48 06 b4 	st.w	sp[1716],r8
800169e6:	14 97       	mov	r7,r10
800169e8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800169ec:	c0 58       	rjmp	800169f6 <_vfprintf_r+0xeba>
800169ee:	92 18       	ld.sh	r8,r9[0x2]
800169f0:	14 97       	mov	r7,r10
800169f2:	2f c9       	sub	r9,-4
800169f4:	51 09       	stdsp	sp[0x40],r9
800169f6:	5c 78       	castu.h	r8
800169f8:	50 18       	stdsp	sp[0x4],r8
800169fa:	c4 68       	rjmp	80016a86 <_vfprintf_r+0xf4a>
800169fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016a00:	40 3c       	lddsp	r12,sp[0xc]
80016a02:	58 0c       	cp.w	r12,0
80016a04:	c1 d0       	breq	80016a3e <_vfprintf_r+0xf02>
80016a06:	10 36       	cp.w	r6,r8
80016a08:	c0 64       	brge	80016a14 <_vfprintf_r+0xed8>
80016a0a:	fa cb f9 44 	sub	r11,sp,-1724
80016a0e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016a12:	c1 f8       	rjmp	80016a50 <_vfprintf_r+0xf14>
80016a14:	fa c8 f9 50 	sub	r8,sp,-1712
80016a18:	1a d8       	st.w	--sp,r8
80016a1a:	fa c8 fa b8 	sub	r8,sp,-1352
80016a1e:	0c 9b       	mov	r11,r6
80016a20:	1a d8       	st.w	--sp,r8
80016a22:	fa c8 fb b4 	sub	r8,sp,-1100
80016a26:	04 9a       	mov	r10,r2
80016a28:	1a d8       	st.w	--sp,r8
80016a2a:	08 9c       	mov	r12,r4
80016a2c:	fa c8 f9 40 	sub	r8,sp,-1728
80016a30:	fa c9 ff b4 	sub	r9,sp,-76
80016a34:	fe b0 f6 e6 	rcall	80015800 <get_arg>
80016a38:	2f dd       	sub	sp,-12
80016a3a:	78 0b       	ld.w	r11,r12[0x0]
80016a3c:	c2 48       	rjmp	80016a84 <_vfprintf_r+0xf48>
80016a3e:	ee ca ff ff 	sub	r10,r7,-1
80016a42:	10 37       	cp.w	r7,r8
80016a44:	c0 94       	brge	80016a56 <_vfprintf_r+0xf1a>
80016a46:	fa c9 f9 44 	sub	r9,sp,-1724
80016a4a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80016a4e:	14 97       	mov	r7,r10
80016a50:	ec fb fd 88 	ld.w	r11,r6[-632]
80016a54:	c1 88       	rjmp	80016a84 <_vfprintf_r+0xf48>
80016a56:	41 09       	lddsp	r9,sp[0x40]
80016a58:	59 f8       	cp.w	r8,31
80016a5a:	e0 89 00 11 	brgt	80016a7c <_vfprintf_r+0xf40>
80016a5e:	f2 cb ff fc 	sub	r11,r9,-4
80016a62:	51 0b       	stdsp	sp[0x40],r11
80016a64:	fa c6 f9 44 	sub	r6,sp,-1724
80016a68:	72 0b       	ld.w	r11,r9[0x0]
80016a6a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80016a6e:	f3 4b fd 88 	st.w	r9[-632],r11
80016a72:	2f f8       	sub	r8,-1
80016a74:	14 97       	mov	r7,r10
80016a76:	fb 48 06 b4 	st.w	sp[1716],r8
80016a7a:	c0 58       	rjmp	80016a84 <_vfprintf_r+0xf48>
80016a7c:	72 0b       	ld.w	r11,r9[0x0]
80016a7e:	14 97       	mov	r7,r10
80016a80:	2f c9       	sub	r9,-4
80016a82:	51 09       	stdsp	sp[0x40],r9
80016a84:	50 1b       	stdsp	sp[0x4],r11
80016a86:	30 0e       	mov	lr,0
80016a88:	50 0e       	stdsp	sp[0x0],lr
80016a8a:	1c 98       	mov	r8,lr
80016a8c:	e0 8f 02 fe 	bral	80017088 <_vfprintf_r+0x154c>
80016a90:	50 a7       	stdsp	sp[0x28],r7
80016a92:	50 80       	stdsp	sp[0x20],r0
80016a94:	0c 97       	mov	r7,r6
80016a96:	04 94       	mov	r4,r2
80016a98:	06 96       	mov	r6,r3
80016a9a:	02 92       	mov	r2,r1
80016a9c:	40 93       	lddsp	r3,sp[0x24]
80016a9e:	40 41       	lddsp	r1,sp[0x10]
80016aa0:	0e 99       	mov	r9,r7
80016aa2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016aa6:	40 3c       	lddsp	r12,sp[0xc]
80016aa8:	58 0c       	cp.w	r12,0
80016aaa:	c1 d0       	breq	80016ae4 <_vfprintf_r+0xfa8>
80016aac:	10 36       	cp.w	r6,r8
80016aae:	c0 64       	brge	80016aba <_vfprintf_r+0xf7e>
80016ab0:	fa cb f9 44 	sub	r11,sp,-1724
80016ab4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016ab8:	c1 d8       	rjmp	80016af2 <_vfprintf_r+0xfb6>
80016aba:	fa c8 f9 50 	sub	r8,sp,-1712
80016abe:	1a d8       	st.w	--sp,r8
80016ac0:	fa c8 fa b8 	sub	r8,sp,-1352
80016ac4:	1a d8       	st.w	--sp,r8
80016ac6:	fa c8 fb b4 	sub	r8,sp,-1100
80016aca:	1a d8       	st.w	--sp,r8
80016acc:	fa c9 ff b4 	sub	r9,sp,-76
80016ad0:	fa c8 f9 40 	sub	r8,sp,-1728
80016ad4:	04 9a       	mov	r10,r2
80016ad6:	0c 9b       	mov	r11,r6
80016ad8:	08 9c       	mov	r12,r4
80016ada:	fe b0 f6 93 	rcall	80015800 <get_arg>
80016ade:	2f dd       	sub	sp,-12
80016ae0:	78 09       	ld.w	r9,r12[0x0]
80016ae2:	c2 18       	rjmp	80016b24 <_vfprintf_r+0xfe8>
80016ae4:	2f f7       	sub	r7,-1
80016ae6:	10 39       	cp.w	r9,r8
80016ae8:	c0 84       	brge	80016af8 <_vfprintf_r+0xfbc>
80016aea:	fa ca f9 44 	sub	r10,sp,-1724
80016aee:	f4 06 00 36 	add	r6,r10,r6<<0x3
80016af2:	ec f9 fd 88 	ld.w	r9,r6[-632]
80016af6:	c1 78       	rjmp	80016b24 <_vfprintf_r+0xfe8>
80016af8:	41 09       	lddsp	r9,sp[0x40]
80016afa:	59 f8       	cp.w	r8,31
80016afc:	e0 89 00 10 	brgt	80016b1c <_vfprintf_r+0xfe0>
80016b00:	f2 ca ff fc 	sub	r10,r9,-4
80016b04:	51 0a       	stdsp	sp[0x40],r10
80016b06:	fa c6 f9 44 	sub	r6,sp,-1724
80016b0a:	72 09       	ld.w	r9,r9[0x0]
80016b0c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80016b10:	f5 49 fd 88 	st.w	r10[-632],r9
80016b14:	2f f8       	sub	r8,-1
80016b16:	fb 48 06 b4 	st.w	sp[1716],r8
80016b1a:	c0 58       	rjmp	80016b24 <_vfprintf_r+0xfe8>
80016b1c:	f2 c8 ff fc 	sub	r8,r9,-4
80016b20:	51 08       	stdsp	sp[0x40],r8
80016b22:	72 09       	ld.w	r9,r9[0x0]
80016b24:	33 08       	mov	r8,48
80016b26:	fb 68 06 b8 	st.b	sp[1720],r8
80016b2a:	37 88       	mov	r8,120
80016b2c:	30 0e       	mov	lr,0
80016b2e:	fb 68 06 b9 	st.b	sp[1721],r8
80016b32:	4c ac       	lddpc	r12,80016c58 <_vfprintf_r+0x111c>
80016b34:	50 19       	stdsp	sp[0x4],r9
80016b36:	a1 b5       	sbr	r5,0x1
80016b38:	50 0e       	stdsp	sp[0x0],lr
80016b3a:	50 dc       	stdsp	sp[0x34],r12
80016b3c:	30 28       	mov	r8,2
80016b3e:	37 80       	mov	r0,120
80016b40:	e0 8f 02 a4 	bral	80017088 <_vfprintf_r+0x154c>
80016b44:	50 a7       	stdsp	sp[0x28],r7
80016b46:	50 80       	stdsp	sp[0x20],r0
80016b48:	10 90       	mov	r0,r8
80016b4a:	30 08       	mov	r8,0
80016b4c:	fb 68 06 bb 	st.b	sp[1723],r8
80016b50:	0c 97       	mov	r7,r6
80016b52:	04 94       	mov	r4,r2
80016b54:	06 96       	mov	r6,r3
80016b56:	02 92       	mov	r2,r1
80016b58:	40 93       	lddsp	r3,sp[0x24]
80016b5a:	40 41       	lddsp	r1,sp[0x10]
80016b5c:	0e 99       	mov	r9,r7
80016b5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016b62:	40 3b       	lddsp	r11,sp[0xc]
80016b64:	58 0b       	cp.w	r11,0
80016b66:	c1 d0       	breq	80016ba0 <_vfprintf_r+0x1064>
80016b68:	10 36       	cp.w	r6,r8
80016b6a:	c0 64       	brge	80016b76 <_vfprintf_r+0x103a>
80016b6c:	fa ca f9 44 	sub	r10,sp,-1724
80016b70:	f4 06 00 36 	add	r6,r10,r6<<0x3
80016b74:	c1 d8       	rjmp	80016bae <_vfprintf_r+0x1072>
80016b76:	fa c8 f9 50 	sub	r8,sp,-1712
80016b7a:	1a d8       	st.w	--sp,r8
80016b7c:	fa c8 fa b8 	sub	r8,sp,-1352
80016b80:	1a d8       	st.w	--sp,r8
80016b82:	fa c8 fb b4 	sub	r8,sp,-1100
80016b86:	0c 9b       	mov	r11,r6
80016b88:	1a d8       	st.w	--sp,r8
80016b8a:	04 9a       	mov	r10,r2
80016b8c:	fa c8 f9 40 	sub	r8,sp,-1728
80016b90:	fa c9 ff b4 	sub	r9,sp,-76
80016b94:	08 9c       	mov	r12,r4
80016b96:	fe b0 f6 35 	rcall	80015800 <get_arg>
80016b9a:	2f dd       	sub	sp,-12
80016b9c:	78 06       	ld.w	r6,r12[0x0]
80016b9e:	c2 08       	rjmp	80016bde <_vfprintf_r+0x10a2>
80016ba0:	2f f7       	sub	r7,-1
80016ba2:	10 39       	cp.w	r9,r8
80016ba4:	c0 84       	brge	80016bb4 <_vfprintf_r+0x1078>
80016ba6:	fa c9 f9 44 	sub	r9,sp,-1724
80016baa:	f2 06 00 36 	add	r6,r9,r6<<0x3
80016bae:	ec f6 fd 88 	ld.w	r6,r6[-632]
80016bb2:	c1 68       	rjmp	80016bde <_vfprintf_r+0x10a2>
80016bb4:	41 09       	lddsp	r9,sp[0x40]
80016bb6:	59 f8       	cp.w	r8,31
80016bb8:	e0 89 00 10 	brgt	80016bd8 <_vfprintf_r+0x109c>
80016bbc:	f2 ca ff fc 	sub	r10,r9,-4
80016bc0:	51 0a       	stdsp	sp[0x40],r10
80016bc2:	72 06       	ld.w	r6,r9[0x0]
80016bc4:	fa ce f9 44 	sub	lr,sp,-1724
80016bc8:	fc 08 00 39 	add	r9,lr,r8<<0x3
80016bcc:	f3 46 fd 88 	st.w	r9[-632],r6
80016bd0:	2f f8       	sub	r8,-1
80016bd2:	fb 48 06 b4 	st.w	sp[1716],r8
80016bd6:	c0 48       	rjmp	80016bde <_vfprintf_r+0x10a2>
80016bd8:	72 06       	ld.w	r6,r9[0x0]
80016bda:	2f c9       	sub	r9,-4
80016bdc:	51 09       	stdsp	sp[0x40],r9
80016bde:	40 2c       	lddsp	r12,sp[0x8]
80016be0:	58 0c       	cp.w	r12,0
80016be2:	c1 05       	brlt	80016c02 <_vfprintf_r+0x10c6>
80016be4:	18 9a       	mov	r10,r12
80016be6:	30 0b       	mov	r11,0
80016be8:	0c 9c       	mov	r12,r6
80016bea:	e0 a0 1d 83 	rcall	8001a6f0 <memchr>
80016bee:	e0 80 02 e0 	breq	800171ae <_vfprintf_r+0x1672>
80016bf2:	f8 06 01 02 	sub	r2,r12,r6
80016bf6:	40 2b       	lddsp	r11,sp[0x8]
80016bf8:	16 32       	cp.w	r2,r11
80016bfa:	e0 89 02 da 	brgt	800171ae <_vfprintf_r+0x1672>
80016bfe:	e0 8f 02 d5 	bral	800171a8 <_vfprintf_r+0x166c>
80016c02:	30 0a       	mov	r10,0
80016c04:	0c 9c       	mov	r12,r6
80016c06:	50 2a       	stdsp	sp[0x8],r10
80016c08:	fe b0 f5 5c 	rcall	800156c0 <strlen>
80016c0c:	18 92       	mov	r2,r12
80016c0e:	e0 8f 02 d3 	bral	800171b4 <_vfprintf_r+0x1678>
80016c12:	50 a7       	stdsp	sp[0x28],r7
80016c14:	50 80       	stdsp	sp[0x20],r0
80016c16:	0c 97       	mov	r7,r6
80016c18:	04 94       	mov	r4,r2
80016c1a:	06 96       	mov	r6,r3
80016c1c:	02 92       	mov	r2,r1
80016c1e:	40 93       	lddsp	r3,sp[0x24]
80016c20:	10 90       	mov	r0,r8
80016c22:	40 41       	lddsp	r1,sp[0x10]
80016c24:	a5 a5       	sbr	r5,0x4
80016c26:	c0 a8       	rjmp	80016c3a <_vfprintf_r+0x10fe>
80016c28:	50 a7       	stdsp	sp[0x28],r7
80016c2a:	50 80       	stdsp	sp[0x20],r0
80016c2c:	0c 97       	mov	r7,r6
80016c2e:	04 94       	mov	r4,r2
80016c30:	06 96       	mov	r6,r3
80016c32:	02 92       	mov	r2,r1
80016c34:	40 93       	lddsp	r3,sp[0x24]
80016c36:	10 90       	mov	r0,r8
80016c38:	40 41       	lddsp	r1,sp[0x10]
80016c3a:	ed b5 00 05 	bld	r5,0x5
80016c3e:	c5 71       	brne	80016cec <_vfprintf_r+0x11b0>
80016c40:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016c44:	40 39       	lddsp	r9,sp[0xc]
80016c46:	58 09       	cp.w	r9,0
80016c48:	c2 20       	breq	80016c8c <_vfprintf_r+0x1150>
80016c4a:	10 36       	cp.w	r6,r8
80016c4c:	c0 84       	brge	80016c5c <_vfprintf_r+0x1120>
80016c4e:	fa c8 f9 44 	sub	r8,sp,-1724
80016c52:	f0 06 00 36 	add	r6,r8,r6<<0x3
80016c56:	c2 48       	rjmp	80016c9e <_vfprintf_r+0x1162>
80016c58:	80 02       	ld.sh	r2,r0[0x0]
80016c5a:	02 e8       	st.h	--r1,r8
80016c5c:	fa c8 f9 50 	sub	r8,sp,-1712
80016c60:	1a d8       	st.w	--sp,r8
80016c62:	fa c8 fa b8 	sub	r8,sp,-1352
80016c66:	1a d8       	st.w	--sp,r8
80016c68:	fa c8 fb b4 	sub	r8,sp,-1100
80016c6c:	1a d8       	st.w	--sp,r8
80016c6e:	fa c8 f9 40 	sub	r8,sp,-1728
80016c72:	fa c9 ff b4 	sub	r9,sp,-76
80016c76:	04 9a       	mov	r10,r2
80016c78:	0c 9b       	mov	r11,r6
80016c7a:	08 9c       	mov	r12,r4
80016c7c:	fe b0 f5 c2 	rcall	80015800 <get_arg>
80016c80:	2f dd       	sub	sp,-12
80016c82:	f8 e8 00 00 	ld.d	r8,r12[0]
80016c86:	fa e9 00 00 	st.d	sp[0],r8
80016c8a:	c2 e8       	rjmp	80016ce6 <_vfprintf_r+0x11aa>
80016c8c:	ee ca ff ff 	sub	r10,r7,-1
80016c90:	10 37       	cp.w	r7,r8
80016c92:	c0 b4       	brge	80016ca8 <_vfprintf_r+0x116c>
80016c94:	fa c8 f9 44 	sub	r8,sp,-1724
80016c98:	14 97       	mov	r7,r10
80016c9a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80016c9e:	ec ea fd 88 	ld.d	r10,r6[-632]
80016ca2:	fa eb 00 00 	st.d	sp[0],r10
80016ca6:	c2 08       	rjmp	80016ce6 <_vfprintf_r+0x11aa>
80016ca8:	41 09       	lddsp	r9,sp[0x40]
80016caa:	59 f8       	cp.w	r8,31
80016cac:	e0 89 00 16 	brgt	80016cd8 <_vfprintf_r+0x119c>
80016cb0:	f2 e6 00 00 	ld.d	r6,r9[0]
80016cb4:	f2 cb ff f8 	sub	r11,r9,-8
80016cb8:	fa e7 00 00 	st.d	sp[0],r6
80016cbc:	51 0b       	stdsp	sp[0x40],r11
80016cbe:	fa c6 f9 44 	sub	r6,sp,-1724
80016cc2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80016cc6:	fa e6 00 00 	ld.d	r6,sp[0]
80016cca:	f2 e7 fd 88 	st.d	r9[-632],r6
80016cce:	2f f8       	sub	r8,-1
80016cd0:	14 97       	mov	r7,r10
80016cd2:	fb 48 06 b4 	st.w	sp[1716],r8
80016cd6:	c0 88       	rjmp	80016ce6 <_vfprintf_r+0x11aa>
80016cd8:	f2 e6 00 00 	ld.d	r6,r9[0]
80016cdc:	2f 89       	sub	r9,-8
80016cde:	fa e7 00 00 	st.d	sp[0],r6
80016ce2:	51 09       	stdsp	sp[0x40],r9
80016ce4:	14 97       	mov	r7,r10
80016ce6:	30 18       	mov	r8,1
80016ce8:	e0 8f 01 d0 	bral	80017088 <_vfprintf_r+0x154c>
80016cec:	ed b5 00 04 	bld	r5,0x4
80016cf0:	c1 61       	brne	80016d1c <_vfprintf_r+0x11e0>
80016cf2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016cf6:	40 3e       	lddsp	lr,sp[0xc]
80016cf8:	58 0e       	cp.w	lr,0
80016cfa:	c0 80       	breq	80016d0a <_vfprintf_r+0x11ce>
80016cfc:	10 36       	cp.w	r6,r8
80016cfe:	c6 74       	brge	80016dcc <_vfprintf_r+0x1290>
80016d00:	fa cc f9 44 	sub	r12,sp,-1724
80016d04:	f8 06 00 36 	add	r6,r12,r6<<0x3
80016d08:	c8 08       	rjmp	80016e08 <_vfprintf_r+0x12cc>
80016d0a:	ee ca ff ff 	sub	r10,r7,-1
80016d0e:	10 37       	cp.w	r7,r8
80016d10:	c7 f4       	brge	80016e0e <_vfprintf_r+0x12d2>
80016d12:	fa cb f9 44 	sub	r11,sp,-1724
80016d16:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016d1a:	c7 68       	rjmp	80016e06 <_vfprintf_r+0x12ca>
80016d1c:	ed b5 00 06 	bld	r5,0x6
80016d20:	c4 a1       	brne	80016db4 <_vfprintf_r+0x1278>
80016d22:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016d26:	40 3c       	lddsp	r12,sp[0xc]
80016d28:	58 0c       	cp.w	r12,0
80016d2a:	c1 d0       	breq	80016d64 <_vfprintf_r+0x1228>
80016d2c:	10 36       	cp.w	r6,r8
80016d2e:	c0 64       	brge	80016d3a <_vfprintf_r+0x11fe>
80016d30:	fa cb f9 44 	sub	r11,sp,-1724
80016d34:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016d38:	c1 f8       	rjmp	80016d76 <_vfprintf_r+0x123a>
80016d3a:	fa c8 f9 50 	sub	r8,sp,-1712
80016d3e:	1a d8       	st.w	--sp,r8
80016d40:	fa c8 fa b8 	sub	r8,sp,-1352
80016d44:	1a d8       	st.w	--sp,r8
80016d46:	fa c8 fb b4 	sub	r8,sp,-1100
80016d4a:	1a d8       	st.w	--sp,r8
80016d4c:	fa c8 f9 40 	sub	r8,sp,-1728
80016d50:	fa c9 ff b4 	sub	r9,sp,-76
80016d54:	04 9a       	mov	r10,r2
80016d56:	0c 9b       	mov	r11,r6
80016d58:	08 9c       	mov	r12,r4
80016d5a:	fe b0 f5 53 	rcall	80015800 <get_arg>
80016d5e:	2f dd       	sub	sp,-12
80016d60:	98 18       	ld.sh	r8,r12[0x2]
80016d62:	c2 68       	rjmp	80016dae <_vfprintf_r+0x1272>
80016d64:	ee ca ff ff 	sub	r10,r7,-1
80016d68:	10 37       	cp.w	r7,r8
80016d6a:	c0 94       	brge	80016d7c <_vfprintf_r+0x1240>
80016d6c:	fa c9 f9 44 	sub	r9,sp,-1724
80016d70:	14 97       	mov	r7,r10
80016d72:	f2 06 00 36 	add	r6,r9,r6<<0x3
80016d76:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80016d7a:	c1 a8       	rjmp	80016dae <_vfprintf_r+0x1272>
80016d7c:	41 09       	lddsp	r9,sp[0x40]
80016d7e:	59 f8       	cp.w	r8,31
80016d80:	e0 89 00 13 	brgt	80016da6 <_vfprintf_r+0x126a>
80016d84:	f2 cb ff fc 	sub	r11,r9,-4
80016d88:	51 0b       	stdsp	sp[0x40],r11
80016d8a:	72 09       	ld.w	r9,r9[0x0]
80016d8c:	fa c6 f9 44 	sub	r6,sp,-1724
80016d90:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80016d94:	2f f8       	sub	r8,-1
80016d96:	f7 49 fd 88 	st.w	r11[-632],r9
80016d9a:	fb 48 06 b4 	st.w	sp[1716],r8
80016d9e:	14 97       	mov	r7,r10
80016da0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80016da4:	c0 58       	rjmp	80016dae <_vfprintf_r+0x1272>
80016da6:	92 18       	ld.sh	r8,r9[0x2]
80016da8:	14 97       	mov	r7,r10
80016daa:	2f c9       	sub	r9,-4
80016dac:	51 09       	stdsp	sp[0x40],r9
80016dae:	5c 78       	castu.h	r8
80016db0:	50 18       	stdsp	sp[0x4],r8
80016db2:	c4 68       	rjmp	80016e3e <_vfprintf_r+0x1302>
80016db4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016db8:	40 3c       	lddsp	r12,sp[0xc]
80016dba:	58 0c       	cp.w	r12,0
80016dbc:	c1 d0       	breq	80016df6 <_vfprintf_r+0x12ba>
80016dbe:	10 36       	cp.w	r6,r8
80016dc0:	c0 64       	brge	80016dcc <_vfprintf_r+0x1290>
80016dc2:	fa cb f9 44 	sub	r11,sp,-1724
80016dc6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016dca:	c1 f8       	rjmp	80016e08 <_vfprintf_r+0x12cc>
80016dcc:	fa c8 f9 50 	sub	r8,sp,-1712
80016dd0:	1a d8       	st.w	--sp,r8
80016dd2:	fa c8 fa b8 	sub	r8,sp,-1352
80016dd6:	0c 9b       	mov	r11,r6
80016dd8:	1a d8       	st.w	--sp,r8
80016dda:	fa c8 fb b4 	sub	r8,sp,-1100
80016dde:	04 9a       	mov	r10,r2
80016de0:	1a d8       	st.w	--sp,r8
80016de2:	08 9c       	mov	r12,r4
80016de4:	fa c8 f9 40 	sub	r8,sp,-1728
80016de8:	fa c9 ff b4 	sub	r9,sp,-76
80016dec:	fe b0 f5 0a 	rcall	80015800 <get_arg>
80016df0:	2f dd       	sub	sp,-12
80016df2:	78 0b       	ld.w	r11,r12[0x0]
80016df4:	c2 48       	rjmp	80016e3c <_vfprintf_r+0x1300>
80016df6:	ee ca ff ff 	sub	r10,r7,-1
80016dfa:	10 37       	cp.w	r7,r8
80016dfc:	c0 94       	brge	80016e0e <_vfprintf_r+0x12d2>
80016dfe:	fa c9 f9 44 	sub	r9,sp,-1724
80016e02:	f2 06 00 36 	add	r6,r9,r6<<0x3
80016e06:	14 97       	mov	r7,r10
80016e08:	ec fb fd 88 	ld.w	r11,r6[-632]
80016e0c:	c1 88       	rjmp	80016e3c <_vfprintf_r+0x1300>
80016e0e:	41 09       	lddsp	r9,sp[0x40]
80016e10:	59 f8       	cp.w	r8,31
80016e12:	e0 89 00 11 	brgt	80016e34 <_vfprintf_r+0x12f8>
80016e16:	f2 cb ff fc 	sub	r11,r9,-4
80016e1a:	51 0b       	stdsp	sp[0x40],r11
80016e1c:	fa c6 f9 44 	sub	r6,sp,-1724
80016e20:	72 0b       	ld.w	r11,r9[0x0]
80016e22:	ec 08 00 39 	add	r9,r6,r8<<0x3
80016e26:	f3 4b fd 88 	st.w	r9[-632],r11
80016e2a:	2f f8       	sub	r8,-1
80016e2c:	14 97       	mov	r7,r10
80016e2e:	fb 48 06 b4 	st.w	sp[1716],r8
80016e32:	c0 58       	rjmp	80016e3c <_vfprintf_r+0x1300>
80016e34:	72 0b       	ld.w	r11,r9[0x0]
80016e36:	14 97       	mov	r7,r10
80016e38:	2f c9       	sub	r9,-4
80016e3a:	51 09       	stdsp	sp[0x40],r9
80016e3c:	50 1b       	stdsp	sp[0x4],r11
80016e3e:	30 0e       	mov	lr,0
80016e40:	30 18       	mov	r8,1
80016e42:	50 0e       	stdsp	sp[0x0],lr
80016e44:	c2 29       	rjmp	80017088 <_vfprintf_r+0x154c>
80016e46:	50 a7       	stdsp	sp[0x28],r7
80016e48:	50 80       	stdsp	sp[0x20],r0
80016e4a:	0c 97       	mov	r7,r6
80016e4c:	04 94       	mov	r4,r2
80016e4e:	06 96       	mov	r6,r3
80016e50:	02 92       	mov	r2,r1
80016e52:	4d 3c       	lddpc	r12,80016f9c <_vfprintf_r+0x1460>
80016e54:	40 93       	lddsp	r3,sp[0x24]
80016e56:	10 90       	mov	r0,r8
80016e58:	40 41       	lddsp	r1,sp[0x10]
80016e5a:	50 dc       	stdsp	sp[0x34],r12
80016e5c:	ed b5 00 05 	bld	r5,0x5
80016e60:	c5 51       	brne	80016f0a <_vfprintf_r+0x13ce>
80016e62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016e66:	40 3b       	lddsp	r11,sp[0xc]
80016e68:	58 0b       	cp.w	r11,0
80016e6a:	c2 20       	breq	80016eae <_vfprintf_r+0x1372>
80016e6c:	10 36       	cp.w	r6,r8
80016e6e:	c0 a4       	brge	80016e82 <_vfprintf_r+0x1346>
80016e70:	fa ca f9 44 	sub	r10,sp,-1724
80016e74:	f4 06 00 36 	add	r6,r10,r6<<0x3
80016e78:	ec e8 fd 88 	ld.d	r8,r6[-632]
80016e7c:	fa e9 00 00 	st.d	sp[0],r8
80016e80:	cf 38       	rjmp	80017066 <_vfprintf_r+0x152a>
80016e82:	fa c8 f9 50 	sub	r8,sp,-1712
80016e86:	1a d8       	st.w	--sp,r8
80016e88:	fa c8 fa b8 	sub	r8,sp,-1352
80016e8c:	04 9a       	mov	r10,r2
80016e8e:	1a d8       	st.w	--sp,r8
80016e90:	0c 9b       	mov	r11,r6
80016e92:	fa c8 fb b4 	sub	r8,sp,-1100
80016e96:	08 9c       	mov	r12,r4
80016e98:	1a d8       	st.w	--sp,r8
80016e9a:	fa c8 f9 40 	sub	r8,sp,-1728
80016e9e:	fa c9 ff b4 	sub	r9,sp,-76
80016ea2:	fe b0 f4 af 	rcall	80015800 <get_arg>
80016ea6:	2f dd       	sub	sp,-12
80016ea8:	f8 ea 00 00 	ld.d	r10,r12[0]
80016eac:	c0 c8       	rjmp	80016ec4 <_vfprintf_r+0x1388>
80016eae:	ee ca ff ff 	sub	r10,r7,-1
80016eb2:	10 37       	cp.w	r7,r8
80016eb4:	c0 b4       	brge	80016eca <_vfprintf_r+0x138e>
80016eb6:	fa c9 f9 44 	sub	r9,sp,-1724
80016eba:	14 97       	mov	r7,r10
80016ebc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80016ec0:	ec ea fd 88 	ld.d	r10,r6[-632]
80016ec4:	fa eb 00 00 	st.d	sp[0],r10
80016ec8:	cc f8       	rjmp	80017066 <_vfprintf_r+0x152a>
80016eca:	41 09       	lddsp	r9,sp[0x40]
80016ecc:	59 f8       	cp.w	r8,31
80016ece:	e0 89 00 16 	brgt	80016efa <_vfprintf_r+0x13be>
80016ed2:	f2 e6 00 00 	ld.d	r6,r9[0]
80016ed6:	f2 cb ff f8 	sub	r11,r9,-8
80016eda:	fa e7 00 00 	st.d	sp[0],r6
80016ede:	51 0b       	stdsp	sp[0x40],r11
80016ee0:	fa c6 f9 44 	sub	r6,sp,-1724
80016ee4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80016ee8:	fa e6 00 00 	ld.d	r6,sp[0]
80016eec:	f2 e7 fd 88 	st.d	r9[-632],r6
80016ef0:	2f f8       	sub	r8,-1
80016ef2:	14 97       	mov	r7,r10
80016ef4:	fb 48 06 b4 	st.w	sp[1716],r8
80016ef8:	cb 78       	rjmp	80017066 <_vfprintf_r+0x152a>
80016efa:	f2 e6 00 00 	ld.d	r6,r9[0]
80016efe:	2f 89       	sub	r9,-8
80016f00:	fa e7 00 00 	st.d	sp[0],r6
80016f04:	51 09       	stdsp	sp[0x40],r9
80016f06:	14 97       	mov	r7,r10
80016f08:	ca f8       	rjmp	80017066 <_vfprintf_r+0x152a>
80016f0a:	ed b5 00 04 	bld	r5,0x4
80016f0e:	c1 71       	brne	80016f3c <_vfprintf_r+0x1400>
80016f10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016f14:	40 3e       	lddsp	lr,sp[0xc]
80016f16:	58 0e       	cp.w	lr,0
80016f18:	c0 80       	breq	80016f28 <_vfprintf_r+0x13ec>
80016f1a:	10 36       	cp.w	r6,r8
80016f1c:	c6 a4       	brge	80016ff0 <_vfprintf_r+0x14b4>
80016f1e:	fa cc f9 44 	sub	r12,sp,-1724
80016f22:	f8 06 00 36 	add	r6,r12,r6<<0x3
80016f26:	c8 38       	rjmp	8001702c <_vfprintf_r+0x14f0>
80016f28:	ee ca ff ff 	sub	r10,r7,-1
80016f2c:	10 37       	cp.w	r7,r8
80016f2e:	e0 84 00 82 	brge	80017032 <_vfprintf_r+0x14f6>
80016f32:	fa cb f9 44 	sub	r11,sp,-1724
80016f36:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016f3a:	c7 88       	rjmp	8001702a <_vfprintf_r+0x14ee>
80016f3c:	ed b5 00 06 	bld	r5,0x6
80016f40:	c4 c1       	brne	80016fd8 <_vfprintf_r+0x149c>
80016f42:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016f46:	40 3c       	lddsp	r12,sp[0xc]
80016f48:	58 0c       	cp.w	r12,0
80016f4a:	c1 d0       	breq	80016f84 <_vfprintf_r+0x1448>
80016f4c:	10 36       	cp.w	r6,r8
80016f4e:	c0 64       	brge	80016f5a <_vfprintf_r+0x141e>
80016f50:	fa cb f9 44 	sub	r11,sp,-1724
80016f54:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016f58:	c1 f8       	rjmp	80016f96 <_vfprintf_r+0x145a>
80016f5a:	fa c8 f9 50 	sub	r8,sp,-1712
80016f5e:	1a d8       	st.w	--sp,r8
80016f60:	fa c8 fa b8 	sub	r8,sp,-1352
80016f64:	1a d8       	st.w	--sp,r8
80016f66:	fa c8 fb b4 	sub	r8,sp,-1100
80016f6a:	1a d8       	st.w	--sp,r8
80016f6c:	fa c8 f9 40 	sub	r8,sp,-1728
80016f70:	fa c9 ff b4 	sub	r9,sp,-76
80016f74:	04 9a       	mov	r10,r2
80016f76:	0c 9b       	mov	r11,r6
80016f78:	08 9c       	mov	r12,r4
80016f7a:	fe b0 f4 43 	rcall	80015800 <get_arg>
80016f7e:	2f dd       	sub	sp,-12
80016f80:	98 18       	ld.sh	r8,r12[0x2]
80016f82:	c2 88       	rjmp	80016fd2 <_vfprintf_r+0x1496>
80016f84:	ee ca ff ff 	sub	r10,r7,-1
80016f88:	10 37       	cp.w	r7,r8
80016f8a:	c0 b4       	brge	80016fa0 <_vfprintf_r+0x1464>
80016f8c:	fa c9 f9 44 	sub	r9,sp,-1724
80016f90:	14 97       	mov	r7,r10
80016f92:	f2 06 00 36 	add	r6,r9,r6<<0x3
80016f96:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80016f9a:	c1 c8       	rjmp	80016fd2 <_vfprintf_r+0x1496>
80016f9c:	80 02       	ld.sh	r2,r0[0x0]
80016f9e:	02 e8       	st.h	--r1,r8
80016fa0:	41 09       	lddsp	r9,sp[0x40]
80016fa2:	59 f8       	cp.w	r8,31
80016fa4:	e0 89 00 13 	brgt	80016fca <_vfprintf_r+0x148e>
80016fa8:	f2 cb ff fc 	sub	r11,r9,-4
80016fac:	51 0b       	stdsp	sp[0x40],r11
80016fae:	72 09       	ld.w	r9,r9[0x0]
80016fb0:	fa c6 f9 44 	sub	r6,sp,-1724
80016fb4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80016fb8:	2f f8       	sub	r8,-1
80016fba:	f7 49 fd 88 	st.w	r11[-632],r9
80016fbe:	fb 48 06 b4 	st.w	sp[1716],r8
80016fc2:	14 97       	mov	r7,r10
80016fc4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80016fc8:	c0 58       	rjmp	80016fd2 <_vfprintf_r+0x1496>
80016fca:	92 18       	ld.sh	r8,r9[0x2]
80016fcc:	14 97       	mov	r7,r10
80016fce:	2f c9       	sub	r9,-4
80016fd0:	51 09       	stdsp	sp[0x40],r9
80016fd2:	5c 78       	castu.h	r8
80016fd4:	50 18       	stdsp	sp[0x4],r8
80016fd6:	c4 68       	rjmp	80017062 <_vfprintf_r+0x1526>
80016fd8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80016fdc:	40 3c       	lddsp	r12,sp[0xc]
80016fde:	58 0c       	cp.w	r12,0
80016fe0:	c1 d0       	breq	8001701a <_vfprintf_r+0x14de>
80016fe2:	10 36       	cp.w	r6,r8
80016fe4:	c0 64       	brge	80016ff0 <_vfprintf_r+0x14b4>
80016fe6:	fa cb f9 44 	sub	r11,sp,-1724
80016fea:	f6 06 00 36 	add	r6,r11,r6<<0x3
80016fee:	c1 f8       	rjmp	8001702c <_vfprintf_r+0x14f0>
80016ff0:	fa c8 f9 50 	sub	r8,sp,-1712
80016ff4:	1a d8       	st.w	--sp,r8
80016ff6:	fa c8 fa b8 	sub	r8,sp,-1352
80016ffa:	0c 9b       	mov	r11,r6
80016ffc:	1a d8       	st.w	--sp,r8
80016ffe:	fa c8 fb b4 	sub	r8,sp,-1100
80017002:	04 9a       	mov	r10,r2
80017004:	1a d8       	st.w	--sp,r8
80017006:	08 9c       	mov	r12,r4
80017008:	fa c8 f9 40 	sub	r8,sp,-1728
8001700c:	fa c9 ff b4 	sub	r9,sp,-76
80017010:	fe b0 f3 f8 	rcall	80015800 <get_arg>
80017014:	2f dd       	sub	sp,-12
80017016:	78 0b       	ld.w	r11,r12[0x0]
80017018:	c2 48       	rjmp	80017060 <_vfprintf_r+0x1524>
8001701a:	ee ca ff ff 	sub	r10,r7,-1
8001701e:	10 37       	cp.w	r7,r8
80017020:	c0 94       	brge	80017032 <_vfprintf_r+0x14f6>
80017022:	fa c9 f9 44 	sub	r9,sp,-1724
80017026:	f2 06 00 36 	add	r6,r9,r6<<0x3
8001702a:	14 97       	mov	r7,r10
8001702c:	ec fb fd 88 	ld.w	r11,r6[-632]
80017030:	c1 88       	rjmp	80017060 <_vfprintf_r+0x1524>
80017032:	41 09       	lddsp	r9,sp[0x40]
80017034:	59 f8       	cp.w	r8,31
80017036:	e0 89 00 11 	brgt	80017058 <_vfprintf_r+0x151c>
8001703a:	f2 cb ff fc 	sub	r11,r9,-4
8001703e:	51 0b       	stdsp	sp[0x40],r11
80017040:	fa c6 f9 44 	sub	r6,sp,-1724
80017044:	72 0b       	ld.w	r11,r9[0x0]
80017046:	ec 08 00 39 	add	r9,r6,r8<<0x3
8001704a:	f3 4b fd 88 	st.w	r9[-632],r11
8001704e:	2f f8       	sub	r8,-1
80017050:	14 97       	mov	r7,r10
80017052:	fb 48 06 b4 	st.w	sp[1716],r8
80017056:	c0 58       	rjmp	80017060 <_vfprintf_r+0x1524>
80017058:	72 0b       	ld.w	r11,r9[0x0]
8001705a:	14 97       	mov	r7,r10
8001705c:	2f c9       	sub	r9,-4
8001705e:	51 09       	stdsp	sp[0x40],r9
80017060:	50 1b       	stdsp	sp[0x4],r11
80017062:	30 0e       	mov	lr,0
80017064:	50 0e       	stdsp	sp[0x0],lr
80017066:	40 08       	lddsp	r8,sp[0x0]
80017068:	40 1c       	lddsp	r12,sp[0x4]
8001706a:	18 48       	or	r8,r12
8001706c:	5f 19       	srne	r9
8001706e:	0a 98       	mov	r8,r5
80017070:	eb e9 00 09 	and	r9,r5,r9
80017074:	a1 b8       	sbr	r8,0x1
80017076:	58 09       	cp.w	r9,0
80017078:	c0 70       	breq	80017086 <_vfprintf_r+0x154a>
8001707a:	10 95       	mov	r5,r8
8001707c:	fb 60 06 b9 	st.b	sp[1721],r0
80017080:	33 08       	mov	r8,48
80017082:	fb 68 06 b8 	st.b	sp[1720],r8
80017086:	30 28       	mov	r8,2
80017088:	30 09       	mov	r9,0
8001708a:	fb 69 06 bb 	st.b	sp[1723],r9
8001708e:	0a 99       	mov	r9,r5
80017090:	a7 d9       	cbr	r9,0x7
80017092:	40 2b       	lddsp	r11,sp[0x8]
80017094:	40 16       	lddsp	r6,sp[0x4]
80017096:	58 0b       	cp.w	r11,0
80017098:	5f 1a       	srne	r10
8001709a:	f2 05 17 40 	movge	r5,r9
8001709e:	fa c2 f9 78 	sub	r2,sp,-1672
800170a2:	40 09       	lddsp	r9,sp[0x0]
800170a4:	0c 49       	or	r9,r6
800170a6:	5f 19       	srne	r9
800170a8:	f5 e9 10 09 	or	r9,r10,r9
800170ac:	c5 c0       	breq	80017164 <_vfprintf_r+0x1628>
800170ae:	30 19       	mov	r9,1
800170b0:	f2 08 18 00 	cp.b	r8,r9
800170b4:	c0 60       	breq	800170c0 <_vfprintf_r+0x1584>
800170b6:	30 29       	mov	r9,2
800170b8:	f2 08 18 00 	cp.b	r8,r9
800170bc:	c0 41       	brne	800170c4 <_vfprintf_r+0x1588>
800170be:	c3 c8       	rjmp	80017136 <_vfprintf_r+0x15fa>
800170c0:	04 96       	mov	r6,r2
800170c2:	c3 08       	rjmp	80017122 <_vfprintf_r+0x15e6>
800170c4:	04 96       	mov	r6,r2
800170c6:	fa e8 00 00 	ld.d	r8,sp[0]
800170ca:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800170ce:	2d 0a       	sub	r10,-48
800170d0:	0c fa       	st.b	--r6,r10
800170d2:	f0 0b 16 03 	lsr	r11,r8,0x3
800170d6:	f2 0c 16 03 	lsr	r12,r9,0x3
800170da:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800170de:	18 99       	mov	r9,r12
800170e0:	16 98       	mov	r8,r11
800170e2:	58 08       	cp.w	r8,0
800170e4:	5c 29       	cpc	r9
800170e6:	cf 21       	brne	800170ca <_vfprintf_r+0x158e>
800170e8:	fa e9 00 00 	st.d	sp[0],r8
800170ec:	ed b5 00 00 	bld	r5,0x0
800170f0:	c4 51       	brne	8001717a <_vfprintf_r+0x163e>
800170f2:	33 09       	mov	r9,48
800170f4:	f2 0a 18 00 	cp.b	r10,r9
800170f8:	c4 10       	breq	8001717a <_vfprintf_r+0x163e>
800170fa:	0c f9       	st.b	--r6,r9
800170fc:	c3 f8       	rjmp	8001717a <_vfprintf_r+0x163e>
800170fe:	fa ea 00 00 	ld.d	r10,sp[0]
80017102:	30 a8       	mov	r8,10
80017104:	30 09       	mov	r9,0
80017106:	e0 a0 32 fa 	rcall	8001d6fa <__avr32_umod64>
8001710a:	30 a8       	mov	r8,10
8001710c:	2d 0a       	sub	r10,-48
8001710e:	30 09       	mov	r9,0
80017110:	ac 8a       	st.b	r6[0x0],r10
80017112:	fa ea 00 00 	ld.d	r10,sp[0]
80017116:	fe b0 ee 16 	rcall	80014d42 <__avr32_udiv64>
8001711a:	16 99       	mov	r9,r11
8001711c:	14 98       	mov	r8,r10
8001711e:	fa e9 00 00 	st.d	sp[0],r8
80017122:	20 16       	sub	r6,1
80017124:	fa ea 00 00 	ld.d	r10,sp[0]
80017128:	58 9a       	cp.w	r10,9
8001712a:	5c 2b       	cpc	r11
8001712c:	fe 9b ff e9 	brhi	800170fe <_vfprintf_r+0x15c2>
80017130:	1b f8       	ld.ub	r8,sp[0x7]
80017132:	2d 08       	sub	r8,-48
80017134:	c2 08       	rjmp	80017174 <_vfprintf_r+0x1638>
80017136:	04 96       	mov	r6,r2
80017138:	fa e8 00 00 	ld.d	r8,sp[0]
8001713c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80017140:	40 de       	lddsp	lr,sp[0x34]
80017142:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80017146:	0c fa       	st.b	--r6,r10
80017148:	f2 0b 16 04 	lsr	r11,r9,0x4
8001714c:	f0 0a 16 04 	lsr	r10,r8,0x4
80017150:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80017154:	16 99       	mov	r9,r11
80017156:	14 98       	mov	r8,r10
80017158:	58 08       	cp.w	r8,0
8001715a:	5c 29       	cpc	r9
8001715c:	cf 01       	brne	8001713c <_vfprintf_r+0x1600>
8001715e:	fa e9 00 00 	st.d	sp[0],r8
80017162:	c0 c8       	rjmp	8001717a <_vfprintf_r+0x163e>
80017164:	58 08       	cp.w	r8,0
80017166:	c0 91       	brne	80017178 <_vfprintf_r+0x163c>
80017168:	ed b5 00 00 	bld	r5,0x0
8001716c:	c0 61       	brne	80017178 <_vfprintf_r+0x163c>
8001716e:	fa c6 f9 79 	sub	r6,sp,-1671
80017172:	33 08       	mov	r8,48
80017174:	ac 88       	st.b	r6[0x0],r8
80017176:	c0 28       	rjmp	8001717a <_vfprintf_r+0x163e>
80017178:	04 96       	mov	r6,r2
8001717a:	0c 12       	sub	r2,r6
8001717c:	c1 c8       	rjmp	800171b4 <_vfprintf_r+0x1678>
8001717e:	50 a7       	stdsp	sp[0x28],r7
80017180:	50 80       	stdsp	sp[0x20],r0
80017182:	40 93       	lddsp	r3,sp[0x24]
80017184:	0c 97       	mov	r7,r6
80017186:	10 90       	mov	r0,r8
80017188:	04 94       	mov	r4,r2
8001718a:	40 41       	lddsp	r1,sp[0x10]
8001718c:	58 08       	cp.w	r8,0
8001718e:	e0 80 04 51 	breq	80017a30 <_vfprintf_r+0x1ef4>
80017192:	fb 68 06 60 	st.b	sp[1632],r8
80017196:	30 0c       	mov	r12,0
80017198:	30 08       	mov	r8,0
8001719a:	30 12       	mov	r2,1
8001719c:	fb 68 06 bb 	st.b	sp[1723],r8
800171a0:	50 2c       	stdsp	sp[0x8],r12
800171a2:	fa c6 f9 a0 	sub	r6,sp,-1632
800171a6:	c0 78       	rjmp	800171b4 <_vfprintf_r+0x1678>
800171a8:	30 0b       	mov	r11,0
800171aa:	50 2b       	stdsp	sp[0x8],r11
800171ac:	c0 48       	rjmp	800171b4 <_vfprintf_r+0x1678>
800171ae:	40 22       	lddsp	r2,sp[0x8]
800171b0:	30 0a       	mov	r10,0
800171b2:	50 2a       	stdsp	sp[0x8],r10
800171b4:	40 29       	lddsp	r9,sp[0x8]
800171b6:	e4 09 0c 49 	max	r9,r2,r9
800171ba:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800171be:	50 39       	stdsp	sp[0xc],r9
800171c0:	0a 9e       	mov	lr,r5
800171c2:	30 09       	mov	r9,0
800171c4:	e2 1e 00 02 	andl	lr,0x2,COH
800171c8:	f2 08 18 00 	cp.b	r8,r9
800171cc:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800171d0:	f7 b8 01 ff 	subne	r8,-1
800171d4:	fb f8 1a 03 	st.wne	sp[0xc],r8
800171d8:	0a 9b       	mov	r11,r5
800171da:	58 0e       	cp.w	lr,0
800171dc:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800171e0:	f7 bc 01 fe 	subne	r12,-2
800171e4:	fb fc 1a 03 	st.wne	sp[0xc],r12
800171e8:	e2 1b 00 84 	andl	r11,0x84,COH
800171ec:	50 fe       	stdsp	sp[0x3c],lr
800171ee:	50 9b       	stdsp	sp[0x24],r11
800171f0:	c4 51       	brne	8001727a <_vfprintf_r+0x173e>
800171f2:	40 8a       	lddsp	r10,sp[0x20]
800171f4:	40 39       	lddsp	r9,sp[0xc]
800171f6:	12 1a       	sub	r10,r9
800171f8:	50 4a       	stdsp	sp[0x10],r10
800171fa:	58 0a       	cp.w	r10,0
800171fc:	e0 89 00 1f 	brgt	8001723a <_vfprintf_r+0x16fe>
80017200:	c3 d8       	rjmp	8001727a <_vfprintf_r+0x173e>
80017202:	2f 09       	sub	r9,-16
80017204:	2f f8       	sub	r8,-1
80017206:	4c ee       	lddpc	lr,8001733c <_vfprintf_r+0x1800>
80017208:	31 0c       	mov	r12,16
8001720a:	fb 49 06 90 	st.w	sp[1680],r9
8001720e:	87 0e       	st.w	r3[0x0],lr
80017210:	87 1c       	st.w	r3[0x4],r12
80017212:	fb 48 06 8c 	st.w	sp[1676],r8
80017216:	58 78       	cp.w	r8,7
80017218:	e0 89 00 04 	brgt	80017220 <_vfprintf_r+0x16e4>
8001721c:	2f 83       	sub	r3,-8
8001721e:	c0 b8       	rjmp	80017234 <_vfprintf_r+0x16f8>
80017220:	fa ca f9 78 	sub	r10,sp,-1672
80017224:	02 9b       	mov	r11,r1
80017226:	08 9c       	mov	r12,r4
80017228:	fe b0 f4 7c 	rcall	80015b20 <__sprint_r>
8001722c:	e0 81 04 13 	brne	80017a52 <_vfprintf_r+0x1f16>
80017230:	fa c3 f9 e0 	sub	r3,sp,-1568
80017234:	40 4b       	lddsp	r11,sp[0x10]
80017236:	21 0b       	sub	r11,16
80017238:	50 4b       	stdsp	sp[0x10],r11
8001723a:	fa f9 06 90 	ld.w	r9,sp[1680]
8001723e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017242:	4b fa       	lddpc	r10,8001733c <_vfprintf_r+0x1800>
80017244:	40 4e       	lddsp	lr,sp[0x10]
80017246:	59 0e       	cp.w	lr,16
80017248:	fe 99 ff dd 	brgt	80017202 <_vfprintf_r+0x16c6>
8001724c:	1c 09       	add	r9,lr
8001724e:	2f f8       	sub	r8,-1
80017250:	87 0a       	st.w	r3[0x0],r10
80017252:	fb 49 06 90 	st.w	sp[1680],r9
80017256:	87 1e       	st.w	r3[0x4],lr
80017258:	fb 48 06 8c 	st.w	sp[1676],r8
8001725c:	58 78       	cp.w	r8,7
8001725e:	e0 89 00 04 	brgt	80017266 <_vfprintf_r+0x172a>
80017262:	2f 83       	sub	r3,-8
80017264:	c0 b8       	rjmp	8001727a <_vfprintf_r+0x173e>
80017266:	fa ca f9 78 	sub	r10,sp,-1672
8001726a:	02 9b       	mov	r11,r1
8001726c:	08 9c       	mov	r12,r4
8001726e:	fe b0 f4 59 	rcall	80015b20 <__sprint_r>
80017272:	e0 81 03 f0 	brne	80017a52 <_vfprintf_r+0x1f16>
80017276:	fa c3 f9 e0 	sub	r3,sp,-1568
8001727a:	30 09       	mov	r9,0
8001727c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80017280:	f2 08 18 00 	cp.b	r8,r9
80017284:	c1 f0       	breq	800172c2 <_vfprintf_r+0x1786>
80017286:	fa f8 06 90 	ld.w	r8,sp[1680]
8001728a:	fa c9 f9 45 	sub	r9,sp,-1723
8001728e:	2f f8       	sub	r8,-1
80017290:	87 09       	st.w	r3[0x0],r9
80017292:	fb 48 06 90 	st.w	sp[1680],r8
80017296:	30 19       	mov	r9,1
80017298:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001729c:	87 19       	st.w	r3[0x4],r9
8001729e:	2f f8       	sub	r8,-1
800172a0:	fb 48 06 8c 	st.w	sp[1676],r8
800172a4:	58 78       	cp.w	r8,7
800172a6:	e0 89 00 04 	brgt	800172ae <_vfprintf_r+0x1772>
800172aa:	2f 83       	sub	r3,-8
800172ac:	c0 b8       	rjmp	800172c2 <_vfprintf_r+0x1786>
800172ae:	fa ca f9 78 	sub	r10,sp,-1672
800172b2:	02 9b       	mov	r11,r1
800172b4:	08 9c       	mov	r12,r4
800172b6:	fe b0 f4 35 	rcall	80015b20 <__sprint_r>
800172ba:	e0 81 03 cc 	brne	80017a52 <_vfprintf_r+0x1f16>
800172be:	fa c3 f9 e0 	sub	r3,sp,-1568
800172c2:	40 fc       	lddsp	r12,sp[0x3c]
800172c4:	58 0c       	cp.w	r12,0
800172c6:	c1 f0       	breq	80017304 <_vfprintf_r+0x17c8>
800172c8:	fa f8 06 90 	ld.w	r8,sp[1680]
800172cc:	fa c9 f9 48 	sub	r9,sp,-1720
800172d0:	2f e8       	sub	r8,-2
800172d2:	87 09       	st.w	r3[0x0],r9
800172d4:	fb 48 06 90 	st.w	sp[1680],r8
800172d8:	30 29       	mov	r9,2
800172da:	fa f8 06 8c 	ld.w	r8,sp[1676]
800172de:	87 19       	st.w	r3[0x4],r9
800172e0:	2f f8       	sub	r8,-1
800172e2:	fb 48 06 8c 	st.w	sp[1676],r8
800172e6:	58 78       	cp.w	r8,7
800172e8:	e0 89 00 04 	brgt	800172f0 <_vfprintf_r+0x17b4>
800172ec:	2f 83       	sub	r3,-8
800172ee:	c0 b8       	rjmp	80017304 <_vfprintf_r+0x17c8>
800172f0:	fa ca f9 78 	sub	r10,sp,-1672
800172f4:	02 9b       	mov	r11,r1
800172f6:	08 9c       	mov	r12,r4
800172f8:	fe b0 f4 14 	rcall	80015b20 <__sprint_r>
800172fc:	e0 81 03 ab 	brne	80017a52 <_vfprintf_r+0x1f16>
80017300:	fa c3 f9 e0 	sub	r3,sp,-1568
80017304:	40 9b       	lddsp	r11,sp[0x24]
80017306:	e0 4b 00 80 	cp.w	r11,128
8001730a:	c4 a1       	brne	8001739e <_vfprintf_r+0x1862>
8001730c:	40 8a       	lddsp	r10,sp[0x20]
8001730e:	40 39       	lddsp	r9,sp[0xc]
80017310:	12 1a       	sub	r10,r9
80017312:	50 4a       	stdsp	sp[0x10],r10
80017314:	58 0a       	cp.w	r10,0
80017316:	e0 89 00 24 	brgt	8001735e <_vfprintf_r+0x1822>
8001731a:	c4 28       	rjmp	8001739e <_vfprintf_r+0x1862>
8001731c:	2f 09       	sub	r9,-16
8001731e:	2f f8       	sub	r8,-1
80017320:	48 8e       	lddpc	lr,80017340 <_vfprintf_r+0x1804>
80017322:	31 0c       	mov	r12,16
80017324:	fb 49 06 90 	st.w	sp[1680],r9
80017328:	87 0e       	st.w	r3[0x0],lr
8001732a:	87 1c       	st.w	r3[0x4],r12
8001732c:	fb 48 06 8c 	st.w	sp[1676],r8
80017330:	58 78       	cp.w	r8,7
80017332:	e0 89 00 09 	brgt	80017344 <_vfprintf_r+0x1808>
80017336:	2f 83       	sub	r3,-8
80017338:	c1 08       	rjmp	80017358 <_vfprintf_r+0x181c>
8001733a:	d7 03       	nop
8001733c:	80 02       	ld.sh	r2,r0[0x0]
8001733e:	03 00       	ld.w	r0,r1++
80017340:	80 02       	ld.sh	r2,r0[0x0]
80017342:	03 10       	ld.sh	r0,r1++
80017344:	fa ca f9 78 	sub	r10,sp,-1672
80017348:	02 9b       	mov	r11,r1
8001734a:	08 9c       	mov	r12,r4
8001734c:	fe b0 f3 ea 	rcall	80015b20 <__sprint_r>
80017350:	e0 81 03 81 	brne	80017a52 <_vfprintf_r+0x1f16>
80017354:	fa c3 f9 e0 	sub	r3,sp,-1568
80017358:	40 4b       	lddsp	r11,sp[0x10]
8001735a:	21 0b       	sub	r11,16
8001735c:	50 4b       	stdsp	sp[0x10],r11
8001735e:	fa f9 06 90 	ld.w	r9,sp[1680]
80017362:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017366:	4c 6a       	lddpc	r10,8001747c <_vfprintf_r+0x1940>
80017368:	40 4e       	lddsp	lr,sp[0x10]
8001736a:	59 0e       	cp.w	lr,16
8001736c:	fe 99 ff d8 	brgt	8001731c <_vfprintf_r+0x17e0>
80017370:	1c 09       	add	r9,lr
80017372:	2f f8       	sub	r8,-1
80017374:	87 0a       	st.w	r3[0x0],r10
80017376:	fb 49 06 90 	st.w	sp[1680],r9
8001737a:	87 1e       	st.w	r3[0x4],lr
8001737c:	fb 48 06 8c 	st.w	sp[1676],r8
80017380:	58 78       	cp.w	r8,7
80017382:	e0 89 00 04 	brgt	8001738a <_vfprintf_r+0x184e>
80017386:	2f 83       	sub	r3,-8
80017388:	c0 b8       	rjmp	8001739e <_vfprintf_r+0x1862>
8001738a:	fa ca f9 78 	sub	r10,sp,-1672
8001738e:	02 9b       	mov	r11,r1
80017390:	08 9c       	mov	r12,r4
80017392:	fe b0 f3 c7 	rcall	80015b20 <__sprint_r>
80017396:	e0 81 03 5e 	brne	80017a52 <_vfprintf_r+0x1f16>
8001739a:	fa c3 f9 e0 	sub	r3,sp,-1568
8001739e:	40 2c       	lddsp	r12,sp[0x8]
800173a0:	04 1c       	sub	r12,r2
800173a2:	50 2c       	stdsp	sp[0x8],r12
800173a4:	58 0c       	cp.w	r12,0
800173a6:	e0 89 00 1f 	brgt	800173e4 <_vfprintf_r+0x18a8>
800173aa:	c3 d8       	rjmp	80017424 <_vfprintf_r+0x18e8>
800173ac:	2f 09       	sub	r9,-16
800173ae:	2f f8       	sub	r8,-1
800173b0:	4b 3b       	lddpc	r11,8001747c <_vfprintf_r+0x1940>
800173b2:	31 0a       	mov	r10,16
800173b4:	fb 49 06 90 	st.w	sp[1680],r9
800173b8:	87 0b       	st.w	r3[0x0],r11
800173ba:	87 1a       	st.w	r3[0x4],r10
800173bc:	fb 48 06 8c 	st.w	sp[1676],r8
800173c0:	58 78       	cp.w	r8,7
800173c2:	e0 89 00 04 	brgt	800173ca <_vfprintf_r+0x188e>
800173c6:	2f 83       	sub	r3,-8
800173c8:	c0 b8       	rjmp	800173de <_vfprintf_r+0x18a2>
800173ca:	fa ca f9 78 	sub	r10,sp,-1672
800173ce:	02 9b       	mov	r11,r1
800173d0:	08 9c       	mov	r12,r4
800173d2:	fe b0 f3 a7 	rcall	80015b20 <__sprint_r>
800173d6:	e0 81 03 3e 	brne	80017a52 <_vfprintf_r+0x1f16>
800173da:	fa c3 f9 e0 	sub	r3,sp,-1568
800173de:	40 29       	lddsp	r9,sp[0x8]
800173e0:	21 09       	sub	r9,16
800173e2:	50 29       	stdsp	sp[0x8],r9
800173e4:	fa f9 06 90 	ld.w	r9,sp[1680]
800173e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800173ec:	4a 4a       	lddpc	r10,8001747c <_vfprintf_r+0x1940>
800173ee:	40 2e       	lddsp	lr,sp[0x8]
800173f0:	59 0e       	cp.w	lr,16
800173f2:	fe 99 ff dd 	brgt	800173ac <_vfprintf_r+0x1870>
800173f6:	1c 09       	add	r9,lr
800173f8:	2f f8       	sub	r8,-1
800173fa:	87 0a       	st.w	r3[0x0],r10
800173fc:	fb 49 06 90 	st.w	sp[1680],r9
80017400:	87 1e       	st.w	r3[0x4],lr
80017402:	fb 48 06 8c 	st.w	sp[1676],r8
80017406:	58 78       	cp.w	r8,7
80017408:	e0 89 00 04 	brgt	80017410 <_vfprintf_r+0x18d4>
8001740c:	2f 83       	sub	r3,-8
8001740e:	c0 b8       	rjmp	80017424 <_vfprintf_r+0x18e8>
80017410:	fa ca f9 78 	sub	r10,sp,-1672
80017414:	02 9b       	mov	r11,r1
80017416:	08 9c       	mov	r12,r4
80017418:	fe b0 f3 84 	rcall	80015b20 <__sprint_r>
8001741c:	e0 81 03 1b 	brne	80017a52 <_vfprintf_r+0x1f16>
80017420:	fa c3 f9 e0 	sub	r3,sp,-1568
80017424:	ed b5 00 08 	bld	r5,0x8
80017428:	c0 b0       	breq	8001743e <_vfprintf_r+0x1902>
8001742a:	fa f8 06 90 	ld.w	r8,sp[1680]
8001742e:	87 12       	st.w	r3[0x4],r2
80017430:	87 06       	st.w	r3[0x0],r6
80017432:	f0 02 00 02 	add	r2,r8,r2
80017436:	fb 42 06 90 	st.w	sp[1680],r2
8001743a:	e0 8f 01 d5 	bral	800177e4 <_vfprintf_r+0x1ca8>
8001743e:	e0 40 00 65 	cp.w	r0,101
80017442:	e0 8a 01 d7 	brle	800177f0 <_vfprintf_r+0x1cb4>
80017446:	30 08       	mov	r8,0
80017448:	30 09       	mov	r9,0
8001744a:	40 5b       	lddsp	r11,sp[0x14]
8001744c:	40 7a       	lddsp	r10,sp[0x1c]
8001744e:	e0 a0 2f 09 	rcall	8001d260 <__avr32_f64_cmp_eq>
80017452:	c7 a0       	breq	80017546 <_vfprintf_r+0x1a0a>
80017454:	fa f8 06 90 	ld.w	r8,sp[1680]
80017458:	48 a9       	lddpc	r9,80017480 <_vfprintf_r+0x1944>
8001745a:	2f f8       	sub	r8,-1
8001745c:	87 09       	st.w	r3[0x0],r9
8001745e:	fb 48 06 90 	st.w	sp[1680],r8
80017462:	30 19       	mov	r9,1
80017464:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017468:	87 19       	st.w	r3[0x4],r9
8001746a:	2f f8       	sub	r8,-1
8001746c:	fb 48 06 8c 	st.w	sp[1676],r8
80017470:	58 78       	cp.w	r8,7
80017472:	e0 89 00 09 	brgt	80017484 <_vfprintf_r+0x1948>
80017476:	2f 83       	sub	r3,-8
80017478:	c1 08       	rjmp	80017498 <_vfprintf_r+0x195c>
8001747a:	d7 03       	nop
8001747c:	80 02       	ld.sh	r2,r0[0x0]
8001747e:	03 10       	ld.sh	r0,r1++
80017480:	80 02       	ld.sh	r2,r0[0x0]
80017482:	02 fc       	st.b	--r1,r12
80017484:	fa ca f9 78 	sub	r10,sp,-1672
80017488:	02 9b       	mov	r11,r1
8001748a:	08 9c       	mov	r12,r4
8001748c:	fe b0 f3 4a 	rcall	80015b20 <__sprint_r>
80017490:	e0 81 02 e1 	brne	80017a52 <_vfprintf_r+0x1f16>
80017494:	fa c3 f9 e0 	sub	r3,sp,-1568
80017498:	fa f8 06 ac 	ld.w	r8,sp[1708]
8001749c:	40 6c       	lddsp	r12,sp[0x18]
8001749e:	18 38       	cp.w	r8,r12
800174a0:	c0 55       	brlt	800174aa <_vfprintf_r+0x196e>
800174a2:	ed b5 00 00 	bld	r5,0x0
800174a6:	e0 81 02 69 	brne	80017978 <_vfprintf_r+0x1e3c>
800174aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800174ae:	2f f8       	sub	r8,-1
800174b0:	40 cb       	lddsp	r11,sp[0x30]
800174b2:	fb 48 06 90 	st.w	sp[1680],r8
800174b6:	30 19       	mov	r9,1
800174b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800174bc:	87 0b       	st.w	r3[0x0],r11
800174be:	2f f8       	sub	r8,-1
800174c0:	87 19       	st.w	r3[0x4],r9
800174c2:	fb 48 06 8c 	st.w	sp[1676],r8
800174c6:	58 78       	cp.w	r8,7
800174c8:	e0 89 00 04 	brgt	800174d0 <_vfprintf_r+0x1994>
800174cc:	2f 83       	sub	r3,-8
800174ce:	c0 b8       	rjmp	800174e4 <_vfprintf_r+0x19a8>
800174d0:	fa ca f9 78 	sub	r10,sp,-1672
800174d4:	02 9b       	mov	r11,r1
800174d6:	08 9c       	mov	r12,r4
800174d8:	fe b0 f3 24 	rcall	80015b20 <__sprint_r>
800174dc:	e0 81 02 bb 	brne	80017a52 <_vfprintf_r+0x1f16>
800174e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800174e4:	40 66       	lddsp	r6,sp[0x18]
800174e6:	20 16       	sub	r6,1
800174e8:	58 06       	cp.w	r6,0
800174ea:	e0 89 00 1d 	brgt	80017524 <_vfprintf_r+0x19e8>
800174ee:	e0 8f 02 45 	bral	80017978 <_vfprintf_r+0x1e3c>
800174f2:	2f 09       	sub	r9,-16
800174f4:	2f f8       	sub	r8,-1
800174f6:	fb 49 06 90 	st.w	sp[1680],r9
800174fa:	87 02       	st.w	r3[0x0],r2
800174fc:	87 10       	st.w	r3[0x4],r0
800174fe:	fb 48 06 8c 	st.w	sp[1676],r8
80017502:	58 78       	cp.w	r8,7
80017504:	e0 89 00 04 	brgt	8001750c <_vfprintf_r+0x19d0>
80017508:	2f 83       	sub	r3,-8
8001750a:	c0 b8       	rjmp	80017520 <_vfprintf_r+0x19e4>
8001750c:	fa ca f9 78 	sub	r10,sp,-1672
80017510:	02 9b       	mov	r11,r1
80017512:	08 9c       	mov	r12,r4
80017514:	fe b0 f3 06 	rcall	80015b20 <__sprint_r>
80017518:	e0 81 02 9d 	brne	80017a52 <_vfprintf_r+0x1f16>
8001751c:	fa c3 f9 e0 	sub	r3,sp,-1568
80017520:	21 06       	sub	r6,16
80017522:	c0 38       	rjmp	80017528 <_vfprintf_r+0x19ec>
80017524:	4d 22       	lddpc	r2,8001766c <_vfprintf_r+0x1b30>
80017526:	31 00       	mov	r0,16
80017528:	fa f9 06 90 	ld.w	r9,sp[1680]
8001752c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017530:	4c fa       	lddpc	r10,8001766c <_vfprintf_r+0x1b30>
80017532:	59 06       	cp.w	r6,16
80017534:	fe 99 ff df 	brgt	800174f2 <_vfprintf_r+0x19b6>
80017538:	0c 09       	add	r9,r6
8001753a:	87 0a       	st.w	r3[0x0],r10
8001753c:	fb 49 06 90 	st.w	sp[1680],r9
80017540:	2f f8       	sub	r8,-1
80017542:	87 16       	st.w	r3[0x4],r6
80017544:	c5 39       	rjmp	800177ea <_vfprintf_r+0x1cae>
80017546:	fa fa 06 ac 	ld.w	r10,sp[1708]
8001754a:	58 0a       	cp.w	r10,0
8001754c:	e0 89 00 94 	brgt	80017674 <_vfprintf_r+0x1b38>
80017550:	fa f8 06 90 	ld.w	r8,sp[1680]
80017554:	4c 79       	lddpc	r9,80017670 <_vfprintf_r+0x1b34>
80017556:	2f f8       	sub	r8,-1
80017558:	87 09       	st.w	r3[0x0],r9
8001755a:	fb 48 06 90 	st.w	sp[1680],r8
8001755e:	30 19       	mov	r9,1
80017560:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017564:	87 19       	st.w	r3[0x4],r9
80017566:	2f f8       	sub	r8,-1
80017568:	fb 48 06 8c 	st.w	sp[1676],r8
8001756c:	58 78       	cp.w	r8,7
8001756e:	e0 89 00 04 	brgt	80017576 <_vfprintf_r+0x1a3a>
80017572:	2f 83       	sub	r3,-8
80017574:	c0 b8       	rjmp	8001758a <_vfprintf_r+0x1a4e>
80017576:	fa ca f9 78 	sub	r10,sp,-1672
8001757a:	02 9b       	mov	r11,r1
8001757c:	08 9c       	mov	r12,r4
8001757e:	fe b0 f2 d1 	rcall	80015b20 <__sprint_r>
80017582:	e0 81 02 68 	brne	80017a52 <_vfprintf_r+0x1f16>
80017586:	fa c3 f9 e0 	sub	r3,sp,-1568
8001758a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8001758e:	58 08       	cp.w	r8,0
80017590:	c0 81       	brne	800175a0 <_vfprintf_r+0x1a64>
80017592:	40 6a       	lddsp	r10,sp[0x18]
80017594:	58 0a       	cp.w	r10,0
80017596:	c0 51       	brne	800175a0 <_vfprintf_r+0x1a64>
80017598:	ed b5 00 00 	bld	r5,0x0
8001759c:	e0 81 01 ee 	brne	80017978 <_vfprintf_r+0x1e3c>
800175a0:	40 c9       	lddsp	r9,sp[0x30]
800175a2:	fa f8 06 90 	ld.w	r8,sp[1680]
800175a6:	2f f8       	sub	r8,-1
800175a8:	87 09       	st.w	r3[0x0],r9
800175aa:	fb 48 06 90 	st.w	sp[1680],r8
800175ae:	30 19       	mov	r9,1
800175b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800175b4:	87 19       	st.w	r3[0x4],r9
800175b6:	2f f8       	sub	r8,-1
800175b8:	fb 48 06 8c 	st.w	sp[1676],r8
800175bc:	58 78       	cp.w	r8,7
800175be:	e0 89 00 04 	brgt	800175c6 <_vfprintf_r+0x1a8a>
800175c2:	2f 83       	sub	r3,-8
800175c4:	c0 b8       	rjmp	800175da <_vfprintf_r+0x1a9e>
800175c6:	fa ca f9 78 	sub	r10,sp,-1672
800175ca:	02 9b       	mov	r11,r1
800175cc:	08 9c       	mov	r12,r4
800175ce:	fe b0 f2 a9 	rcall	80015b20 <__sprint_r>
800175d2:	e0 81 02 40 	brne	80017a52 <_vfprintf_r+0x1f16>
800175d6:	fa c3 f9 e0 	sub	r3,sp,-1568
800175da:	fa f2 06 ac 	ld.w	r2,sp[1708]
800175de:	5c 32       	neg	r2
800175e0:	58 02       	cp.w	r2,0
800175e2:	e0 89 00 1d 	brgt	8001761c <_vfprintf_r+0x1ae0>
800175e6:	c3 b8       	rjmp	8001765c <_vfprintf_r+0x1b20>
800175e8:	2f 09       	sub	r9,-16
800175ea:	2f f8       	sub	r8,-1
800175ec:	31 0e       	mov	lr,16
800175ee:	fb 49 06 90 	st.w	sp[1680],r9
800175f2:	87 00       	st.w	r3[0x0],r0
800175f4:	87 1e       	st.w	r3[0x4],lr
800175f6:	fb 48 06 8c 	st.w	sp[1676],r8
800175fa:	58 78       	cp.w	r8,7
800175fc:	e0 89 00 04 	brgt	80017604 <_vfprintf_r+0x1ac8>
80017600:	2f 83       	sub	r3,-8
80017602:	c0 b8       	rjmp	80017618 <_vfprintf_r+0x1adc>
80017604:	fa ca f9 78 	sub	r10,sp,-1672
80017608:	02 9b       	mov	r11,r1
8001760a:	08 9c       	mov	r12,r4
8001760c:	fe b0 f2 8a 	rcall	80015b20 <__sprint_r>
80017610:	e0 81 02 21 	brne	80017a52 <_vfprintf_r+0x1f16>
80017614:	fa c3 f9 e0 	sub	r3,sp,-1568
80017618:	21 02       	sub	r2,16
8001761a:	c0 28       	rjmp	8001761e <_vfprintf_r+0x1ae2>
8001761c:	49 40       	lddpc	r0,8001766c <_vfprintf_r+0x1b30>
8001761e:	fa f9 06 90 	ld.w	r9,sp[1680]
80017622:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017626:	49 2a       	lddpc	r10,8001766c <_vfprintf_r+0x1b30>
80017628:	59 02       	cp.w	r2,16
8001762a:	fe 99 ff df 	brgt	800175e8 <_vfprintf_r+0x1aac>
8001762e:	04 09       	add	r9,r2
80017630:	2f f8       	sub	r8,-1
80017632:	87 0a       	st.w	r3[0x0],r10
80017634:	fb 49 06 90 	st.w	sp[1680],r9
80017638:	87 12       	st.w	r3[0x4],r2
8001763a:	fb 48 06 8c 	st.w	sp[1676],r8
8001763e:	58 78       	cp.w	r8,7
80017640:	e0 89 00 04 	brgt	80017648 <_vfprintf_r+0x1b0c>
80017644:	2f 83       	sub	r3,-8
80017646:	c0 b8       	rjmp	8001765c <_vfprintf_r+0x1b20>
80017648:	fa ca f9 78 	sub	r10,sp,-1672
8001764c:	02 9b       	mov	r11,r1
8001764e:	08 9c       	mov	r12,r4
80017650:	fe b0 f2 68 	rcall	80015b20 <__sprint_r>
80017654:	e0 81 01 ff 	brne	80017a52 <_vfprintf_r+0x1f16>
80017658:	fa c3 f9 e0 	sub	r3,sp,-1568
8001765c:	40 6c       	lddsp	r12,sp[0x18]
8001765e:	fa f8 06 90 	ld.w	r8,sp[1680]
80017662:	87 06       	st.w	r3[0x0],r6
80017664:	87 1c       	st.w	r3[0x4],r12
80017666:	18 08       	add	r8,r12
80017668:	cb c8       	rjmp	800177e0 <_vfprintf_r+0x1ca4>
8001766a:	d7 03       	nop
8001766c:	80 02       	ld.sh	r2,r0[0x0]
8001766e:	03 10       	ld.sh	r0,r1++
80017670:	80 02       	ld.sh	r2,r0[0x0]
80017672:	02 fc       	st.b	--r1,r12
80017674:	fa f9 06 90 	ld.w	r9,sp[1680]
80017678:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001767c:	40 6b       	lddsp	r11,sp[0x18]
8001767e:	16 3a       	cp.w	r10,r11
80017680:	c6 d5       	brlt	8001775a <_vfprintf_r+0x1c1e>
80017682:	16 09       	add	r9,r11
80017684:	2f f8       	sub	r8,-1
80017686:	87 06       	st.w	r3[0x0],r6
80017688:	fb 49 06 90 	st.w	sp[1680],r9
8001768c:	87 1b       	st.w	r3[0x4],r11
8001768e:	fb 48 06 8c 	st.w	sp[1676],r8
80017692:	58 78       	cp.w	r8,7
80017694:	e0 89 00 04 	brgt	8001769c <_vfprintf_r+0x1b60>
80017698:	2f 83       	sub	r3,-8
8001769a:	c0 b8       	rjmp	800176b0 <_vfprintf_r+0x1b74>
8001769c:	fa ca f9 78 	sub	r10,sp,-1672
800176a0:	02 9b       	mov	r11,r1
800176a2:	08 9c       	mov	r12,r4
800176a4:	fe b0 f2 3e 	rcall	80015b20 <__sprint_r>
800176a8:	e0 81 01 d5 	brne	80017a52 <_vfprintf_r+0x1f16>
800176ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800176b0:	fa f6 06 ac 	ld.w	r6,sp[1708]
800176b4:	40 6a       	lddsp	r10,sp[0x18]
800176b6:	14 16       	sub	r6,r10
800176b8:	58 06       	cp.w	r6,0
800176ba:	e0 89 00 1c 	brgt	800176f2 <_vfprintf_r+0x1bb6>
800176be:	c3 b8       	rjmp	80017734 <_vfprintf_r+0x1bf8>
800176c0:	2f 09       	sub	r9,-16
800176c2:	2f f8       	sub	r8,-1
800176c4:	fb 49 06 90 	st.w	sp[1680],r9
800176c8:	87 02       	st.w	r3[0x0],r2
800176ca:	87 10       	st.w	r3[0x4],r0
800176cc:	fb 48 06 8c 	st.w	sp[1676],r8
800176d0:	58 78       	cp.w	r8,7
800176d2:	e0 89 00 04 	brgt	800176da <_vfprintf_r+0x1b9e>
800176d6:	2f 83       	sub	r3,-8
800176d8:	c0 b8       	rjmp	800176ee <_vfprintf_r+0x1bb2>
800176da:	fa ca f9 78 	sub	r10,sp,-1672
800176de:	02 9b       	mov	r11,r1
800176e0:	08 9c       	mov	r12,r4
800176e2:	fe b0 f2 1f 	rcall	80015b20 <__sprint_r>
800176e6:	e0 81 01 b6 	brne	80017a52 <_vfprintf_r+0x1f16>
800176ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800176ee:	21 06       	sub	r6,16
800176f0:	c0 38       	rjmp	800176f6 <_vfprintf_r+0x1bba>
800176f2:	4d c2       	lddpc	r2,80017860 <_vfprintf_r+0x1d24>
800176f4:	31 00       	mov	r0,16
800176f6:	fa f9 06 90 	ld.w	r9,sp[1680]
800176fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800176fe:	4d 9a       	lddpc	r10,80017860 <_vfprintf_r+0x1d24>
80017700:	59 06       	cp.w	r6,16
80017702:	fe 99 ff df 	brgt	800176c0 <_vfprintf_r+0x1b84>
80017706:	0c 09       	add	r9,r6
80017708:	2f f8       	sub	r8,-1
8001770a:	87 0a       	st.w	r3[0x0],r10
8001770c:	fb 49 06 90 	st.w	sp[1680],r9
80017710:	87 16       	st.w	r3[0x4],r6
80017712:	fb 48 06 8c 	st.w	sp[1676],r8
80017716:	58 78       	cp.w	r8,7
80017718:	e0 89 00 04 	brgt	80017720 <_vfprintf_r+0x1be4>
8001771c:	2f 83       	sub	r3,-8
8001771e:	c0 b8       	rjmp	80017734 <_vfprintf_r+0x1bf8>
80017720:	fa ca f9 78 	sub	r10,sp,-1672
80017724:	02 9b       	mov	r11,r1
80017726:	08 9c       	mov	r12,r4
80017728:	fe b0 f1 fc 	rcall	80015b20 <__sprint_r>
8001772c:	e0 81 01 93 	brne	80017a52 <_vfprintf_r+0x1f16>
80017730:	fa c3 f9 e0 	sub	r3,sp,-1568
80017734:	ed b5 00 00 	bld	r5,0x0
80017738:	e0 81 01 20 	brne	80017978 <_vfprintf_r+0x1e3c>
8001773c:	40 c9       	lddsp	r9,sp[0x30]
8001773e:	fa f8 06 90 	ld.w	r8,sp[1680]
80017742:	2f f8       	sub	r8,-1
80017744:	87 09       	st.w	r3[0x0],r9
80017746:	fb 48 06 90 	st.w	sp[1680],r8
8001774a:	30 19       	mov	r9,1
8001774c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017750:	87 19       	st.w	r3[0x4],r9
80017752:	2f f8       	sub	r8,-1
80017754:	fb 48 06 8c 	st.w	sp[1676],r8
80017758:	c0 29       	rjmp	8001795c <_vfprintf_r+0x1e20>
8001775a:	14 09       	add	r9,r10
8001775c:	2f f8       	sub	r8,-1
8001775e:	fb 49 06 90 	st.w	sp[1680],r9
80017762:	87 06       	st.w	r3[0x0],r6
80017764:	87 1a       	st.w	r3[0x4],r10
80017766:	fb 48 06 8c 	st.w	sp[1676],r8
8001776a:	58 78       	cp.w	r8,7
8001776c:	e0 89 00 04 	brgt	80017774 <_vfprintf_r+0x1c38>
80017770:	2f 83       	sub	r3,-8
80017772:	c0 b8       	rjmp	80017788 <_vfprintf_r+0x1c4c>
80017774:	fa ca f9 78 	sub	r10,sp,-1672
80017778:	02 9b       	mov	r11,r1
8001777a:	08 9c       	mov	r12,r4
8001777c:	fe b0 f1 d2 	rcall	80015b20 <__sprint_r>
80017780:	e0 81 01 69 	brne	80017a52 <_vfprintf_r+0x1f16>
80017784:	fa c3 f9 e0 	sub	r3,sp,-1568
80017788:	40 c8       	lddsp	r8,sp[0x30]
8001778a:	87 08       	st.w	r3[0x0],r8
8001778c:	fa f8 06 90 	ld.w	r8,sp[1680]
80017790:	2f f8       	sub	r8,-1
80017792:	30 19       	mov	r9,1
80017794:	fb 48 06 90 	st.w	sp[1680],r8
80017798:	87 19       	st.w	r3[0x4],r9
8001779a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001779e:	2f f8       	sub	r8,-1
800177a0:	fb 48 06 8c 	st.w	sp[1676],r8
800177a4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800177a8:	58 78       	cp.w	r8,7
800177aa:	e0 89 00 04 	brgt	800177b2 <_vfprintf_r+0x1c76>
800177ae:	2f 83       	sub	r3,-8
800177b0:	c0 b8       	rjmp	800177c6 <_vfprintf_r+0x1c8a>
800177b2:	fa ca f9 78 	sub	r10,sp,-1672
800177b6:	02 9b       	mov	r11,r1
800177b8:	08 9c       	mov	r12,r4
800177ba:	fe b0 f1 b3 	rcall	80015b20 <__sprint_r>
800177be:	e0 81 01 4a 	brne	80017a52 <_vfprintf_r+0x1f16>
800177c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800177c6:	04 06       	add	r6,r2
800177c8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800177cc:	87 06       	st.w	r3[0x0],r6
800177ce:	fa f9 06 90 	ld.w	r9,sp[1680]
800177d2:	40 66       	lddsp	r6,sp[0x18]
800177d4:	40 6e       	lddsp	lr,sp[0x18]
800177d6:	10 16       	sub	r6,r8
800177d8:	f2 08 01 08 	sub	r8,r9,r8
800177dc:	87 16       	st.w	r3[0x4],r6
800177de:	1c 08       	add	r8,lr
800177e0:	fb 48 06 90 	st.w	sp[1680],r8
800177e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800177e8:	2f f8       	sub	r8,-1
800177ea:	fb 48 06 8c 	st.w	sp[1676],r8
800177ee:	cb 78       	rjmp	8001795c <_vfprintf_r+0x1e20>
800177f0:	40 6c       	lddsp	r12,sp[0x18]
800177f2:	58 1c       	cp.w	r12,1
800177f4:	e0 89 00 06 	brgt	80017800 <_vfprintf_r+0x1cc4>
800177f8:	ed b5 00 00 	bld	r5,0x0
800177fc:	e0 81 00 85 	brne	80017906 <_vfprintf_r+0x1dca>
80017800:	fa f8 06 90 	ld.w	r8,sp[1680]
80017804:	2f f8       	sub	r8,-1
80017806:	30 19       	mov	r9,1
80017808:	fb 48 06 90 	st.w	sp[1680],r8
8001780c:	87 06       	st.w	r3[0x0],r6
8001780e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017812:	87 19       	st.w	r3[0x4],r9
80017814:	2f f8       	sub	r8,-1
80017816:	fb 48 06 8c 	st.w	sp[1676],r8
8001781a:	58 78       	cp.w	r8,7
8001781c:	e0 89 00 04 	brgt	80017824 <_vfprintf_r+0x1ce8>
80017820:	2f 83       	sub	r3,-8
80017822:	c0 b8       	rjmp	80017838 <_vfprintf_r+0x1cfc>
80017824:	fa ca f9 78 	sub	r10,sp,-1672
80017828:	02 9b       	mov	r11,r1
8001782a:	08 9c       	mov	r12,r4
8001782c:	fe b0 f1 7a 	rcall	80015b20 <__sprint_r>
80017830:	e0 81 01 11 	brne	80017a52 <_vfprintf_r+0x1f16>
80017834:	fa c3 f9 e0 	sub	r3,sp,-1568
80017838:	fa f8 06 90 	ld.w	r8,sp[1680]
8001783c:	2f f8       	sub	r8,-1
8001783e:	40 cb       	lddsp	r11,sp[0x30]
80017840:	fb 48 06 90 	st.w	sp[1680],r8
80017844:	30 19       	mov	r9,1
80017846:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001784a:	87 0b       	st.w	r3[0x0],r11
8001784c:	2f f8       	sub	r8,-1
8001784e:	87 19       	st.w	r3[0x4],r9
80017850:	fb 48 06 8c 	st.w	sp[1676],r8
80017854:	58 78       	cp.w	r8,7
80017856:	e0 89 00 07 	brgt	80017864 <_vfprintf_r+0x1d28>
8001785a:	2f 83       	sub	r3,-8
8001785c:	c0 e8       	rjmp	80017878 <_vfprintf_r+0x1d3c>
8001785e:	d7 03       	nop
80017860:	80 02       	ld.sh	r2,r0[0x0]
80017862:	03 10       	ld.sh	r0,r1++
80017864:	fa ca f9 78 	sub	r10,sp,-1672
80017868:	02 9b       	mov	r11,r1
8001786a:	08 9c       	mov	r12,r4
8001786c:	fe b0 f1 5a 	rcall	80015b20 <__sprint_r>
80017870:	e0 81 00 f1 	brne	80017a52 <_vfprintf_r+0x1f16>
80017874:	fa c3 f9 e0 	sub	r3,sp,-1568
80017878:	30 08       	mov	r8,0
8001787a:	30 09       	mov	r9,0
8001787c:	40 5b       	lddsp	r11,sp[0x14]
8001787e:	40 7a       	lddsp	r10,sp[0x1c]
80017880:	e0 a0 2c f0 	rcall	8001d260 <__avr32_f64_cmp_eq>
80017884:	40 68       	lddsp	r8,sp[0x18]
80017886:	20 18       	sub	r8,1
80017888:	58 0c       	cp.w	r12,0
8001788a:	c0 d1       	brne	800178a4 <_vfprintf_r+0x1d68>
8001788c:	2f f6       	sub	r6,-1
8001788e:	87 18       	st.w	r3[0x4],r8
80017890:	87 06       	st.w	r3[0x0],r6
80017892:	fa f6 06 90 	ld.w	r6,sp[1680]
80017896:	10 06       	add	r6,r8
80017898:	fa f8 06 8c 	ld.w	r8,sp[1676]
8001789c:	fb 46 06 90 	st.w	sp[1680],r6
800178a0:	2f f8       	sub	r8,-1
800178a2:	c2 f8       	rjmp	80017900 <_vfprintf_r+0x1dc4>
800178a4:	10 96       	mov	r6,r8
800178a6:	58 08       	cp.w	r8,0
800178a8:	e0 89 00 1c 	brgt	800178e0 <_vfprintf_r+0x1da4>
800178ac:	c4 98       	rjmp	8001793e <_vfprintf_r+0x1e02>
800178ae:	2f 09       	sub	r9,-16
800178b0:	2f f8       	sub	r8,-1
800178b2:	fb 49 06 90 	st.w	sp[1680],r9
800178b6:	87 02       	st.w	r3[0x0],r2
800178b8:	87 10       	st.w	r3[0x4],r0
800178ba:	fb 48 06 8c 	st.w	sp[1676],r8
800178be:	58 78       	cp.w	r8,7
800178c0:	e0 89 00 04 	brgt	800178c8 <_vfprintf_r+0x1d8c>
800178c4:	2f 83       	sub	r3,-8
800178c6:	c0 b8       	rjmp	800178dc <_vfprintf_r+0x1da0>
800178c8:	fa ca f9 78 	sub	r10,sp,-1672
800178cc:	02 9b       	mov	r11,r1
800178ce:	08 9c       	mov	r12,r4
800178d0:	fe b0 f1 28 	rcall	80015b20 <__sprint_r>
800178d4:	e0 81 00 bf 	brne	80017a52 <_vfprintf_r+0x1f16>
800178d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800178dc:	21 06       	sub	r6,16
800178de:	c0 38       	rjmp	800178e4 <_vfprintf_r+0x1da8>
800178e0:	4d 22       	lddpc	r2,80017a28 <_vfprintf_r+0x1eec>
800178e2:	31 00       	mov	r0,16
800178e4:	fa f9 06 90 	ld.w	r9,sp[1680]
800178e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800178ec:	4c fa       	lddpc	r10,80017a28 <_vfprintf_r+0x1eec>
800178ee:	59 06       	cp.w	r6,16
800178f0:	fe 99 ff df 	brgt	800178ae <_vfprintf_r+0x1d72>
800178f4:	0c 09       	add	r9,r6
800178f6:	87 0a       	st.w	r3[0x0],r10
800178f8:	fb 49 06 90 	st.w	sp[1680],r9
800178fc:	2f f8       	sub	r8,-1
800178fe:	87 16       	st.w	r3[0x4],r6
80017900:	fb 48 06 8c 	st.w	sp[1676],r8
80017904:	c0 e8       	rjmp	80017920 <_vfprintf_r+0x1de4>
80017906:	fa f8 06 90 	ld.w	r8,sp[1680]
8001790a:	2f f8       	sub	r8,-1
8001790c:	30 19       	mov	r9,1
8001790e:	fb 48 06 90 	st.w	sp[1680],r8
80017912:	87 06       	st.w	r3[0x0],r6
80017914:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017918:	87 19       	st.w	r3[0x4],r9
8001791a:	2f f8       	sub	r8,-1
8001791c:	fb 48 06 8c 	st.w	sp[1676],r8
80017920:	58 78       	cp.w	r8,7
80017922:	e0 89 00 04 	brgt	8001792a <_vfprintf_r+0x1dee>
80017926:	2f 83       	sub	r3,-8
80017928:	c0 b8       	rjmp	8001793e <_vfprintf_r+0x1e02>
8001792a:	fa ca f9 78 	sub	r10,sp,-1672
8001792e:	02 9b       	mov	r11,r1
80017930:	08 9c       	mov	r12,r4
80017932:	fe b0 f0 f7 	rcall	80015b20 <__sprint_r>
80017936:	e0 81 00 8e 	brne	80017a52 <_vfprintf_r+0x1f16>
8001793a:	fa c3 f9 e0 	sub	r3,sp,-1568
8001793e:	40 ea       	lddsp	r10,sp[0x38]
80017940:	fa f8 06 90 	ld.w	r8,sp[1680]
80017944:	14 08       	add	r8,r10
80017946:	fa c9 f9 64 	sub	r9,sp,-1692
8001794a:	fb 48 06 90 	st.w	sp[1680],r8
8001794e:	87 1a       	st.w	r3[0x4],r10
80017950:	fa f8 06 8c 	ld.w	r8,sp[1676]
80017954:	87 09       	st.w	r3[0x0],r9
80017956:	2f f8       	sub	r8,-1
80017958:	fb 48 06 8c 	st.w	sp[1676],r8
8001795c:	58 78       	cp.w	r8,7
8001795e:	e0 89 00 04 	brgt	80017966 <_vfprintf_r+0x1e2a>
80017962:	2f 83       	sub	r3,-8
80017964:	c0 a8       	rjmp	80017978 <_vfprintf_r+0x1e3c>
80017966:	fa ca f9 78 	sub	r10,sp,-1672
8001796a:	02 9b       	mov	r11,r1
8001796c:	08 9c       	mov	r12,r4
8001796e:	fe b0 f0 d9 	rcall	80015b20 <__sprint_r>
80017972:	c7 01       	brne	80017a52 <_vfprintf_r+0x1f16>
80017974:	fa c3 f9 e0 	sub	r3,sp,-1568
80017978:	e2 15 00 04 	andl	r5,0x4,COH
8001797c:	c3 d0       	breq	800179f6 <_vfprintf_r+0x1eba>
8001797e:	40 86       	lddsp	r6,sp[0x20]
80017980:	40 39       	lddsp	r9,sp[0xc]
80017982:	12 16       	sub	r6,r9
80017984:	58 06       	cp.w	r6,0
80017986:	e0 89 00 1a 	brgt	800179ba <_vfprintf_r+0x1e7e>
8001798a:	c3 68       	rjmp	800179f6 <_vfprintf_r+0x1eba>
8001798c:	2f 09       	sub	r9,-16
8001798e:	2f f8       	sub	r8,-1
80017990:	fb 49 06 90 	st.w	sp[1680],r9
80017994:	87 05       	st.w	r3[0x0],r5
80017996:	87 12       	st.w	r3[0x4],r2
80017998:	fb 48 06 8c 	st.w	sp[1676],r8
8001799c:	58 78       	cp.w	r8,7
8001799e:	e0 89 00 04 	brgt	800179a6 <_vfprintf_r+0x1e6a>
800179a2:	2f 83       	sub	r3,-8
800179a4:	c0 98       	rjmp	800179b6 <_vfprintf_r+0x1e7a>
800179a6:	00 9a       	mov	r10,r0
800179a8:	02 9b       	mov	r11,r1
800179aa:	08 9c       	mov	r12,r4
800179ac:	fe b0 f0 ba 	rcall	80015b20 <__sprint_r>
800179b0:	c5 11       	brne	80017a52 <_vfprintf_r+0x1f16>
800179b2:	fa c3 f9 e0 	sub	r3,sp,-1568
800179b6:	21 06       	sub	r6,16
800179b8:	c0 58       	rjmp	800179c2 <_vfprintf_r+0x1e86>
800179ba:	49 d5       	lddpc	r5,80017a2c <_vfprintf_r+0x1ef0>
800179bc:	31 02       	mov	r2,16
800179be:	fa c0 f9 78 	sub	r0,sp,-1672
800179c2:	fa f9 06 90 	ld.w	r9,sp[1680]
800179c6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800179ca:	49 9a       	lddpc	r10,80017a2c <_vfprintf_r+0x1ef0>
800179cc:	59 06       	cp.w	r6,16
800179ce:	fe 99 ff df 	brgt	8001798c <_vfprintf_r+0x1e50>
800179d2:	0c 09       	add	r9,r6
800179d4:	2f f8       	sub	r8,-1
800179d6:	87 0a       	st.w	r3[0x0],r10
800179d8:	87 16       	st.w	r3[0x4],r6
800179da:	fb 49 06 90 	st.w	sp[1680],r9
800179de:	fb 48 06 8c 	st.w	sp[1676],r8
800179e2:	58 78       	cp.w	r8,7
800179e4:	e0 8a 00 09 	brle	800179f6 <_vfprintf_r+0x1eba>
800179e8:	fa ca f9 78 	sub	r10,sp,-1672
800179ec:	02 9b       	mov	r11,r1
800179ee:	08 9c       	mov	r12,r4
800179f0:	fe b0 f0 98 	rcall	80015b20 <__sprint_r>
800179f4:	c2 f1       	brne	80017a52 <_vfprintf_r+0x1f16>
800179f6:	40 bc       	lddsp	r12,sp[0x2c]
800179f8:	40 36       	lddsp	r6,sp[0xc]
800179fa:	40 8e       	lddsp	lr,sp[0x20]
800179fc:	ec 0e 0c 48 	max	r8,r6,lr
80017a00:	10 0c       	add	r12,r8
80017a02:	50 bc       	stdsp	sp[0x2c],r12
80017a04:	fa f8 06 90 	ld.w	r8,sp[1680]
80017a08:	58 08       	cp.w	r8,0
80017a0a:	c0 80       	breq	80017a1a <_vfprintf_r+0x1ede>
80017a0c:	fa ca f9 78 	sub	r10,sp,-1672
80017a10:	02 9b       	mov	r11,r1
80017a12:	08 9c       	mov	r12,r4
80017a14:	fe b0 f0 86 	rcall	80015b20 <__sprint_r>
80017a18:	c1 d1       	brne	80017a52 <_vfprintf_r+0x1f16>
80017a1a:	30 0b       	mov	r11,0
80017a1c:	fa c3 f9 e0 	sub	r3,sp,-1568
80017a20:	fb 4b 06 8c 	st.w	sp[1676],r11
80017a24:	fe 9f f1 17 	bral	80015c52 <_vfprintf_r+0x116>
80017a28:	80 02       	ld.sh	r2,r0[0x0]
80017a2a:	03 10       	ld.sh	r0,r1++
80017a2c:	80 02       	ld.sh	r2,r0[0x0]
80017a2e:	03 00       	ld.w	r0,r1++
80017a30:	08 95       	mov	r5,r4
80017a32:	fa f8 06 90 	ld.w	r8,sp[1680]
80017a36:	58 08       	cp.w	r8,0
80017a38:	c0 80       	breq	80017a48 <_vfprintf_r+0x1f0c>
80017a3a:	08 9c       	mov	r12,r4
80017a3c:	fa ca f9 78 	sub	r10,sp,-1672
80017a40:	02 9b       	mov	r11,r1
80017a42:	fe b0 f0 6f 	rcall	80015b20 <__sprint_r>
80017a46:	c0 61       	brne	80017a52 <_vfprintf_r+0x1f16>
80017a48:	30 08       	mov	r8,0
80017a4a:	fb 48 06 8c 	st.w	sp[1676],r8
80017a4e:	c0 28       	rjmp	80017a52 <_vfprintf_r+0x1f16>
80017a50:	40 41       	lddsp	r1,sp[0x10]
80017a52:	82 68       	ld.sh	r8,r1[0xc]
80017a54:	ed b8 00 06 	bld	r8,0x6
80017a58:	c0 31       	brne	80017a5e <_vfprintf_r+0x1f22>
80017a5a:	3f fa       	mov	r10,-1
80017a5c:	50 ba       	stdsp	sp[0x2c],r10
80017a5e:	40 bc       	lddsp	r12,sp[0x2c]
80017a60:	fe 3d f9 44 	sub	sp,-1724
80017a64:	d8 32       	popm	r0-r7,pc
80017a66:	d7 03       	nop

80017a68 <__svfscanf_r>:
80017a68:	d4 31       	pushm	r0-r7,lr
80017a6a:	fa cd 03 2c 	sub	sp,sp,812
80017a6e:	30 07       	mov	r7,0
80017a70:	50 4c       	stdsp	sp[0x10],r12
80017a72:	16 95       	mov	r5,r11
80017a74:	12 96       	mov	r6,r9
80017a76:	50 9a       	stdsp	sp[0x24],r10
80017a78:	50 a7       	stdsp	sp[0x28],r7
80017a7a:	50 87       	stdsp	sp[0x20],r7
80017a7c:	0e 93       	mov	r3,r7
80017a7e:	50 37       	stdsp	sp[0xc],r7
80017a80:	50 77       	stdsp	sp[0x1c],r7
80017a82:	c0 28       	rjmp	80017a86 <__svfscanf_r+0x1e>
80017a84:	50 34       	stdsp	sp[0xc],r4
80017a86:	40 9b       	lddsp	r11,sp[0x24]
80017a88:	17 89       	ld.ub	r9,r11[0x0]
80017a8a:	fb 49 03 28 	st.w	sp[808],r9
80017a8e:	58 09       	cp.w	r9,0
80017a90:	e0 80 0a 5f 	breq	80018f4e <__svfscanf_r+0x14e6>
80017a94:	2f fb       	sub	r11,-1
80017a96:	50 9b       	stdsp	sp[0x24],r11
80017a98:	32 ca       	mov	r10,44
80017a9a:	74 01       	ld.w	r1,r10[0x0]
80017a9c:	e2 09 07 08 	ld.ub	r8,r1[r9]
80017aa0:	e2 18 00 08 	andl	r8,0x8,COH
80017aa4:	c1 c0       	breq	80017adc <__svfscanf_r+0x74>
80017aa6:	40 34       	lddsp	r4,sp[0xc]
80017aa8:	6a 18       	ld.w	r8,r5[0x4]
80017aaa:	58 08       	cp.w	r8,0
80017aac:	e0 89 00 07 	brgt	80017aba <__svfscanf_r+0x52>
80017ab0:	0a 9b       	mov	r11,r5
80017ab2:	40 4c       	lddsp	r12,sp[0x10]
80017ab4:	e0 a0 1b a6 	rcall	8001b200 <__srefill_r>
80017ab8:	ce 61       	brne	80017a84 <__svfscanf_r+0x1c>
80017aba:	6a 08       	ld.w	r8,r5[0x0]
80017abc:	32 cb       	mov	r11,44
80017abe:	f0 c9 ff ff 	sub	r9,r8,-1
80017ac2:	76 0a       	ld.w	r10,r11[0x0]
80017ac4:	11 88       	ld.ub	r8,r8[0x0]
80017ac6:	f4 08 07 08 	ld.ub	r8,r10[r8]
80017aca:	ed b8 00 03 	bld	r8,0x3
80017ace:	cd b1       	brne	80017a84 <__svfscanf_r+0x1c>
80017ad0:	6a 18       	ld.w	r8,r5[0x4]
80017ad2:	8b 09       	st.w	r5[0x0],r9
80017ad4:	20 18       	sub	r8,1
80017ad6:	2f f4       	sub	r4,-1
80017ad8:	8b 18       	st.w	r5[0x4],r8
80017ada:	ce 7b       	rjmp	80017aa8 <__svfscanf_r+0x40>
80017adc:	e0 49 00 25 	cp.w	r9,37
80017ae0:	e0 81 00 8a 	brne	80017bf4 <__svfscanf_r+0x18c>
80017ae4:	50 68       	stdsp	sp[0x18],r8
80017ae6:	06 94       	mov	r4,r3
80017ae8:	10 90       	mov	r0,r8
80017aea:	10 92       	mov	r2,r8
80017aec:	36 8a       	mov	r10,104
80017aee:	36 c9       	mov	r9,108
80017af0:	34 5c       	mov	r12,69
80017af2:	34 fe       	mov	lr,79
80017af4:	40 9b       	lddsp	r11,sp[0x24]
80017af6:	17 38       	ld.ub	r8,r11++
80017af8:	50 9b       	stdsp	sp[0x24],r11
80017afa:	36 4b       	mov	r11,100
80017afc:	f6 08 18 00 	cp.b	r8,r11
80017b00:	e0 80 00 c2 	breq	80017c84 <__svfscanf_r+0x21c>
80017b04:	e0 8b 00 48 	brhi	80017b94 <__svfscanf_r+0x12c>
80017b08:	f8 08 18 00 	cp.b	r8,r12
80017b0c:	c7 20       	breq	80017bf0 <__svfscanf_r+0x188>
80017b0e:	e0 8b 00 27 	brhi	80017b5c <__svfscanf_r+0xf4>
80017b12:	33 9b       	mov	r11,57
80017b14:	f6 08 18 00 	cp.b	r8,r11
80017b18:	e0 8b 00 1c 	brhi	80017b50 <__svfscanf_r+0xe8>
80017b1c:	33 0b       	mov	r11,48
80017b1e:	f6 08 18 00 	cp.b	r8,r11
80017b22:	e0 82 00 9b 	brhs	80017c58 <__svfscanf_r+0x1f0>
80017b26:	32 5b       	mov	r11,37
80017b28:	f6 08 18 00 	cp.b	r8,r11
80017b2c:	c6 40       	breq	80017bf4 <__svfscanf_r+0x18c>
80017b2e:	e0 8b 00 0b 	brhi	80017b44 <__svfscanf_r+0xdc>
80017b32:	58 08       	cp.w	r8,0
80017b34:	e0 80 0a 0b 	breq	80018f4a <__svfscanf_r+0x14e2>
80017b38:	32 4b       	mov	r11,36
80017b3a:	f6 08 18 00 	cp.b	r8,r11
80017b3e:	e0 81 01 f5 	brne	80017f28 <__svfscanf_r+0x4c0>
80017b42:	c9 18       	rjmp	80017c64 <__svfscanf_r+0x1fc>
80017b44:	32 ab       	mov	r11,42
80017b46:	f6 08 18 00 	cp.b	r8,r11
80017b4a:	e0 81 01 ef 	brne	80017f28 <__svfscanf_r+0x4c0>
80017b4e:	c6 f8       	rjmp	80017c2c <__svfscanf_r+0x1c4>
80017b50:	34 49       	mov	r9,68
80017b52:	f2 08 18 00 	cp.b	r8,r9
80017b56:	e0 81 01 e9 	brne	80017f28 <__svfscanf_r+0x4c0>
80017b5a:	c9 48       	rjmp	80017c82 <__svfscanf_r+0x21a>
80017b5c:	fc 08 18 00 	cp.b	r8,lr
80017b60:	e0 80 00 9c 	breq	80017c98 <__svfscanf_r+0x230>
80017b64:	e0 8b 00 0c 	brhi	80017b7c <__svfscanf_r+0x114>
80017b68:	34 7b       	mov	r11,71
80017b6a:	f6 08 18 00 	cp.b	r8,r11
80017b6e:	c4 10       	breq	80017bf0 <__svfscanf_r+0x188>
80017b70:	34 cb       	mov	r11,76
80017b72:	f6 08 18 00 	cp.b	r8,r11
80017b76:	e0 81 01 d9 	brne	80017f28 <__svfscanf_r+0x4c0>
80017b7a:	c6 b8       	rjmp	80017c50 <__svfscanf_r+0x1e8>
80017b7c:	35 b9       	mov	r9,91
80017b7e:	f2 08 18 00 	cp.b	r8,r9
80017b82:	e0 80 00 9f 	breq	80017cc0 <__svfscanf_r+0x258>
80017b86:	36 39       	mov	r9,99
80017b88:	f2 08 18 00 	cp.b	r8,r9
80017b8c:	e0 80 00 a3 	breq	80017cd2 <__svfscanf_r+0x26a>
80017b90:	35 89       	mov	r9,88
80017b92:	c2 a8       	rjmp	80017be6 <__svfscanf_r+0x17e>
80017b94:	36 eb       	mov	r11,110
80017b96:	f6 08 18 00 	cp.b	r8,r11
80017b9a:	e0 80 00 a7 	breq	80017ce8 <__svfscanf_r+0x280>
80017b9e:	e0 8b 00 0f 	brhi	80017bbc <__svfscanf_r+0x154>
80017ba2:	f4 08 18 00 	cp.b	r8,r10
80017ba6:	c5 70       	breq	80017c54 <__svfscanf_r+0x1ec>
80017ba8:	c2 43       	brcs	80017bf0 <__svfscanf_r+0x188>
80017baa:	36 9b       	mov	r11,105
80017bac:	f6 08 18 00 	cp.b	r8,r11
80017bb0:	c6 f0       	breq	80017c8e <__svfscanf_r+0x226>
80017bb2:	f2 08 18 00 	cp.b	r8,r9
80017bb6:	e0 81 01 b9 	brne	80017f28 <__svfscanf_r+0x4c0>
80017bba:	c3 b8       	rjmp	80017c30 <__svfscanf_r+0x1c8>
80017bbc:	37 39       	mov	r9,115
80017bbe:	f2 08 18 00 	cp.b	r8,r9
80017bc2:	c7 d0       	breq	80017cbc <__svfscanf_r+0x254>
80017bc4:	e0 8b 00 0c 	brhi	80017bdc <__svfscanf_r+0x174>
80017bc8:	36 f9       	mov	r9,111
80017bca:	f2 08 18 00 	cp.b	r8,r9
80017bce:	c6 60       	breq	80017c9a <__svfscanf_r+0x232>
80017bd0:	37 09       	mov	r9,112
80017bd2:	f2 08 18 00 	cp.b	r8,r9
80017bd6:	e0 81 01 a9 	brne	80017f28 <__svfscanf_r+0x4c0>
80017bda:	c7 f8       	rjmp	80017cd8 <__svfscanf_r+0x270>
80017bdc:	37 59       	mov	r9,117
80017bde:	f2 08 18 00 	cp.b	r8,r9
80017be2:	c6 20       	breq	80017ca6 <__svfscanf_r+0x23e>
80017be4:	37 89       	mov	r9,120
80017be6:	f2 08 18 00 	cp.b	r8,r9
80017bea:	e0 81 01 9f 	brne	80017f28 <__svfscanf_r+0x4c0>
80017bee:	c6 18       	rjmp	80017cb0 <__svfscanf_r+0x248>
80017bf0:	30 41       	mov	r1,4
80017bf2:	ca 69       	rjmp	80017f3e <__svfscanf_r+0x4d6>
80017bf4:	6a 18       	ld.w	r8,r5[0x4]
80017bf6:	58 08       	cp.w	r8,0
80017bf8:	e0 89 00 08 	brgt	80017c08 <__svfscanf_r+0x1a0>
80017bfc:	0a 9b       	mov	r11,r5
80017bfe:	40 4c       	lddsp	r12,sp[0x10]
80017c00:	e0 a0 1b 00 	rcall	8001b200 <__srefill_r>
80017c04:	e0 81 09 9c 	brne	80018f3c <__svfscanf_r+0x14d4>
80017c08:	40 9a       	lddsp	r10,sp[0x24]
80017c0a:	6a 08       	ld.w	r8,r5[0x0]
80017c0c:	f5 39 ff ff 	ld.ub	r9,r10[-1]
80017c10:	11 8a       	ld.ub	r10,r8[0x0]
80017c12:	f2 0a 18 00 	cp.b	r10,r9
80017c16:	e0 81 09 9c 	brne	80018f4e <__svfscanf_r+0x14e6>
80017c1a:	2f f8       	sub	r8,-1
80017c1c:	40 39       	lddsp	r9,sp[0xc]
80017c1e:	8b 08       	st.w	r5[0x0],r8
80017c20:	2f f9       	sub	r9,-1
80017c22:	6a 18       	ld.w	r8,r5[0x4]
80017c24:	50 39       	stdsp	sp[0xc],r9
80017c26:	20 18       	sub	r8,1
80017c28:	8b 18       	st.w	r5[0x4],r8
80017c2a:	c2 eb       	rjmp	80017a86 <__svfscanf_r+0x1e>
80017c2c:	a5 a0       	sbr	r0,0x4
80017c2e:	c6 3b       	rjmp	80017af4 <__svfscanf_r+0x8c>
80017c30:	00 98       	mov	r8,r0
80017c32:	a1 b0       	sbr	r0,0x1
80017c34:	40 9b       	lddsp	r11,sp[0x24]
80017c36:	a1 a8       	sbr	r8,0x0
80017c38:	17 8b       	ld.ub	r11,r11[0x0]
80017c3a:	f2 0b 18 00 	cp.b	r11,r9
80017c3e:	fb f8 00 09 	ld.weq	r8,sp[0x24]
80017c42:	f7 b8 00 ff 	subeq	r8,-1
80017c46:	fb f8 0a 09 	st.weq	sp[0x24],r8
80017c4a:	f0 00 17 10 	movne	r0,r8
80017c4e:	c5 3b       	rjmp	80017af4 <__svfscanf_r+0x8c>
80017c50:	a1 b0       	sbr	r0,0x1
80017c52:	c5 1b       	rjmp	80017af4 <__svfscanf_r+0x8c>
80017c54:	a3 a0       	sbr	r0,0x2
80017c56:	c4 fb       	rjmp	80017af4 <__svfscanf_r+0x8c>
80017c58:	e4 02 00 22 	add	r2,r2,r2<<0x2
80017c5c:	a1 72       	lsl	r2,0x1
80017c5e:	23 02       	sub	r2,48
80017c60:	10 02       	add	r2,r8
80017c62:	c4 9b       	rjmp	80017af4 <__svfscanf_r+0x8c>
80017c64:	e0 42 00 20 	cp.w	r2,32
80017c68:	e0 8b 00 08 	brhi	80017c78 <__svfscanf_r+0x210>
80017c6c:	e4 c4 00 01 	sub	r4,r2,1
80017c70:	30 1b       	mov	r11,1
80017c72:	30 02       	mov	r2,0
80017c74:	50 6b       	stdsp	sp[0x18],r11
80017c76:	c3 fb       	rjmp	80017af4 <__svfscanf_r+0x8c>
80017c78:	31 68       	mov	r8,22
80017c7a:	40 4a       	lddsp	r10,sp[0x10]
80017c7c:	95 38       	st.w	r10[0xc],r8
80017c7e:	e0 8f 09 5f 	bral	80018f3c <__svfscanf_r+0x14d4>
80017c82:	a1 a0       	sbr	r0,0x0
80017c84:	fe c9 bb b4 	sub	r9,pc,-17484
80017c88:	30 a8       	mov	r8,10
80017c8a:	50 a9       	stdsp	sp[0x28],r9
80017c8c:	c0 b8       	rjmp	80017ca2 <__svfscanf_r+0x23a>
80017c8e:	fe cb bb be 	sub	r11,pc,-17474
80017c92:	30 0a       	mov	r10,0
80017c94:	50 ab       	stdsp	sp[0x28],r11
80017c96:	c2 78       	rjmp	80017ce4 <__svfscanf_r+0x27c>
80017c98:	a1 a0       	sbr	r0,0x0
80017c9a:	fe c9 b8 fa 	sub	r9,pc,-18182
80017c9e:	30 88       	mov	r8,8
80017ca0:	50 a9       	stdsp	sp[0x28],r9
80017ca2:	50 88       	stdsp	sp[0x20],r8
80017ca4:	c4 c9       	rjmp	80017f3c <__svfscanf_r+0x4d4>
80017ca6:	fe cb b9 06 	sub	r11,pc,-18170
80017caa:	30 aa       	mov	r10,10
80017cac:	50 ab       	stdsp	sp[0x28],r11
80017cae:	c1 b8       	rjmp	80017ce4 <__svfscanf_r+0x27c>
80017cb0:	fe c9 b9 10 	sub	r9,pc,-18160
80017cb4:	a9 b0       	sbr	r0,0x9
80017cb6:	50 a9       	stdsp	sp[0x28],r9
80017cb8:	31 08       	mov	r8,16
80017cba:	cf 4b       	rjmp	80017ca2 <__svfscanf_r+0x23a>
80017cbc:	30 21       	mov	r1,2
80017cbe:	c4 09       	rjmp	80017f3e <__svfscanf_r+0x4d6>
80017cc0:	40 9b       	lddsp	r11,sp[0x24]
80017cc2:	fa cc fe 60 	sub	r12,sp,-416
80017cc6:	a7 a0       	sbr	r0,0x6
80017cc8:	e0 a0 1b 45 	rcall	8001b352 <__sccl>
80017ccc:	30 11       	mov	r1,1
80017cce:	50 9c       	stdsp	sp[0x24],r12
80017cd0:	c3 79       	rjmp	80017f3e <__svfscanf_r+0x4d6>
80017cd2:	a7 a0       	sbr	r0,0x6
80017cd4:	30 01       	mov	r1,0
80017cd6:	c3 49       	rjmp	80017f3e <__svfscanf_r+0x4d6>
80017cd8:	fe cb b9 38 	sub	r11,pc,-18120
80017cdc:	e8 10 02 20 	orl	r0,0x220
80017ce0:	50 ab       	stdsp	sp[0x28],r11
80017ce2:	31 0a       	mov	r10,16
80017ce4:	50 8a       	stdsp	sp[0x20],r10
80017ce6:	c2 b9       	rjmp	80017f3c <__svfscanf_r+0x4d4>
80017ce8:	ed b0 00 04 	bld	r0,0x4
80017cec:	fe 90 fe cd 	breq	80017a86 <__svfscanf_r+0x1e>
80017cf0:	ed b0 00 02 	bld	r0,0x2
80017cf4:	c4 61       	brne	80017d80 <__svfscanf_r+0x318>
80017cf6:	40 69       	lddsp	r9,sp[0x18]
80017cf8:	58 09       	cp.w	r9,0
80017cfa:	c2 50       	breq	80017d44 <__svfscanf_r+0x2dc>
80017cfc:	0e 34       	cp.w	r4,r7
80017cfe:	c0 64       	brge	80017d0a <__svfscanf_r+0x2a2>
80017d00:	fa c8 fc d4 	sub	r8,sp,-812
80017d04:	f0 04 00 24 	add	r4,r8,r4<<0x2
80017d08:	c2 78       	rjmp	80017d56 <__svfscanf_r+0x2ee>
80017d0a:	fa ca fd 60 	sub	r10,sp,-672
80017d0e:	0c 99       	mov	r9,r6
80017d10:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80017d14:	0e 98       	mov	r8,r7
80017d16:	13 0b       	ld.w	r11,r9++
80017d18:	14 ab       	st.w	r10++,r11
80017d1a:	2f f8       	sub	r8,-1
80017d1c:	10 34       	cp.w	r4,r8
80017d1e:	cf c4       	brge	80017d16 <__svfscanf_r+0x2ae>
80017d20:	ee c9 ff ff 	sub	r9,r7,-1
80017d24:	ee 08 11 ff 	rsub	r8,r7,-1
80017d28:	f0 c7 ff ff 	sub	r7,r8,-1
80017d2c:	2f e8       	sub	r8,-2
80017d2e:	08 08       	add	r8,r4
80017d30:	08 07       	add	r7,r4
80017d32:	ec 08 00 26 	add	r6,r6,r8<<0x2
80017d36:	f2 07 00 07 	add	r7,r9,r7
80017d3a:	fa c8 fd 60 	sub	r8,sp,-672
80017d3e:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80017d42:	c1 c8       	rjmp	80017d7a <__svfscanf_r+0x312>
80017d44:	e6 c8 ff ff 	sub	r8,r3,-1
80017d48:	0e 33       	cp.w	r3,r7
80017d4a:	c0 94       	brge	80017d5c <__svfscanf_r+0x2f4>
80017d4c:	fa cb fc d4 	sub	r11,sp,-812
80017d50:	10 93       	mov	r3,r8
80017d52:	f6 04 00 24 	add	r4,r11,r4<<0x2
80017d56:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80017d5a:	c1 08       	rjmp	80017d7a <__svfscanf_r+0x312>
80017d5c:	6c 04       	ld.w	r4,r6[0x0]
80017d5e:	2f c6       	sub	r6,-4
80017d60:	59 f7       	cp.w	r7,31
80017d62:	e0 89 00 0b 	brgt	80017d78 <__svfscanf_r+0x310>
80017d66:	10 93       	mov	r3,r8
80017d68:	fa ca fc d4 	sub	r10,sp,-812
80017d6c:	f4 07 00 28 	add	r8,r10,r7<<0x2
80017d70:	2f f7       	sub	r7,-1
80017d72:	f1 44 ff 74 	st.w	r8[-140],r4
80017d76:	c0 28       	rjmp	80017d7a <__svfscanf_r+0x312>
80017d78:	10 93       	mov	r3,r8
80017d7a:	40 39       	lddsp	r9,sp[0xc]
80017d7c:	a8 09       	st.h	r4[0x0],r9
80017d7e:	c8 4a       	rjmp	80017a86 <__svfscanf_r+0x1e>
80017d80:	ed b0 00 00 	bld	r0,0x0
80017d84:	c4 61       	brne	80017e10 <__svfscanf_r+0x3a8>
80017d86:	40 68       	lddsp	r8,sp[0x18]
80017d88:	58 08       	cp.w	r8,0
80017d8a:	c2 60       	breq	80017dd6 <__svfscanf_r+0x36e>
80017d8c:	0e 34       	cp.w	r4,r7
80017d8e:	c0 74       	brge	80017d9c <__svfscanf_r+0x334>
80017d90:	fa cb fc d4 	sub	r11,sp,-812
80017d94:	f6 04 00 24 	add	r4,r11,r4<<0x2
80017d98:	c2 88       	rjmp	80017de8 <__svfscanf_r+0x380>
80017d9a:	d7 03       	nop
80017d9c:	fa ca fd 60 	sub	r10,sp,-672
80017da0:	0c 99       	mov	r9,r6
80017da2:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80017da6:	0e 98       	mov	r8,r7
80017da8:	13 0b       	ld.w	r11,r9++
80017daa:	14 ab       	st.w	r10++,r11
80017dac:	2f f8       	sub	r8,-1
80017dae:	10 34       	cp.w	r4,r8
80017db0:	cf c4       	brge	80017da8 <__svfscanf_r+0x340>
80017db2:	ee c9 ff ff 	sub	r9,r7,-1
80017db6:	ee 08 11 ff 	rsub	r8,r7,-1
80017dba:	f0 c7 ff ff 	sub	r7,r8,-1
80017dbe:	2f e8       	sub	r8,-2
80017dc0:	08 08       	add	r8,r4
80017dc2:	08 07       	add	r7,r4
80017dc4:	ec 08 00 26 	add	r6,r6,r8<<0x2
80017dc8:	f2 07 00 07 	add	r7,r9,r7
80017dcc:	fa c8 fd 60 	sub	r8,sp,-672
80017dd0:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80017dd4:	c1 c8       	rjmp	80017e0c <__svfscanf_r+0x3a4>
80017dd6:	e6 c8 ff ff 	sub	r8,r3,-1
80017dda:	0e 33       	cp.w	r3,r7
80017ddc:	c0 94       	brge	80017dee <__svfscanf_r+0x386>
80017dde:	fa ca fc d4 	sub	r10,sp,-812
80017de2:	10 93       	mov	r3,r8
80017de4:	f4 04 00 24 	add	r4,r10,r4<<0x2
80017de8:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80017dec:	c1 08       	rjmp	80017e0c <__svfscanf_r+0x3a4>
80017dee:	6c 04       	ld.w	r4,r6[0x0]
80017df0:	2f c6       	sub	r6,-4
80017df2:	59 f7       	cp.w	r7,31
80017df4:	e0 89 00 0b 	brgt	80017e0a <__svfscanf_r+0x3a2>
80017df8:	10 93       	mov	r3,r8
80017dfa:	fa c9 fc d4 	sub	r9,sp,-812
80017dfe:	f2 07 00 28 	add	r8,r9,r7<<0x2
80017e02:	2f f7       	sub	r7,-1
80017e04:	f1 44 ff 74 	st.w	r8[-140],r4
80017e08:	c0 28       	rjmp	80017e0c <__svfscanf_r+0x3a4>
80017e0a:	10 93       	mov	r3,r8
80017e0c:	40 38       	lddsp	r8,sp[0xc]
80017e0e:	c4 a8       	rjmp	80017ea2 <__svfscanf_r+0x43a>
80017e10:	e2 10 00 02 	andl	r0,0x2,COH
80017e14:	c4 a0       	breq	80017ea8 <__svfscanf_r+0x440>
80017e16:	40 6b       	lddsp	r11,sp[0x18]
80017e18:	58 0b       	cp.w	r11,0
80017e1a:	c2 50       	breq	80017e64 <__svfscanf_r+0x3fc>
80017e1c:	0e 34       	cp.w	r4,r7
80017e1e:	c0 64       	brge	80017e2a <__svfscanf_r+0x3c2>
80017e20:	fa ca fc d4 	sub	r10,sp,-812
80017e24:	f4 04 00 24 	add	r4,r10,r4<<0x2
80017e28:	c2 78       	rjmp	80017e76 <__svfscanf_r+0x40e>
80017e2a:	fa ca fd 60 	sub	r10,sp,-672
80017e2e:	0c 99       	mov	r9,r6
80017e30:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80017e34:	0e 98       	mov	r8,r7
80017e36:	13 0b       	ld.w	r11,r9++
80017e38:	14 ab       	st.w	r10++,r11
80017e3a:	2f f8       	sub	r8,-1
80017e3c:	10 34       	cp.w	r4,r8
80017e3e:	cf c4       	brge	80017e36 <__svfscanf_r+0x3ce>
80017e40:	ee c9 ff ff 	sub	r9,r7,-1
80017e44:	ee 08 11 ff 	rsub	r8,r7,-1
80017e48:	f0 c7 ff ff 	sub	r7,r8,-1
80017e4c:	2f e8       	sub	r8,-2
80017e4e:	08 08       	add	r8,r4
80017e50:	08 07       	add	r7,r4
80017e52:	ec 08 00 26 	add	r6,r6,r8<<0x2
80017e56:	f2 07 00 07 	add	r7,r9,r7
80017e5a:	fa c8 fd 60 	sub	r8,sp,-672
80017e5e:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80017e62:	c1 c8       	rjmp	80017e9a <__svfscanf_r+0x432>
80017e64:	e6 c8 ff ff 	sub	r8,r3,-1
80017e68:	0e 33       	cp.w	r3,r7
80017e6a:	c0 94       	brge	80017e7c <__svfscanf_r+0x414>
80017e6c:	fa c9 fc d4 	sub	r9,sp,-812
80017e70:	10 93       	mov	r3,r8
80017e72:	f2 04 00 24 	add	r4,r9,r4<<0x2
80017e76:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80017e7a:	c1 08       	rjmp	80017e9a <__svfscanf_r+0x432>
80017e7c:	6c 04       	ld.w	r4,r6[0x0]
80017e7e:	2f c6       	sub	r6,-4
80017e80:	59 f7       	cp.w	r7,31
80017e82:	e0 89 00 0b 	brgt	80017e98 <__svfscanf_r+0x430>
80017e86:	10 93       	mov	r3,r8
80017e88:	fa cb fc d4 	sub	r11,sp,-812
80017e8c:	f6 07 00 28 	add	r8,r11,r7<<0x2
80017e90:	2f f7       	sub	r7,-1
80017e92:	f1 44 ff 74 	st.w	r8[-140],r4
80017e96:	c0 28       	rjmp	80017e9a <__svfscanf_r+0x432>
80017e98:	10 93       	mov	r3,r8
80017e9a:	40 3a       	lddsp	r10,sp[0xc]
80017e9c:	14 98       	mov	r8,r10
80017e9e:	89 1a       	st.w	r4[0x4],r10
80017ea0:	bf 58       	asr	r8,0x1f
80017ea2:	89 08       	st.w	r4[0x0],r8
80017ea4:	fe 9f fd f1 	bral	80017a86 <__svfscanf_r+0x1e>
80017ea8:	40 69       	lddsp	r9,sp[0x18]
80017eaa:	58 09       	cp.w	r9,0
80017eac:	c1 f0       	breq	80017eea <__svfscanf_r+0x482>
80017eae:	0e 34       	cp.w	r4,r7
80017eb0:	c0 85       	brlt	80017ec0 <__svfscanf_r+0x458>
80017eb2:	fa ca fd 60 	sub	r10,sp,-672
80017eb6:	0c 99       	mov	r9,r6
80017eb8:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80017ebc:	0e 98       	mov	r8,r7
80017ebe:	c0 68       	rjmp	80017eca <__svfscanf_r+0x462>
80017ec0:	fa c8 fc d4 	sub	r8,sp,-812
80017ec4:	f0 04 00 24 	add	r4,r8,r4<<0x2
80017ec8:	c1 a8       	rjmp	80017efc <__svfscanf_r+0x494>
80017eca:	13 0b       	ld.w	r11,r9++
80017ecc:	14 ab       	st.w	r10++,r11
80017ece:	2f f8       	sub	r8,-1
80017ed0:	10 34       	cp.w	r4,r8
80017ed2:	cf c4       	brge	80017eca <__svfscanf_r+0x462>
80017ed4:	ee 08 11 01 	rsub	r8,r7,1
80017ed8:	08 08       	add	r8,r4
80017eda:	10 07       	add	r7,r8
80017edc:	ec 08 00 26 	add	r6,r6,r8<<0x2
80017ee0:	fa c8 fd 60 	sub	r8,sp,-672
80017ee4:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80017ee8:	c1 c8       	rjmp	80017f20 <__svfscanf_r+0x4b8>
80017eea:	e6 c8 ff ff 	sub	r8,r3,-1
80017eee:	0e 33       	cp.w	r3,r7
80017ef0:	c0 94       	brge	80017f02 <__svfscanf_r+0x49a>
80017ef2:	fa cb fc d4 	sub	r11,sp,-812
80017ef6:	10 93       	mov	r3,r8
80017ef8:	f6 04 00 24 	add	r4,r11,r4<<0x2
80017efc:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80017f00:	c1 08       	rjmp	80017f20 <__svfscanf_r+0x4b8>
80017f02:	6c 04       	ld.w	r4,r6[0x0]
80017f04:	2f c6       	sub	r6,-4
80017f06:	59 f7       	cp.w	r7,31
80017f08:	e0 89 00 0b 	brgt	80017f1e <__svfscanf_r+0x4b6>
80017f0c:	10 93       	mov	r3,r8
80017f0e:	fa ca fc d4 	sub	r10,sp,-812
80017f12:	f4 07 00 28 	add	r8,r10,r7<<0x2
80017f16:	2f f7       	sub	r7,-1
80017f18:	f1 44 ff 74 	st.w	r8[-140],r4
80017f1c:	c0 28       	rjmp	80017f20 <__svfscanf_r+0x4b8>
80017f1e:	10 93       	mov	r3,r8
80017f20:	40 39       	lddsp	r9,sp[0xc]
80017f22:	89 09       	st.w	r4[0x0],r9
80017f24:	fe 9f fd b1 	bral	80017a86 <__svfscanf_r+0x1e>
80017f28:	e2 08 07 08 	ld.ub	r8,r1[r8]
80017f2c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80017f30:	30 ab       	mov	r11,10
80017f32:	10 40       	or	r0,r8
80017f34:	50 8b       	stdsp	sp[0x20],r11
80017f36:	fe c8 be 66 	sub	r8,pc,-16794
80017f3a:	50 a8       	stdsp	sp[0x28],r8
80017f3c:	30 31       	mov	r1,3
80017f3e:	6a 18       	ld.w	r8,r5[0x4]
80017f40:	58 08       	cp.w	r8,0
80017f42:	e0 89 00 08 	brgt	80017f52 <__svfscanf_r+0x4ea>
80017f46:	0a 9b       	mov	r11,r5
80017f48:	40 4c       	lddsp	r12,sp[0x10]
80017f4a:	e0 a0 19 5b 	rcall	8001b200 <__srefill_r>
80017f4e:	e0 81 07 f7 	brne	80018f3c <__svfscanf_r+0x14d4>
80017f52:	ed b0 00 06 	bld	r0,0x6
80017f56:	c1 31       	brne	80017f7c <__svfscanf_r+0x514>
80017f58:	c1 d8       	rjmp	80017f92 <__svfscanf_r+0x52a>
80017f5a:	6a 18       	ld.w	r8,r5[0x4]
80017f5c:	20 18       	sub	r8,1
80017f5e:	8b 18       	st.w	r5[0x4],r8
80017f60:	58 08       	cp.w	r8,0
80017f62:	e0 8a 00 04 	brle	80017f6a <__svfscanf_r+0x502>
80017f66:	8b 0a       	st.w	r5[0x0],r10
80017f68:	c0 78       	rjmp	80017f76 <__svfscanf_r+0x50e>
80017f6a:	0a 9b       	mov	r11,r5
80017f6c:	40 4c       	lddsp	r12,sp[0x10]
80017f6e:	e0 a0 19 49 	rcall	8001b200 <__srefill_r>
80017f72:	e0 81 07 e5 	brne	80018f3c <__svfscanf_r+0x14d4>
80017f76:	40 3a       	lddsp	r10,sp[0xc]
80017f78:	2f fa       	sub	r10,-1
80017f7a:	50 3a       	stdsp	sp[0xc],r10
80017f7c:	6a 08       	ld.w	r8,r5[0x0]
80017f7e:	32 cb       	mov	r11,44
80017f80:	f0 ca ff ff 	sub	r10,r8,-1
80017f84:	76 09       	ld.w	r9,r11[0x0]
80017f86:	11 88       	ld.ub	r8,r8[0x0]
80017f88:	f2 08 07 08 	ld.ub	r8,r9[r8]
80017f8c:	ed b8 00 03 	bld	r8,0x3
80017f90:	ce 50       	breq	80017f5a <__svfscanf_r+0x4f2>
80017f92:	58 21       	cp.w	r1,2
80017f94:	e0 80 01 c2 	breq	80018318 <__svfscanf_r+0x8b0>
80017f98:	e0 89 00 05 	brgt	80017fa2 <__svfscanf_r+0x53a>
80017f9c:	58 11       	cp.w	r1,1
80017f9e:	c0 81       	brne	80017fae <__svfscanf_r+0x546>
80017fa0:	c1 c9       	rjmp	800181d8 <__svfscanf_r+0x770>
80017fa2:	58 31       	cp.w	r1,3
80017fa4:	e0 80 03 11 	breq	800185c6 <__svfscanf_r+0xb5e>
80017fa8:	58 41       	cp.w	r1,4
80017faa:	e0 80 05 1b 	breq	800189e0 <__svfscanf_r+0xf78>
80017fae:	00 9a       	mov	r10,r0
80017fb0:	e2 1a 00 10 	andl	r10,0x10,COH
80017fb4:	50 5a       	stdsp	sp[0x14],r10
80017fb6:	58 02       	cp.w	r2,0
80017fb8:	f9 b2 00 01 	moveq	r2,1
80017fbc:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80017fc0:	e0 80 00 9e 	breq	800180fc <__svfscanf_r+0x694>
80017fc4:	58 0a       	cp.w	r10,0
80017fc6:	c0 30       	breq	80017fcc <__svfscanf_r+0x564>
80017fc8:	30 00       	mov	r0,0
80017fca:	c4 58       	rjmp	80018054 <__svfscanf_r+0x5ec>
80017fcc:	40 69       	lddsp	r9,sp[0x18]
80017fce:	58 09       	cp.w	r9,0
80017fd0:	c2 50       	breq	8001801a <__svfscanf_r+0x5b2>
80017fd2:	0e 34       	cp.w	r4,r7
80017fd4:	c0 64       	brge	80017fe0 <__svfscanf_r+0x578>
80017fd6:	fa c8 fc d4 	sub	r8,sp,-812
80017fda:	f0 04 00 24 	add	r4,r8,r4<<0x2
80017fde:	c2 78       	rjmp	8001802c <__svfscanf_r+0x5c4>
80017fe0:	fa ca fd 60 	sub	r10,sp,-672
80017fe4:	0c 99       	mov	r9,r6
80017fe6:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80017fea:	0e 98       	mov	r8,r7
80017fec:	13 0b       	ld.w	r11,r9++
80017fee:	14 ab       	st.w	r10++,r11
80017ff0:	2f f8       	sub	r8,-1
80017ff2:	10 34       	cp.w	r4,r8
80017ff4:	cf c4       	brge	80017fec <__svfscanf_r+0x584>
80017ff6:	ee c9 ff ff 	sub	r9,r7,-1
80017ffa:	ee 08 11 ff 	rsub	r8,r7,-1
80017ffe:	f0 c7 ff ff 	sub	r7,r8,-1
80018002:	2f e8       	sub	r8,-2
80018004:	08 08       	add	r8,r4
80018006:	08 07       	add	r7,r4
80018008:	ec 08 00 26 	add	r6,r6,r8<<0x2
8001800c:	f2 07 00 07 	add	r7,r9,r7
80018010:	fa c8 fd 60 	sub	r8,sp,-672
80018014:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80018018:	c1 d8       	rjmp	80018052 <__svfscanf_r+0x5ea>
8001801a:	e6 c8 ff ff 	sub	r8,r3,-1
8001801e:	0e 33       	cp.w	r3,r7
80018020:	c0 94       	brge	80018032 <__svfscanf_r+0x5ca>
80018022:	fa cb fc d4 	sub	r11,sp,-812
80018026:	10 93       	mov	r3,r8
80018028:	f6 04 00 24 	add	r4,r11,r4<<0x2
8001802c:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80018030:	c1 18       	rjmp	80018052 <__svfscanf_r+0x5ea>
80018032:	6c 04       	ld.w	r4,r6[0x0]
80018034:	2f c6       	sub	r6,-4
80018036:	59 f7       	cp.w	r7,31
80018038:	e0 89 00 0c 	brgt	80018050 <__svfscanf_r+0x5e8>
8001803c:	10 93       	mov	r3,r8
8001803e:	fa ca fc d4 	sub	r10,sp,-812
80018042:	f4 07 00 28 	add	r8,r10,r7<<0x2
80018046:	2f f7       	sub	r7,-1
80018048:	f1 44 ff 74 	st.w	r8[-140],r4
8001804c:	c0 38       	rjmp	80018052 <__svfscanf_r+0x5ea>
8001804e:	d7 03       	nop
80018050:	10 93       	mov	r3,r8
80018052:	08 90       	mov	r0,r4
80018054:	30 04       	mov	r4,0
80018056:	e0 61 05 38 	mov	r1,1336
8001805a:	62 08       	ld.w	r8,r1[0x0]
8001805c:	10 34       	cp.w	r4,r8
8001805e:	e0 80 07 6f 	breq	80018f3c <__svfscanf_r+0x14d4>
80018062:	6a 08       	ld.w	r8,r5[0x0]
80018064:	11 89       	ld.ub	r9,r8[0x0]
80018066:	fa c8 fc d4 	sub	r8,sp,-812
8001806a:	08 08       	add	r8,r4
8001806c:	f1 69 fd 14 	st.b	r8[-748],r9
80018070:	6a 18       	ld.w	r8,r5[0x4]
80018072:	20 18       	sub	r8,1
80018074:	8b 18       	st.w	r5[0x4],r8
80018076:	6a 08       	ld.w	r8,r5[0x0]
80018078:	2f f8       	sub	r8,-1
8001807a:	30 8a       	mov	r10,8
8001807c:	8b 08       	st.w	r5[0x0],r8
8001807e:	30 0b       	mov	r11,0
80018080:	fa cc fc e0 	sub	r12,sp,-800
80018084:	fe b0 ea bf 	rcall	80015602 <memset>
80018088:	2f f4       	sub	r4,-1
8001808a:	fa c8 fc e0 	sub	r8,sp,-800
8001808e:	08 99       	mov	r9,r4
80018090:	fa ca ff c0 	sub	r10,sp,-64
80018094:	00 9b       	mov	r11,r0
80018096:	40 4c       	lddsp	r12,sp[0x10]
80018098:	e0 a0 12 fe 	rcall	8001a694 <_mbrtowc_r>
8001809c:	5b fc       	cp.w	r12,-1
8001809e:	e0 80 07 4f 	breq	80018f3c <__svfscanf_r+0x14d4>
800180a2:	58 0c       	cp.w	r12,0
800180a4:	c0 61       	brne	800180b0 <__svfscanf_r+0x648>
800180a6:	40 59       	lddsp	r9,sp[0x14]
800180a8:	58 09       	cp.w	r9,0
800180aa:	c0 51       	brne	800180b4 <__svfscanf_r+0x64c>
800180ac:	81 09       	st.w	r0[0x0],r9
800180ae:	c0 38       	rjmp	800180b4 <__svfscanf_r+0x64c>
800180b0:	5b ec       	cp.w	r12,-2
800180b2:	c0 d0       	breq	800180cc <__svfscanf_r+0x664>
800180b4:	40 38       	lddsp	r8,sp[0xc]
800180b6:	40 5b       	lddsp	r11,sp[0x14]
800180b8:	08 08       	add	r8,r4
800180ba:	20 12       	sub	r2,1
800180bc:	58 0b       	cp.w	r11,0
800180be:	f9 b4 01 00 	movne	r4,0
800180c2:	f7 b0 00 fc 	subeq	r0,-4
800180c6:	fb f4 00 05 	ld.weq	r4,sp[0x14]
800180ca:	50 38       	stdsp	sp[0xc],r8
800180cc:	6a 18       	ld.w	r8,r5[0x4]
800180ce:	58 08       	cp.w	r8,0
800180d0:	e0 89 00 0b 	brgt	800180e6 <__svfscanf_r+0x67e>
800180d4:	0a 9b       	mov	r11,r5
800180d6:	40 4c       	lddsp	r12,sp[0x10]
800180d8:	e0 a0 18 94 	rcall	8001b200 <__srefill_r>
800180dc:	c0 50       	breq	800180e6 <__svfscanf_r+0x67e>
800180de:	58 04       	cp.w	r4,0
800180e0:	c0 50       	breq	800180ea <__svfscanf_r+0x682>
800180e2:	e0 8f 07 2d 	bral	80018f3c <__svfscanf_r+0x14d4>
800180e6:	58 02       	cp.w	r2,0
800180e8:	cb 91       	brne	8001805a <__svfscanf_r+0x5f2>
800180ea:	40 5a       	lddsp	r10,sp[0x14]
800180ec:	58 0a       	cp.w	r10,0
800180ee:	fe 91 fc cc 	brne	80017a86 <__svfscanf_r+0x1e>
800180f2:	40 79       	lddsp	r9,sp[0x1c]
800180f4:	2f f9       	sub	r9,-1
800180f6:	50 79       	stdsp	sp[0x1c],r9
800180f8:	fe 9f fc c7 	bral	80017a86 <__svfscanf_r+0x1e>
800180fc:	40 58       	lddsp	r8,sp[0x14]
800180fe:	58 08       	cp.w	r8,0
80018100:	c1 d0       	breq	8001813a <__svfscanf_r+0x6d2>
80018102:	6a 18       	ld.w	r8,r5[0x4]
80018104:	6a 09       	ld.w	r9,r5[0x0]
80018106:	04 38       	cp.w	r8,r2
80018108:	c0 e4       	brge	80018124 <__svfscanf_r+0x6bc>
8001810a:	10 09       	add	r9,r8
8001810c:	10 12       	sub	r2,r8
8001810e:	8b 09       	st.w	r5[0x0],r9
80018110:	10 00       	add	r0,r8
80018112:	0a 9b       	mov	r11,r5
80018114:	40 4c       	lddsp	r12,sp[0x10]
80018116:	e0 a0 18 75 	rcall	8001b200 <__srefill_r>
8001811a:	cf 40       	breq	80018102 <__svfscanf_r+0x69a>
8001811c:	58 00       	cp.w	r0,0
8001811e:	c0 81       	brne	8001812e <__svfscanf_r+0x6c6>
80018120:	e0 8f 07 0e 	bral	80018f3c <__svfscanf_r+0x14d4>
80018124:	04 09       	add	r9,r2
80018126:	04 18       	sub	r8,r2
80018128:	8b 09       	st.w	r5[0x0],r9
8001812a:	8b 18       	st.w	r5[0x4],r8
8001812c:	04 00       	add	r0,r2
8001812e:	40 3b       	lddsp	r11,sp[0xc]
80018130:	e0 0b 00 0b 	add	r11,r0,r11
80018134:	50 3b       	stdsp	sp[0xc],r11
80018136:	fe 9f fc a8 	bral	80017a86 <__svfscanf_r+0x1e>
8001813a:	40 6a       	lddsp	r10,sp[0x18]
8001813c:	58 0a       	cp.w	r10,0
8001813e:	c2 50       	breq	80018188 <__svfscanf_r+0x720>
80018140:	0e 34       	cp.w	r4,r7
80018142:	c0 64       	brge	8001814e <__svfscanf_r+0x6e6>
80018144:	fa c9 fc d4 	sub	r9,sp,-812
80018148:	f2 04 00 24 	add	r4,r9,r4<<0x2
8001814c:	c2 78       	rjmp	8001819a <__svfscanf_r+0x732>
8001814e:	fa ca fd 60 	sub	r10,sp,-672
80018152:	0c 99       	mov	r9,r6
80018154:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80018158:	0e 98       	mov	r8,r7
8001815a:	13 0b       	ld.w	r11,r9++
8001815c:	14 ab       	st.w	r10++,r11
8001815e:	2f f8       	sub	r8,-1
80018160:	10 34       	cp.w	r4,r8
80018162:	cf c4       	brge	8001815a <__svfscanf_r+0x6f2>
80018164:	ee c9 ff ff 	sub	r9,r7,-1
80018168:	ee 08 11 ff 	rsub	r8,r7,-1
8001816c:	f0 c7 ff ff 	sub	r7,r8,-1
80018170:	2f e8       	sub	r8,-2
80018172:	08 08       	add	r8,r4
80018174:	08 07       	add	r7,r4
80018176:	ec 08 00 26 	add	r6,r6,r8<<0x2
8001817a:	f2 07 00 07 	add	r7,r9,r7
8001817e:	fa c8 fd 60 	sub	r8,sp,-672
80018182:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80018186:	c1 c8       	rjmp	800181be <__svfscanf_r+0x756>
80018188:	e6 c8 ff ff 	sub	r8,r3,-1
8001818c:	0e 33       	cp.w	r3,r7
8001818e:	c0 94       	brge	800181a0 <__svfscanf_r+0x738>
80018190:	fa cb fc d4 	sub	r11,sp,-812
80018194:	10 93       	mov	r3,r8
80018196:	f6 04 00 24 	add	r4,r11,r4<<0x2
8001819a:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8001819e:	c1 08       	rjmp	800181be <__svfscanf_r+0x756>
800181a0:	6c 04       	ld.w	r4,r6[0x0]
800181a2:	2f c6       	sub	r6,-4
800181a4:	59 f7       	cp.w	r7,31
800181a6:	e0 89 00 0b 	brgt	800181bc <__svfscanf_r+0x754>
800181aa:	10 93       	mov	r3,r8
800181ac:	fa ca fc d4 	sub	r10,sp,-812
800181b0:	f4 07 00 28 	add	r8,r10,r7<<0x2
800181b4:	2f f7       	sub	r7,-1
800181b6:	f1 44 ff 74 	st.w	r8[-140],r4
800181ba:	c0 28       	rjmp	800181be <__svfscanf_r+0x756>
800181bc:	10 93       	mov	r3,r8
800181be:	04 9a       	mov	r10,r2
800181c0:	08 9c       	mov	r12,r4
800181c2:	0a 99       	mov	r9,r5
800181c4:	30 1b       	mov	r11,1
800181c6:	e0 a0 0f 45 	rcall	8001a050 <fread>
800181ca:	e0 80 06 b9 	breq	80018f3c <__svfscanf_r+0x14d4>
800181ce:	40 39       	lddsp	r9,sp[0xc]
800181d0:	f8 09 00 09 	add	r9,r12,r9
800181d4:	50 39       	stdsp	sp[0xc],r9
800181d6:	c6 29       	rjmp	8001849a <__svfscanf_r+0xa32>
800181d8:	58 02       	cp.w	r2,0
800181da:	f9 b2 00 ff 	moveq	r2,-1
800181de:	e2 10 00 10 	andl	r0,0x10,COH
800181e2:	c2 60       	breq	8001822e <__svfscanf_r+0x7c6>
800181e4:	30 04       	mov	r4,0
800181e6:	08 91       	mov	r1,r4
800181e8:	c1 28       	rjmp	8001820c <__svfscanf_r+0x7a4>
800181ea:	6a 18       	ld.w	r8,r5[0x4]
800181ec:	8b 09       	st.w	r5[0x0],r9
800181ee:	20 18       	sub	r8,1
800181f0:	8b 18       	st.w	r5[0x4],r8
800181f2:	2f f4       	sub	r4,-1
800181f4:	08 32       	cp.w	r2,r4
800181f6:	e0 80 00 8c 	breq	8001830e <__svfscanf_r+0x8a6>
800181fa:	58 08       	cp.w	r8,0
800181fc:	e0 89 00 08 	brgt	8001820c <__svfscanf_r+0x7a4>
80018200:	0a 9b       	mov	r11,r5
80018202:	40 4c       	lddsp	r12,sp[0x10]
80018204:	e0 a0 17 fe 	rcall	8001b200 <__srefill_r>
80018208:	e0 81 00 83 	brne	8001830e <__svfscanf_r+0x8a6>
8001820c:	6a 08       	ld.w	r8,r5[0x0]
8001820e:	fa cb fc d4 	sub	r11,sp,-812
80018212:	f0 c9 ff ff 	sub	r9,r8,-1
80018216:	11 88       	ld.ub	r8,r8[0x0]
80018218:	f6 08 00 08 	add	r8,r11,r8
8001821c:	f1 38 fe 74 	ld.ub	r8,r8[-396]
80018220:	e2 08 18 00 	cp.b	r8,r1
80018224:	ce 31       	brne	800181ea <__svfscanf_r+0x782>
80018226:	58 04       	cp.w	r4,0
80018228:	c7 31       	brne	8001830e <__svfscanf_r+0x8a6>
8001822a:	e0 8f 06 92 	bral	80018f4e <__svfscanf_r+0x14e6>
8001822e:	40 6a       	lddsp	r10,sp[0x18]
80018230:	58 0a       	cp.w	r10,0
80018232:	c2 50       	breq	8001827c <__svfscanf_r+0x814>
80018234:	0e 34       	cp.w	r4,r7
80018236:	c0 64       	brge	80018242 <__svfscanf_r+0x7da>
80018238:	fa c9 fc d4 	sub	r9,sp,-812
8001823c:	f2 04 00 24 	add	r4,r9,r4<<0x2
80018240:	c2 78       	rjmp	8001828e <__svfscanf_r+0x826>
80018242:	fa ca fd 60 	sub	r10,sp,-672
80018246:	0c 99       	mov	r9,r6
80018248:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8001824c:	0e 98       	mov	r8,r7
8001824e:	13 0b       	ld.w	r11,r9++
80018250:	14 ab       	st.w	r10++,r11
80018252:	2f f8       	sub	r8,-1
80018254:	10 34       	cp.w	r4,r8
80018256:	cf c4       	brge	8001824e <__svfscanf_r+0x7e6>
80018258:	ee c9 ff ff 	sub	r9,r7,-1
8001825c:	ee 08 11 ff 	rsub	r8,r7,-1
80018260:	f0 c7 ff ff 	sub	r7,r8,-1
80018264:	2f e8       	sub	r8,-2
80018266:	08 08       	add	r8,r4
80018268:	08 07       	add	r7,r4
8001826a:	ec 08 00 26 	add	r6,r6,r8<<0x2
8001826e:	f2 07 00 07 	add	r7,r9,r7
80018272:	fa c8 fd 60 	sub	r8,sp,-672
80018276:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8001827a:	c1 c8       	rjmp	800182b2 <__svfscanf_r+0x84a>
8001827c:	e6 c8 ff ff 	sub	r8,r3,-1
80018280:	0e 33       	cp.w	r3,r7
80018282:	c0 94       	brge	80018294 <__svfscanf_r+0x82c>
80018284:	fa cb fc d4 	sub	r11,sp,-812
80018288:	10 93       	mov	r3,r8
8001828a:	f6 04 00 24 	add	r4,r11,r4<<0x2
8001828e:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80018292:	c1 08       	rjmp	800182b2 <__svfscanf_r+0x84a>
80018294:	6c 04       	ld.w	r4,r6[0x0]
80018296:	2f c6       	sub	r6,-4
80018298:	59 f7       	cp.w	r7,31
8001829a:	e0 89 00 0b 	brgt	800182b0 <__svfscanf_r+0x848>
8001829e:	10 93       	mov	r3,r8
800182a0:	fa ca fc d4 	sub	r10,sp,-812
800182a4:	f4 07 00 28 	add	r8,r10,r7<<0x2
800182a8:	2f f7       	sub	r7,-1
800182aa:	f1 44 ff 74 	st.w	r8[-140],r4
800182ae:	c0 28       	rjmp	800182b2 <__svfscanf_r+0x84a>
800182b0:	10 93       	mov	r3,r8
800182b2:	08 91       	mov	r1,r4
800182b4:	30 00       	mov	r0,0
800182b6:	c1 68       	rjmp	800182e2 <__svfscanf_r+0x87a>
800182b8:	6a 19       	ld.w	r9,r5[0x4]
800182ba:	20 19       	sub	r9,1
800182bc:	8b 19       	st.w	r5[0x4],r9
800182be:	11 39       	ld.ub	r9,r8++
800182c0:	02 c9       	st.b	r1++,r9
800182c2:	8b 08       	st.w	r5[0x0],r8
800182c4:	58 02       	cp.w	r2,0
800182c6:	c1 b0       	breq	800182fc <__svfscanf_r+0x894>
800182c8:	6a 18       	ld.w	r8,r5[0x4]
800182ca:	58 08       	cp.w	r8,0
800182cc:	e0 89 00 0b 	brgt	800182e2 <__svfscanf_r+0x87a>
800182d0:	0a 9b       	mov	r11,r5
800182d2:	40 4c       	lddsp	r12,sp[0x10]
800182d4:	e0 a0 17 96 	rcall	8001b200 <__srefill_r>
800182d8:	c0 50       	breq	800182e2 <__svfscanf_r+0x87a>
800182da:	08 31       	cp.w	r1,r4
800182dc:	c1 01       	brne	800182fc <__svfscanf_r+0x894>
800182de:	e0 8f 06 2f 	bral	80018f3c <__svfscanf_r+0x14d4>
800182e2:	6a 09       	ld.w	r9,r5[0x0]
800182e4:	fa cb fc d4 	sub	r11,sp,-812
800182e8:	12 98       	mov	r8,r9
800182ea:	20 12       	sub	r2,1
800182ec:	13 89       	ld.ub	r9,r9[0x0]
800182ee:	f6 09 00 09 	add	r9,r11,r9
800182f2:	f3 39 fe 74 	ld.ub	r9,r9[-396]
800182f6:	e0 09 18 00 	cp.b	r9,r0
800182fa:	cd f1       	brne	800182b8 <__svfscanf_r+0x850>
800182fc:	e2 04 01 04 	sub	r4,r1,r4
80018300:	e0 80 06 27 	breq	80018f4e <__svfscanf_r+0x14e6>
80018304:	40 7a       	lddsp	r10,sp[0x1c]
80018306:	2f fa       	sub	r10,-1
80018308:	50 7a       	stdsp	sp[0x1c],r10
8001830a:	30 08       	mov	r8,0
8001830c:	a2 88       	st.b	r1[0x0],r8
8001830e:	40 39       	lddsp	r9,sp[0xc]
80018310:	08 09       	add	r9,r4
80018312:	50 39       	stdsp	sp[0xc],r9
80018314:	fe 9f fb b9 	bral	80017a86 <__svfscanf_r+0x1e>
80018318:	00 98       	mov	r8,r0
8001831a:	e2 18 00 10 	andl	r8,0x10,COH
8001831e:	50 58       	stdsp	sp[0x14],r8
80018320:	58 02       	cp.w	r2,0
80018322:	f9 b2 00 ff 	moveq	r2,-1
80018326:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8001832a:	e0 80 00 bd 	breq	800184a4 <__svfscanf_r+0xa3c>
8001832e:	58 08       	cp.w	r8,0
80018330:	c0 40       	breq	80018338 <__svfscanf_r+0x8d0>
80018332:	fa c0 fc d8 	sub	r0,sp,-808
80018336:	c4 48       	rjmp	800183be <__svfscanf_r+0x956>
80018338:	40 6b       	lddsp	r11,sp[0x18]
8001833a:	58 0b       	cp.w	r11,0
8001833c:	c2 50       	breq	80018386 <__svfscanf_r+0x91e>
8001833e:	0e 34       	cp.w	r4,r7
80018340:	c0 64       	brge	8001834c <__svfscanf_r+0x8e4>
80018342:	fa ca fc d4 	sub	r10,sp,-812
80018346:	f4 04 00 24 	add	r4,r10,r4<<0x2
8001834a:	c2 78       	rjmp	80018398 <__svfscanf_r+0x930>
8001834c:	fa ca fd 60 	sub	r10,sp,-672
80018350:	0c 99       	mov	r9,r6
80018352:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80018356:	0e 98       	mov	r8,r7
80018358:	13 0b       	ld.w	r11,r9++
8001835a:	14 ab       	st.w	r10++,r11
8001835c:	2f f8       	sub	r8,-1
8001835e:	10 34       	cp.w	r4,r8
80018360:	cf c4       	brge	80018358 <__svfscanf_r+0x8f0>
80018362:	ee c9 ff ff 	sub	r9,r7,-1
80018366:	ee 08 11 ff 	rsub	r8,r7,-1
8001836a:	f0 c7 ff ff 	sub	r7,r8,-1
8001836e:	2f e8       	sub	r8,-2
80018370:	08 08       	add	r8,r4
80018372:	08 07       	add	r7,r4
80018374:	ec 08 00 26 	add	r6,r6,r8<<0x2
80018378:	f2 07 00 07 	add	r7,r9,r7
8001837c:	fa c8 fd 60 	sub	r8,sp,-672
80018380:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80018384:	c1 c8       	rjmp	800183bc <__svfscanf_r+0x954>
80018386:	e6 c8 ff ff 	sub	r8,r3,-1
8001838a:	0e 33       	cp.w	r3,r7
8001838c:	c0 94       	brge	8001839e <__svfscanf_r+0x936>
8001838e:	fa c9 fc d4 	sub	r9,sp,-812
80018392:	10 93       	mov	r3,r8
80018394:	f2 04 00 24 	add	r4,r9,r4<<0x2
80018398:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8001839c:	c1 08       	rjmp	800183bc <__svfscanf_r+0x954>
8001839e:	6c 04       	ld.w	r4,r6[0x0]
800183a0:	2f c6       	sub	r6,-4
800183a2:	59 f7       	cp.w	r7,31
800183a4:	e0 89 00 0b 	brgt	800183ba <__svfscanf_r+0x952>
800183a8:	10 93       	mov	r3,r8
800183aa:	fa cb fc d4 	sub	r11,sp,-812
800183ae:	f6 07 00 28 	add	r8,r11,r7<<0x2
800183b2:	2f f7       	sub	r7,-1
800183b4:	f1 44 ff 74 	st.w	r8[-140],r4
800183b8:	c0 28       	rjmp	800183bc <__svfscanf_r+0x954>
800183ba:	10 93       	mov	r3,r8
800183bc:	08 90       	mov	r0,r4
800183be:	30 01       	mov	r1,0
800183c0:	e0 64 05 38 	mov	r4,1336
800183c4:	c5 68       	rjmp	80018470 <__svfscanf_r+0xa08>
800183c6:	68 08       	ld.w	r8,r4[0x0]
800183c8:	10 31       	cp.w	r1,r8
800183ca:	e0 80 05 b9 	breq	80018f3c <__svfscanf_r+0x14d4>
800183ce:	fa c8 fc d4 	sub	r8,sp,-812
800183d2:	02 08       	add	r8,r1
800183d4:	f1 69 fd 14 	st.b	r8[-748],r9
800183d8:	6a 18       	ld.w	r8,r5[0x4]
800183da:	20 18       	sub	r8,1
800183dc:	8b 18       	st.w	r5[0x4],r8
800183de:	6a 08       	ld.w	r8,r5[0x0]
800183e0:	2f f8       	sub	r8,-1
800183e2:	30 8a       	mov	r10,8
800183e4:	8b 08       	st.w	r5[0x0],r8
800183e6:	30 0b       	mov	r11,0
800183e8:	fa cc fc e0 	sub	r12,sp,-800
800183ec:	fe b0 e9 0b 	rcall	80015602 <memset>
800183f0:	2f f1       	sub	r1,-1
800183f2:	fa c8 fc e0 	sub	r8,sp,-800
800183f6:	02 99       	mov	r9,r1
800183f8:	fa ca ff c0 	sub	r10,sp,-64
800183fc:	00 9b       	mov	r11,r0
800183fe:	40 4c       	lddsp	r12,sp[0x10]
80018400:	e0 a0 11 4a 	rcall	8001a694 <_mbrtowc_r>
80018404:	5b fc       	cp.w	r12,-1
80018406:	e0 80 05 9b 	breq	80018f3c <__svfscanf_r+0x14d4>
8001840a:	58 0c       	cp.w	r12,0
8001840c:	c0 31       	brne	80018412 <__svfscanf_r+0x9aa>
8001840e:	81 0c       	st.w	r0[0x0],r12
80018410:	c0 38       	rjmp	80018416 <__svfscanf_r+0x9ae>
80018412:	5b ec       	cp.w	r12,-2
80018414:	c2 10       	breq	80018456 <__svfscanf_r+0x9ee>
80018416:	60 0c       	ld.w	r12,r0[0x0]
80018418:	e0 a0 10 d0 	rcall	8001a5b8 <iswspace>
8001841c:	c1 10       	breq	8001843e <__svfscanf_r+0x9d6>
8001841e:	fa c4 fc d4 	sub	r4,sp,-812
80018422:	02 04       	add	r4,r1
80018424:	e8 c4 02 ed 	sub	r4,r4,749
80018428:	c0 88       	rjmp	80018438 <__svfscanf_r+0x9d0>
8001842a:	09 8b       	ld.ub	r11,r4[0x0]
8001842c:	20 11       	sub	r1,1
8001842e:	20 14       	sub	r4,1
80018430:	0a 9a       	mov	r10,r5
80018432:	40 4c       	lddsp	r12,sp[0x10]
80018434:	e0 a0 21 2c 	rcall	8001c68c <_ungetc_r>
80018438:	58 01       	cp.w	r1,0
8001843a:	cf 81       	brne	8001842a <__svfscanf_r+0x9c2>
8001843c:	c2 a8       	rjmp	80018490 <__svfscanf_r+0xa28>
8001843e:	40 3a       	lddsp	r10,sp[0xc]
80018440:	40 59       	lddsp	r9,sp[0x14]
80018442:	02 0a       	add	r10,r1
80018444:	20 12       	sub	r2,1
80018446:	58 09       	cp.w	r9,0
80018448:	f8 01 17 10 	movne	r1,r12
8001844c:	f7 b0 00 fc 	subeq	r0,-4
80018450:	fb f1 00 05 	ld.weq	r1,sp[0x14]
80018454:	50 3a       	stdsp	sp[0xc],r10
80018456:	6a 18       	ld.w	r8,r5[0x4]
80018458:	58 08       	cp.w	r8,0
8001845a:	e0 89 00 0b 	brgt	80018470 <__svfscanf_r+0xa08>
8001845e:	0a 9b       	mov	r11,r5
80018460:	40 4c       	lddsp	r12,sp[0x10]
80018462:	e0 a0 16 cf 	rcall	8001b200 <__srefill_r>
80018466:	c0 50       	breq	80018470 <__svfscanf_r+0xa08>
80018468:	58 01       	cp.w	r1,0
8001846a:	e0 81 05 69 	brne	80018f3c <__svfscanf_r+0x14d4>
8001846e:	c1 18       	rjmp	80018490 <__svfscanf_r+0xa28>
80018470:	6a 08       	ld.w	r8,r5[0x0]
80018472:	58 02       	cp.w	r2,0
80018474:	5f 1a       	srne	r10
80018476:	11 89       	ld.ub	r9,r8[0x0]
80018478:	32 cb       	mov	r11,44
8001847a:	76 08       	ld.w	r8,r11[0x0]
8001847c:	f0 09 07 08 	ld.ub	r8,r8[r9]
80018480:	ec 18 00 08 	eorl	r8,0x8
80018484:	f5 e8 02 38 	and	r8,r10,r8>>0x3
80018488:	30 0a       	mov	r10,0
8001848a:	f4 08 18 00 	cp.b	r8,r10
8001848e:	c9 c1       	brne	800183c6 <__svfscanf_r+0x95e>
80018490:	40 59       	lddsp	r9,sp[0x14]
80018492:	58 09       	cp.w	r9,0
80018494:	fe 91 fa f9 	brne	80017a86 <__svfscanf_r+0x1e>
80018498:	81 09       	st.w	r0[0x0],r9
8001849a:	40 78       	lddsp	r8,sp[0x1c]
8001849c:	2f f8       	sub	r8,-1
8001849e:	50 78       	stdsp	sp[0x1c],r8
800184a0:	fe 9f fa f3 	bral	80017a86 <__svfscanf_r+0x1e>
800184a4:	40 5b       	lddsp	r11,sp[0x14]
800184a6:	58 0b       	cp.w	r11,0
800184a8:	c2 20       	breq	800184ec <__svfscanf_r+0xa84>
800184aa:	c1 08       	rjmp	800184ca <__svfscanf_r+0xa62>
800184ac:	6a 18       	ld.w	r8,r5[0x4]
800184ae:	8b 0a       	st.w	r5[0x0],r10
800184b0:	20 18       	sub	r8,1
800184b2:	8b 18       	st.w	r5[0x4],r8
800184b4:	2f f0       	sub	r0,-1
800184b6:	00 32       	cp.w	r2,r0
800184b8:	c1 40       	breq	800184e0 <__svfscanf_r+0xa78>
800184ba:	58 08       	cp.w	r8,0
800184bc:	e0 89 00 07 	brgt	800184ca <__svfscanf_r+0xa62>
800184c0:	0a 9b       	mov	r11,r5
800184c2:	40 4c       	lddsp	r12,sp[0x10]
800184c4:	e0 a0 16 9e 	rcall	8001b200 <__srefill_r>
800184c8:	c0 c1       	brne	800184e0 <__svfscanf_r+0xa78>
800184ca:	6a 08       	ld.w	r8,r5[0x0]
800184cc:	32 cb       	mov	r11,44
800184ce:	f0 ca ff ff 	sub	r10,r8,-1
800184d2:	76 09       	ld.w	r9,r11[0x0]
800184d4:	11 88       	ld.ub	r8,r8[0x0]
800184d6:	f2 08 07 08 	ld.ub	r8,r9[r8]
800184da:	ed b8 00 03 	bld	r8,0x3
800184de:	ce 71       	brne	800184ac <__svfscanf_r+0xa44>
800184e0:	40 3a       	lddsp	r10,sp[0xc]
800184e2:	00 0a       	add	r10,r0
800184e4:	50 3a       	stdsp	sp[0xc],r10
800184e6:	fe 9f fa d0 	bral	80017a86 <__svfscanf_r+0x1e>
800184ea:	d7 03       	nop
800184ec:	40 69       	lddsp	r9,sp[0x18]
800184ee:	58 09       	cp.w	r9,0
800184f0:	c2 50       	breq	8001853a <__svfscanf_r+0xad2>
800184f2:	0e 34       	cp.w	r4,r7
800184f4:	c0 64       	brge	80018500 <__svfscanf_r+0xa98>
800184f6:	fa c8 fc d4 	sub	r8,sp,-812
800184fa:	f0 04 00 24 	add	r4,r8,r4<<0x2
800184fe:	c2 78       	rjmp	8001854c <__svfscanf_r+0xae4>
80018500:	fa ca fd 60 	sub	r10,sp,-672
80018504:	0c 99       	mov	r9,r6
80018506:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8001850a:	0e 98       	mov	r8,r7
8001850c:	13 0b       	ld.w	r11,r9++
8001850e:	14 ab       	st.w	r10++,r11
80018510:	2f f8       	sub	r8,-1
80018512:	10 34       	cp.w	r4,r8
80018514:	cf c4       	brge	8001850c <__svfscanf_r+0xaa4>
80018516:	ee c9 ff ff 	sub	r9,r7,-1
8001851a:	ee 08 11 ff 	rsub	r8,r7,-1
8001851e:	f0 c7 ff ff 	sub	r7,r8,-1
80018522:	2f e8       	sub	r8,-2
80018524:	08 08       	add	r8,r4
80018526:	08 07       	add	r7,r4
80018528:	ec 08 00 26 	add	r6,r6,r8<<0x2
8001852c:	f2 07 00 07 	add	r7,r9,r7
80018530:	fa c8 fd 60 	sub	r8,sp,-672
80018534:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80018538:	c1 c8       	rjmp	80018570 <__svfscanf_r+0xb08>
8001853a:	e6 c8 ff ff 	sub	r8,r3,-1
8001853e:	0e 33       	cp.w	r3,r7
80018540:	c0 94       	brge	80018552 <__svfscanf_r+0xaea>
80018542:	fa cb fc d4 	sub	r11,sp,-812
80018546:	10 93       	mov	r3,r8
80018548:	f6 04 00 24 	add	r4,r11,r4<<0x2
8001854c:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80018550:	c1 08       	rjmp	80018570 <__svfscanf_r+0xb08>
80018552:	6c 04       	ld.w	r4,r6[0x0]
80018554:	2f c6       	sub	r6,-4
80018556:	59 f7       	cp.w	r7,31
80018558:	e0 89 00 0b 	brgt	8001856e <__svfscanf_r+0xb06>
8001855c:	10 93       	mov	r3,r8
8001855e:	fa ca fc d4 	sub	r10,sp,-812
80018562:	f4 07 00 28 	add	r8,r10,r7<<0x2
80018566:	2f f7       	sub	r7,-1
80018568:	f1 44 ff 74 	st.w	r8[-140],r4
8001856c:	c0 28       	rjmp	80018570 <__svfscanf_r+0xb08>
8001856e:	10 93       	mov	r3,r8
80018570:	08 91       	mov	r1,r4
80018572:	c1 28       	rjmp	80018596 <__svfscanf_r+0xb2e>
80018574:	6a 19       	ld.w	r9,r5[0x4]
80018576:	20 19       	sub	r9,1
80018578:	8b 19       	st.w	r5[0x4],r9
8001857a:	11 39       	ld.ub	r9,r8++
8001857c:	02 c9       	st.b	r1++,r9
8001857e:	8b 08       	st.w	r5[0x0],r8
80018580:	58 02       	cp.w	r2,0
80018582:	c1 50       	breq	800185ac <__svfscanf_r+0xb44>
80018584:	6a 18       	ld.w	r8,r5[0x4]
80018586:	58 08       	cp.w	r8,0
80018588:	e0 89 00 07 	brgt	80018596 <__svfscanf_r+0xb2e>
8001858c:	0a 9b       	mov	r11,r5
8001858e:	40 4c       	lddsp	r12,sp[0x10]
80018590:	e0 a0 16 38 	rcall	8001b200 <__srefill_r>
80018594:	c0 c1       	brne	800185ac <__svfscanf_r+0xb44>
80018596:	6a 09       	ld.w	r9,r5[0x0]
80018598:	32 cb       	mov	r11,44
8001859a:	12 98       	mov	r8,r9
8001859c:	76 0a       	ld.w	r10,r11[0x0]
8001859e:	13 89       	ld.ub	r9,r9[0x0]
800185a0:	20 12       	sub	r2,1
800185a2:	f4 09 07 09 	ld.ub	r9,r10[r9]
800185a6:	ed b9 00 03 	bld	r9,0x3
800185aa:	ce 51       	brne	80018574 <__svfscanf_r+0xb0c>
800185ac:	40 3a       	lddsp	r10,sp[0xc]
800185ae:	40 79       	lddsp	r9,sp[0x1c]
800185b0:	f4 04 01 04 	sub	r4,r10,r4
800185b4:	2f f9       	sub	r9,-1
800185b6:	e2 04 00 04 	add	r4,r1,r4
800185ba:	50 79       	stdsp	sp[0x1c],r9
800185bc:	50 34       	stdsp	sp[0xc],r4
800185be:	30 08       	mov	r8,0
800185c0:	a2 88       	st.b	r1[0x0],r8
800185c2:	fe 9f fa 62 	bral	80017a86 <__svfscanf_r+0x1e>
800185c6:	e4 c9 00 01 	sub	r9,r2,1
800185ca:	e4 c8 01 5d 	sub	r8,r2,349
800185ce:	e0 6a 01 5d 	mov	r10,349
800185d2:	e0 49 01 5c 	cp.w	r9,348
800185d6:	f9 b8 08 00 	movls	r8,0
800185da:	f4 02 17 b0 	movhi	r2,r10
800185de:	30 0b       	mov	r11,0
800185e0:	50 c7       	stdsp	sp[0x30],r7
800185e2:	50 b3       	stdsp	sp[0x2c],r3
800185e4:	e8 10 0d 80 	orl	r0,0xd80
800185e8:	50 5b       	stdsp	sp[0x14],r11
800185ea:	fa c1 ff c0 	sub	r1,sp,-64
800185ee:	35 89       	mov	r9,88
800185f0:	40 87       	lddsp	r7,sp[0x20]
800185f2:	10 93       	mov	r3,r8
800185f4:	6a 0a       	ld.w	r10,r5[0x0]
800185f6:	33 98       	mov	r8,57
800185f8:	15 8a       	ld.ub	r10,r10[0x0]
800185fa:	f0 0a 18 00 	cp.b	r10,r8
800185fe:	e0 8b 00 15 	brhi	80018628 <__svfscanf_r+0xbc0>
80018602:	33 8b       	mov	r11,56
80018604:	f6 0a 18 00 	cp.b	r10,r11
80018608:	c4 b2       	brcc	8001869e <__svfscanf_r+0xc36>
8001860a:	33 0b       	mov	r11,48
8001860c:	f6 0a 18 00 	cp.b	r10,r11
80018610:	c2 70       	breq	8001865e <__svfscanf_r+0xbf6>
80018612:	e0 8b 00 41 	brhi	80018694 <__svfscanf_r+0xc2c>
80018616:	32 bb       	mov	r11,43
80018618:	f6 0a 18 00 	cp.b	r10,r11
8001861c:	c4 f0       	breq	800186ba <__svfscanf_r+0xc52>
8001861e:	32 db       	mov	r11,45
80018620:	f6 0a 18 00 	cp.b	r10,r11
80018624:	c7 01       	brne	80018704 <__svfscanf_r+0xc9c>
80018626:	c4 a8       	rjmp	800186ba <__svfscanf_r+0xc52>
80018628:	f2 0a 18 00 	cp.b	r10,r9
8001862c:	c4 c0       	breq	800186c4 <__svfscanf_r+0xc5c>
8001862e:	e0 8b 00 0a 	brhi	80018642 <__svfscanf_r+0xbda>
80018632:	f4 cb 00 41 	sub	r11,r10,65
80018636:	30 58       	mov	r8,5
80018638:	f0 0b 18 00 	cp.b	r11,r8
8001863c:	e0 8b 00 64 	brhi	80018704 <__svfscanf_r+0xc9c>
80018640:	c3 78       	rjmp	800186ae <__svfscanf_r+0xc46>
80018642:	36 1b       	mov	r11,97
80018644:	f6 0a 18 00 	cp.b	r10,r11
80018648:	c5 e3       	brcs	80018704 <__svfscanf_r+0xc9c>
8001864a:	36 68       	mov	r8,102
8001864c:	f0 0a 18 00 	cp.b	r10,r8
80018650:	e0 88 00 2f 	brls	800186ae <__svfscanf_r+0xc46>
80018654:	37 8b       	mov	r11,120
80018656:	f6 0a 18 00 	cp.b	r10,r11
8001865a:	c5 51       	brne	80018704 <__svfscanf_r+0xc9c>
8001865c:	c3 48       	rjmp	800186c4 <__svfscanf_r+0xc5c>
8001865e:	ed b0 00 0b 	bld	r0,0xb
80018662:	c3 b1       	brne	800186d8 <__svfscanf_r+0xc70>
80018664:	00 9b       	mov	r11,r0
80018666:	a9 bb       	sbr	r11,0x9
80018668:	58 07       	cp.w	r7,0
8001866a:	f6 00 17 00 	moveq	r0,r11
8001866e:	f9 b7 00 08 	moveq	r7,8
80018672:	ed b0 00 0a 	bld	r0,0xa
80018676:	c0 41       	brne	8001867e <__svfscanf_r+0xc16>
80018678:	e0 10 fa 7f 	andl	r0,0xfa7f
8001867c:	c2 e8       	rjmp	800186d8 <__svfscanf_r+0xc70>
8001867e:	40 5a       	lddsp	r10,sp[0x14]
80018680:	58 03       	cp.w	r3,0
80018682:	f7 b3 01 01 	subne	r3,1
80018686:	f7 b2 01 ff 	subne	r2,-1
8001868a:	2f fa       	sub	r10,-1
8001868c:	e0 10 fc 7f 	andl	r0,0xfc7f
80018690:	50 5a       	stdsp	sp[0x14],r10
80018692:	c2 48       	rjmp	800186da <__svfscanf_r+0xc72>
80018694:	fe c8 82 74 	sub	r8,pc,-32140
80018698:	f0 07 04 17 	ld.sh	r7,r8[r7<<0x1]
8001869c:	c0 c8       	rjmp	800186b4 <__svfscanf_r+0xc4c>
8001869e:	fe cb 82 7e 	sub	r11,pc,-32130
800186a2:	f6 07 04 17 	ld.sh	r7,r11[r7<<0x1]
800186a6:	58 87       	cp.w	r7,8
800186a8:	e0 89 00 06 	brgt	800186b4 <__svfscanf_r+0xc4c>
800186ac:	c2 c8       	rjmp	80018704 <__svfscanf_r+0xc9c>
800186ae:	58 a7       	cp.w	r7,10
800186b0:	e0 8a 00 2a 	brle	80018704 <__svfscanf_r+0xc9c>
800186b4:	e0 10 f4 7f 	andl	r0,0xf47f
800186b8:	c1 08       	rjmp	800186d8 <__svfscanf_r+0xc70>
800186ba:	ed b0 00 07 	bld	r0,0x7
800186be:	c2 31       	brne	80018704 <__svfscanf_r+0xc9c>
800186c0:	a7 d0       	cbr	r0,0x7
800186c2:	c0 b8       	rjmp	800186d8 <__svfscanf_r+0xc70>
800186c4:	00 9b       	mov	r11,r0
800186c6:	e2 1b 06 00 	andl	r11,0x600,COH
800186ca:	e0 4b 02 00 	cp.w	r11,512
800186ce:	c1 b1       	brne	80018704 <__svfscanf_r+0xc9c>
800186d0:	a9 d0       	cbr	r0,0x9
800186d2:	31 07       	mov	r7,16
800186d4:	e8 10 05 00 	orl	r0,0x500
800186d8:	02 ca       	st.b	r1++,r10
800186da:	6a 1a       	ld.w	r10,r5[0x4]
800186dc:	20 1a       	sub	r10,1
800186de:	8b 1a       	st.w	r5[0x4],r10
800186e0:	58 0a       	cp.w	r10,0
800186e2:	e0 8a 00 07 	brle	800186f0 <__svfscanf_r+0xc88>
800186e6:	6a 0a       	ld.w	r10,r5[0x0]
800186e8:	2f fa       	sub	r10,-1
800186ea:	8b 0a       	st.w	r5[0x0],r10
800186ec:	c0 98       	rjmp	800186fe <__svfscanf_r+0xc96>
800186ee:	d7 03       	nop
800186f0:	50 19       	stdsp	sp[0x4],r9
800186f2:	0a 9b       	mov	r11,r5
800186f4:	40 4c       	lddsp	r12,sp[0x10]
800186f6:	e0 a0 15 85 	rcall	8001b200 <__srefill_r>
800186fa:	40 19       	lddsp	r9,sp[0x4]
800186fc:	c0 41       	brne	80018704 <__svfscanf_r+0xc9c>
800186fe:	20 12       	sub	r2,1
80018700:	fe 91 ff 7a 	brne	800185f4 <__svfscanf_r+0xb8c>
80018704:	50 87       	stdsp	sp[0x20],r7
80018706:	40 b3       	lddsp	r3,sp[0x2c]
80018708:	40 c7       	lddsp	r7,sp[0x30]
8001870a:	ed b0 00 08 	bld	r0,0x8
8001870e:	c1 01       	brne	8001872e <__svfscanf_r+0xcc6>
80018710:	fa c8 ff c0 	sub	r8,sp,-64
80018714:	10 31       	cp.w	r1,r8
80018716:	e0 88 00 07 	brls	80018724 <__svfscanf_r+0xcbc>
8001871a:	0a 9a       	mov	r10,r5
8001871c:	03 7b       	ld.ub	r11,--r1
8001871e:	40 4c       	lddsp	r12,sp[0x10]
80018720:	e0 a0 1f b6 	rcall	8001c68c <_ungetc_r>
80018724:	fa c8 ff c0 	sub	r8,sp,-64
80018728:	10 31       	cp.w	r1,r8
8001872a:	e0 80 04 12 	breq	80018f4e <__svfscanf_r+0x14e6>
8001872e:	00 9a       	mov	r10,r0
80018730:	e2 1a 00 10 	andl	r10,0x10,COH
80018734:	e0 81 01 49 	brne	800189c6 <__svfscanf_r+0xf5e>
80018738:	a2 8a       	st.b	r1[0x0],r10
8001873a:	fa c2 ff c0 	sub	r2,sp,-64
8001873e:	40 89       	lddsp	r9,sp[0x20]
80018740:	04 9b       	mov	r11,r2
80018742:	40 4c       	lddsp	r12,sp[0x10]
80018744:	40 a8       	lddsp	r8,sp[0x28]
80018746:	5d 18       	icall	r8
80018748:	ed b0 00 05 	bld	r0,0x5
8001874c:	c2 b1       	brne	800187a2 <__svfscanf_r+0xd3a>
8001874e:	40 6b       	lddsp	r11,sp[0x18]
80018750:	58 0b       	cp.w	r11,0
80018752:	c1 40       	breq	8001877a <__svfscanf_r+0xd12>
80018754:	0e 34       	cp.w	r4,r7
80018756:	c0 64       	brge	80018762 <__svfscanf_r+0xcfa>
80018758:	fa ca fc d4 	sub	r10,sp,-812
8001875c:	f4 04 00 24 	add	r4,r10,r4<<0x2
80018760:	c1 d9       	rjmp	8001899a <__svfscanf_r+0xf32>
80018762:	fa ca fd 60 	sub	r10,sp,-672
80018766:	0c 99       	mov	r9,r6
80018768:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8001876c:	0e 98       	mov	r8,r7
8001876e:	13 0b       	ld.w	r11,r9++
80018770:	14 ab       	st.w	r10++,r11
80018772:	2f f8       	sub	r8,-1
80018774:	10 34       	cp.w	r4,r8
80018776:	cf c4       	brge	8001876e <__svfscanf_r+0xd06>
80018778:	cf 68       	rjmp	80018964 <__svfscanf_r+0xefc>
8001877a:	e6 c8 ff ff 	sub	r8,r3,-1
8001877e:	0e 33       	cp.w	r3,r7
80018780:	c0 64       	brge	8001878c <__svfscanf_r+0xd24>
80018782:	fa c9 fc d4 	sub	r9,sp,-812
80018786:	f2 04 00 24 	add	r4,r9,r4<<0x2
8001878a:	c0 79       	rjmp	80018998 <__svfscanf_r+0xf30>
8001878c:	6c 04       	ld.w	r4,r6[0x0]
8001878e:	2f c6       	sub	r6,-4
80018790:	59 f7       	cp.w	r7,31
80018792:	e0 89 01 15 	brgt	800189bc <__svfscanf_r+0xf54>
80018796:	10 93       	mov	r3,r8
80018798:	fa cb fc d4 	sub	r11,sp,-812
8001879c:	f6 07 00 28 	add	r8,r11,r7<<0x2
800187a0:	c0 a9       	rjmp	800189b4 <__svfscanf_r+0xf4c>
800187a2:	ed b0 00 02 	bld	r0,0x2
800187a6:	c4 51       	brne	80018830 <__svfscanf_r+0xdc8>
800187a8:	40 6a       	lddsp	r10,sp[0x18]
800187aa:	58 0a       	cp.w	r10,0
800187ac:	c2 50       	breq	800187f6 <__svfscanf_r+0xd8e>
800187ae:	0e 34       	cp.w	r4,r7
800187b0:	c0 64       	brge	800187bc <__svfscanf_r+0xd54>
800187b2:	fa c9 fc d4 	sub	r9,sp,-812
800187b6:	f2 04 00 24 	add	r4,r9,r4<<0x2
800187ba:	c2 78       	rjmp	80018808 <__svfscanf_r+0xda0>
800187bc:	fa ca fd 60 	sub	r10,sp,-672
800187c0:	0c 99       	mov	r9,r6
800187c2:	f4 07 00 2a 	add	r10,r10,r7<<0x2
800187c6:	0e 98       	mov	r8,r7
800187c8:	13 0b       	ld.w	r11,r9++
800187ca:	14 ab       	st.w	r10++,r11
800187cc:	2f f8       	sub	r8,-1
800187ce:	10 34       	cp.w	r4,r8
800187d0:	cf c4       	brge	800187c8 <__svfscanf_r+0xd60>
800187d2:	ee c9 ff ff 	sub	r9,r7,-1
800187d6:	ee 08 11 ff 	rsub	r8,r7,-1
800187da:	f0 c7 ff ff 	sub	r7,r8,-1
800187de:	2f e8       	sub	r8,-2
800187e0:	08 08       	add	r8,r4
800187e2:	08 07       	add	r7,r4
800187e4:	ec 08 00 26 	add	r6,r6,r8<<0x2
800187e8:	f2 07 00 07 	add	r7,r9,r7
800187ec:	fa c8 fd 60 	sub	r8,sp,-672
800187f0:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
800187f4:	c1 c8       	rjmp	8001882c <__svfscanf_r+0xdc4>
800187f6:	e6 c8 ff ff 	sub	r8,r3,-1
800187fa:	0e 33       	cp.w	r3,r7
800187fc:	c0 94       	brge	8001880e <__svfscanf_r+0xda6>
800187fe:	fa cb fc d4 	sub	r11,sp,-812
80018802:	10 93       	mov	r3,r8
80018804:	f6 04 00 24 	add	r4,r11,r4<<0x2
80018808:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8001880c:	c1 08       	rjmp	8001882c <__svfscanf_r+0xdc4>
8001880e:	6c 04       	ld.w	r4,r6[0x0]
80018810:	2f c6       	sub	r6,-4
80018812:	59 f7       	cp.w	r7,31
80018814:	e0 89 00 0b 	brgt	8001882a <__svfscanf_r+0xdc2>
80018818:	10 93       	mov	r3,r8
8001881a:	fa ca fc d4 	sub	r10,sp,-812
8001881e:	f4 07 00 28 	add	r8,r10,r7<<0x2
80018822:	2f f7       	sub	r7,-1
80018824:	f1 44 ff 74 	st.w	r8[-140],r4
80018828:	c0 28       	rjmp	8001882c <__svfscanf_r+0xdc4>
8001882a:	10 93       	mov	r3,r8
8001882c:	a8 0c       	st.h	r4[0x0],r12
8001882e:	cc 98       	rjmp	800189c0 <__svfscanf_r+0xf58>
80018830:	f5 d0 c0 01 	bfextu	r10,r0,0x0,0x1
80018834:	c2 b0       	breq	8001888a <__svfscanf_r+0xe22>
80018836:	40 69       	lddsp	r9,sp[0x18]
80018838:	58 09       	cp.w	r9,0
8001883a:	c1 40       	breq	80018862 <__svfscanf_r+0xdfa>
8001883c:	0e 34       	cp.w	r4,r7
8001883e:	c0 64       	brge	8001884a <__svfscanf_r+0xde2>
80018840:	fa c8 fc d4 	sub	r8,sp,-812
80018844:	f0 04 00 24 	add	r4,r8,r4<<0x2
80018848:	ca 98       	rjmp	8001899a <__svfscanf_r+0xf32>
8001884a:	fa ca fd 60 	sub	r10,sp,-672
8001884e:	0c 99       	mov	r9,r6
80018850:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80018854:	0e 98       	mov	r8,r7
80018856:	13 0b       	ld.w	r11,r9++
80018858:	14 ab       	st.w	r10++,r11
8001885a:	2f f8       	sub	r8,-1
8001885c:	10 34       	cp.w	r4,r8
8001885e:	cf c4       	brge	80018856 <__svfscanf_r+0xdee>
80018860:	c8 28       	rjmp	80018964 <__svfscanf_r+0xefc>
80018862:	e6 c8 ff ff 	sub	r8,r3,-1
80018866:	0e 33       	cp.w	r3,r7
80018868:	c0 64       	brge	80018874 <__svfscanf_r+0xe0c>
8001886a:	fa cb fc d4 	sub	r11,sp,-812
8001886e:	f6 04 00 24 	add	r4,r11,r4<<0x2
80018872:	c9 38       	rjmp	80018998 <__svfscanf_r+0xf30>
80018874:	6c 04       	ld.w	r4,r6[0x0]
80018876:	2f c6       	sub	r6,-4
80018878:	59 f7       	cp.w	r7,31
8001887a:	e0 89 00 a1 	brgt	800189bc <__svfscanf_r+0xf54>
8001887e:	10 93       	mov	r3,r8
80018880:	fa ca fc d4 	sub	r10,sp,-812
80018884:	f4 07 00 28 	add	r8,r10,r7<<0x2
80018888:	c9 68       	rjmp	800189b4 <__svfscanf_r+0xf4c>
8001888a:	e2 10 00 02 	andl	r0,0x2,COH
8001888e:	c5 60       	breq	8001893a <__svfscanf_r+0xed2>
80018890:	fe c8 c4 f0 	sub	r8,pc,-15120
80018894:	40 a9       	lddsp	r9,sp[0x28]
80018896:	10 39       	cp.w	r9,r8
80018898:	c0 71       	brne	800188a6 <__svfscanf_r+0xe3e>
8001889a:	04 9b       	mov	r11,r2
8001889c:	40 89       	lddsp	r9,sp[0x20]
8001889e:	40 4c       	lddsp	r12,sp[0x10]
800188a0:	e0 a0 1e 08 	rcall	8001c4b0 <_strtoull_r>
800188a4:	c0 68       	rjmp	800188b0 <__svfscanf_r+0xe48>
800188a6:	04 9b       	mov	r11,r2
800188a8:	40 89       	lddsp	r9,sp[0x20]
800188aa:	40 4c       	lddsp	r12,sp[0x10]
800188ac:	e0 a0 1c ac 	rcall	8001c204 <_strtoll_r>
800188b0:	40 68       	lddsp	r8,sp[0x18]
800188b2:	58 08       	cp.w	r8,0
800188b4:	c2 50       	breq	800188fe <__svfscanf_r+0xe96>
800188b6:	0e 34       	cp.w	r4,r7
800188b8:	c0 64       	brge	800188c4 <__svfscanf_r+0xe5c>
800188ba:	fa c9 fc d4 	sub	r9,sp,-812
800188be:	f2 04 00 24 	add	r4,r9,r4<<0x2
800188c2:	c2 78       	rjmp	80018910 <__svfscanf_r+0xea8>
800188c4:	fa cc fd 60 	sub	r12,sp,-672
800188c8:	0c 99       	mov	r9,r6
800188ca:	f8 07 00 2c 	add	r12,r12,r7<<0x2
800188ce:	0e 98       	mov	r8,r7
800188d0:	13 0e       	ld.w	lr,r9++
800188d2:	18 ae       	st.w	r12++,lr
800188d4:	2f f8       	sub	r8,-1
800188d6:	10 34       	cp.w	r4,r8
800188d8:	cf c4       	brge	800188d0 <__svfscanf_r+0xe68>
800188da:	ee c9 ff ff 	sub	r9,r7,-1
800188de:	ee 08 11 ff 	rsub	r8,r7,-1
800188e2:	f0 c7 ff ff 	sub	r7,r8,-1
800188e6:	2f e8       	sub	r8,-2
800188e8:	08 08       	add	r8,r4
800188ea:	08 07       	add	r7,r4
800188ec:	ec 08 00 26 	add	r6,r6,r8<<0x2
800188f0:	f2 07 00 07 	add	r7,r9,r7
800188f4:	fa c8 fd 60 	sub	r8,sp,-672
800188f8:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
800188fc:	c1 c8       	rjmp	80018934 <__svfscanf_r+0xecc>
800188fe:	e6 c8 ff ff 	sub	r8,r3,-1
80018902:	0e 33       	cp.w	r3,r7
80018904:	c0 94       	brge	80018916 <__svfscanf_r+0xeae>
80018906:	fa c9 fc d4 	sub	r9,sp,-812
8001890a:	10 93       	mov	r3,r8
8001890c:	f2 04 00 24 	add	r4,r9,r4<<0x2
80018910:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80018914:	c1 08       	rjmp	80018934 <__svfscanf_r+0xecc>
80018916:	6c 04       	ld.w	r4,r6[0x0]
80018918:	2f c6       	sub	r6,-4
8001891a:	59 f7       	cp.w	r7,31
8001891c:	e0 89 00 0b 	brgt	80018932 <__svfscanf_r+0xeca>
80018920:	10 93       	mov	r3,r8
80018922:	fa c9 fc d4 	sub	r9,sp,-812
80018926:	f2 07 00 28 	add	r8,r9,r7<<0x2
8001892a:	2f f7       	sub	r7,-1
8001892c:	f1 44 ff 74 	st.w	r8[-140],r4
80018930:	c0 28       	rjmp	80018934 <__svfscanf_r+0xecc>
80018932:	10 93       	mov	r3,r8
80018934:	89 1a       	st.w	r4[0x4],r10
80018936:	89 0b       	st.w	r4[0x0],r11
80018938:	c4 48       	rjmp	800189c0 <__svfscanf_r+0xf58>
8001893a:	40 68       	lddsp	r8,sp[0x18]
8001893c:	58 08       	cp.w	r8,0
8001893e:	c2 50       	breq	80018988 <__svfscanf_r+0xf20>
80018940:	0e 34       	cp.w	r4,r7
80018942:	c0 64       	brge	8001894e <__svfscanf_r+0xee6>
80018944:	fa cb fc d4 	sub	r11,sp,-812
80018948:	f6 04 00 24 	add	r4,r11,r4<<0x2
8001894c:	c2 78       	rjmp	8001899a <__svfscanf_r+0xf32>
8001894e:	fa ca fd 60 	sub	r10,sp,-672
80018952:	0c 99       	mov	r9,r6
80018954:	f4 07 00 2a 	add	r10,r10,r7<<0x2
80018958:	0e 98       	mov	r8,r7
8001895a:	13 0b       	ld.w	r11,r9++
8001895c:	14 ab       	st.w	r10++,r11
8001895e:	2f f8       	sub	r8,-1
80018960:	10 34       	cp.w	r4,r8
80018962:	cf c4       	brge	8001895a <__svfscanf_r+0xef2>
80018964:	ee c9 ff ff 	sub	r9,r7,-1
80018968:	ee 08 11 ff 	rsub	r8,r7,-1
8001896c:	f0 c7 ff ff 	sub	r7,r8,-1
80018970:	2f e8       	sub	r8,-2
80018972:	08 08       	add	r8,r4
80018974:	08 07       	add	r7,r4
80018976:	ec 08 00 26 	add	r6,r6,r8<<0x2
8001897a:	f2 07 00 07 	add	r7,r9,r7
8001897e:	fa c8 fd 60 	sub	r8,sp,-672
80018982:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
80018986:	c1 c8       	rjmp	800189be <__svfscanf_r+0xf56>
80018988:	e6 c8 ff ff 	sub	r8,r3,-1
8001898c:	0e 33       	cp.w	r3,r7
8001898e:	c0 94       	brge	800189a0 <__svfscanf_r+0xf38>
80018990:	fa ca fc d4 	sub	r10,sp,-812
80018994:	f4 04 00 24 	add	r4,r10,r4<<0x2
80018998:	10 93       	mov	r3,r8
8001899a:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8001899e:	c1 08       	rjmp	800189be <__svfscanf_r+0xf56>
800189a0:	6c 04       	ld.w	r4,r6[0x0]
800189a2:	2f c6       	sub	r6,-4
800189a4:	59 f7       	cp.w	r7,31
800189a6:	e0 89 00 0b 	brgt	800189bc <__svfscanf_r+0xf54>
800189aa:	10 93       	mov	r3,r8
800189ac:	fa c9 fc d4 	sub	r9,sp,-812
800189b0:	f2 07 00 28 	add	r8,r9,r7<<0x2
800189b4:	f1 44 ff 74 	st.w	r8[-140],r4
800189b8:	2f f7       	sub	r7,-1
800189ba:	c0 28       	rjmp	800189be <__svfscanf_r+0xf56>
800189bc:	10 93       	mov	r3,r8
800189be:	89 0c       	st.w	r4[0x0],r12
800189c0:	40 78       	lddsp	r8,sp[0x1c]
800189c2:	2f f8       	sub	r8,-1
800189c4:	50 78       	stdsp	sp[0x1c],r8
800189c6:	40 3b       	lddsp	r11,sp[0xc]
800189c8:	fa c8 ff c0 	sub	r8,sp,-64
800189cc:	40 5a       	lddsp	r10,sp[0x14]
800189ce:	f6 08 01 08 	sub	r8,r11,r8
800189d2:	14 08       	add	r8,r10
800189d4:	e2 08 00 08 	add	r8,r1,r8
800189d8:	50 38       	stdsp	sp[0xc],r8
800189da:	fe 9f f8 56 	bral	80017a86 <__svfscanf_r+0x1e>
800189de:	d7 03       	nop
800189e0:	30 01       	mov	r1,0
800189e2:	e4 c8 00 01 	sub	r8,r2,1
800189e6:	e4 c9 01 5d 	sub	r9,r2,349
800189ea:	e0 48 01 5c 	cp.w	r8,348
800189ee:	e2 09 17 80 	movls	r9,r1
800189f2:	50 b9       	stdsp	sp[0x2c],r9
800189f4:	e0 69 01 5d 	mov	r9,349
800189f8:	50 f7       	stdsp	sp[0x3c],r7
800189fa:	f2 02 17 b0 	movhi	r2,r9
800189fe:	e8 10 07 80 	orl	r0,0x780
80018a02:	fa c8 ff c0 	sub	r8,sp,-64
80018a06:	02 99       	mov	r9,r1
80018a08:	50 51       	stdsp	sp[0x14],r1
80018a0a:	50 d1       	stdsp	sp[0x34],r1
80018a0c:	50 c1       	stdsp	sp[0x30],r1
80018a0e:	50 e1       	stdsp	sp[0x38],r1
80018a10:	10 97       	mov	r7,r8
80018a12:	02 9a       	mov	r10,r1
80018a14:	6a 0b       	ld.w	r11,r5[0x0]
80018a16:	34 e8       	mov	r8,78
80018a18:	17 8b       	ld.ub	r11,r11[0x0]
80018a1a:	f0 0b 18 00 	cp.b	r11,r8
80018a1e:	e0 80 00 86 	breq	80018b2a <__svfscanf_r+0x10c2>
80018a22:	e0 8b 00 36 	brhi	80018a8e <__svfscanf_r+0x1026>
80018a26:	33 9c       	mov	r12,57
80018a28:	f8 0b 18 00 	cp.b	r11,r12
80018a2c:	e0 8b 00 1d 	brhi	80018a66 <__svfscanf_r+0xffe>
80018a30:	33 1c       	mov	r12,49
80018a32:	f8 0b 18 00 	cp.b	r11,r12
80018a36:	c6 d2       	brcc	80018b10 <__svfscanf_r+0x10a8>
80018a38:	32 ec       	mov	r12,46
80018a3a:	f8 0b 18 00 	cp.b	r11,r12
80018a3e:	e0 80 00 c6 	breq	80018bca <__svfscanf_r+0x1162>
80018a42:	e0 8b 00 0c 	brhi	80018a5a <__svfscanf_r+0xff2>
80018a46:	32 bc       	mov	r12,43
80018a48:	f8 0b 18 00 	cp.b	r11,r12
80018a4c:	c6 90       	breq	80018b1e <__svfscanf_r+0x10b6>
80018a4e:	32 dc       	mov	r12,45
80018a50:	f8 0b 18 00 	cp.b	r11,r12
80018a54:	e0 81 00 fa 	brne	80018c48 <__svfscanf_r+0x11e0>
80018a58:	c6 38       	rjmp	80018b1e <__svfscanf_r+0x10b6>
80018a5a:	33 0c       	mov	r12,48
80018a5c:	f8 0b 18 00 	cp.b	r11,r12
80018a60:	e0 81 00 f4 	brne	80018c48 <__svfscanf_r+0x11e0>
80018a64:	c4 98       	rjmp	80018af6 <__svfscanf_r+0x108e>
80018a66:	34 5c       	mov	r12,69
80018a68:	f8 0b 18 00 	cp.b	r11,r12
80018a6c:	e0 80 00 b6 	breq	80018bd8 <__svfscanf_r+0x1170>
80018a70:	e0 8b 00 08 	brhi	80018a80 <__svfscanf_r+0x1018>
80018a74:	34 1c       	mov	r12,65
80018a76:	f8 0b 18 00 	cp.b	r11,r12
80018a7a:	e0 81 00 e7 	brne	80018c48 <__svfscanf_r+0x11e0>
80018a7e:	c7 18       	rjmp	80018b60 <__svfscanf_r+0x10f8>
80018a80:	34 6c       	mov	r12,70
80018a82:	f8 0b 18 00 	cp.b	r11,r12
80018a86:	e0 80 00 90 	breq	80018ba6 <__svfscanf_r+0x113e>
80018a8a:	34 9c       	mov	r12,73
80018a8c:	c2 68       	rjmp	80018ad8 <__svfscanf_r+0x1070>
80018a8e:	36 6c       	mov	r12,102
80018a90:	f8 0b 18 00 	cp.b	r11,r12
80018a94:	e0 80 00 89 	breq	80018ba6 <__svfscanf_r+0x113e>
80018a98:	e0 8b 00 19 	brhi	80018aca <__svfscanf_r+0x1062>
80018a9c:	35 9c       	mov	r12,89
80018a9e:	f8 0b 18 00 	cp.b	r11,r12
80018aa2:	e0 80 00 8e 	breq	80018bbe <__svfscanf_r+0x1156>
80018aa6:	e0 8b 00 08 	brhi	80018ab6 <__svfscanf_r+0x104e>
80018aaa:	35 4c       	mov	r12,84
80018aac:	f8 0b 18 00 	cp.b	r11,r12
80018ab0:	e0 81 00 cc 	brne	80018c48 <__svfscanf_r+0x11e0>
80018ab4:	c7 f8       	rjmp	80018bb2 <__svfscanf_r+0x114a>
80018ab6:	36 1c       	mov	r12,97
80018ab8:	f8 0b 18 00 	cp.b	r11,r12
80018abc:	c5 20       	breq	80018b60 <__svfscanf_r+0x10f8>
80018abe:	36 5c       	mov	r12,101
80018ac0:	f8 0b 18 00 	cp.b	r11,r12
80018ac4:	e0 81 00 c2 	brne	80018c48 <__svfscanf_r+0x11e0>
80018ac8:	c8 88       	rjmp	80018bd8 <__svfscanf_r+0x1170>
80018aca:	36 e8       	mov	r8,110
80018acc:	f0 0b 18 00 	cp.b	r11,r8
80018ad0:	c2 d0       	breq	80018b2a <__svfscanf_r+0x10c2>
80018ad2:	e0 8b 00 08 	brhi	80018ae2 <__svfscanf_r+0x107a>
80018ad6:	36 9c       	mov	r12,105
80018ad8:	f8 0b 18 00 	cp.b	r11,r12
80018adc:	e0 81 00 b6 	brne	80018c48 <__svfscanf_r+0x11e0>
80018ae0:	c4 68       	rjmp	80018b6c <__svfscanf_r+0x1104>
80018ae2:	37 4c       	mov	r12,116
80018ae4:	f8 0b 18 00 	cp.b	r11,r12
80018ae8:	c6 50       	breq	80018bb2 <__svfscanf_r+0x114a>
80018aea:	37 9c       	mov	r12,121
80018aec:	f8 0b 18 00 	cp.b	r11,r12
80018af0:	e0 81 00 ac 	brne	80018c48 <__svfscanf_r+0x11e0>
80018af4:	c6 58       	rjmp	80018bbe <__svfscanf_r+0x1156>
80018af6:	ed b0 00 08 	bld	r0,0x8
80018afa:	c0 b1       	brne	80018b10 <__svfscanf_r+0x10a8>
80018afc:	a7 d0       	cbr	r0,0x7
80018afe:	2f fa       	sub	r10,-1
80018b00:	40 bb       	lddsp	r11,sp[0x2c]
80018b02:	58 0b       	cp.w	r11,0
80018b04:	e0 80 00 89 	breq	80018c16 <__svfscanf_r+0x11ae>
80018b08:	20 1b       	sub	r11,1
80018b0a:	2f f2       	sub	r2,-1
80018b0c:	50 bb       	stdsp	sp[0x2c],r11
80018b0e:	c8 48       	rjmp	80018c16 <__svfscanf_r+0x11ae>
80018b10:	e2 09 00 0c 	add	r12,r1,r9
80018b14:	e0 81 00 9a 	brne	80018c48 <__svfscanf_r+0x11e0>
80018b18:	e0 10 fe 7f 	andl	r0,0xfe7f
80018b1c:	c7 c8       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018b1e:	ed b0 00 07 	bld	r0,0x7
80018b22:	e0 81 00 93 	brne	80018c48 <__svfscanf_r+0x11e0>
80018b26:	a7 d0       	cbr	r0,0x7
80018b28:	c7 68       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018b2a:	58 09       	cp.w	r9,0
80018b2c:	c0 b1       	brne	80018b42 <__svfscanf_r+0x10da>
80018b2e:	00 9c       	mov	r12,r0
80018b30:	e2 1c 07 00 	andl	r12,0x700,COH
80018b34:	e0 4c 07 00 	cp.w	r12,1792
80018b38:	c0 b1       	brne	80018b4e <__svfscanf_r+0x10e6>
80018b3a:	e0 10 f8 7f 	andl	r0,0xf87f
80018b3e:	30 19       	mov	r9,1
80018b40:	c6 a8       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018b42:	30 28       	mov	r8,2
80018b44:	f0 09 18 00 	cp.b	r9,r8
80018b48:	c0 31       	brne	80018b4e <__svfscanf_r+0x10e6>
80018b4a:	30 39       	mov	r9,3
80018b4c:	c6 48       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018b4e:	30 48       	mov	r8,4
80018b50:	f0 01 18 00 	cp.b	r1,r8
80018b54:	5f 0e       	sreq	lr
80018b56:	30 18       	mov	r8,1
80018b58:	f0 01 18 00 	cp.b	r1,r8
80018b5c:	5f 0c       	sreq	r12
80018b5e:	c1 b8       	rjmp	80018b94 <__svfscanf_r+0x112c>
80018b60:	30 18       	mov	r8,1
80018b62:	f0 09 18 00 	cp.b	r9,r8
80018b66:	c7 11       	brne	80018c48 <__svfscanf_r+0x11e0>
80018b68:	30 29       	mov	r9,2
80018b6a:	c5 58       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018b6c:	58 01       	cp.w	r1,0
80018b6e:	c0 b1       	brne	80018b84 <__svfscanf_r+0x111c>
80018b70:	00 9c       	mov	r12,r0
80018b72:	e2 1c 07 00 	andl	r12,0x700,COH
80018b76:	e0 4c 07 00 	cp.w	r12,1792
80018b7a:	c0 51       	brne	80018b84 <__svfscanf_r+0x111c>
80018b7c:	e0 10 f8 7f 	andl	r0,0xf87f
80018b80:	30 11       	mov	r1,1
80018b82:	c4 98       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018b84:	30 58       	mov	r8,5
80018b86:	30 3c       	mov	r12,3
80018b88:	f0 01 18 00 	cp.b	r1,r8
80018b8c:	5f 0e       	sreq	lr
80018b8e:	f8 01 18 00 	cp.b	r1,r12
80018b92:	5f 0c       	sreq	r12
80018b94:	fd ec 10 0c 	or	r12,lr,r12
80018b98:	30 08       	mov	r8,0
80018b9a:	f0 0c 18 00 	cp.b	r12,r8
80018b9e:	c5 50       	breq	80018c48 <__svfscanf_r+0x11e0>
80018ba0:	2f f1       	sub	r1,-1
80018ba2:	5c 51       	castu.b	r1
80018ba4:	c3 88       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018ba6:	30 28       	mov	r8,2
80018ba8:	f0 01 18 00 	cp.b	r1,r8
80018bac:	c4 e1       	brne	80018c48 <__svfscanf_r+0x11e0>
80018bae:	30 31       	mov	r1,3
80018bb0:	c3 28       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018bb2:	30 6c       	mov	r12,6
80018bb4:	f8 01 18 00 	cp.b	r1,r12
80018bb8:	c4 81       	brne	80018c48 <__svfscanf_r+0x11e0>
80018bba:	30 71       	mov	r1,7
80018bbc:	c2 c8       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018bbe:	30 7c       	mov	r12,7
80018bc0:	f8 01 18 00 	cp.b	r1,r12
80018bc4:	c4 21       	brne	80018c48 <__svfscanf_r+0x11e0>
80018bc6:	30 81       	mov	r1,8
80018bc8:	c2 68       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018bca:	ed b0 00 09 	bld	r0,0x9
80018bce:	c3 d1       	brne	80018c48 <__svfscanf_r+0x11e0>
80018bd0:	e0 10 fd 7f 	andl	r0,0xfd7f
80018bd4:	50 ea       	stdsp	sp[0x38],r10
80018bd6:	c1 f8       	rjmp	80018c14 <__svfscanf_r+0x11ac>
80018bd8:	00 9c       	mov	r12,r0
80018bda:	e2 1c 05 00 	andl	r12,0x500,COH
80018bde:	e0 4c 04 00 	cp.w	r12,1024
80018be2:	c0 90       	breq	80018bf4 <__svfscanf_r+0x118c>
80018be4:	58 0a       	cp.w	r10,0
80018be6:	5f 1c       	srne	r12
80018be8:	30 08       	mov	r8,0
80018bea:	f9 e0 02 ac 	and	r12,r12,r0>>0xa
80018bee:	f0 0c 18 00 	cp.b	r12,r8
80018bf2:	c2 b0       	breq	80018c48 <__svfscanf_r+0x11e0>
80018bf4:	ed b0 00 09 	bld	r0,0x9
80018bf8:	fb f8 10 0e 	ld.wne	r8,sp[0x38]
80018bfc:	f5 d8 e1 1a 	subne	r10,r10,r8
80018c00:	fb fa 1a 0d 	st.wne	sp[0x34],r10
80018c04:	fb f7 1a 05 	st.wne	sp[0x14],r7
80018c08:	00 9c       	mov	r12,r0
80018c0a:	30 0a       	mov	r10,0
80018c0c:	e0 10 f8 7f 	andl	r0,0xf87f
80018c10:	e8 10 01 80 	orl	r0,0x180
80018c14:	0e cb       	st.b	r7++,r11
80018c16:	6a 1b       	ld.w	r11,r5[0x4]
80018c18:	40 38       	lddsp	r8,sp[0xc]
80018c1a:	20 1b       	sub	r11,1
80018c1c:	2f f8       	sub	r8,-1
80018c1e:	8b 1b       	st.w	r5[0x4],r11
80018c20:	50 38       	stdsp	sp[0xc],r8
80018c22:	58 0b       	cp.w	r11,0
80018c24:	e0 8a 00 06 	brle	80018c30 <__svfscanf_r+0x11c8>
80018c28:	6a 0b       	ld.w	r11,r5[0x0]
80018c2a:	2f fb       	sub	r11,-1
80018c2c:	8b 0b       	st.w	r5[0x0],r11
80018c2e:	c0 a8       	rjmp	80018c42 <__svfscanf_r+0x11da>
80018c30:	50 2a       	stdsp	sp[0x8],r10
80018c32:	50 19       	stdsp	sp[0x4],r9
80018c34:	0a 9b       	mov	r11,r5
80018c36:	40 4c       	lddsp	r12,sp[0x10]
80018c38:	e0 a0 12 e4 	rcall	8001b200 <__srefill_r>
80018c3c:	40 2a       	lddsp	r10,sp[0x8]
80018c3e:	40 19       	lddsp	r9,sp[0x4]
80018c40:	c0 41       	brne	80018c48 <__svfscanf_r+0x11e0>
80018c42:	20 12       	sub	r2,1
80018c44:	fe 91 fe e8 	brne	80018a14 <__svfscanf_r+0xfac>
80018c48:	50 ca       	stdsp	sp[0x30],r10
80018c4a:	0e 98       	mov	r8,r7
80018c4c:	00 9a       	mov	r10,r0
80018c4e:	40 cb       	lddsp	r11,sp[0x30]
80018c50:	a9 ca       	cbr	r10,0x8
80018c52:	40 f7       	lddsp	r7,sp[0x3c]
80018c54:	20 19       	sub	r9,1
80018c56:	58 0b       	cp.w	r11,0
80018c58:	f4 00 17 10 	movne	r0,r10
80018c5c:	58 19       	cp.w	r9,1
80018c5e:	e0 8b 00 10 	brhi	80018c7e <__svfscanf_r+0x1216>
80018c62:	c0 78       	rjmp	80018c70 <__svfscanf_r+0x1208>
80018c64:	0a 9a       	mov	r10,r5
80018c66:	0d 7b       	ld.ub	r11,--r6
80018c68:	40 4c       	lddsp	r12,sp[0x10]
80018c6a:	e0 a0 1d 11 	rcall	8001c68c <_ungetc_r>
80018c6e:	c0 48       	rjmp	80018c76 <__svfscanf_r+0x120e>
80018c70:	fa c7 ff c0 	sub	r7,sp,-64
80018c74:	10 96       	mov	r6,r8
80018c76:	0e 36       	cp.w	r6,r7
80018c78:	fe 9b ff f6 	brhi	80018c64 <__svfscanf_r+0x11fc>
80018c7c:	c6 99       	rjmp	80018f4e <__svfscanf_r+0x14e6>
80018c7e:	e2 c9 00 01 	sub	r9,r1,1
80018c82:	58 69       	cp.w	r9,6
80018c84:	e0 8b 00 2d 	brhi	80018cde <__svfscanf_r+0x1276>
80018c88:	30 29       	mov	r9,2
80018c8a:	f2 01 18 00 	cp.b	r1,r9
80018c8e:	e0 88 00 21 	brls	80018cd0 <__svfscanf_r+0x1268>
80018c92:	50 b7       	stdsp	sp[0x2c],r7
80018c94:	02 92       	mov	r2,r1
80018c96:	10 97       	mov	r7,r8
80018c98:	c0 a8       	rjmp	80018cac <__svfscanf_r+0x1244>
80018c9a:	0f 7b       	ld.ub	r11,--r7
80018c9c:	0a 9a       	mov	r10,r5
80018c9e:	50 28       	stdsp	sp[0x8],r8
80018ca0:	40 4c       	lddsp	r12,sp[0x10]
80018ca2:	e0 a0 1c f5 	rcall	8001c68c <_ungetc_r>
80018ca6:	20 12       	sub	r2,1
80018ca8:	40 28       	lddsp	r8,sp[0x8]
80018caa:	5c 52       	castu.b	r2
80018cac:	30 3a       	mov	r10,3
80018cae:	f4 02 18 00 	cp.b	r2,r10
80018cb2:	cf 41       	brne	80018c9a <__svfscanf_r+0x1232>
80018cb4:	40 39       	lddsp	r9,sp[0xc]
80018cb6:	20 31       	sub	r1,3
80018cb8:	40 b7       	lddsp	r7,sp[0x2c]
80018cba:	5c 51       	castu.b	r1
80018cbc:	02 19       	sub	r9,r1
80018cbe:	02 18       	sub	r8,r1
80018cc0:	50 39       	stdsp	sp[0xc],r9
80018cc2:	c0 e8       	rjmp	80018cde <__svfscanf_r+0x1276>
80018cc4:	0a 9a       	mov	r10,r5
80018cc6:	0d 7b       	ld.ub	r11,--r6
80018cc8:	40 4c       	lddsp	r12,sp[0x10]
80018cca:	e0 a0 1c e1 	rcall	8001c68c <_ungetc_r>
80018cce:	c0 48       	rjmp	80018cd6 <__svfscanf_r+0x126e>
80018cd0:	fa c7 ff c0 	sub	r7,sp,-64
80018cd4:	10 96       	mov	r6,r8
80018cd6:	0e 36       	cp.w	r6,r7
80018cd8:	fe 9b ff f6 	brhi	80018cc4 <__svfscanf_r+0x125c>
80018cdc:	c3 99       	rjmp	80018f4e <__svfscanf_r+0x14e6>
80018cde:	ed b0 00 08 	bld	r0,0x8
80018ce2:	c3 21       	brne	80018d46 <__svfscanf_r+0x12de>
80018ce4:	00 99       	mov	r9,r0
80018ce6:	e2 19 04 00 	andl	r9,0x400,COH
80018cea:	c0 f0       	breq	80018d08 <__svfscanf_r+0x12a0>
80018cec:	c0 78       	rjmp	80018cfa <__svfscanf_r+0x1292>
80018cee:	0a 9a       	mov	r10,r5
80018cf0:	0d 7b       	ld.ub	r11,--r6
80018cf2:	40 4c       	lddsp	r12,sp[0x10]
80018cf4:	e0 a0 1c cc 	rcall	8001c68c <_ungetc_r>
80018cf8:	c0 48       	rjmp	80018d00 <__svfscanf_r+0x1298>
80018cfa:	fa c7 ff c0 	sub	r7,sp,-64
80018cfe:	10 96       	mov	r6,r8
80018d00:	0e 36       	cp.w	r6,r7
80018d02:	fe 9b ff f6 	brhi	80018cee <__svfscanf_r+0x1286>
80018d06:	c2 49       	rjmp	80018f4e <__svfscanf_r+0x14e6>
80018d08:	40 3b       	lddsp	r11,sp[0xc]
80018d0a:	20 1b       	sub	r11,1
80018d0c:	50 3b       	stdsp	sp[0xc],r11
80018d0e:	11 7b       	ld.ub	r11,--r8
80018d10:	e0 4b 00 45 	cp.w	r11,69
80018d14:	5f 1c       	srne	r12
80018d16:	e0 4b 00 65 	cp.w	r11,101
80018d1a:	5f 1a       	srne	r10
80018d1c:	f9 ea 00 0a 	and	r10,r12,r10
80018d20:	f2 0a 18 00 	cp.b	r10,r9
80018d24:	c0 b0       	breq	80018d3a <__svfscanf_r+0x12d2>
80018d26:	40 3a       	lddsp	r10,sp[0xc]
80018d28:	20 1a       	sub	r10,1
80018d2a:	50 28       	stdsp	sp[0x8],r8
80018d2c:	50 3a       	stdsp	sp[0xc],r10
80018d2e:	40 4c       	lddsp	r12,sp[0x10]
80018d30:	0a 9a       	mov	r10,r5
80018d32:	e0 a0 1c ad 	rcall	8001c68c <_ungetc_r>
80018d36:	40 28       	lddsp	r8,sp[0x8]
80018d38:	11 7b       	ld.ub	r11,--r8
80018d3a:	50 28       	stdsp	sp[0x8],r8
80018d3c:	0a 9a       	mov	r10,r5
80018d3e:	40 4c       	lddsp	r12,sp[0x10]
80018d40:	e0 a0 1c a6 	rcall	8001c68c <_ungetc_r>
80018d44:	40 28       	lddsp	r8,sp[0x8]
80018d46:	00 9a       	mov	r10,r0
80018d48:	e2 1a 00 10 	andl	r10,0x10,COH
80018d4c:	fe 91 f6 9d 	brne	80017a86 <__svfscanf_r+0x1e>
80018d50:	b0 8a       	st.b	r8[0x0],r10
80018d52:	00 99       	mov	r9,r0
80018d54:	e2 19 06 00 	andl	r9,0x600,COH
80018d58:	e0 49 04 00 	cp.w	r9,1024
80018d5c:	c0 81       	brne	80018d6c <__svfscanf_r+0x1304>
80018d5e:	40 cc       	lddsp	r12,sp[0x30]
80018d60:	40 e9       	lddsp	r9,sp[0x38]
80018d62:	12 1c       	sub	r12,r9
80018d64:	c1 f0       	breq	80018da2 <__svfscanf_r+0x133a>
80018d66:	5c 3c       	neg	r12
80018d68:	50 58       	stdsp	sp[0x14],r8
80018d6a:	c0 c8       	rjmp	80018d82 <__svfscanf_r+0x131a>
80018d6c:	40 d8       	lddsp	r8,sp[0x34]
80018d6e:	58 08       	cp.w	r8,0
80018d70:	c1 90       	breq	80018da2 <__svfscanf_r+0x133a>
80018d72:	40 5b       	lddsp	r11,sp[0x14]
80018d74:	30 a9       	mov	r9,10
80018d76:	2f fb       	sub	r11,-1
80018d78:	40 4c       	lddsp	r12,sp[0x10]
80018d7a:	e0 a0 19 ab 	rcall	8001c0d0 <_strtol_r>
80018d7e:	40 db       	lddsp	r11,sp[0x34]
80018d80:	16 1c       	sub	r12,r11
80018d82:	1a dc       	st.w	--sp,r12
80018d84:	fa c8 fe 6a 	sub	r8,sp,-406
80018d88:	40 6a       	lddsp	r10,sp[0x18]
80018d8a:	fa cc fe 69 	sub	r12,sp,-407
80018d8e:	fe cb 89 4a 	sub	r11,pc,-30390
80018d92:	18 3a       	cp.w	r10,r12
80018d94:	f4 0c 17 30 	movlo	r12,r10
80018d98:	f0 0c 17 20 	movhs	r12,r8
80018d9c:	fe b0 e4 54 	rcall	80015644 <sprintf>
80018da0:	2f fd       	sub	sp,-4
80018da2:	30 0a       	mov	r10,0
80018da4:	fa cb ff c0 	sub	r11,sp,-64
80018da8:	40 4c       	lddsp	r12,sp[0x10]
80018daa:	e0 a0 13 61 	rcall	8001b46c <_strtod_r>
80018dae:	14 98       	mov	r8,r10
80018db0:	16 99       	mov	r9,r11
80018db2:	ed b0 00 00 	bld	r0,0x0
80018db6:	c1 91       	brne	80018de8 <__svfscanf_r+0x1380>
80018db8:	40 6b       	lddsp	r11,sp[0x18]
80018dba:	58 0b       	cp.w	r11,0
80018dbc:	c4 40       	breq	80018e44 <__svfscanf_r+0x13dc>
80018dbe:	0e 34       	cp.w	r4,r7
80018dc0:	c0 64       	brge	80018dcc <__svfscanf_r+0x1364>
80018dc2:	fa ca fc d4 	sub	r10,sp,-812
80018dc6:	f4 04 00 24 	add	r4,r10,r4<<0x2
80018dca:	c4 68       	rjmp	80018e56 <__svfscanf_r+0x13ee>
80018dcc:	fa cc fd 60 	sub	r12,sp,-672
80018dd0:	0c 9b       	mov	r11,r6
80018dd2:	f8 07 00 2c 	add	r12,r12,r7<<0x2
80018dd6:	0e 9a       	mov	r10,r7
80018dd8:	10 90       	mov	r0,r8
80018dda:	12 91       	mov	r1,r9
80018ddc:	17 08       	ld.w	r8,r11++
80018dde:	18 a8       	st.w	r12++,r8
80018de0:	2f fa       	sub	r10,-1
80018de2:	14 34       	cp.w	r4,r10
80018de4:	cf c4       	brge	80018ddc <__svfscanf_r+0x1374>
80018de6:	c1 b8       	rjmp	80018e1c <__svfscanf_r+0x13b4>
80018de8:	e2 10 00 02 	andl	r0,0x2,COH
80018dec:	c4 a0       	breq	80018e80 <__svfscanf_r+0x1418>
80018dee:	40 6a       	lddsp	r10,sp[0x18]
80018df0:	58 0a       	cp.w	r10,0
80018df2:	c2 90       	breq	80018e44 <__svfscanf_r+0x13dc>
80018df4:	0e 34       	cp.w	r4,r7
80018df6:	c0 64       	brge	80018e02 <__svfscanf_r+0x139a>
80018df8:	fa cb fc d4 	sub	r11,sp,-812
80018dfc:	f6 04 00 24 	add	r4,r11,r4<<0x2
80018e00:	c2 b8       	rjmp	80018e56 <__svfscanf_r+0x13ee>
80018e02:	fa cc fd 60 	sub	r12,sp,-672
80018e06:	0c 9b       	mov	r11,r6
80018e08:	f8 07 00 2c 	add	r12,r12,r7<<0x2
80018e0c:	0e 9a       	mov	r10,r7
80018e0e:	10 90       	mov	r0,r8
80018e10:	12 91       	mov	r1,r9
80018e12:	17 08       	ld.w	r8,r11++
80018e14:	18 a8       	st.w	r12++,r8
80018e16:	2f fa       	sub	r10,-1
80018e18:	14 34       	cp.w	r4,r10
80018e1a:	cf c4       	brge	80018e12 <__svfscanf_r+0x13aa>
80018e1c:	ee cb ff ff 	sub	r11,r7,-1
80018e20:	ee 0a 11 ff 	rsub	r10,r7,-1
80018e24:	f4 c7 ff ff 	sub	r7,r10,-1
80018e28:	2f ea       	sub	r10,-2
80018e2a:	08 0a       	add	r10,r4
80018e2c:	08 07       	add	r7,r4
80018e2e:	ec 0a 00 26 	add	r6,r6,r10<<0x2
80018e32:	00 98       	mov	r8,r0
80018e34:	fa ca fd 60 	sub	r10,sp,-672
80018e38:	02 99       	mov	r9,r1
80018e3a:	f6 07 00 07 	add	r7,r11,r7
80018e3e:	f4 04 03 24 	ld.w	r4,r10[r4<<0x2]
80018e42:	c1 c8       	rjmp	80018e7a <__svfscanf_r+0x1412>
80018e44:	e6 ca ff ff 	sub	r10,r3,-1
80018e48:	0e 33       	cp.w	r3,r7
80018e4a:	c0 94       	brge	80018e5c <__svfscanf_r+0x13f4>
80018e4c:	fa cb fc d4 	sub	r11,sp,-812
80018e50:	14 93       	mov	r3,r10
80018e52:	f6 04 00 24 	add	r4,r11,r4<<0x2
80018e56:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80018e5a:	c1 08       	rjmp	80018e7a <__svfscanf_r+0x1412>
80018e5c:	6c 04       	ld.w	r4,r6[0x0]
80018e5e:	2f c6       	sub	r6,-4
80018e60:	59 f7       	cp.w	r7,31
80018e62:	e0 89 00 0b 	brgt	80018e78 <__svfscanf_r+0x1410>
80018e66:	14 93       	mov	r3,r10
80018e68:	fa cb fc d4 	sub	r11,sp,-812
80018e6c:	f6 07 00 2a 	add	r10,r11,r7<<0x2
80018e70:	2f f7       	sub	r7,-1
80018e72:	f5 44 ff 74 	st.w	r10[-140],r4
80018e76:	c0 28       	rjmp	80018e7a <__svfscanf_r+0x1412>
80018e78:	14 93       	mov	r3,r10
80018e7a:	e8 e9 00 00 	st.d	r4[0],r8
80018e7e:	c5 a8       	rjmp	80018f32 <__svfscanf_r+0x14ca>
80018e80:	40 6a       	lddsp	r10,sp[0x18]
80018e82:	58 0a       	cp.w	r10,0
80018e84:	c2 90       	breq	80018ed6 <__svfscanf_r+0x146e>
80018e86:	0e 34       	cp.w	r4,r7
80018e88:	c0 64       	brge	80018e94 <__svfscanf_r+0x142c>
80018e8a:	fa cb fc d4 	sub	r11,sp,-812
80018e8e:	f6 04 00 24 	add	r4,r11,r4<<0x2
80018e92:	c2 b8       	rjmp	80018ee8 <__svfscanf_r+0x1480>
80018e94:	fa cc fd 60 	sub	r12,sp,-672
80018e98:	0c 9b       	mov	r11,r6
80018e9a:	f8 07 00 2c 	add	r12,r12,r7<<0x2
80018e9e:	0e 9a       	mov	r10,r7
80018ea0:	10 90       	mov	r0,r8
80018ea2:	12 91       	mov	r1,r9
80018ea4:	17 08       	ld.w	r8,r11++
80018ea6:	18 a8       	st.w	r12++,r8
80018ea8:	2f fa       	sub	r10,-1
80018eaa:	14 34       	cp.w	r4,r10
80018eac:	cf c4       	brge	80018ea4 <__svfscanf_r+0x143c>
80018eae:	ee cb ff ff 	sub	r11,r7,-1
80018eb2:	ee 0a 11 ff 	rsub	r10,r7,-1
80018eb6:	f4 c7 ff ff 	sub	r7,r10,-1
80018eba:	2f ea       	sub	r10,-2
80018ebc:	08 0a       	add	r10,r4
80018ebe:	08 07       	add	r7,r4
80018ec0:	ec 0a 00 26 	add	r6,r6,r10<<0x2
80018ec4:	00 98       	mov	r8,r0
80018ec6:	fa ca fd 60 	sub	r10,sp,-672
80018eca:	02 99       	mov	r9,r1
80018ecc:	f6 07 00 07 	add	r7,r11,r7
80018ed0:	f4 04 03 24 	ld.w	r4,r10[r4<<0x2]
80018ed4:	c1 d8       	rjmp	80018f0e <__svfscanf_r+0x14a6>
80018ed6:	e6 ca ff ff 	sub	r10,r3,-1
80018eda:	0e 33       	cp.w	r3,r7
80018edc:	c0 a4       	brge	80018ef0 <__svfscanf_r+0x1488>
80018ede:	fa cb fc d4 	sub	r11,sp,-812
80018ee2:	14 93       	mov	r3,r10
80018ee4:	f6 04 00 24 	add	r4,r11,r4<<0x2
80018ee8:	e8 f4 ff 74 	ld.w	r4,r4[-140]
80018eec:	c1 18       	rjmp	80018f0e <__svfscanf_r+0x14a6>
80018eee:	d7 03       	nop
80018ef0:	6c 04       	ld.w	r4,r6[0x0]
80018ef2:	2f c6       	sub	r6,-4
80018ef4:	59 f7       	cp.w	r7,31
80018ef6:	e0 89 00 0b 	brgt	80018f0c <__svfscanf_r+0x14a4>
80018efa:	14 93       	mov	r3,r10
80018efc:	fa cb fc d4 	sub	r11,sp,-812
80018f00:	f6 07 00 2a 	add	r10,r11,r7<<0x2
80018f04:	2f f7       	sub	r7,-1
80018f06:	f5 44 ff 74 	st.w	r10[-140],r4
80018f0a:	c0 28       	rjmp	80018f0e <__svfscanf_r+0x14a6>
80018f0c:	14 93       	mov	r3,r10
80018f0e:	10 9a       	mov	r10,r8
80018f10:	12 9b       	mov	r11,r9
80018f12:	50 19       	stdsp	sp[0x4],r9
80018f14:	50 28       	stdsp	sp[0x8],r8
80018f16:	e0 a0 12 10 	rcall	8001b336 <__isnand>
80018f1a:	40 19       	lddsp	r9,sp[0x4]
80018f1c:	40 28       	lddsp	r8,sp[0x8]
80018f1e:	c0 50       	breq	80018f28 <__svfscanf_r+0x14c0>
80018f20:	30 0c       	mov	r12,0
80018f22:	e0 a0 12 61 	rcall	8001b3e4 <nanf>
80018f26:	c0 58       	rjmp	80018f30 <__svfscanf_r+0x14c8>
80018f28:	10 9a       	mov	r10,r8
80018f2a:	12 9b       	mov	r11,r9
80018f2c:	e0 a0 23 a2 	rcall	8001d670 <__avr32_f64_to_f32>
80018f30:	89 0c       	st.w	r4[0x0],r12
80018f32:	40 7a       	lddsp	r10,sp[0x1c]
80018f34:	2f fa       	sub	r10,-1
80018f36:	50 7a       	stdsp	sp[0x1c],r10
80018f38:	fe 9f f5 a7 	bral	80017a86 <__svfscanf_r+0x1e>
80018f3c:	40 79       	lddsp	r9,sp[0x1c]
80018f3e:	58 09       	cp.w	r9,0
80018f40:	c0 50       	breq	80018f4a <__svfscanf_r+0x14e2>
80018f42:	8a 68       	ld.sh	r8,r5[0xc]
80018f44:	ed b8 00 06 	bld	r8,0x6
80018f48:	c0 31       	brne	80018f4e <__svfscanf_r+0x14e6>
80018f4a:	3f f8       	mov	r8,-1
80018f4c:	50 78       	stdsp	sp[0x1c],r8
80018f4e:	40 7c       	lddsp	r12,sp[0x1c]
80018f50:	fe 3d fc d4 	sub	sp,-812
80018f54:	d8 32       	popm	r0-r7,pc
80018f56:	d7 03       	nop

80018f58 <__swsetup_r>:
80018f58:	d4 21       	pushm	r4-r7,lr
80018f5a:	e0 68 01 20 	mov	r8,288
80018f5e:	18 96       	mov	r6,r12
80018f60:	16 97       	mov	r7,r11
80018f62:	70 0c       	ld.w	r12,r8[0x0]
80018f64:	58 0c       	cp.w	r12,0
80018f66:	c0 60       	breq	80018f72 <__swsetup_r+0x1a>
80018f68:	78 68       	ld.w	r8,r12[0x18]
80018f6a:	58 08       	cp.w	r8,0
80018f6c:	c0 31       	brne	80018f72 <__swsetup_r+0x1a>
80018f6e:	e0 a0 07 d3 	rcall	80019f14 <__sinit>
80018f72:	fe c8 8b 16 	sub	r8,pc,-29930
80018f76:	10 37       	cp.w	r7,r8
80018f78:	c0 61       	brne	80018f84 <__swsetup_r+0x2c>
80018f7a:	e0 68 01 20 	mov	r8,288
80018f7e:	70 08       	ld.w	r8,r8[0x0]
80018f80:	70 07       	ld.w	r7,r8[0x0]
80018f82:	c1 28       	rjmp	80018fa6 <__swsetup_r+0x4e>
80018f84:	fe c8 8b 08 	sub	r8,pc,-29944
80018f88:	10 37       	cp.w	r7,r8
80018f8a:	c0 61       	brne	80018f96 <__swsetup_r+0x3e>
80018f8c:	e0 68 01 20 	mov	r8,288
80018f90:	70 08       	ld.w	r8,r8[0x0]
80018f92:	70 17       	ld.w	r7,r8[0x4]
80018f94:	c0 98       	rjmp	80018fa6 <__swsetup_r+0x4e>
80018f96:	fe c8 8a fa 	sub	r8,pc,-29958
80018f9a:	10 37       	cp.w	r7,r8
80018f9c:	c0 51       	brne	80018fa6 <__swsetup_r+0x4e>
80018f9e:	e0 68 01 20 	mov	r8,288
80018fa2:	70 08       	ld.w	r8,r8[0x0]
80018fa4:	70 27       	ld.w	r7,r8[0x8]
80018fa6:	8e 68       	ld.sh	r8,r7[0xc]
80018fa8:	ed b8 00 03 	bld	r8,0x3
80018fac:	c1 e0       	breq	80018fe8 <__swsetup_r+0x90>
80018fae:	ed b8 00 04 	bld	r8,0x4
80018fb2:	c3 e1       	brne	8001902e <__swsetup_r+0xd6>
80018fb4:	ed b8 00 02 	bld	r8,0x2
80018fb8:	c1 51       	brne	80018fe2 <__swsetup_r+0x8a>
80018fba:	6e db       	ld.w	r11,r7[0x34]
80018fbc:	58 0b       	cp.w	r11,0
80018fbe:	c0 a0       	breq	80018fd2 <__swsetup_r+0x7a>
80018fc0:	ee c8 ff bc 	sub	r8,r7,-68
80018fc4:	10 3b       	cp.w	r11,r8
80018fc6:	c0 40       	breq	80018fce <__swsetup_r+0x76>
80018fc8:	0c 9c       	mov	r12,r6
80018fca:	e0 a0 08 99 	rcall	8001a0fc <_free_r>
80018fce:	30 08       	mov	r8,0
80018fd0:	8f d8       	st.w	r7[0x34],r8
80018fd2:	8e 68       	ld.sh	r8,r7[0xc]
80018fd4:	e0 18 ff db 	andl	r8,0xffdb
80018fd8:	ae 68       	st.h	r7[0xc],r8
80018fda:	30 08       	mov	r8,0
80018fdc:	8f 18       	st.w	r7[0x4],r8
80018fde:	6e 48       	ld.w	r8,r7[0x10]
80018fe0:	8f 08       	st.w	r7[0x0],r8
80018fe2:	8e 68       	ld.sh	r8,r7[0xc]
80018fe4:	a3 b8       	sbr	r8,0x3
80018fe6:	ae 68       	st.h	r7[0xc],r8
80018fe8:	6e 48       	ld.w	r8,r7[0x10]
80018fea:	58 08       	cp.w	r8,0
80018fec:	c0 b1       	brne	80019002 <__swsetup_r+0xaa>
80018fee:	8e 68       	ld.sh	r8,r7[0xc]
80018ff0:	e2 18 02 80 	andl	r8,0x280,COH
80018ff4:	e0 48 02 00 	cp.w	r8,512
80018ff8:	c0 50       	breq	80019002 <__swsetup_r+0xaa>
80018ffa:	0c 9c       	mov	r12,r6
80018ffc:	0e 9b       	mov	r11,r7
80018ffe:	e0 a0 0a ed 	rcall	8001a5d8 <__smakebuf_r>
80019002:	8e 69       	ld.sh	r9,r7[0xc]
80019004:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80019008:	c0 70       	breq	80019016 <__swsetup_r+0xbe>
8001900a:	30 08       	mov	r8,0
8001900c:	8f 28       	st.w	r7[0x8],r8
8001900e:	6e 58       	ld.w	r8,r7[0x14]
80019010:	5c 38       	neg	r8
80019012:	8f 68       	st.w	r7[0x18],r8
80019014:	c0 68       	rjmp	80019020 <__swsetup_r+0xc8>
80019016:	ed b9 00 01 	bld	r9,0x1
8001901a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8001901e:	8f 28       	st.w	r7[0x8],r8
80019020:	6e 48       	ld.w	r8,r7[0x10]
80019022:	58 08       	cp.w	r8,0
80019024:	c0 61       	brne	80019030 <__swsetup_r+0xd8>
80019026:	8e 68       	ld.sh	r8,r7[0xc]
80019028:	ed b8 00 07 	bld	r8,0x7
8001902c:	c0 21       	brne	80019030 <__swsetup_r+0xd8>
8001902e:	dc 2a       	popm	r4-r7,pc,r12=-1
80019030:	d8 2a       	popm	r4-r7,pc,r12=0
80019032:	d7 03       	nop

80019034 <quorem>:
80019034:	d4 31       	pushm	r0-r7,lr
80019036:	20 2d       	sub	sp,8
80019038:	18 97       	mov	r7,r12
8001903a:	78 48       	ld.w	r8,r12[0x10]
8001903c:	76 46       	ld.w	r6,r11[0x10]
8001903e:	0c 38       	cp.w	r8,r6
80019040:	c0 34       	brge	80019046 <quorem+0x12>
80019042:	30 0c       	mov	r12,0
80019044:	c8 58       	rjmp	8001914e <quorem+0x11a>
80019046:	ec c2 ff fc 	sub	r2,r6,-4
8001904a:	f6 c3 ff ec 	sub	r3,r11,-20
8001904e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80019052:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80019056:	2f f9       	sub	r9,-1
80019058:	20 16       	sub	r6,1
8001905a:	f8 09 0d 08 	divu	r8,r12,r9
8001905e:	f6 02 00 22 	add	r2,r11,r2<<0x2
80019062:	ee c4 ff ec 	sub	r4,r7,-20
80019066:	10 95       	mov	r5,r8
80019068:	58 08       	cp.w	r8,0
8001906a:	c4 10       	breq	800190ec <quorem+0xb8>
8001906c:	30 09       	mov	r9,0
8001906e:	06 9a       	mov	r10,r3
80019070:	08 98       	mov	r8,r4
80019072:	12 91       	mov	r1,r9
80019074:	50 0b       	stdsp	sp[0x0],r11
80019076:	70 0e       	ld.w	lr,r8[0x0]
80019078:	b1 8e       	lsr	lr,0x10
8001907a:	50 1e       	stdsp	sp[0x4],lr
8001907c:	15 0e       	ld.w	lr,r10++
8001907e:	fc 00 16 10 	lsr	r0,lr,0x10
80019082:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80019086:	ea 0e 03 41 	mac	r1,r5,lr
8001908a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8001908e:	b1 81       	lsr	r1,0x10
80019090:	40 1b       	lddsp	r11,sp[0x4]
80019092:	ea 00 02 40 	mul	r0,r5,r0
80019096:	e2 00 00 00 	add	r0,r1,r0
8001909a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8001909e:	02 1b       	sub	r11,r1
800190a0:	50 1b       	stdsp	sp[0x4],r11
800190a2:	70 0b       	ld.w	r11,r8[0x0]
800190a4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800190a8:	02 09       	add	r9,r1
800190aa:	f2 0e 01 0e 	sub	lr,r9,lr
800190ae:	b0 1e       	st.h	r8[0x2],lr
800190b0:	fc 09 14 10 	asr	r9,lr,0x10
800190b4:	40 1e       	lddsp	lr,sp[0x4]
800190b6:	fc 09 00 09 	add	r9,lr,r9
800190ba:	b0 09       	st.h	r8[0x0],r9
800190bc:	e0 01 16 10 	lsr	r1,r0,0x10
800190c0:	2f c8       	sub	r8,-4
800190c2:	b1 49       	asr	r9,0x10
800190c4:	04 3a       	cp.w	r10,r2
800190c6:	fe 98 ff d8 	brls	80019076 <quorem+0x42>
800190ca:	40 0b       	lddsp	r11,sp[0x0]
800190cc:	58 0c       	cp.w	r12,0
800190ce:	c0 f1       	brne	800190ec <quorem+0xb8>
800190d0:	ec c8 ff fb 	sub	r8,r6,-5
800190d4:	ee 08 00 28 	add	r8,r7,r8<<0x2
800190d8:	c0 28       	rjmp	800190dc <quorem+0xa8>
800190da:	20 16       	sub	r6,1
800190dc:	20 48       	sub	r8,4
800190de:	08 38       	cp.w	r8,r4
800190e0:	e0 88 00 05 	brls	800190ea <quorem+0xb6>
800190e4:	70 09       	ld.w	r9,r8[0x0]
800190e6:	58 09       	cp.w	r9,0
800190e8:	cf 90       	breq	800190da <quorem+0xa6>
800190ea:	8f 46       	st.w	r7[0x10],r6
800190ec:	0e 9c       	mov	r12,r7
800190ee:	e0 a0 0b a2 	rcall	8001a832 <__mcmp>
800190f2:	c2 d5       	brlt	8001914c <quorem+0x118>
800190f4:	2f f5       	sub	r5,-1
800190f6:	08 98       	mov	r8,r4
800190f8:	30 09       	mov	r9,0
800190fa:	07 0b       	ld.w	r11,r3++
800190fc:	f6 0a 16 10 	lsr	r10,r11,0x10
80019100:	70 0c       	ld.w	r12,r8[0x0]
80019102:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80019106:	f8 0e 16 10 	lsr	lr,r12,0x10
8001910a:	14 1e       	sub	lr,r10
8001910c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80019110:	16 1a       	sub	r10,r11
80019112:	12 0a       	add	r10,r9
80019114:	b0 1a       	st.h	r8[0x2],r10
80019116:	b1 4a       	asr	r10,0x10
80019118:	fc 0a 00 09 	add	r9,lr,r10
8001911c:	b0 09       	st.h	r8[0x0],r9
8001911e:	2f c8       	sub	r8,-4
80019120:	b1 49       	asr	r9,0x10
80019122:	04 33       	cp.w	r3,r2
80019124:	fe 98 ff eb 	brls	800190fa <quorem+0xc6>
80019128:	ec c8 ff fb 	sub	r8,r6,-5
8001912c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80019130:	58 09       	cp.w	r9,0
80019132:	c0 d1       	brne	8001914c <quorem+0x118>
80019134:	ee 08 00 28 	add	r8,r7,r8<<0x2
80019138:	c0 28       	rjmp	8001913c <quorem+0x108>
8001913a:	20 16       	sub	r6,1
8001913c:	20 48       	sub	r8,4
8001913e:	08 38       	cp.w	r8,r4
80019140:	e0 88 00 05 	brls	8001914a <quorem+0x116>
80019144:	70 09       	ld.w	r9,r8[0x0]
80019146:	58 09       	cp.w	r9,0
80019148:	cf 90       	breq	8001913a <quorem+0x106>
8001914a:	8f 46       	st.w	r7[0x10],r6
8001914c:	0a 9c       	mov	r12,r5
8001914e:	2f ed       	sub	sp,-8
80019150:	d8 32       	popm	r0-r7,pc
80019152:	d7 03       	nop

80019154 <_dtoa_r>:
80019154:	d4 31       	pushm	r0-r7,lr
80019156:	21 ad       	sub	sp,104
80019158:	fa c4 ff 74 	sub	r4,sp,-140
8001915c:	18 97       	mov	r7,r12
8001915e:	16 95       	mov	r5,r11
80019160:	68 2c       	ld.w	r12,r4[0x8]
80019162:	50 c9       	stdsp	sp[0x30],r9
80019164:	68 16       	ld.w	r6,r4[0x4]
80019166:	68 09       	ld.w	r9,r4[0x0]
80019168:	50 e8       	stdsp	sp[0x38],r8
8001916a:	14 94       	mov	r4,r10
8001916c:	51 2c       	stdsp	sp[0x48],r12
8001916e:	fa e5 00 08 	st.d	sp[8],r4
80019172:	51 59       	stdsp	sp[0x54],r9
80019174:	6e 95       	ld.w	r5,r7[0x24]
80019176:	58 05       	cp.w	r5,0
80019178:	c0 91       	brne	8001918a <_dtoa_r+0x36>
8001917a:	31 0c       	mov	r12,16
8001917c:	fe b0 df 6e 	rcall	80015058 <malloc>
80019180:	99 35       	st.w	r12[0xc],r5
80019182:	8f 9c       	st.w	r7[0x24],r12
80019184:	99 15       	st.w	r12[0x4],r5
80019186:	99 25       	st.w	r12[0x8],r5
80019188:	99 05       	st.w	r12[0x0],r5
8001918a:	6e 99       	ld.w	r9,r7[0x24]
8001918c:	72 08       	ld.w	r8,r9[0x0]
8001918e:	58 08       	cp.w	r8,0
80019190:	c0 f0       	breq	800191ae <_dtoa_r+0x5a>
80019192:	72 1a       	ld.w	r10,r9[0x4]
80019194:	91 1a       	st.w	r8[0x4],r10
80019196:	30 1a       	mov	r10,1
80019198:	72 19       	ld.w	r9,r9[0x4]
8001919a:	f4 09 09 49 	lsl	r9,r10,r9
8001919e:	10 9b       	mov	r11,r8
800191a0:	91 29       	st.w	r8[0x8],r9
800191a2:	0e 9c       	mov	r12,r7
800191a4:	e0 a0 0c 36 	rcall	8001aa10 <_Bfree>
800191a8:	6e 98       	ld.w	r8,r7[0x24]
800191aa:	30 09       	mov	r9,0
800191ac:	91 09       	st.w	r8[0x0],r9
800191ae:	40 28       	lddsp	r8,sp[0x8]
800191b0:	10 94       	mov	r4,r8
800191b2:	58 08       	cp.w	r8,0
800191b4:	c0 64       	brge	800191c0 <_dtoa_r+0x6c>
800191b6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800191ba:	50 28       	stdsp	sp[0x8],r8
800191bc:	30 18       	mov	r8,1
800191be:	c0 28       	rjmp	800191c2 <_dtoa_r+0x6e>
800191c0:	30 08       	mov	r8,0
800191c2:	8d 08       	st.w	r6[0x0],r8
800191c4:	fc 1c 7f f0 	movh	r12,0x7ff0
800191c8:	40 26       	lddsp	r6,sp[0x8]
800191ca:	0c 98       	mov	r8,r6
800191cc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800191d0:	18 38       	cp.w	r8,r12
800191d2:	c2 01       	brne	80019212 <_dtoa_r+0xbe>
800191d4:	e0 68 27 0f 	mov	r8,9999
800191d8:	41 5b       	lddsp	r11,sp[0x54]
800191da:	97 08       	st.w	r11[0x0],r8
800191dc:	40 3a       	lddsp	r10,sp[0xc]
800191de:	58 0a       	cp.w	r10,0
800191e0:	c0 71       	brne	800191ee <_dtoa_r+0x9a>
800191e2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800191e6:	c0 41       	brne	800191ee <_dtoa_r+0x9a>
800191e8:	fe cc 8d 9c 	sub	r12,pc,-29284
800191ec:	c0 38       	rjmp	800191f2 <_dtoa_r+0x9e>
800191ee:	fe cc 8d 96 	sub	r12,pc,-29290
800191f2:	41 29       	lddsp	r9,sp[0x48]
800191f4:	58 09       	cp.w	r9,0
800191f6:	e0 80 05 9a 	breq	80019d2a <_dtoa_r+0xbd6>
800191fa:	f8 c8 ff fd 	sub	r8,r12,-3
800191fe:	f8 c9 ff f8 	sub	r9,r12,-8
80019202:	11 8b       	ld.ub	r11,r8[0x0]
80019204:	30 0a       	mov	r10,0
80019206:	41 25       	lddsp	r5,sp[0x48]
80019208:	f4 0b 18 00 	cp.b	r11,r10
8001920c:	f2 08 17 10 	movne	r8,r9
80019210:	c1 68       	rjmp	8001923c <_dtoa_r+0xe8>
80019212:	fa ea 00 08 	ld.d	r10,sp[8]
80019216:	30 08       	mov	r8,0
80019218:	fa eb 00 3c 	st.d	sp[60],r10
8001921c:	30 09       	mov	r9,0
8001921e:	e0 a0 20 21 	rcall	8001d260 <__avr32_f64_cmp_eq>
80019222:	c1 00       	breq	80019242 <_dtoa_r+0xee>
80019224:	30 18       	mov	r8,1
80019226:	41 5a       	lddsp	r10,sp[0x54]
80019228:	95 08       	st.w	r10[0x0],r8
8001922a:	fe cc 8f 2e 	sub	r12,pc,-28882
8001922e:	41 29       	lddsp	r9,sp[0x48]
80019230:	f8 08 00 08 	add	r8,r12,r8
80019234:	58 09       	cp.w	r9,0
80019236:	e0 80 05 7a 	breq	80019d2a <_dtoa_r+0xbd6>
8001923a:	12 95       	mov	r5,r9
8001923c:	8b 08       	st.w	r5[0x0],r8
8001923e:	e0 8f 05 76 	bral	80019d2a <_dtoa_r+0xbd6>
80019242:	fa c8 ff 9c 	sub	r8,sp,-100
80019246:	fa c9 ff a0 	sub	r9,sp,-96
8001924a:	fa ea 00 3c 	ld.d	r10,sp[60]
8001924e:	0e 9c       	mov	r12,r7
80019250:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80019254:	e0 a0 0c 30 	rcall	8001aab4 <__d2b>
80019258:	18 93       	mov	r3,r12
8001925a:	58 05       	cp.w	r5,0
8001925c:	c0 d0       	breq	80019276 <_dtoa_r+0x122>
8001925e:	fa ea 00 3c 	ld.d	r10,sp[60]
80019262:	30 04       	mov	r4,0
80019264:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80019268:	ea c5 03 ff 	sub	r5,r5,1023
8001926c:	10 9b       	mov	r11,r8
8001926e:	51 74       	stdsp	sp[0x5c],r4
80019270:	ea 1b 3f f0 	orh	r11,0x3ff0
80019274:	c2 58       	rjmp	800192be <_dtoa_r+0x16a>
80019276:	41 88       	lddsp	r8,sp[0x60]
80019278:	41 9c       	lddsp	r12,sp[0x64]
8001927a:	10 0c       	add	r12,r8
8001927c:	f8 c5 fb ce 	sub	r5,r12,-1074
80019280:	e0 45 00 20 	cp.w	r5,32
80019284:	e0 8a 00 0e 	brle	800192a0 <_dtoa_r+0x14c>
80019288:	f8 cc fb ee 	sub	r12,r12,-1042
8001928c:	40 3b       	lddsp	r11,sp[0xc]
8001928e:	ea 08 11 40 	rsub	r8,r5,64
80019292:	f6 0c 0a 4c 	lsr	r12,r11,r12
80019296:	ec 08 09 46 	lsl	r6,r6,r8
8001929a:	0c 4c       	or	r12,r6
8001929c:	c0 78       	rjmp	800192aa <_dtoa_r+0x156>
8001929e:	d7 03       	nop
800192a0:	ea 0c 11 20 	rsub	r12,r5,32
800192a4:	40 3a       	lddsp	r10,sp[0xc]
800192a6:	f4 0c 09 4c 	lsl	r12,r10,r12
800192aa:	fe b0 dc d8 	rcall	80014c5a <__avr32_u32_to_f64>
800192ae:	fc 18 fe 10 	movh	r8,0xfe10
800192b2:	30 19       	mov	r9,1
800192b4:	ea c5 04 33 	sub	r5,r5,1075
800192b8:	f0 0b 00 0b 	add	r11,r8,r11
800192bc:	51 79       	stdsp	sp[0x5c],r9
800192be:	30 08       	mov	r8,0
800192c0:	fc 19 3f f8 	movh	r9,0x3ff8
800192c4:	e0 a0 1e 78 	rcall	8001cfb4 <__avr32_f64_sub>
800192c8:	e0 68 43 61 	mov	r8,17249
800192cc:	ea 18 63 6f 	orh	r8,0x636f
800192d0:	e0 69 87 a7 	mov	r9,34727
800192d4:	ea 19 3f d2 	orh	r9,0x3fd2
800192d8:	fe b0 db c2 	rcall	80014a5c <__avr32_f64_mul>
800192dc:	e0 68 c8 b3 	mov	r8,51379
800192e0:	ea 18 8b 60 	orh	r8,0x8b60
800192e4:	e0 69 8a 28 	mov	r9,35368
800192e8:	ea 19 3f c6 	orh	r9,0x3fc6
800192ec:	e0 a0 1f 32 	rcall	8001d150 <__avr32_f64_add>
800192f0:	0a 9c       	mov	r12,r5
800192f2:	14 90       	mov	r0,r10
800192f4:	16 91       	mov	r1,r11
800192f6:	fe b0 dc b6 	rcall	80014c62 <__avr32_s32_to_f64>
800192fa:	e0 68 79 fb 	mov	r8,31227
800192fe:	ea 18 50 9f 	orh	r8,0x509f
80019302:	e0 69 44 13 	mov	r9,17427
80019306:	ea 19 3f d3 	orh	r9,0x3fd3
8001930a:	fe b0 db a9 	rcall	80014a5c <__avr32_f64_mul>
8001930e:	14 98       	mov	r8,r10
80019310:	16 99       	mov	r9,r11
80019312:	00 9a       	mov	r10,r0
80019314:	02 9b       	mov	r11,r1
80019316:	e0 a0 1f 1d 	rcall	8001d150 <__avr32_f64_add>
8001931a:	14 90       	mov	r0,r10
8001931c:	16 91       	mov	r1,r11
8001931e:	fe b0 dc 8b 	rcall	80014c34 <__avr32_f64_to_s32>
80019322:	30 08       	mov	r8,0
80019324:	18 96       	mov	r6,r12
80019326:	30 09       	mov	r9,0
80019328:	00 9a       	mov	r10,r0
8001932a:	02 9b       	mov	r11,r1
8001932c:	e0 a0 1f e1 	rcall	8001d2ee <__avr32_f64_cmp_lt>
80019330:	c0 c0       	breq	80019348 <_dtoa_r+0x1f4>
80019332:	0c 9c       	mov	r12,r6
80019334:	fe b0 dc 97 	rcall	80014c62 <__avr32_s32_to_f64>
80019338:	14 98       	mov	r8,r10
8001933a:	16 99       	mov	r9,r11
8001933c:	00 9a       	mov	r10,r0
8001933e:	02 9b       	mov	r11,r1
80019340:	e0 a0 1f 90 	rcall	8001d260 <__avr32_f64_cmp_eq>
80019344:	f7 b6 00 01 	subeq	r6,1
80019348:	59 66       	cp.w	r6,22
8001934a:	e0 88 00 05 	brls	80019354 <_dtoa_r+0x200>
8001934e:	30 18       	mov	r8,1
80019350:	51 48       	stdsp	sp[0x50],r8
80019352:	c1 38       	rjmp	80019378 <_dtoa_r+0x224>
80019354:	fe c8 8e 4c 	sub	r8,pc,-29108
80019358:	fa ea 00 3c 	ld.d	r10,sp[60]
8001935c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80019360:	e0 a0 1f c7 	rcall	8001d2ee <__avr32_f64_cmp_lt>
80019364:	f9 b4 00 00 	moveq	r4,0
80019368:	fb f4 0a 14 	st.weq	sp[0x50],r4
8001936c:	f7 b6 01 01 	subne	r6,1
80019370:	f9 bc 01 00 	movne	r12,0
80019374:	fb fc 1a 14 	st.wne	sp[0x50],r12
80019378:	41 90       	lddsp	r0,sp[0x64]
8001937a:	20 10       	sub	r0,1
8001937c:	0a 10       	sub	r0,r5
8001937e:	c0 46       	brmi	80019386 <_dtoa_r+0x232>
80019380:	50 40       	stdsp	sp[0x10],r0
80019382:	30 00       	mov	r0,0
80019384:	c0 48       	rjmp	8001938c <_dtoa_r+0x238>
80019386:	30 0b       	mov	r11,0
80019388:	5c 30       	neg	r0
8001938a:	50 4b       	stdsp	sp[0x10],r11
8001938c:	ec 02 11 00 	rsub	r2,r6,0
80019390:	58 06       	cp.w	r6,0
80019392:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80019396:	f5 d6 e4 0a 	addge	r10,r10,r6
8001939a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8001939e:	fb f6 4a 11 	st.wge	sp[0x44],r6
800193a2:	f9 b2 04 00 	movge	r2,0
800193a6:	e1 d6 e5 10 	sublt	r0,r0,r6
800193aa:	f9 b9 05 00 	movlt	r9,0
800193ae:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800193b2:	40 c8       	lddsp	r8,sp[0x30]
800193b4:	58 98       	cp.w	r8,9
800193b6:	e0 8b 00 20 	brhi	800193f6 <_dtoa_r+0x2a2>
800193ba:	58 58       	cp.w	r8,5
800193bc:	f9 b4 0a 01 	movle	r4,1
800193c0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800193c4:	f7 b5 09 04 	subgt	r5,4
800193c8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800193cc:	f9 b4 09 00 	movgt	r4,0
800193d0:	40 cc       	lddsp	r12,sp[0x30]
800193d2:	58 3c       	cp.w	r12,3
800193d4:	c2 d0       	breq	8001942e <_dtoa_r+0x2da>
800193d6:	e0 89 00 05 	brgt	800193e0 <_dtoa_r+0x28c>
800193da:	58 2c       	cp.w	r12,2
800193dc:	c1 01       	brne	800193fc <_dtoa_r+0x2a8>
800193de:	c1 88       	rjmp	8001940e <_dtoa_r+0x2ba>
800193e0:	40 cb       	lddsp	r11,sp[0x30]
800193e2:	58 4b       	cp.w	r11,4
800193e4:	c0 60       	breq	800193f0 <_dtoa_r+0x29c>
800193e6:	58 5b       	cp.w	r11,5
800193e8:	c0 a1       	brne	800193fc <_dtoa_r+0x2a8>
800193ea:	30 1a       	mov	r10,1
800193ec:	50 da       	stdsp	sp[0x34],r10
800193ee:	c2 28       	rjmp	80019432 <_dtoa_r+0x2de>
800193f0:	30 19       	mov	r9,1
800193f2:	50 d9       	stdsp	sp[0x34],r9
800193f4:	c0 f8       	rjmp	80019412 <_dtoa_r+0x2be>
800193f6:	30 08       	mov	r8,0
800193f8:	30 14       	mov	r4,1
800193fa:	50 c8       	stdsp	sp[0x30],r8
800193fc:	3f f5       	mov	r5,-1
800193fe:	30 1c       	mov	r12,1
80019400:	30 0b       	mov	r11,0
80019402:	50 95       	stdsp	sp[0x24],r5
80019404:	50 dc       	stdsp	sp[0x34],r12
80019406:	0a 91       	mov	r1,r5
80019408:	31 28       	mov	r8,18
8001940a:	50 eb       	stdsp	sp[0x38],r11
8001940c:	c2 08       	rjmp	8001944c <_dtoa_r+0x2f8>
8001940e:	30 0a       	mov	r10,0
80019410:	50 da       	stdsp	sp[0x34],r10
80019412:	40 e9       	lddsp	r9,sp[0x38]
80019414:	58 09       	cp.w	r9,0
80019416:	e0 89 00 07 	brgt	80019424 <_dtoa_r+0x2d0>
8001941a:	30 18       	mov	r8,1
8001941c:	50 98       	stdsp	sp[0x24],r8
8001941e:	10 91       	mov	r1,r8
80019420:	50 e8       	stdsp	sp[0x38],r8
80019422:	c1 58       	rjmp	8001944c <_dtoa_r+0x2f8>
80019424:	40 e5       	lddsp	r5,sp[0x38]
80019426:	50 95       	stdsp	sp[0x24],r5
80019428:	0a 91       	mov	r1,r5
8001942a:	0a 98       	mov	r8,r5
8001942c:	c1 08       	rjmp	8001944c <_dtoa_r+0x2f8>
8001942e:	30 0c       	mov	r12,0
80019430:	50 dc       	stdsp	sp[0x34],r12
80019432:	40 eb       	lddsp	r11,sp[0x38]
80019434:	ec 0b 00 0b 	add	r11,r6,r11
80019438:	50 9b       	stdsp	sp[0x24],r11
8001943a:	16 98       	mov	r8,r11
8001943c:	2f f8       	sub	r8,-1
8001943e:	58 08       	cp.w	r8,0
80019440:	e0 89 00 05 	brgt	8001944a <_dtoa_r+0x2f6>
80019444:	10 91       	mov	r1,r8
80019446:	30 18       	mov	r8,1
80019448:	c0 28       	rjmp	8001944c <_dtoa_r+0x2f8>
8001944a:	10 91       	mov	r1,r8
8001944c:	30 09       	mov	r9,0
8001944e:	6e 9a       	ld.w	r10,r7[0x24]
80019450:	95 19       	st.w	r10[0x4],r9
80019452:	30 49       	mov	r9,4
80019454:	c0 68       	rjmp	80019460 <_dtoa_r+0x30c>
80019456:	d7 03       	nop
80019458:	6a 1a       	ld.w	r10,r5[0x4]
8001945a:	a1 79       	lsl	r9,0x1
8001945c:	2f fa       	sub	r10,-1
8001945e:	8b 1a       	st.w	r5[0x4],r10
80019460:	6e 95       	ld.w	r5,r7[0x24]
80019462:	f2 ca ff ec 	sub	r10,r9,-20
80019466:	10 3a       	cp.w	r10,r8
80019468:	fe 98 ff f8 	brls	80019458 <_dtoa_r+0x304>
8001946c:	6a 1b       	ld.w	r11,r5[0x4]
8001946e:	0e 9c       	mov	r12,r7
80019470:	e0 a0 0a ea 	rcall	8001aa44 <_Balloc>
80019474:	58 e1       	cp.w	r1,14
80019476:	5f 88       	srls	r8
80019478:	8b 0c       	st.w	r5[0x0],r12
8001947a:	f1 e4 00 04 	and	r4,r8,r4
8001947e:	6e 98       	ld.w	r8,r7[0x24]
80019480:	70 08       	ld.w	r8,r8[0x0]
80019482:	50 88       	stdsp	sp[0x20],r8
80019484:	e0 80 01 82 	breq	80019788 <_dtoa_r+0x634>
80019488:	58 06       	cp.w	r6,0
8001948a:	e0 8a 00 43 	brle	80019510 <_dtoa_r+0x3bc>
8001948e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80019492:	fe c8 8f 8a 	sub	r8,pc,-28790
80019496:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8001949a:	fa e5 00 18 	st.d	sp[24],r4
8001949e:	ec 04 14 04 	asr	r4,r6,0x4
800194a2:	ed b4 00 04 	bld	r4,0x4
800194a6:	c0 30       	breq	800194ac <_dtoa_r+0x358>
800194a8:	30 25       	mov	r5,2
800194aa:	c1 08       	rjmp	800194ca <_dtoa_r+0x376>
800194ac:	fe c8 8e dc 	sub	r8,pc,-28964
800194b0:	f0 e8 00 20 	ld.d	r8,r8[32]
800194b4:	fa ea 00 3c 	ld.d	r10,sp[60]
800194b8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800194bc:	e0 a0 1f 4e 	rcall	8001d358 <__avr32_f64_div>
800194c0:	30 35       	mov	r5,3
800194c2:	14 98       	mov	r8,r10
800194c4:	16 99       	mov	r9,r11
800194c6:	fa e9 00 08 	st.d	sp[8],r8
800194ca:	fe cc 8e fa 	sub	r12,pc,-28934
800194ce:	50 a3       	stdsp	sp[0x28],r3
800194d0:	0c 93       	mov	r3,r6
800194d2:	18 96       	mov	r6,r12
800194d4:	c0 f8       	rjmp	800194f2 <_dtoa_r+0x39e>
800194d6:	fa ea 00 18 	ld.d	r10,sp[24]
800194da:	ed b4 00 00 	bld	r4,0x0
800194de:	c0 81       	brne	800194ee <_dtoa_r+0x39a>
800194e0:	ec e8 00 00 	ld.d	r8,r6[0]
800194e4:	2f f5       	sub	r5,-1
800194e6:	fe b0 da bb 	rcall	80014a5c <__avr32_f64_mul>
800194ea:	fa eb 00 18 	st.d	sp[24],r10
800194ee:	a1 54       	asr	r4,0x1
800194f0:	2f 86       	sub	r6,-8
800194f2:	58 04       	cp.w	r4,0
800194f4:	cf 11       	brne	800194d6 <_dtoa_r+0x382>
800194f6:	fa e8 00 18 	ld.d	r8,sp[24]
800194fa:	fa ea 00 08 	ld.d	r10,sp[8]
800194fe:	06 96       	mov	r6,r3
80019500:	e0 a0 1f 2c 	rcall	8001d358 <__avr32_f64_div>
80019504:	40 a3       	lddsp	r3,sp[0x28]
80019506:	14 98       	mov	r8,r10
80019508:	16 99       	mov	r9,r11
8001950a:	fa e9 00 08 	st.d	sp[8],r8
8001950e:	c2 f8       	rjmp	8001956c <_dtoa_r+0x418>
80019510:	ec 08 11 00 	rsub	r8,r6,0
80019514:	c0 31       	brne	8001951a <_dtoa_r+0x3c6>
80019516:	30 25       	mov	r5,2
80019518:	c2 a8       	rjmp	8001956c <_dtoa_r+0x418>
8001951a:	fe cc 8f 4a 	sub	r12,pc,-28854
8001951e:	f0 04 14 04 	asr	r4,r8,0x4
80019522:	50 1c       	stdsp	sp[0x4],r12
80019524:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80019528:	fe c9 90 20 	sub	r9,pc,-28640
8001952c:	fa ea 00 3c 	ld.d	r10,sp[60]
80019530:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80019534:	fe b0 da 94 	rcall	80014a5c <__avr32_f64_mul>
80019538:	40 1c       	lddsp	r12,sp[0x4]
8001953a:	50 63       	stdsp	sp[0x18],r3
8001953c:	30 25       	mov	r5,2
8001953e:	0c 93       	mov	r3,r6
80019540:	fa eb 00 08 	st.d	sp[8],r10
80019544:	18 96       	mov	r6,r12
80019546:	c0 f8       	rjmp	80019564 <_dtoa_r+0x410>
80019548:	fa ea 00 08 	ld.d	r10,sp[8]
8001954c:	ed b4 00 00 	bld	r4,0x0
80019550:	c0 81       	brne	80019560 <_dtoa_r+0x40c>
80019552:	ec e8 00 00 	ld.d	r8,r6[0]
80019556:	2f f5       	sub	r5,-1
80019558:	fe b0 da 82 	rcall	80014a5c <__avr32_f64_mul>
8001955c:	fa eb 00 08 	st.d	sp[8],r10
80019560:	a1 54       	asr	r4,0x1
80019562:	2f 86       	sub	r6,-8
80019564:	58 04       	cp.w	r4,0
80019566:	cf 11       	brne	80019548 <_dtoa_r+0x3f4>
80019568:	06 96       	mov	r6,r3
8001956a:	40 63       	lddsp	r3,sp[0x18]
8001956c:	41 4a       	lddsp	r10,sp[0x50]
8001956e:	58 0a       	cp.w	r10,0
80019570:	c2 a0       	breq	800195c4 <_dtoa_r+0x470>
80019572:	fa e8 00 08 	ld.d	r8,sp[8]
80019576:	58 01       	cp.w	r1,0
80019578:	5f 94       	srgt	r4
8001957a:	fa e9 00 18 	st.d	sp[24],r8
8001957e:	30 08       	mov	r8,0
80019580:	fc 19 3f f0 	movh	r9,0x3ff0
80019584:	fa ea 00 18 	ld.d	r10,sp[24]
80019588:	e0 a0 1e b3 	rcall	8001d2ee <__avr32_f64_cmp_lt>
8001958c:	f9 bc 00 00 	moveq	r12,0
80019590:	f9 bc 01 01 	movne	r12,1
80019594:	e9 ec 00 0c 	and	r12,r4,r12
80019598:	c1 60       	breq	800195c4 <_dtoa_r+0x470>
8001959a:	40 98       	lddsp	r8,sp[0x24]
8001959c:	58 08       	cp.w	r8,0
8001959e:	e0 8a 00 f1 	brle	80019780 <_dtoa_r+0x62c>
800195a2:	30 08       	mov	r8,0
800195a4:	fc 19 40 24 	movh	r9,0x4024
800195a8:	ec c4 00 01 	sub	r4,r6,1
800195ac:	fa ea 00 18 	ld.d	r10,sp[24]
800195b0:	2f f5       	sub	r5,-1
800195b2:	50 64       	stdsp	sp[0x18],r4
800195b4:	fe b0 da 54 	rcall	80014a5c <__avr32_f64_mul>
800195b8:	40 94       	lddsp	r4,sp[0x24]
800195ba:	14 98       	mov	r8,r10
800195bc:	16 99       	mov	r9,r11
800195be:	fa e9 00 08 	st.d	sp[8],r8
800195c2:	c0 38       	rjmp	800195c8 <_dtoa_r+0x474>
800195c4:	50 66       	stdsp	sp[0x18],r6
800195c6:	02 94       	mov	r4,r1
800195c8:	0a 9c       	mov	r12,r5
800195ca:	fe b0 db 4c 	rcall	80014c62 <__avr32_s32_to_f64>
800195ce:	fa e8 00 08 	ld.d	r8,sp[8]
800195d2:	fe b0 da 45 	rcall	80014a5c <__avr32_f64_mul>
800195d6:	30 08       	mov	r8,0
800195d8:	fc 19 40 1c 	movh	r9,0x401c
800195dc:	e0 a0 1d ba 	rcall	8001d150 <__avr32_f64_add>
800195e0:	14 98       	mov	r8,r10
800195e2:	16 99       	mov	r9,r11
800195e4:	fa e9 00 28 	st.d	sp[40],r8
800195e8:	fc 18 fc c0 	movh	r8,0xfcc0
800195ec:	40 a5       	lddsp	r5,sp[0x28]
800195ee:	10 05       	add	r5,r8
800195f0:	50 a5       	stdsp	sp[0x28],r5
800195f2:	58 04       	cp.w	r4,0
800195f4:	c2 11       	brne	80019636 <_dtoa_r+0x4e2>
800195f6:	fa ea 00 08 	ld.d	r10,sp[8]
800195fa:	30 08       	mov	r8,0
800195fc:	fc 19 40 14 	movh	r9,0x4014
80019600:	e0 a0 1c da 	rcall	8001cfb4 <__avr32_f64_sub>
80019604:	40 bc       	lddsp	r12,sp[0x2c]
80019606:	fa eb 00 08 	st.d	sp[8],r10
8001960a:	14 98       	mov	r8,r10
8001960c:	16 99       	mov	r9,r11
8001960e:	18 9a       	mov	r10,r12
80019610:	0a 9b       	mov	r11,r5
80019612:	e0 a0 1e 6e 	rcall	8001d2ee <__avr32_f64_cmp_lt>
80019616:	e0 81 02 54 	brne	80019abe <_dtoa_r+0x96a>
8001961a:	0a 98       	mov	r8,r5
8001961c:	40 b9       	lddsp	r9,sp[0x2c]
8001961e:	ee 18 80 00 	eorh	r8,0x8000
80019622:	fa ea 00 08 	ld.d	r10,sp[8]
80019626:	10 95       	mov	r5,r8
80019628:	12 98       	mov	r8,r9
8001962a:	0a 99       	mov	r9,r5
8001962c:	e0 a0 1e 61 	rcall	8001d2ee <__avr32_f64_cmp_lt>
80019630:	e0 81 02 3e 	brne	80019aac <_dtoa_r+0x958>
80019634:	ca 68       	rjmp	80019780 <_dtoa_r+0x62c>
80019636:	fe c9 91 2e 	sub	r9,pc,-28370
8001963a:	e8 c8 00 01 	sub	r8,r4,1
8001963e:	40 d5       	lddsp	r5,sp[0x34]
80019640:	58 05       	cp.w	r5,0
80019642:	c4 f0       	breq	800196e0 <_dtoa_r+0x58c>
80019644:	30 0c       	mov	r12,0
80019646:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8001964a:	51 3c       	stdsp	sp[0x4c],r12
8001964c:	30 0a       	mov	r10,0
8001964e:	fc 1b 3f e0 	movh	r11,0x3fe0
80019652:	e0 a0 1e 83 	rcall	8001d358 <__avr32_f64_div>
80019656:	fa e8 00 28 	ld.d	r8,sp[40]
8001965a:	40 85       	lddsp	r5,sp[0x20]
8001965c:	e0 a0 1c ac 	rcall	8001cfb4 <__avr32_f64_sub>
80019660:	fa eb 00 28 	st.d	sp[40],r10
80019664:	fa ea 00 08 	ld.d	r10,sp[8]
80019668:	fe b0 da e6 	rcall	80014c34 <__avr32_f64_to_s32>
8001966c:	51 6c       	stdsp	sp[0x58],r12
8001966e:	fe b0 da fa 	rcall	80014c62 <__avr32_s32_to_f64>
80019672:	14 98       	mov	r8,r10
80019674:	16 99       	mov	r9,r11
80019676:	fa ea 00 08 	ld.d	r10,sp[8]
8001967a:	e0 a0 1c 9d 	rcall	8001cfb4 <__avr32_f64_sub>
8001967e:	fa eb 00 08 	st.d	sp[8],r10
80019682:	41 68       	lddsp	r8,sp[0x58]
80019684:	2d 08       	sub	r8,-48
80019686:	0a c8       	st.b	r5++,r8
80019688:	41 39       	lddsp	r9,sp[0x4c]
8001968a:	2f f9       	sub	r9,-1
8001968c:	51 39       	stdsp	sp[0x4c],r9
8001968e:	fa e8 00 28 	ld.d	r8,sp[40]
80019692:	e0 a0 1e 2e 	rcall	8001d2ee <__avr32_f64_cmp_lt>
80019696:	e0 81 03 39 	brne	80019d08 <_dtoa_r+0xbb4>
8001969a:	fa e8 00 08 	ld.d	r8,sp[8]
8001969e:	30 0a       	mov	r10,0
800196a0:	fc 1b 3f f0 	movh	r11,0x3ff0
800196a4:	e0 a0 1c 88 	rcall	8001cfb4 <__avr32_f64_sub>
800196a8:	fa e8 00 28 	ld.d	r8,sp[40]
800196ac:	e0 a0 1e 21 	rcall	8001d2ee <__avr32_f64_cmp_lt>
800196b0:	fa ea 00 28 	ld.d	r10,sp[40]
800196b4:	30 08       	mov	r8,0
800196b6:	fc 19 40 24 	movh	r9,0x4024
800196ba:	e0 81 00 da 	brne	8001986e <_dtoa_r+0x71a>
800196be:	41 3c       	lddsp	r12,sp[0x4c]
800196c0:	08 3c       	cp.w	r12,r4
800196c2:	c5 f4       	brge	80019780 <_dtoa_r+0x62c>
800196c4:	fe b0 d9 cc 	rcall	80014a5c <__avr32_f64_mul>
800196c8:	30 08       	mov	r8,0
800196ca:	fa eb 00 28 	st.d	sp[40],r10
800196ce:	fc 19 40 24 	movh	r9,0x4024
800196d2:	fa ea 00 08 	ld.d	r10,sp[8]
800196d6:	fe b0 d9 c3 	rcall	80014a5c <__avr32_f64_mul>
800196da:	fa eb 00 08 	st.d	sp[8],r10
800196de:	cc 3b       	rjmp	80019664 <_dtoa_r+0x510>
800196e0:	40 85       	lddsp	r5,sp[0x20]
800196e2:	08 05       	add	r5,r4
800196e4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
800196e8:	51 35       	stdsp	sp[0x4c],r5
800196ea:	fa e8 00 28 	ld.d	r8,sp[40]
800196ee:	40 85       	lddsp	r5,sp[0x20]
800196f0:	fe b0 d9 b6 	rcall	80014a5c <__avr32_f64_mul>
800196f4:	fa eb 00 28 	st.d	sp[40],r10
800196f8:	fa ea 00 08 	ld.d	r10,sp[8]
800196fc:	fe b0 da 9c 	rcall	80014c34 <__avr32_f64_to_s32>
80019700:	51 6c       	stdsp	sp[0x58],r12
80019702:	fe b0 da b0 	rcall	80014c62 <__avr32_s32_to_f64>
80019706:	14 98       	mov	r8,r10
80019708:	16 99       	mov	r9,r11
8001970a:	fa ea 00 08 	ld.d	r10,sp[8]
8001970e:	e0 a0 1c 53 	rcall	8001cfb4 <__avr32_f64_sub>
80019712:	fa eb 00 08 	st.d	sp[8],r10
80019716:	41 68       	lddsp	r8,sp[0x58]
80019718:	2d 08       	sub	r8,-48
8001971a:	0a c8       	st.b	r5++,r8
8001971c:	41 3c       	lddsp	r12,sp[0x4c]
8001971e:	18 35       	cp.w	r5,r12
80019720:	c2 81       	brne	80019770 <_dtoa_r+0x61c>
80019722:	30 08       	mov	r8,0
80019724:	fc 19 3f e0 	movh	r9,0x3fe0
80019728:	fa ea 00 28 	ld.d	r10,sp[40]
8001972c:	e0 a0 1d 12 	rcall	8001d150 <__avr32_f64_add>
80019730:	40 85       	lddsp	r5,sp[0x20]
80019732:	fa e8 00 08 	ld.d	r8,sp[8]
80019736:	08 05       	add	r5,r4
80019738:	e0 a0 1d db 	rcall	8001d2ee <__avr32_f64_cmp_lt>
8001973c:	e0 81 00 99 	brne	8001986e <_dtoa_r+0x71a>
80019740:	fa e8 00 28 	ld.d	r8,sp[40]
80019744:	30 0a       	mov	r10,0
80019746:	fc 1b 3f e0 	movh	r11,0x3fe0
8001974a:	e0 a0 1c 35 	rcall	8001cfb4 <__avr32_f64_sub>
8001974e:	14 98       	mov	r8,r10
80019750:	16 99       	mov	r9,r11
80019752:	fa ea 00 08 	ld.d	r10,sp[8]
80019756:	e0 a0 1d cc 	rcall	8001d2ee <__avr32_f64_cmp_lt>
8001975a:	c1 30       	breq	80019780 <_dtoa_r+0x62c>
8001975c:	33 09       	mov	r9,48
8001975e:	0a 98       	mov	r8,r5
80019760:	11 7a       	ld.ub	r10,--r8
80019762:	f2 0a 18 00 	cp.b	r10,r9
80019766:	e0 81 02 d1 	brne	80019d08 <_dtoa_r+0xbb4>
8001976a:	10 95       	mov	r5,r8
8001976c:	cf 9b       	rjmp	8001975e <_dtoa_r+0x60a>
8001976e:	d7 03       	nop
80019770:	30 08       	mov	r8,0
80019772:	fc 19 40 24 	movh	r9,0x4024
80019776:	fe b0 d9 73 	rcall	80014a5c <__avr32_f64_mul>
8001977a:	fa eb 00 08 	st.d	sp[8],r10
8001977e:	cb db       	rjmp	800196f8 <_dtoa_r+0x5a4>
80019780:	fa ea 00 3c 	ld.d	r10,sp[60]
80019784:	fa eb 00 08 	st.d	sp[8],r10
80019788:	58 e6       	cp.w	r6,14
8001978a:	5f ab       	srle	r11
8001978c:	41 8a       	lddsp	r10,sp[0x60]
8001978e:	30 08       	mov	r8,0
80019790:	f4 09 11 ff 	rsub	r9,r10,-1
80019794:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80019798:	f0 09 18 00 	cp.b	r9,r8
8001979c:	e0 80 00 82 	breq	800198a0 <_dtoa_r+0x74c>
800197a0:	40 ea       	lddsp	r10,sp[0x38]
800197a2:	58 01       	cp.w	r1,0
800197a4:	5f a9       	srle	r9
800197a6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
800197aa:	fe ca 92 a2 	sub	r10,pc,-27998
800197ae:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
800197b2:	fa e5 00 10 	st.d	sp[16],r4
800197b6:	f0 09 18 00 	cp.b	r9,r8
800197ba:	c1 40       	breq	800197e2 <_dtoa_r+0x68e>
800197bc:	58 01       	cp.w	r1,0
800197be:	e0 81 01 77 	brne	80019aac <_dtoa_r+0x958>
800197c2:	30 08       	mov	r8,0
800197c4:	fc 19 40 14 	movh	r9,0x4014
800197c8:	08 9a       	mov	r10,r4
800197ca:	0a 9b       	mov	r11,r5
800197cc:	fe b0 d9 48 	rcall	80014a5c <__avr32_f64_mul>
800197d0:	fa e8 00 08 	ld.d	r8,sp[8]
800197d4:	e0 a0 1d 59 	rcall	8001d286 <__avr32_f64_cmp_ge>
800197d8:	e0 81 01 6a 	brne	80019aac <_dtoa_r+0x958>
800197dc:	02 92       	mov	r2,r1
800197de:	e0 8f 01 72 	bral	80019ac2 <_dtoa_r+0x96e>
800197e2:	40 85       	lddsp	r5,sp[0x20]
800197e4:	30 14       	mov	r4,1
800197e6:	fa e8 00 10 	ld.d	r8,sp[16]
800197ea:	fa ea 00 08 	ld.d	r10,sp[8]
800197ee:	e0 a0 1d b5 	rcall	8001d358 <__avr32_f64_div>
800197f2:	fe b0 da 21 	rcall	80014c34 <__avr32_f64_to_s32>
800197f6:	18 92       	mov	r2,r12
800197f8:	fe b0 da 35 	rcall	80014c62 <__avr32_s32_to_f64>
800197fc:	fa e8 00 10 	ld.d	r8,sp[16]
80019800:	fe b0 d9 2e 	rcall	80014a5c <__avr32_f64_mul>
80019804:	14 98       	mov	r8,r10
80019806:	16 99       	mov	r9,r11
80019808:	fa ea 00 08 	ld.d	r10,sp[8]
8001980c:	e0 a0 1b d4 	rcall	8001cfb4 <__avr32_f64_sub>
80019810:	fa eb 00 08 	st.d	sp[8],r10
80019814:	e4 c8 ff d0 	sub	r8,r2,-48
80019818:	0a c8       	st.b	r5++,r8
8001981a:	fc 19 40 24 	movh	r9,0x4024
8001981e:	30 08       	mov	r8,0
80019820:	02 34       	cp.w	r4,r1
80019822:	c3 31       	brne	80019888 <_dtoa_r+0x734>
80019824:	fa e8 00 08 	ld.d	r8,sp[8]
80019828:	e0 a0 1c 94 	rcall	8001d150 <__avr32_f64_add>
8001982c:	16 91       	mov	r1,r11
8001982e:	14 90       	mov	r0,r10
80019830:	14 98       	mov	r8,r10
80019832:	02 99       	mov	r9,r1
80019834:	fa ea 00 10 	ld.d	r10,sp[16]
80019838:	e0 a0 1d 5b 	rcall	8001d2ee <__avr32_f64_cmp_lt>
8001983c:	c1 a1       	brne	80019870 <_dtoa_r+0x71c>
8001983e:	fa e8 00 10 	ld.d	r8,sp[16]
80019842:	00 9a       	mov	r10,r0
80019844:	02 9b       	mov	r11,r1
80019846:	e0 a0 1d 0d 	rcall	8001d260 <__avr32_f64_cmp_eq>
8001984a:	e0 80 02 5e 	breq	80019d06 <_dtoa_r+0xbb2>
8001984e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80019852:	c0 f1       	brne	80019870 <_dtoa_r+0x71c>
80019854:	e0 8f 02 59 	bral	80019d06 <_dtoa_r+0xbb2>
80019858:	40 8a       	lddsp	r10,sp[0x20]
8001985a:	14 38       	cp.w	r8,r10
8001985c:	c0 30       	breq	80019862 <_dtoa_r+0x70e>
8001985e:	10 95       	mov	r5,r8
80019860:	c0 98       	rjmp	80019872 <_dtoa_r+0x71e>
80019862:	33 08       	mov	r8,48
80019864:	40 89       	lddsp	r9,sp[0x20]
80019866:	2f f6       	sub	r6,-1
80019868:	b2 88       	st.b	r9[0x0],r8
8001986a:	40 88       	lddsp	r8,sp[0x20]
8001986c:	c0 88       	rjmp	8001987c <_dtoa_r+0x728>
8001986e:	40 66       	lddsp	r6,sp[0x18]
80019870:	33 99       	mov	r9,57
80019872:	0a 98       	mov	r8,r5
80019874:	11 7a       	ld.ub	r10,--r8
80019876:	f2 0a 18 00 	cp.b	r10,r9
8001987a:	ce f0       	breq	80019858 <_dtoa_r+0x704>
8001987c:	50 66       	stdsp	sp[0x18],r6
8001987e:	11 89       	ld.ub	r9,r8[0x0]
80019880:	2f f9       	sub	r9,-1
80019882:	b0 89       	st.b	r8[0x0],r9
80019884:	e0 8f 02 42 	bral	80019d08 <_dtoa_r+0xbb4>
80019888:	fe b0 d8 ea 	rcall	80014a5c <__avr32_f64_mul>
8001988c:	2f f4       	sub	r4,-1
8001988e:	fa eb 00 08 	st.d	sp[8],r10
80019892:	30 08       	mov	r8,0
80019894:	30 09       	mov	r9,0
80019896:	e0 a0 1c e5 	rcall	8001d260 <__avr32_f64_cmp_eq>
8001989a:	ca 60       	breq	800197e6 <_dtoa_r+0x692>
8001989c:	e0 8f 02 35 	bral	80019d06 <_dtoa_r+0xbb2>
800198a0:	40 d8       	lddsp	r8,sp[0x34]
800198a2:	58 08       	cp.w	r8,0
800198a4:	c0 51       	brne	800198ae <_dtoa_r+0x75a>
800198a6:	04 98       	mov	r8,r2
800198a8:	00 95       	mov	r5,r0
800198aa:	40 d4       	lddsp	r4,sp[0x34]
800198ac:	c3 78       	rjmp	8001991a <_dtoa_r+0x7c6>
800198ae:	40 c5       	lddsp	r5,sp[0x30]
800198b0:	58 15       	cp.w	r5,1
800198b2:	e0 89 00 0f 	brgt	800198d0 <_dtoa_r+0x77c>
800198b6:	41 74       	lddsp	r4,sp[0x5c]
800198b8:	58 04       	cp.w	r4,0
800198ba:	c0 40       	breq	800198c2 <_dtoa_r+0x76e>
800198bc:	f4 c9 fb cd 	sub	r9,r10,-1075
800198c0:	c0 48       	rjmp	800198c8 <_dtoa_r+0x774>
800198c2:	41 99       	lddsp	r9,sp[0x64]
800198c4:	f2 09 11 36 	rsub	r9,r9,54
800198c8:	04 98       	mov	r8,r2
800198ca:	00 95       	mov	r5,r0
800198cc:	c1 c8       	rjmp	80019904 <_dtoa_r+0x7b0>
800198ce:	d7 03       	nop
800198d0:	e2 c8 00 01 	sub	r8,r1,1
800198d4:	58 01       	cp.w	r1,0
800198d6:	e0 05 17 40 	movge	r5,r0
800198da:	e2 09 17 40 	movge	r9,r1
800198de:	e1 d1 e5 15 	sublt	r5,r0,r1
800198e2:	f9 b9 05 00 	movlt	r9,0
800198e6:	10 32       	cp.w	r2,r8
800198e8:	e5 d8 e4 18 	subge	r8,r2,r8
800198ec:	f1 d2 e5 18 	sublt	r8,r8,r2
800198f0:	e5 d8 e5 02 	addlt	r2,r2,r8
800198f4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
800198f8:	f9 d8 e5 0c 	addlt	r12,r12,r8
800198fc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80019900:	f9 b8 05 00 	movlt	r8,0
80019904:	40 4b       	lddsp	r11,sp[0x10]
80019906:	12 0b       	add	r11,r9
80019908:	50 08       	stdsp	sp[0x0],r8
8001990a:	50 4b       	stdsp	sp[0x10],r11
8001990c:	12 00       	add	r0,r9
8001990e:	30 1b       	mov	r11,1
80019910:	0e 9c       	mov	r12,r7
80019912:	e0 a0 0a 4f 	rcall	8001adb0 <__i2b>
80019916:	40 08       	lddsp	r8,sp[0x0]
80019918:	18 94       	mov	r4,r12
8001991a:	40 4a       	lddsp	r10,sp[0x10]
8001991c:	58 05       	cp.w	r5,0
8001991e:	5f 99       	srgt	r9
80019920:	58 0a       	cp.w	r10,0
80019922:	5f 9a       	srgt	r10
80019924:	f5 e9 00 09 	and	r9,r10,r9
80019928:	c0 80       	breq	80019938 <_dtoa_r+0x7e4>
8001992a:	40 4c       	lddsp	r12,sp[0x10]
8001992c:	f8 05 0d 49 	min	r9,r12,r5
80019930:	12 1c       	sub	r12,r9
80019932:	12 10       	sub	r0,r9
80019934:	50 4c       	stdsp	sp[0x10],r12
80019936:	12 15       	sub	r5,r9
80019938:	58 02       	cp.w	r2,0
8001993a:	e0 8a 00 27 	brle	80019988 <_dtoa_r+0x834>
8001993e:	40 db       	lddsp	r11,sp[0x34]
80019940:	58 0b       	cp.w	r11,0
80019942:	c1 d0       	breq	8001997c <_dtoa_r+0x828>
80019944:	58 08       	cp.w	r8,0
80019946:	e0 8a 00 17 	brle	80019974 <_dtoa_r+0x820>
8001994a:	10 9a       	mov	r10,r8
8001994c:	50 08       	stdsp	sp[0x0],r8
8001994e:	08 9b       	mov	r11,r4
80019950:	0e 9c       	mov	r12,r7
80019952:	e0 a0 0a 75 	rcall	8001ae3c <__pow5mult>
80019956:	06 9a       	mov	r10,r3
80019958:	18 9b       	mov	r11,r12
8001995a:	18 94       	mov	r4,r12
8001995c:	0e 9c       	mov	r12,r7
8001995e:	e0 a0 09 a9 	rcall	8001acb0 <__multiply>
80019962:	18 99       	mov	r9,r12
80019964:	06 9b       	mov	r11,r3
80019966:	50 19       	stdsp	sp[0x4],r9
80019968:	0e 9c       	mov	r12,r7
8001996a:	e0 a0 08 53 	rcall	8001aa10 <_Bfree>
8001996e:	40 19       	lddsp	r9,sp[0x4]
80019970:	40 08       	lddsp	r8,sp[0x0]
80019972:	12 93       	mov	r3,r9
80019974:	e4 08 01 0a 	sub	r10,r2,r8
80019978:	c0 80       	breq	80019988 <_dtoa_r+0x834>
8001997a:	c0 28       	rjmp	8001997e <_dtoa_r+0x82a>
8001997c:	04 9a       	mov	r10,r2
8001997e:	06 9b       	mov	r11,r3
80019980:	0e 9c       	mov	r12,r7
80019982:	e0 a0 0a 5d 	rcall	8001ae3c <__pow5mult>
80019986:	18 93       	mov	r3,r12
80019988:	30 1b       	mov	r11,1
8001998a:	0e 9c       	mov	r12,r7
8001998c:	e0 a0 0a 12 	rcall	8001adb0 <__i2b>
80019990:	41 1a       	lddsp	r10,sp[0x44]
80019992:	18 92       	mov	r2,r12
80019994:	58 0a       	cp.w	r10,0
80019996:	e0 8a 00 07 	brle	800199a4 <_dtoa_r+0x850>
8001999a:	18 9b       	mov	r11,r12
8001999c:	0e 9c       	mov	r12,r7
8001999e:	e0 a0 0a 4f 	rcall	8001ae3c <__pow5mult>
800199a2:	18 92       	mov	r2,r12
800199a4:	40 c9       	lddsp	r9,sp[0x30]
800199a6:	58 19       	cp.w	r9,1
800199a8:	e0 89 00 14 	brgt	800199d0 <_dtoa_r+0x87c>
800199ac:	40 38       	lddsp	r8,sp[0xc]
800199ae:	58 08       	cp.w	r8,0
800199b0:	c1 01       	brne	800199d0 <_dtoa_r+0x87c>
800199b2:	40 29       	lddsp	r9,sp[0x8]
800199b4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
800199b8:	c0 c1       	brne	800199d0 <_dtoa_r+0x87c>
800199ba:	12 98       	mov	r8,r9
800199bc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800199c0:	c0 80       	breq	800199d0 <_dtoa_r+0x87c>
800199c2:	40 4c       	lddsp	r12,sp[0x10]
800199c4:	30 1b       	mov	r11,1
800199c6:	2f fc       	sub	r12,-1
800199c8:	2f f0       	sub	r0,-1
800199ca:	50 4c       	stdsp	sp[0x10],r12
800199cc:	50 6b       	stdsp	sp[0x18],r11
800199ce:	c0 38       	rjmp	800199d4 <_dtoa_r+0x880>
800199d0:	30 0a       	mov	r10,0
800199d2:	50 6a       	stdsp	sp[0x18],r10
800199d4:	41 19       	lddsp	r9,sp[0x44]
800199d6:	58 09       	cp.w	r9,0
800199d8:	c0 31       	brne	800199de <_dtoa_r+0x88a>
800199da:	30 1c       	mov	r12,1
800199dc:	c0 98       	rjmp	800199ee <_dtoa_r+0x89a>
800199de:	64 48       	ld.w	r8,r2[0x10]
800199e0:	2f c8       	sub	r8,-4
800199e2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
800199e6:	e0 a0 06 af 	rcall	8001a744 <__hi0bits>
800199ea:	f8 0c 11 20 	rsub	r12,r12,32
800199ee:	40 4b       	lddsp	r11,sp[0x10]
800199f0:	f8 0b 00 08 	add	r8,r12,r11
800199f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800199f8:	c0 c0       	breq	80019a10 <_dtoa_r+0x8bc>
800199fa:	f0 08 11 20 	rsub	r8,r8,32
800199fe:	58 48       	cp.w	r8,4
80019a00:	e0 8a 00 06 	brle	80019a0c <_dtoa_r+0x8b8>
80019a04:	20 48       	sub	r8,4
80019a06:	10 0b       	add	r11,r8
80019a08:	50 4b       	stdsp	sp[0x10],r11
80019a0a:	c0 78       	rjmp	80019a18 <_dtoa_r+0x8c4>
80019a0c:	58 48       	cp.w	r8,4
80019a0e:	c0 70       	breq	80019a1c <_dtoa_r+0x8c8>
80019a10:	40 4a       	lddsp	r10,sp[0x10]
80019a12:	2e 48       	sub	r8,-28
80019a14:	10 0a       	add	r10,r8
80019a16:	50 4a       	stdsp	sp[0x10],r10
80019a18:	10 00       	add	r0,r8
80019a1a:	10 05       	add	r5,r8
80019a1c:	58 00       	cp.w	r0,0
80019a1e:	e0 8a 00 08 	brle	80019a2e <_dtoa_r+0x8da>
80019a22:	06 9b       	mov	r11,r3
80019a24:	00 9a       	mov	r10,r0
80019a26:	0e 9c       	mov	r12,r7
80019a28:	e0 a0 09 00 	rcall	8001ac28 <__lshift>
80019a2c:	18 93       	mov	r3,r12
80019a2e:	40 49       	lddsp	r9,sp[0x10]
80019a30:	58 09       	cp.w	r9,0
80019a32:	e0 8a 00 08 	brle	80019a42 <_dtoa_r+0x8ee>
80019a36:	04 9b       	mov	r11,r2
80019a38:	12 9a       	mov	r10,r9
80019a3a:	0e 9c       	mov	r12,r7
80019a3c:	e0 a0 08 f6 	rcall	8001ac28 <__lshift>
80019a40:	18 92       	mov	r2,r12
80019a42:	41 48       	lddsp	r8,sp[0x50]
80019a44:	58 08       	cp.w	r8,0
80019a46:	c1 b0       	breq	80019a7c <_dtoa_r+0x928>
80019a48:	04 9b       	mov	r11,r2
80019a4a:	06 9c       	mov	r12,r3
80019a4c:	e0 a0 06 f3 	rcall	8001a832 <__mcmp>
80019a50:	c1 64       	brge	80019a7c <_dtoa_r+0x928>
80019a52:	06 9b       	mov	r11,r3
80019a54:	30 09       	mov	r9,0
80019a56:	30 aa       	mov	r10,10
80019a58:	0e 9c       	mov	r12,r7
80019a5a:	e0 a0 09 b3 	rcall	8001adc0 <__multadd>
80019a5e:	20 16       	sub	r6,1
80019a60:	18 93       	mov	r3,r12
80019a62:	40 dc       	lddsp	r12,sp[0x34]
80019a64:	58 0c       	cp.w	r12,0
80019a66:	c0 31       	brne	80019a6c <_dtoa_r+0x918>
80019a68:	40 91       	lddsp	r1,sp[0x24]
80019a6a:	c0 98       	rjmp	80019a7c <_dtoa_r+0x928>
80019a6c:	08 9b       	mov	r11,r4
80019a6e:	40 91       	lddsp	r1,sp[0x24]
80019a70:	30 09       	mov	r9,0
80019a72:	30 aa       	mov	r10,10
80019a74:	0e 9c       	mov	r12,r7
80019a76:	e0 a0 09 a5 	rcall	8001adc0 <__multadd>
80019a7a:	18 94       	mov	r4,r12
80019a7c:	58 01       	cp.w	r1,0
80019a7e:	5f a9       	srle	r9
80019a80:	40 cb       	lddsp	r11,sp[0x30]
80019a82:	58 2b       	cp.w	r11,2
80019a84:	5f 98       	srgt	r8
80019a86:	f3 e8 00 08 	and	r8,r9,r8
80019a8a:	c2 50       	breq	80019ad4 <_dtoa_r+0x980>
80019a8c:	58 01       	cp.w	r1,0
80019a8e:	c1 11       	brne	80019ab0 <_dtoa_r+0x95c>
80019a90:	04 9b       	mov	r11,r2
80019a92:	02 99       	mov	r9,r1
80019a94:	30 5a       	mov	r10,5
80019a96:	0e 9c       	mov	r12,r7
80019a98:	e0 a0 09 94 	rcall	8001adc0 <__multadd>
80019a9c:	18 92       	mov	r2,r12
80019a9e:	18 9b       	mov	r11,r12
80019aa0:	06 9c       	mov	r12,r3
80019aa2:	e0 a0 06 c8 	rcall	8001a832 <__mcmp>
80019aa6:	e0 89 00 0f 	brgt	80019ac4 <_dtoa_r+0x970>
80019aaa:	c0 38       	rjmp	80019ab0 <_dtoa_r+0x95c>
80019aac:	30 02       	mov	r2,0
80019aae:	04 94       	mov	r4,r2
80019ab0:	40 ea       	lddsp	r10,sp[0x38]
80019ab2:	30 09       	mov	r9,0
80019ab4:	5c da       	com	r10
80019ab6:	40 85       	lddsp	r5,sp[0x20]
80019ab8:	50 6a       	stdsp	sp[0x18],r10
80019aba:	50 49       	stdsp	sp[0x10],r9
80019abc:	c0 f9       	rjmp	80019cda <_dtoa_r+0xb86>
80019abe:	08 92       	mov	r2,r4
80019ac0:	40 66       	lddsp	r6,sp[0x18]
80019ac2:	04 94       	mov	r4,r2
80019ac4:	2f f6       	sub	r6,-1
80019ac6:	50 66       	stdsp	sp[0x18],r6
80019ac8:	33 18       	mov	r8,49
80019aca:	40 85       	lddsp	r5,sp[0x20]
80019acc:	0a c8       	st.b	r5++,r8
80019ace:	30 08       	mov	r8,0
80019ad0:	50 48       	stdsp	sp[0x10],r8
80019ad2:	c0 49       	rjmp	80019cda <_dtoa_r+0xb86>
80019ad4:	40 dc       	lddsp	r12,sp[0x34]
80019ad6:	58 0c       	cp.w	r12,0
80019ad8:	e0 80 00 b5 	breq	80019c42 <_dtoa_r+0xaee>
80019adc:	58 05       	cp.w	r5,0
80019ade:	e0 8a 00 08 	brle	80019aee <_dtoa_r+0x99a>
80019ae2:	08 9b       	mov	r11,r4
80019ae4:	0a 9a       	mov	r10,r5
80019ae6:	0e 9c       	mov	r12,r7
80019ae8:	e0 a0 08 a0 	rcall	8001ac28 <__lshift>
80019aec:	18 94       	mov	r4,r12
80019aee:	40 6b       	lddsp	r11,sp[0x18]
80019af0:	58 0b       	cp.w	r11,0
80019af2:	c0 31       	brne	80019af8 <_dtoa_r+0x9a4>
80019af4:	08 9c       	mov	r12,r4
80019af6:	c1 38       	rjmp	80019b1c <_dtoa_r+0x9c8>
80019af8:	68 1b       	ld.w	r11,r4[0x4]
80019afa:	0e 9c       	mov	r12,r7
80019afc:	e0 a0 07 a4 	rcall	8001aa44 <_Balloc>
80019b00:	68 4a       	ld.w	r10,r4[0x10]
80019b02:	18 95       	mov	r5,r12
80019b04:	e8 cb ff f4 	sub	r11,r4,-12
80019b08:	2f ea       	sub	r10,-2
80019b0a:	2f 4c       	sub	r12,-12
80019b0c:	a3 6a       	lsl	r10,0x2
80019b0e:	fe b0 dc d6 	rcall	800154ba <memcpy>
80019b12:	0a 9b       	mov	r11,r5
80019b14:	30 1a       	mov	r10,1
80019b16:	0e 9c       	mov	r12,r7
80019b18:	e0 a0 08 88 	rcall	8001ac28 <__lshift>
80019b1c:	50 44       	stdsp	sp[0x10],r4
80019b1e:	40 3a       	lddsp	r10,sp[0xc]
80019b20:	30 19       	mov	r9,1
80019b22:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80019b26:	18 94       	mov	r4,r12
80019b28:	50 da       	stdsp	sp[0x34],r10
80019b2a:	40 85       	lddsp	r5,sp[0x20]
80019b2c:	50 99       	stdsp	sp[0x24],r9
80019b2e:	50 26       	stdsp	sp[0x8],r6
80019b30:	50 e1       	stdsp	sp[0x38],r1
80019b32:	04 9b       	mov	r11,r2
80019b34:	06 9c       	mov	r12,r3
80019b36:	fe b0 fa 7f 	rcall	80019034 <quorem>
80019b3a:	40 4b       	lddsp	r11,sp[0x10]
80019b3c:	f8 c0 ff d0 	sub	r0,r12,-48
80019b40:	06 9c       	mov	r12,r3
80019b42:	e0 a0 06 78 	rcall	8001a832 <__mcmp>
80019b46:	08 9a       	mov	r10,r4
80019b48:	50 6c       	stdsp	sp[0x18],r12
80019b4a:	04 9b       	mov	r11,r2
80019b4c:	0e 9c       	mov	r12,r7
80019b4e:	e0 a0 08 05 	rcall	8001ab58 <__mdiff>
80019b52:	18 91       	mov	r1,r12
80019b54:	78 38       	ld.w	r8,r12[0xc]
80019b56:	58 08       	cp.w	r8,0
80019b58:	c0 30       	breq	80019b5e <_dtoa_r+0xa0a>
80019b5a:	30 16       	mov	r6,1
80019b5c:	c0 68       	rjmp	80019b68 <_dtoa_r+0xa14>
80019b5e:	18 9b       	mov	r11,r12
80019b60:	06 9c       	mov	r12,r3
80019b62:	e0 a0 06 68 	rcall	8001a832 <__mcmp>
80019b66:	18 96       	mov	r6,r12
80019b68:	0e 9c       	mov	r12,r7
80019b6a:	02 9b       	mov	r11,r1
80019b6c:	e0 a0 07 52 	rcall	8001aa10 <_Bfree>
80019b70:	40 cc       	lddsp	r12,sp[0x30]
80019b72:	ed ec 10 08 	or	r8,r6,r12
80019b76:	c0 d1       	brne	80019b90 <_dtoa_r+0xa3c>
80019b78:	40 db       	lddsp	r11,sp[0x34]
80019b7a:	58 0b       	cp.w	r11,0
80019b7c:	c0 a1       	brne	80019b90 <_dtoa_r+0xa3c>
80019b7e:	40 26       	lddsp	r6,sp[0x8]
80019b80:	e0 40 00 39 	cp.w	r0,57
80019b84:	c3 00       	breq	80019be4 <_dtoa_r+0xa90>
80019b86:	40 6a       	lddsp	r10,sp[0x18]
80019b88:	58 0a       	cp.w	r10,0
80019b8a:	e0 89 00 24 	brgt	80019bd2 <_dtoa_r+0xa7e>
80019b8e:	c2 f8       	rjmp	80019bec <_dtoa_r+0xa98>
80019b90:	40 69       	lddsp	r9,sp[0x18]
80019b92:	58 09       	cp.w	r9,0
80019b94:	c0 85       	brlt	80019ba4 <_dtoa_r+0xa50>
80019b96:	12 98       	mov	r8,r9
80019b98:	40 cc       	lddsp	r12,sp[0x30]
80019b9a:	18 48       	or	r8,r12
80019b9c:	c1 d1       	brne	80019bd6 <_dtoa_r+0xa82>
80019b9e:	40 db       	lddsp	r11,sp[0x34]
80019ba0:	58 0b       	cp.w	r11,0
80019ba2:	c1 a1       	brne	80019bd6 <_dtoa_r+0xa82>
80019ba4:	0c 99       	mov	r9,r6
80019ba6:	40 26       	lddsp	r6,sp[0x8]
80019ba8:	58 09       	cp.w	r9,0
80019baa:	e0 8a 00 21 	brle	80019bec <_dtoa_r+0xa98>
80019bae:	06 9b       	mov	r11,r3
80019bb0:	30 1a       	mov	r10,1
80019bb2:	0e 9c       	mov	r12,r7
80019bb4:	e0 a0 08 3a 	rcall	8001ac28 <__lshift>
80019bb8:	04 9b       	mov	r11,r2
80019bba:	18 93       	mov	r3,r12
80019bbc:	e0 a0 06 3b 	rcall	8001a832 <__mcmp>
80019bc0:	e0 89 00 06 	brgt	80019bcc <_dtoa_r+0xa78>
80019bc4:	c1 41       	brne	80019bec <_dtoa_r+0xa98>
80019bc6:	ed b0 00 00 	bld	r0,0x0
80019bca:	c1 11       	brne	80019bec <_dtoa_r+0xa98>
80019bcc:	e0 40 00 39 	cp.w	r0,57
80019bd0:	c0 a0       	breq	80019be4 <_dtoa_r+0xa90>
80019bd2:	2f f0       	sub	r0,-1
80019bd4:	c0 c8       	rjmp	80019bec <_dtoa_r+0xa98>
80019bd6:	58 06       	cp.w	r6,0
80019bd8:	e0 8a 00 0c 	brle	80019bf0 <_dtoa_r+0xa9c>
80019bdc:	40 26       	lddsp	r6,sp[0x8]
80019bde:	e0 40 00 39 	cp.w	r0,57
80019be2:	c0 41       	brne	80019bea <_dtoa_r+0xa96>
80019be4:	33 98       	mov	r8,57
80019be6:	0a c8       	st.b	r5++,r8
80019be8:	c6 78       	rjmp	80019cb6 <_dtoa_r+0xb62>
80019bea:	2f f0       	sub	r0,-1
80019bec:	0a c0       	st.b	r5++,r0
80019bee:	c7 58       	rjmp	80019cd8 <_dtoa_r+0xb84>
80019bf0:	0a c0       	st.b	r5++,r0
80019bf2:	40 9a       	lddsp	r10,sp[0x24]
80019bf4:	40 e9       	lddsp	r9,sp[0x38]
80019bf6:	12 3a       	cp.w	r10,r9
80019bf8:	c4 30       	breq	80019c7e <_dtoa_r+0xb2a>
80019bfa:	06 9b       	mov	r11,r3
80019bfc:	30 09       	mov	r9,0
80019bfe:	30 aa       	mov	r10,10
80019c00:	0e 9c       	mov	r12,r7
80019c02:	e0 a0 08 df 	rcall	8001adc0 <__multadd>
80019c06:	40 48       	lddsp	r8,sp[0x10]
80019c08:	18 93       	mov	r3,r12
80019c0a:	08 38       	cp.w	r8,r4
80019c0c:	c0 91       	brne	80019c1e <_dtoa_r+0xaca>
80019c0e:	10 9b       	mov	r11,r8
80019c10:	30 09       	mov	r9,0
80019c12:	30 aa       	mov	r10,10
80019c14:	0e 9c       	mov	r12,r7
80019c16:	e0 a0 08 d5 	rcall	8001adc0 <__multadd>
80019c1a:	50 4c       	stdsp	sp[0x10],r12
80019c1c:	c0 e8       	rjmp	80019c38 <_dtoa_r+0xae4>
80019c1e:	40 4b       	lddsp	r11,sp[0x10]
80019c20:	30 09       	mov	r9,0
80019c22:	30 aa       	mov	r10,10
80019c24:	0e 9c       	mov	r12,r7
80019c26:	e0 a0 08 cd 	rcall	8001adc0 <__multadd>
80019c2a:	08 9b       	mov	r11,r4
80019c2c:	50 4c       	stdsp	sp[0x10],r12
80019c2e:	30 09       	mov	r9,0
80019c30:	30 aa       	mov	r10,10
80019c32:	0e 9c       	mov	r12,r7
80019c34:	e0 a0 08 c6 	rcall	8001adc0 <__multadd>
80019c38:	18 94       	mov	r4,r12
80019c3a:	40 9c       	lddsp	r12,sp[0x24]
80019c3c:	2f fc       	sub	r12,-1
80019c3e:	50 9c       	stdsp	sp[0x24],r12
80019c40:	c7 9b       	rjmp	80019b32 <_dtoa_r+0x9de>
80019c42:	30 18       	mov	r8,1
80019c44:	06 90       	mov	r0,r3
80019c46:	40 85       	lddsp	r5,sp[0x20]
80019c48:	08 93       	mov	r3,r4
80019c4a:	0c 94       	mov	r4,r6
80019c4c:	10 96       	mov	r6,r8
80019c4e:	04 9b       	mov	r11,r2
80019c50:	00 9c       	mov	r12,r0
80019c52:	fe b0 f9 f1 	rcall	80019034 <quorem>
80019c56:	2d 0c       	sub	r12,-48
80019c58:	0a cc       	st.b	r5++,r12
80019c5a:	02 36       	cp.w	r6,r1
80019c5c:	c0 a4       	brge	80019c70 <_dtoa_r+0xb1c>
80019c5e:	00 9b       	mov	r11,r0
80019c60:	30 09       	mov	r9,0
80019c62:	30 aa       	mov	r10,10
80019c64:	0e 9c       	mov	r12,r7
80019c66:	2f f6       	sub	r6,-1
80019c68:	e0 a0 08 ac 	rcall	8001adc0 <__multadd>
80019c6c:	18 90       	mov	r0,r12
80019c6e:	cf 0b       	rjmp	80019c4e <_dtoa_r+0xafa>
80019c70:	08 96       	mov	r6,r4
80019c72:	30 0b       	mov	r11,0
80019c74:	06 94       	mov	r4,r3
80019c76:	50 4b       	stdsp	sp[0x10],r11
80019c78:	00 93       	mov	r3,r0
80019c7a:	18 90       	mov	r0,r12
80019c7c:	c0 28       	rjmp	80019c80 <_dtoa_r+0xb2c>
80019c7e:	40 26       	lddsp	r6,sp[0x8]
80019c80:	06 9b       	mov	r11,r3
80019c82:	30 1a       	mov	r10,1
80019c84:	0e 9c       	mov	r12,r7
80019c86:	e0 a0 07 d1 	rcall	8001ac28 <__lshift>
80019c8a:	04 9b       	mov	r11,r2
80019c8c:	18 93       	mov	r3,r12
80019c8e:	e0 a0 05 d2 	rcall	8001a832 <__mcmp>
80019c92:	e0 89 00 12 	brgt	80019cb6 <_dtoa_r+0xb62>
80019c96:	c1 b1       	brne	80019ccc <_dtoa_r+0xb78>
80019c98:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80019c9c:	c0 d1       	brne	80019cb6 <_dtoa_r+0xb62>
80019c9e:	c1 78       	rjmp	80019ccc <_dtoa_r+0xb78>
80019ca0:	40 89       	lddsp	r9,sp[0x20]
80019ca2:	12 38       	cp.w	r8,r9
80019ca4:	c0 30       	breq	80019caa <_dtoa_r+0xb56>
80019ca6:	10 95       	mov	r5,r8
80019ca8:	c0 88       	rjmp	80019cb8 <_dtoa_r+0xb64>
80019caa:	2f f6       	sub	r6,-1
80019cac:	50 66       	stdsp	sp[0x18],r6
80019cae:	33 18       	mov	r8,49
80019cb0:	40 8c       	lddsp	r12,sp[0x20]
80019cb2:	b8 88       	st.b	r12[0x0],r8
80019cb4:	c1 38       	rjmp	80019cda <_dtoa_r+0xb86>
80019cb6:	33 9a       	mov	r10,57
80019cb8:	0a 98       	mov	r8,r5
80019cba:	11 79       	ld.ub	r9,--r8
80019cbc:	f4 09 18 00 	cp.b	r9,r10
80019cc0:	cf 00       	breq	80019ca0 <_dtoa_r+0xb4c>
80019cc2:	2f f9       	sub	r9,-1
80019cc4:	b0 89       	st.b	r8[0x0],r9
80019cc6:	c0 98       	rjmp	80019cd8 <_dtoa_r+0xb84>
80019cc8:	10 95       	mov	r5,r8
80019cca:	c0 28       	rjmp	80019cce <_dtoa_r+0xb7a>
80019ccc:	33 09       	mov	r9,48
80019cce:	0a 98       	mov	r8,r5
80019cd0:	11 7a       	ld.ub	r10,--r8
80019cd2:	f2 0a 18 00 	cp.b	r10,r9
80019cd6:	cf 90       	breq	80019cc8 <_dtoa_r+0xb74>
80019cd8:	50 66       	stdsp	sp[0x18],r6
80019cda:	04 9b       	mov	r11,r2
80019cdc:	0e 9c       	mov	r12,r7
80019cde:	e0 a0 06 99 	rcall	8001aa10 <_Bfree>
80019ce2:	58 04       	cp.w	r4,0
80019ce4:	c1 20       	breq	80019d08 <_dtoa_r+0xbb4>
80019ce6:	40 4b       	lddsp	r11,sp[0x10]
80019ce8:	08 3b       	cp.w	r11,r4
80019cea:	5f 19       	srne	r9
80019cec:	58 0b       	cp.w	r11,0
80019cee:	5f 18       	srne	r8
80019cf0:	f3 e8 00 08 	and	r8,r9,r8
80019cf4:	c0 40       	breq	80019cfc <_dtoa_r+0xba8>
80019cf6:	0e 9c       	mov	r12,r7
80019cf8:	e0 a0 06 8c 	rcall	8001aa10 <_Bfree>
80019cfc:	08 9b       	mov	r11,r4
80019cfe:	0e 9c       	mov	r12,r7
80019d00:	e0 a0 06 88 	rcall	8001aa10 <_Bfree>
80019d04:	c0 28       	rjmp	80019d08 <_dtoa_r+0xbb4>
80019d06:	50 66       	stdsp	sp[0x18],r6
80019d08:	0e 9c       	mov	r12,r7
80019d0a:	06 9b       	mov	r11,r3
80019d0c:	e0 a0 06 82 	rcall	8001aa10 <_Bfree>
80019d10:	30 08       	mov	r8,0
80019d12:	aa 88       	st.b	r5[0x0],r8
80019d14:	40 68       	lddsp	r8,sp[0x18]
80019d16:	41 5a       	lddsp	r10,sp[0x54]
80019d18:	2f f8       	sub	r8,-1
80019d1a:	41 29       	lddsp	r9,sp[0x48]
80019d1c:	95 08       	st.w	r10[0x0],r8
80019d1e:	40 8c       	lddsp	r12,sp[0x20]
80019d20:	58 09       	cp.w	r9,0
80019d22:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80019d26:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80019d2a:	2e 6d       	sub	sp,-104
80019d2c:	d8 32       	popm	r0-r7,pc
80019d2e:	d7 03       	nop

80019d30 <__env_lock>:
80019d30:	5e fc       	retal	r12

80019d32 <__env_unlock>:
80019d32:	5e fc       	retal	r12

80019d34 <__errno>:
80019d34:	e0 68 01 20 	mov	r8,288
80019d38:	70 0c       	ld.w	r12,r8[0x0]
80019d3a:	2f 4c       	sub	r12,-12
80019d3c:	5e fc       	retal	r12
80019d3e:	d7 03       	nop

80019d40 <_fflush_r>:
80019d40:	d4 21       	pushm	r4-r7,lr
80019d42:	16 97       	mov	r7,r11
80019d44:	18 96       	mov	r6,r12
80019d46:	76 48       	ld.w	r8,r11[0x10]
80019d48:	58 08       	cp.w	r8,0
80019d4a:	c7 f0       	breq	80019e48 <_fflush_r+0x108>
80019d4c:	58 0c       	cp.w	r12,0
80019d4e:	c0 50       	breq	80019d58 <_fflush_r+0x18>
80019d50:	78 68       	ld.w	r8,r12[0x18]
80019d52:	58 08       	cp.w	r8,0
80019d54:	c0 21       	brne	80019d58 <_fflush_r+0x18>
80019d56:	cd fc       	rcall	80019f14 <__sinit>
80019d58:	fe c8 98 fc 	sub	r8,pc,-26372
80019d5c:	10 37       	cp.w	r7,r8
80019d5e:	c0 31       	brne	80019d64 <_fflush_r+0x24>
80019d60:	6c 07       	ld.w	r7,r6[0x0]
80019d62:	c0 c8       	rjmp	80019d7a <_fflush_r+0x3a>
80019d64:	fe c8 98 e8 	sub	r8,pc,-26392
80019d68:	10 37       	cp.w	r7,r8
80019d6a:	c0 31       	brne	80019d70 <_fflush_r+0x30>
80019d6c:	6c 17       	ld.w	r7,r6[0x4]
80019d6e:	c0 68       	rjmp	80019d7a <_fflush_r+0x3a>
80019d70:	fe c8 98 d4 	sub	r8,pc,-26412
80019d74:	10 37       	cp.w	r7,r8
80019d76:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80019d7a:	8e 6a       	ld.sh	r10,r7[0xc]
80019d7c:	14 98       	mov	r8,r10
80019d7e:	ed ba 00 03 	bld	r10,0x3
80019d82:	c4 20       	breq	80019e06 <_fflush_r+0xc6>
80019d84:	ab ba       	sbr	r10,0xb
80019d86:	ae 6a       	st.h	r7[0xc],r10
80019d88:	6e 18       	ld.w	r8,r7[0x4]
80019d8a:	58 08       	cp.w	r8,0
80019d8c:	e0 89 00 06 	brgt	80019d98 <_fflush_r+0x58>
80019d90:	6f 08       	ld.w	r8,r7[0x40]
80019d92:	58 08       	cp.w	r8,0
80019d94:	e0 8a 00 5a 	brle	80019e48 <_fflush_r+0x108>
80019d98:	6e b8       	ld.w	r8,r7[0x2c]
80019d9a:	58 08       	cp.w	r8,0
80019d9c:	c5 60       	breq	80019e48 <_fflush_r+0x108>
80019d9e:	e2 1a 10 00 	andl	r10,0x1000,COH
80019da2:	c0 30       	breq	80019da8 <_fflush_r+0x68>
80019da4:	6f 55       	ld.w	r5,r7[0x54]
80019da6:	c0 f8       	rjmp	80019dc4 <_fflush_r+0x84>
80019da8:	30 19       	mov	r9,1
80019daa:	6e 8b       	ld.w	r11,r7[0x20]
80019dac:	0c 9c       	mov	r12,r6
80019dae:	5d 18       	icall	r8
80019db0:	18 95       	mov	r5,r12
80019db2:	5b fc       	cp.w	r12,-1
80019db4:	c0 81       	brne	80019dc4 <_fflush_r+0x84>
80019db6:	6c 38       	ld.w	r8,r6[0xc]
80019db8:	59 d8       	cp.w	r8,29
80019dba:	c4 70       	breq	80019e48 <_fflush_r+0x108>
80019dbc:	8e 68       	ld.sh	r8,r7[0xc]
80019dbe:	a7 a8       	sbr	r8,0x6
80019dc0:	ae 68       	st.h	r7[0xc],r8
80019dc2:	d8 22       	popm	r4-r7,pc
80019dc4:	8e 68       	ld.sh	r8,r7[0xc]
80019dc6:	ed b8 00 02 	bld	r8,0x2
80019dca:	c0 91       	brne	80019ddc <_fflush_r+0x9c>
80019dcc:	6e 18       	ld.w	r8,r7[0x4]
80019dce:	10 15       	sub	r5,r8
80019dd0:	6e d8       	ld.w	r8,r7[0x34]
80019dd2:	58 08       	cp.w	r8,0
80019dd4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80019dd8:	eb d8 e1 15 	subne	r5,r5,r8
80019ddc:	6e b8       	ld.w	r8,r7[0x2c]
80019dde:	0c 9c       	mov	r12,r6
80019de0:	30 09       	mov	r9,0
80019de2:	0a 9a       	mov	r10,r5
80019de4:	6e 8b       	ld.w	r11,r7[0x20]
80019de6:	5d 18       	icall	r8
80019de8:	8e 68       	ld.sh	r8,r7[0xc]
80019dea:	0a 3c       	cp.w	r12,r5
80019dec:	c2 61       	brne	80019e38 <_fflush_r+0xf8>
80019dee:	ab d8       	cbr	r8,0xb
80019df0:	30 0c       	mov	r12,0
80019df2:	6e 49       	ld.w	r9,r7[0x10]
80019df4:	ae 68       	st.h	r7[0xc],r8
80019df6:	8f 1c       	st.w	r7[0x4],r12
80019df8:	8f 09       	st.w	r7[0x0],r9
80019dfa:	ed b8 00 0c 	bld	r8,0xc
80019dfe:	c2 51       	brne	80019e48 <_fflush_r+0x108>
80019e00:	ef 45 00 54 	st.w	r7[84],r5
80019e04:	d8 22       	popm	r4-r7,pc
80019e06:	6e 45       	ld.w	r5,r7[0x10]
80019e08:	58 05       	cp.w	r5,0
80019e0a:	c1 f0       	breq	80019e48 <_fflush_r+0x108>
80019e0c:	6e 04       	ld.w	r4,r7[0x0]
80019e0e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80019e12:	8f 05       	st.w	r7[0x0],r5
80019e14:	f9 b8 01 00 	movne	r8,0
80019e18:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80019e1c:	0a 14       	sub	r4,r5
80019e1e:	8f 28       	st.w	r7[0x8],r8
80019e20:	c1 18       	rjmp	80019e42 <_fflush_r+0x102>
80019e22:	08 99       	mov	r9,r4
80019e24:	0a 9a       	mov	r10,r5
80019e26:	6e a8       	ld.w	r8,r7[0x28]
80019e28:	6e 8b       	ld.w	r11,r7[0x20]
80019e2a:	0c 9c       	mov	r12,r6
80019e2c:	5d 18       	icall	r8
80019e2e:	18 14       	sub	r4,r12
80019e30:	58 0c       	cp.w	r12,0
80019e32:	e0 89 00 07 	brgt	80019e40 <_fflush_r+0x100>
80019e36:	8e 68       	ld.sh	r8,r7[0xc]
80019e38:	a7 a8       	sbr	r8,0x6
80019e3a:	3f fc       	mov	r12,-1
80019e3c:	ae 68       	st.h	r7[0xc],r8
80019e3e:	d8 22       	popm	r4-r7,pc
80019e40:	18 05       	add	r5,r12
80019e42:	58 04       	cp.w	r4,0
80019e44:	fe 99 ff ef 	brgt	80019e22 <_fflush_r+0xe2>
80019e48:	d8 2a       	popm	r4-r7,pc,r12=0
80019e4a:	d7 03       	nop

80019e4c <fflush>:
80019e4c:	d4 01       	pushm	lr
80019e4e:	18 9b       	mov	r11,r12
80019e50:	58 0c       	cp.w	r12,0
80019e52:	c0 91       	brne	80019e64 <fflush+0x18>
80019e54:	fe c8 9e 0c 	sub	r8,pc,-25076
80019e58:	fe cb 01 18 	sub	r11,pc,280
80019e5c:	70 0c       	ld.w	r12,r8[0x0]
80019e5e:	e0 a0 03 5f 	rcall	8001a51c <_fwalk_reent>
80019e62:	d8 02       	popm	pc
80019e64:	e0 68 01 20 	mov	r8,288
80019e68:	70 0c       	ld.w	r12,r8[0x0]
80019e6a:	c6 bf       	rcall	80019d40 <_fflush_r>
80019e6c:	d8 02       	popm	pc
80019e6e:	d7 03       	nop

80019e70 <__sfp_lock_acquire>:
80019e70:	5e fc       	retal	r12

80019e72 <__sfp_lock_release>:
80019e72:	5e fc       	retal	r12

80019e74 <_cleanup_r>:
80019e74:	d4 01       	pushm	lr
80019e76:	fe cb d5 b6 	sub	r11,pc,-10826
80019e7a:	e0 a0 03 79 	rcall	8001a56c <_fwalk>
80019e7e:	d8 02       	popm	pc

80019e80 <__sfmoreglue>:
80019e80:	d4 21       	pushm	r4-r7,lr
80019e82:	16 95       	mov	r5,r11
80019e84:	f6 06 10 5c 	mul	r6,r11,92
80019e88:	ec cb ff f4 	sub	r11,r6,-12
80019e8c:	fe b0 d8 ee 	rcall	80015068 <_malloc_r>
80019e90:	18 97       	mov	r7,r12
80019e92:	c0 90       	breq	80019ea4 <__sfmoreglue+0x24>
80019e94:	99 15       	st.w	r12[0x4],r5
80019e96:	30 0b       	mov	r11,0
80019e98:	2f 4c       	sub	r12,-12
80019e9a:	0c 9a       	mov	r10,r6
80019e9c:	8f 2c       	st.w	r7[0x8],r12
80019e9e:	8f 0b       	st.w	r7[0x0],r11
80019ea0:	fe b0 db b1 	rcall	80015602 <memset>
80019ea4:	0e 9c       	mov	r12,r7
80019ea6:	d8 22       	popm	r4-r7,pc

80019ea8 <__sfp>:
80019ea8:	d4 21       	pushm	r4-r7,lr
80019eaa:	fe c8 9e 62 	sub	r8,pc,-24990
80019eae:	18 96       	mov	r6,r12
80019eb0:	70 07       	ld.w	r7,r8[0x0]
80019eb2:	6e 68       	ld.w	r8,r7[0x18]
80019eb4:	58 08       	cp.w	r8,0
80019eb6:	c0 31       	brne	80019ebc <__sfp+0x14>
80019eb8:	0e 9c       	mov	r12,r7
80019eba:	c2 dc       	rcall	80019f14 <__sinit>
80019ebc:	ee c7 ff 28 	sub	r7,r7,-216
80019ec0:	30 05       	mov	r5,0
80019ec2:	6e 2c       	ld.w	r12,r7[0x8]
80019ec4:	6e 18       	ld.w	r8,r7[0x4]
80019ec6:	c0 68       	rjmp	80019ed2 <__sfp+0x2a>
80019ec8:	98 69       	ld.sh	r9,r12[0xc]
80019eca:	ea 09 19 00 	cp.h	r9,r5
80019ece:	c1 10       	breq	80019ef0 <__sfp+0x48>
80019ed0:	2a 4c       	sub	r12,-92
80019ed2:	20 18       	sub	r8,1
80019ed4:	cf a7       	brpl	80019ec8 <__sfp+0x20>
80019ed6:	6e 08       	ld.w	r8,r7[0x0]
80019ed8:	58 08       	cp.w	r8,0
80019eda:	c0 61       	brne	80019ee6 <__sfp+0x3e>
80019edc:	30 4b       	mov	r11,4
80019ede:	0c 9c       	mov	r12,r6
80019ee0:	cd 0f       	rcall	80019e80 <__sfmoreglue>
80019ee2:	8f 0c       	st.w	r7[0x0],r12
80019ee4:	c0 30       	breq	80019eea <__sfp+0x42>
80019ee6:	6e 07       	ld.w	r7,r7[0x0]
80019ee8:	ce db       	rjmp	80019ec2 <__sfp+0x1a>
80019eea:	30 c8       	mov	r8,12
80019eec:	8d 38       	st.w	r6[0xc],r8
80019eee:	d8 22       	popm	r4-r7,pc
80019ef0:	30 08       	mov	r8,0
80019ef2:	f9 48 00 4c 	st.w	r12[76],r8
80019ef6:	99 08       	st.w	r12[0x0],r8
80019ef8:	99 28       	st.w	r12[0x8],r8
80019efa:	99 18       	st.w	r12[0x4],r8
80019efc:	99 48       	st.w	r12[0x10],r8
80019efe:	99 58       	st.w	r12[0x14],r8
80019f00:	99 68       	st.w	r12[0x18],r8
80019f02:	99 d8       	st.w	r12[0x34],r8
80019f04:	99 e8       	st.w	r12[0x38],r8
80019f06:	f9 48 00 48 	st.w	r12[72],r8
80019f0a:	3f f8       	mov	r8,-1
80019f0c:	b8 78       	st.h	r12[0xe],r8
80019f0e:	30 18       	mov	r8,1
80019f10:	b8 68       	st.h	r12[0xc],r8
80019f12:	d8 22       	popm	r4-r7,pc

80019f14 <__sinit>:
80019f14:	d4 21       	pushm	r4-r7,lr
80019f16:	18 96       	mov	r6,r12
80019f18:	78 67       	ld.w	r7,r12[0x18]
80019f1a:	58 07       	cp.w	r7,0
80019f1c:	c4 91       	brne	80019fae <__sinit+0x9a>
80019f1e:	fe c8 00 aa 	sub	r8,pc,170
80019f22:	30 15       	mov	r5,1
80019f24:	99 a8       	st.w	r12[0x28],r8
80019f26:	f9 47 00 d8 	st.w	r12[216],r7
80019f2a:	f9 47 00 dc 	st.w	r12[220],r7
80019f2e:	f9 47 00 e0 	st.w	r12[224],r7
80019f32:	99 65       	st.w	r12[0x18],r5
80019f34:	cb af       	rcall	80019ea8 <__sfp>
80019f36:	8d 0c       	st.w	r6[0x0],r12
80019f38:	0c 9c       	mov	r12,r6
80019f3a:	cb 7f       	rcall	80019ea8 <__sfp>
80019f3c:	8d 1c       	st.w	r6[0x4],r12
80019f3e:	0c 9c       	mov	r12,r6
80019f40:	cb 4f       	rcall	80019ea8 <__sfp>
80019f42:	6c 09       	ld.w	r9,r6[0x0]
80019f44:	30 48       	mov	r8,4
80019f46:	93 07       	st.w	r9[0x0],r7
80019f48:	b2 68       	st.h	r9[0xc],r8
80019f4a:	93 17       	st.w	r9[0x4],r7
80019f4c:	93 27       	st.w	r9[0x8],r7
80019f4e:	6c 18       	ld.w	r8,r6[0x4]
80019f50:	b2 77       	st.h	r9[0xe],r7
80019f52:	93 47       	st.w	r9[0x10],r7
80019f54:	93 57       	st.w	r9[0x14],r7
80019f56:	93 67       	st.w	r9[0x18],r7
80019f58:	93 89       	st.w	r9[0x20],r9
80019f5a:	91 07       	st.w	r8[0x0],r7
80019f5c:	91 17       	st.w	r8[0x4],r7
80019f5e:	91 27       	st.w	r8[0x8],r7
80019f60:	fe ce eb 14 	sub	lr,pc,-5356
80019f64:	fe cb eb 48 	sub	r11,pc,-5304
80019f68:	93 9e       	st.w	r9[0x24],lr
80019f6a:	93 ab       	st.w	r9[0x28],r11
80019f6c:	fe ca eb 74 	sub	r10,pc,-5260
80019f70:	fe c4 eb 84 	sub	r4,pc,-5244
80019f74:	93 ba       	st.w	r9[0x2c],r10
80019f76:	93 c4       	st.w	r9[0x30],r4
80019f78:	30 99       	mov	r9,9
80019f7a:	b0 69       	st.h	r8[0xc],r9
80019f7c:	b0 75       	st.h	r8[0xe],r5
80019f7e:	91 c4       	st.w	r8[0x30],r4
80019f80:	91 47       	st.w	r8[0x10],r7
80019f82:	91 57       	st.w	r8[0x14],r7
80019f84:	91 67       	st.w	r8[0x18],r7
80019f86:	91 88       	st.w	r8[0x20],r8
80019f88:	91 9e       	st.w	r8[0x24],lr
80019f8a:	91 ab       	st.w	r8[0x28],r11
80019f8c:	91 ba       	st.w	r8[0x2c],r10
80019f8e:	8d 2c       	st.w	r6[0x8],r12
80019f90:	31 28       	mov	r8,18
80019f92:	99 07       	st.w	r12[0x0],r7
80019f94:	b8 68       	st.h	r12[0xc],r8
80019f96:	99 17       	st.w	r12[0x4],r7
80019f98:	99 27       	st.w	r12[0x8],r7
80019f9a:	30 28       	mov	r8,2
80019f9c:	b8 78       	st.h	r12[0xe],r8
80019f9e:	99 c4       	st.w	r12[0x30],r4
80019fa0:	99 67       	st.w	r12[0x18],r7
80019fa2:	99 9e       	st.w	r12[0x24],lr
80019fa4:	99 ab       	st.w	r12[0x28],r11
80019fa6:	99 ba       	st.w	r12[0x2c],r10
80019fa8:	99 47       	st.w	r12[0x10],r7
80019faa:	99 57       	st.w	r12[0x14],r7
80019fac:	99 8c       	st.w	r12[0x20],r12
80019fae:	d8 22       	popm	r4-r7,pc

80019fb0 <_fread_r>:
80019fb0:	d4 31       	pushm	r0-r7,lr
80019fb2:	14 90       	mov	r0,r10
80019fb4:	12 91       	mov	r1,r9
80019fb6:	16 93       	mov	r3,r11
80019fb8:	10 97       	mov	r7,r8
80019fba:	18 95       	mov	r5,r12
80019fbc:	f2 0a 02 42 	mul	r2,r9,r10
80019fc0:	58 02       	cp.w	r2,0
80019fc2:	c0 31       	brne	80019fc8 <_fread_r+0x18>
80019fc4:	04 91       	mov	r1,r2
80019fc6:	c4 38       	rjmp	8001a04c <_fread_r+0x9c>
80019fc8:	58 0c       	cp.w	r12,0
80019fca:	c0 50       	breq	80019fd4 <_fread_r+0x24>
80019fcc:	78 68       	ld.w	r8,r12[0x18]
80019fce:	58 08       	cp.w	r8,0
80019fd0:	c0 21       	brne	80019fd4 <_fread_r+0x24>
80019fd2:	ca 1f       	rcall	80019f14 <__sinit>
80019fd4:	fe c8 9b 78 	sub	r8,pc,-25736
80019fd8:	10 37       	cp.w	r7,r8
80019fda:	c0 31       	brne	80019fe0 <_fread_r+0x30>
80019fdc:	6a 07       	ld.w	r7,r5[0x0]
80019fde:	c0 c8       	rjmp	80019ff6 <_fread_r+0x46>
80019fe0:	fe c8 9b 64 	sub	r8,pc,-25756
80019fe4:	10 37       	cp.w	r7,r8
80019fe6:	c0 31       	brne	80019fec <_fread_r+0x3c>
80019fe8:	6a 17       	ld.w	r7,r5[0x4]
80019fea:	c0 68       	rjmp	80019ff6 <_fread_r+0x46>
80019fec:	fe c8 9b 50 	sub	r8,pc,-25776
80019ff0:	10 37       	cp.w	r7,r8
80019ff2:	eb f7 00 02 	ld.weq	r7,r5[0x8]
80019ff6:	6e 18       	ld.w	r8,r7[0x4]
80019ff8:	58 08       	cp.w	r8,0
80019ffa:	c0 34       	brge	8001a000 <_fread_r+0x50>
80019ffc:	30 08       	mov	r8,0
80019ffe:	8f 18       	st.w	r7[0x4],r8
8001a000:	04 96       	mov	r6,r2
8001a002:	c1 48       	rjmp	8001a02a <_fread_r+0x7a>
8001a004:	fe b0 da 5b 	rcall	800154ba <memcpy>
8001a008:	6e 08       	ld.w	r8,r7[0x0]
8001a00a:	08 03       	add	r3,r4
8001a00c:	08 16       	sub	r6,r4
8001a00e:	0e 9b       	mov	r11,r7
8001a010:	f0 04 00 04 	add	r4,r8,r4
8001a014:	0a 9c       	mov	r12,r5
8001a016:	8f 04       	st.w	r7[0x0],r4
8001a018:	e0 a0 08 f4 	rcall	8001b200 <__srefill_r>
8001a01c:	c0 70       	breq	8001a02a <_fread_r+0x7a>
8001a01e:	e4 06 01 09 	sub	r9,r2,r6
8001a022:	f2 00 0d 08 	divu	r8,r9,r0
8001a026:	10 91       	mov	r1,r8
8001a028:	c1 28       	rjmp	8001a04c <_fread_r+0x9c>
8001a02a:	6e 14       	ld.w	r4,r7[0x4]
8001a02c:	6e 08       	ld.w	r8,r7[0x0]
8001a02e:	06 9c       	mov	r12,r3
8001a030:	08 9a       	mov	r10,r4
8001a032:	10 9b       	mov	r11,r8
8001a034:	08 36       	cp.w	r6,r4
8001a036:	fe 9b ff e7 	brhi	8001a004 <_fread_r+0x54>
8001a03a:	0c 9a       	mov	r10,r6
8001a03c:	fe b0 da 3f 	rcall	800154ba <memcpy>
8001a040:	6e 08       	ld.w	r8,r7[0x0]
8001a042:	0c 08       	add	r8,r6
8001a044:	8f 08       	st.w	r7[0x0],r8
8001a046:	6e 18       	ld.w	r8,r7[0x4]
8001a048:	0c 18       	sub	r8,r6
8001a04a:	8f 18       	st.w	r7[0x4],r8
8001a04c:	02 9c       	mov	r12,r1
8001a04e:	d8 32       	popm	r0-r7,pc

8001a050 <fread>:
8001a050:	d4 01       	pushm	lr
8001a052:	12 98       	mov	r8,r9
8001a054:	14 99       	mov	r9,r10
8001a056:	16 9a       	mov	r10,r11
8001a058:	18 9b       	mov	r11,r12
8001a05a:	e0 6c 01 20 	mov	r12,288
8001a05e:	78 0c       	ld.w	r12,r12[0x0]
8001a060:	ca 8f       	rcall	80019fb0 <_fread_r>
8001a062:	d8 02       	popm	pc

8001a064 <_malloc_trim_r>:
8001a064:	d4 21       	pushm	r4-r7,lr
8001a066:	16 95       	mov	r5,r11
8001a068:	18 97       	mov	r7,r12
8001a06a:	fe b0 da d3 	rcall	80015610 <__malloc_lock>
8001a06e:	e0 64 01 24 	mov	r4,292
8001a072:	68 28       	ld.w	r8,r4[0x8]
8001a074:	70 16       	ld.w	r6,r8[0x4]
8001a076:	e0 16 ff fc 	andl	r6,0xfffc
8001a07a:	ec c8 ff 91 	sub	r8,r6,-111
8001a07e:	f0 05 01 05 	sub	r5,r8,r5
8001a082:	e0 15 ff 80 	andl	r5,0xff80
8001a086:	ea c5 00 80 	sub	r5,r5,128
8001a08a:	e0 45 00 7f 	cp.w	r5,127
8001a08e:	e0 8a 00 25 	brle	8001a0d8 <_malloc_trim_r+0x74>
8001a092:	30 0b       	mov	r11,0
8001a094:	0e 9c       	mov	r12,r7
8001a096:	fe b0 da bf 	rcall	80015614 <_sbrk_r>
8001a09a:	68 28       	ld.w	r8,r4[0x8]
8001a09c:	0c 08       	add	r8,r6
8001a09e:	10 3c       	cp.w	r12,r8
8001a0a0:	c1 c1       	brne	8001a0d8 <_malloc_trim_r+0x74>
8001a0a2:	ea 0b 11 00 	rsub	r11,r5,0
8001a0a6:	0e 9c       	mov	r12,r7
8001a0a8:	fe b0 da b6 	rcall	80015614 <_sbrk_r>
8001a0ac:	5b fc       	cp.w	r12,-1
8001a0ae:	c1 91       	brne	8001a0e0 <_malloc_trim_r+0x7c>
8001a0b0:	30 0b       	mov	r11,0
8001a0b2:	0e 9c       	mov	r12,r7
8001a0b4:	fe b0 da b0 	rcall	80015614 <_sbrk_r>
8001a0b8:	68 28       	ld.w	r8,r4[0x8]
8001a0ba:	f8 08 01 09 	sub	r9,r12,r8
8001a0be:	58 f9       	cp.w	r9,15
8001a0c0:	e0 8a 00 0c 	brle	8001a0d8 <_malloc_trim_r+0x74>
8001a0c4:	a1 a9       	sbr	r9,0x0
8001a0c6:	91 19       	st.w	r8[0x4],r9
8001a0c8:	e0 68 05 30 	mov	r8,1328
8001a0cc:	70 09       	ld.w	r9,r8[0x0]
8001a0ce:	e0 68 07 94 	mov	r8,1940
8001a0d2:	f8 09 01 09 	sub	r9,r12,r9
8001a0d6:	91 09       	st.w	r8[0x0],r9
8001a0d8:	0e 9c       	mov	r12,r7
8001a0da:	fe b0 da 9c 	rcall	80015612 <__malloc_unlock>
8001a0de:	d8 2a       	popm	r4-r7,pc,r12=0
8001a0e0:	68 28       	ld.w	r8,r4[0x8]
8001a0e2:	0a 16       	sub	r6,r5
8001a0e4:	a1 a6       	sbr	r6,0x0
8001a0e6:	91 16       	st.w	r8[0x4],r6
8001a0e8:	e0 68 07 94 	mov	r8,1940
8001a0ec:	70 09       	ld.w	r9,r8[0x0]
8001a0ee:	0a 19       	sub	r9,r5
8001a0f0:	0e 9c       	mov	r12,r7
8001a0f2:	91 09       	st.w	r8[0x0],r9
8001a0f4:	fe b0 da 8f 	rcall	80015612 <__malloc_unlock>
8001a0f8:	da 2a       	popm	r4-r7,pc,r12=1
8001a0fa:	d7 03       	nop

8001a0fc <_free_r>:
8001a0fc:	d4 21       	pushm	r4-r7,lr
8001a0fe:	16 96       	mov	r6,r11
8001a100:	18 97       	mov	r7,r12
8001a102:	58 0b       	cp.w	r11,0
8001a104:	e0 80 00 c0 	breq	8001a284 <_free_r+0x188>
8001a108:	fe b0 da 84 	rcall	80015610 <__malloc_lock>
8001a10c:	20 86       	sub	r6,8
8001a10e:	e0 6a 01 24 	mov	r10,292
8001a112:	6c 18       	ld.w	r8,r6[0x4]
8001a114:	74 2e       	ld.w	lr,r10[0x8]
8001a116:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8001a11a:	a1 c8       	cbr	r8,0x0
8001a11c:	ec 08 00 09 	add	r9,r6,r8
8001a120:	72 1b       	ld.w	r11,r9[0x4]
8001a122:	e0 1b ff fc 	andl	r11,0xfffc
8001a126:	1c 39       	cp.w	r9,lr
8001a128:	c1 e1       	brne	8001a164 <_free_r+0x68>
8001a12a:	f6 08 00 08 	add	r8,r11,r8
8001a12e:	58 0c       	cp.w	r12,0
8001a130:	c0 81       	brne	8001a140 <_free_r+0x44>
8001a132:	6c 09       	ld.w	r9,r6[0x0]
8001a134:	12 16       	sub	r6,r9
8001a136:	12 08       	add	r8,r9
8001a138:	6c 3b       	ld.w	r11,r6[0xc]
8001a13a:	6c 29       	ld.w	r9,r6[0x8]
8001a13c:	97 29       	st.w	r11[0x8],r9
8001a13e:	93 3b       	st.w	r9[0xc],r11
8001a140:	10 99       	mov	r9,r8
8001a142:	95 26       	st.w	r10[0x8],r6
8001a144:	a1 a9       	sbr	r9,0x0
8001a146:	8d 19       	st.w	r6[0x4],r9
8001a148:	e0 69 05 2c 	mov	r9,1324
8001a14c:	72 09       	ld.w	r9,r9[0x0]
8001a14e:	12 38       	cp.w	r8,r9
8001a150:	c0 63       	brcs	8001a15c <_free_r+0x60>
8001a152:	e0 68 07 90 	mov	r8,1936
8001a156:	0e 9c       	mov	r12,r7
8001a158:	70 0b       	ld.w	r11,r8[0x0]
8001a15a:	c8 5f       	rcall	8001a064 <_malloc_trim_r>
8001a15c:	0e 9c       	mov	r12,r7
8001a15e:	fe b0 da 5a 	rcall	80015612 <__malloc_unlock>
8001a162:	d8 22       	popm	r4-r7,pc
8001a164:	93 1b       	st.w	r9[0x4],r11
8001a166:	58 0c       	cp.w	r12,0
8001a168:	c0 30       	breq	8001a16e <_free_r+0x72>
8001a16a:	30 0c       	mov	r12,0
8001a16c:	c1 08       	rjmp	8001a18c <_free_r+0x90>
8001a16e:	6c 0e       	ld.w	lr,r6[0x0]
8001a170:	f4 c5 ff f8 	sub	r5,r10,-8
8001a174:	1c 16       	sub	r6,lr
8001a176:	1c 08       	add	r8,lr
8001a178:	6c 2e       	ld.w	lr,r6[0x8]
8001a17a:	0a 3e       	cp.w	lr,r5
8001a17c:	f9 bc 00 01 	moveq	r12,1
8001a180:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8001a184:	eb fe 1a 02 	st.wne	r5[0x8],lr
8001a188:	fd f5 1a 03 	st.wne	lr[0xc],r5
8001a18c:	f2 0b 00 0e 	add	lr,r9,r11
8001a190:	7c 1e       	ld.w	lr,lr[0x4]
8001a192:	ed be 00 00 	bld	lr,0x0
8001a196:	c1 40       	breq	8001a1be <_free_r+0xc2>
8001a198:	16 08       	add	r8,r11
8001a19a:	58 0c       	cp.w	r12,0
8001a19c:	c0 d1       	brne	8001a1b6 <_free_r+0xba>
8001a19e:	e0 6e 01 24 	mov	lr,292
8001a1a2:	72 2b       	ld.w	r11,r9[0x8]
8001a1a4:	2f 8e       	sub	lr,-8
8001a1a6:	1c 3b       	cp.w	r11,lr
8001a1a8:	c0 71       	brne	8001a1b6 <_free_r+0xba>
8001a1aa:	97 36       	st.w	r11[0xc],r6
8001a1ac:	97 26       	st.w	r11[0x8],r6
8001a1ae:	8d 2b       	st.w	r6[0x8],r11
8001a1b0:	8d 3b       	st.w	r6[0xc],r11
8001a1b2:	30 1c       	mov	r12,1
8001a1b4:	c0 58       	rjmp	8001a1be <_free_r+0xc2>
8001a1b6:	72 2b       	ld.w	r11,r9[0x8]
8001a1b8:	72 39       	ld.w	r9,r9[0xc]
8001a1ba:	93 2b       	st.w	r9[0x8],r11
8001a1bc:	97 39       	st.w	r11[0xc],r9
8001a1be:	10 99       	mov	r9,r8
8001a1c0:	ec 08 09 08 	st.w	r6[r8],r8
8001a1c4:	a1 a9       	sbr	r9,0x0
8001a1c6:	8d 19       	st.w	r6[0x4],r9
8001a1c8:	58 0c       	cp.w	r12,0
8001a1ca:	c5 a1       	brne	8001a27e <_free_r+0x182>
8001a1cc:	e0 48 01 ff 	cp.w	r8,511
8001a1d0:	e0 8b 00 13 	brhi	8001a1f6 <_free_r+0xfa>
8001a1d4:	a3 98       	lsr	r8,0x3
8001a1d6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8001a1da:	72 2b       	ld.w	r11,r9[0x8]
8001a1dc:	8d 39       	st.w	r6[0xc],r9
8001a1de:	8d 2b       	st.w	r6[0x8],r11
8001a1e0:	97 36       	st.w	r11[0xc],r6
8001a1e2:	93 26       	st.w	r9[0x8],r6
8001a1e4:	a3 48       	asr	r8,0x2
8001a1e6:	74 19       	ld.w	r9,r10[0x4]
8001a1e8:	30 1b       	mov	r11,1
8001a1ea:	f6 08 09 48 	lsl	r8,r11,r8
8001a1ee:	f3 e8 10 08 	or	r8,r9,r8
8001a1f2:	95 18       	st.w	r10[0x4],r8
8001a1f4:	c4 58       	rjmp	8001a27e <_free_r+0x182>
8001a1f6:	f0 0b 16 09 	lsr	r11,r8,0x9
8001a1fa:	58 4b       	cp.w	r11,4
8001a1fc:	e0 8b 00 06 	brhi	8001a208 <_free_r+0x10c>
8001a200:	f0 0b 16 06 	lsr	r11,r8,0x6
8001a204:	2c 8b       	sub	r11,-56
8001a206:	c2 08       	rjmp	8001a246 <_free_r+0x14a>
8001a208:	59 4b       	cp.w	r11,20
8001a20a:	e0 8b 00 04 	brhi	8001a212 <_free_r+0x116>
8001a20e:	2a 5b       	sub	r11,-91
8001a210:	c1 b8       	rjmp	8001a246 <_free_r+0x14a>
8001a212:	e0 4b 00 54 	cp.w	r11,84
8001a216:	e0 8b 00 06 	brhi	8001a222 <_free_r+0x126>
8001a21a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8001a21e:	29 2b       	sub	r11,-110
8001a220:	c1 38       	rjmp	8001a246 <_free_r+0x14a>
8001a222:	e0 4b 01 54 	cp.w	r11,340
8001a226:	e0 8b 00 06 	brhi	8001a232 <_free_r+0x136>
8001a22a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8001a22e:	28 9b       	sub	r11,-119
8001a230:	c0 b8       	rjmp	8001a246 <_free_r+0x14a>
8001a232:	e0 4b 05 54 	cp.w	r11,1364
8001a236:	e0 88 00 05 	brls	8001a240 <_free_r+0x144>
8001a23a:	37 eb       	mov	r11,126
8001a23c:	c0 58       	rjmp	8001a246 <_free_r+0x14a>
8001a23e:	d7 03       	nop
8001a240:	f0 0b 16 12 	lsr	r11,r8,0x12
8001a244:	28 4b       	sub	r11,-124
8001a246:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8001a24a:	78 29       	ld.w	r9,r12[0x8]
8001a24c:	18 39       	cp.w	r9,r12
8001a24e:	c0 e1       	brne	8001a26a <_free_r+0x16e>
8001a250:	74 18       	ld.w	r8,r10[0x4]
8001a252:	a3 4b       	asr	r11,0x2
8001a254:	30 1c       	mov	r12,1
8001a256:	f8 0b 09 4b 	lsl	r11,r12,r11
8001a25a:	f1 eb 10 0b 	or	r11,r8,r11
8001a25e:	12 98       	mov	r8,r9
8001a260:	95 1b       	st.w	r10[0x4],r11
8001a262:	c0 a8       	rjmp	8001a276 <_free_r+0x17a>
8001a264:	72 29       	ld.w	r9,r9[0x8]
8001a266:	18 39       	cp.w	r9,r12
8001a268:	c0 60       	breq	8001a274 <_free_r+0x178>
8001a26a:	72 1a       	ld.w	r10,r9[0x4]
8001a26c:	e0 1a ff fc 	andl	r10,0xfffc
8001a270:	14 38       	cp.w	r8,r10
8001a272:	cf 93       	brcs	8001a264 <_free_r+0x168>
8001a274:	72 38       	ld.w	r8,r9[0xc]
8001a276:	8d 38       	st.w	r6[0xc],r8
8001a278:	8d 29       	st.w	r6[0x8],r9
8001a27a:	93 36       	st.w	r9[0xc],r6
8001a27c:	91 26       	st.w	r8[0x8],r6
8001a27e:	0e 9c       	mov	r12,r7
8001a280:	fe b0 d9 c9 	rcall	80015612 <__malloc_unlock>
8001a284:	d8 22       	popm	r4-r7,pc
8001a286:	d7 03       	nop

8001a288 <__sfvwrite_r>:
8001a288:	d4 31       	pushm	r0-r7,lr
8001a28a:	20 3d       	sub	sp,12
8001a28c:	14 94       	mov	r4,r10
8001a28e:	18 95       	mov	r5,r12
8001a290:	16 97       	mov	r7,r11
8001a292:	74 28       	ld.w	r8,r10[0x8]
8001a294:	58 08       	cp.w	r8,0
8001a296:	e0 80 01 40 	breq	8001a516 <__sfvwrite_r+0x28e>
8001a29a:	96 68       	ld.sh	r8,r11[0xc]
8001a29c:	ed b8 00 03 	bld	r8,0x3
8001a2a0:	c0 41       	brne	8001a2a8 <__sfvwrite_r+0x20>
8001a2a2:	76 48       	ld.w	r8,r11[0x10]
8001a2a4:	58 08       	cp.w	r8,0
8001a2a6:	c0 c1       	brne	8001a2be <__sfvwrite_r+0x36>
8001a2a8:	0e 9b       	mov	r11,r7
8001a2aa:	0a 9c       	mov	r12,r5
8001a2ac:	fe b0 f6 56 	rcall	80018f58 <__swsetup_r>
8001a2b0:	c0 70       	breq	8001a2be <__sfvwrite_r+0x36>
8001a2b2:	8e 68       	ld.sh	r8,r7[0xc]
8001a2b4:	a7 a8       	sbr	r8,0x6
8001a2b6:	ae 68       	st.h	r7[0xc],r8
8001a2b8:	30 98       	mov	r8,9
8001a2ba:	8b 38       	st.w	r5[0xc],r8
8001a2bc:	c2 b9       	rjmp	8001a512 <__sfvwrite_r+0x28a>
8001a2be:	8e 63       	ld.sh	r3,r7[0xc]
8001a2c0:	68 00       	ld.w	r0,r4[0x0]
8001a2c2:	06 96       	mov	r6,r3
8001a2c4:	e2 16 00 02 	andl	r6,0x2,COH
8001a2c8:	c2 10       	breq	8001a30a <__sfvwrite_r+0x82>
8001a2ca:	30 03       	mov	r3,0
8001a2cc:	e0 62 04 00 	mov	r2,1024
8001a2d0:	06 96       	mov	r6,r3
8001a2d2:	c0 48       	rjmp	8001a2da <__sfvwrite_r+0x52>
8001a2d4:	60 03       	ld.w	r3,r0[0x0]
8001a2d6:	60 16       	ld.w	r6,r0[0x4]
8001a2d8:	2f 80       	sub	r0,-8
8001a2da:	58 06       	cp.w	r6,0
8001a2dc:	cf c0       	breq	8001a2d4 <__sfvwrite_r+0x4c>
8001a2de:	e0 46 04 00 	cp.w	r6,1024
8001a2e2:	ec 09 17 80 	movls	r9,r6
8001a2e6:	e4 09 17 b0 	movhi	r9,r2
8001a2ea:	06 9a       	mov	r10,r3
8001a2ec:	6e a8       	ld.w	r8,r7[0x28]
8001a2ee:	6e 8b       	ld.w	r11,r7[0x20]
8001a2f0:	0a 9c       	mov	r12,r5
8001a2f2:	5d 18       	icall	r8
8001a2f4:	18 16       	sub	r6,r12
8001a2f6:	58 0c       	cp.w	r12,0
8001a2f8:	e0 8a 01 0a 	brle	8001a50c <__sfvwrite_r+0x284>
8001a2fc:	68 28       	ld.w	r8,r4[0x8]
8001a2fe:	18 18       	sub	r8,r12
8001a300:	89 28       	st.w	r4[0x8],r8
8001a302:	e0 80 01 0a 	breq	8001a516 <__sfvwrite_r+0x28e>
8001a306:	18 03       	add	r3,r12
8001a308:	ce 9b       	rjmp	8001a2da <__sfvwrite_r+0x52>
8001a30a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8001a30e:	c0 70       	breq	8001a31c <__sfvwrite_r+0x94>
8001a310:	50 06       	stdsp	sp[0x0],r6
8001a312:	0c 93       	mov	r3,r6
8001a314:	0c 91       	mov	r1,r6
8001a316:	50 15       	stdsp	sp[0x4],r5
8001a318:	08 92       	mov	r2,r4
8001a31a:	c9 c8       	rjmp	8001a452 <__sfvwrite_r+0x1ca>
8001a31c:	06 96       	mov	r6,r3
8001a31e:	08 91       	mov	r1,r4
8001a320:	c0 48       	rjmp	8001a328 <__sfvwrite_r+0xa0>
8001a322:	60 03       	ld.w	r3,r0[0x0]
8001a324:	60 16       	ld.w	r6,r0[0x4]
8001a326:	2f 80       	sub	r0,-8
8001a328:	58 06       	cp.w	r6,0
8001a32a:	cf c0       	breq	8001a322 <__sfvwrite_r+0x9a>
8001a32c:	8e 68       	ld.sh	r8,r7[0xc]
8001a32e:	6e 24       	ld.w	r4,r7[0x8]
8001a330:	10 99       	mov	r9,r8
8001a332:	e2 19 02 00 	andl	r9,0x200,COH
8001a336:	c5 50       	breq	8001a3e0 <__sfvwrite_r+0x158>
8001a338:	08 36       	cp.w	r6,r4
8001a33a:	c4 43       	brcs	8001a3c2 <__sfvwrite_r+0x13a>
8001a33c:	10 99       	mov	r9,r8
8001a33e:	e2 19 04 80 	andl	r9,0x480,COH
8001a342:	c4 00       	breq	8001a3c2 <__sfvwrite_r+0x13a>
8001a344:	6e 4b       	ld.w	r11,r7[0x10]
8001a346:	6e 09       	ld.w	r9,r7[0x0]
8001a348:	16 19       	sub	r9,r11
8001a34a:	50 09       	stdsp	sp[0x0],r9
8001a34c:	6e 59       	ld.w	r9,r7[0x14]
8001a34e:	10 9c       	mov	r12,r8
8001a350:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8001a354:	30 28       	mov	r8,2
8001a356:	f4 08 0c 08 	divs	r8,r10,r8
8001a35a:	fa e9 00 04 	st.d	sp[4],r8
8001a35e:	10 94       	mov	r4,r8
8001a360:	40 09       	lddsp	r9,sp[0x0]
8001a362:	e2 1c 04 00 	andl	r12,0x400,COH
8001a366:	2f f9       	sub	r9,-1
8001a368:	0c 09       	add	r9,r6
8001a36a:	12 38       	cp.w	r8,r9
8001a36c:	f2 04 17 30 	movlo	r4,r9
8001a370:	58 0c       	cp.w	r12,0
8001a372:	c1 10       	breq	8001a394 <__sfvwrite_r+0x10c>
8001a374:	08 9b       	mov	r11,r4
8001a376:	0a 9c       	mov	r12,r5
8001a378:	fe b0 d6 78 	rcall	80015068 <_malloc_r>
8001a37c:	18 92       	mov	r2,r12
8001a37e:	c1 40       	breq	8001a3a6 <__sfvwrite_r+0x11e>
8001a380:	40 0a       	lddsp	r10,sp[0x0]
8001a382:	6e 4b       	ld.w	r11,r7[0x10]
8001a384:	fe b0 d8 9b 	rcall	800154ba <memcpy>
8001a388:	8e 68       	ld.sh	r8,r7[0xc]
8001a38a:	e0 18 fb 7f 	andl	r8,0xfb7f
8001a38e:	a7 b8       	sbr	r8,0x7
8001a390:	ae 68       	st.h	r7[0xc],r8
8001a392:	c0 d8       	rjmp	8001a3ac <__sfvwrite_r+0x124>
8001a394:	08 9a       	mov	r10,r4
8001a396:	0a 9c       	mov	r12,r5
8001a398:	e0 a0 05 d4 	rcall	8001af40 <_realloc_r>
8001a39c:	18 92       	mov	r2,r12
8001a39e:	c0 71       	brne	8001a3ac <__sfvwrite_r+0x124>
8001a3a0:	6e 4b       	ld.w	r11,r7[0x10]
8001a3a2:	0a 9c       	mov	r12,r5
8001a3a4:	ca ce       	rcall	8001a0fc <_free_r>
8001a3a6:	30 c8       	mov	r8,12
8001a3a8:	8b 38       	st.w	r5[0xc],r8
8001a3aa:	cb 18       	rjmp	8001a50c <__sfvwrite_r+0x284>
8001a3ac:	40 0a       	lddsp	r10,sp[0x0]
8001a3ae:	40 09       	lddsp	r9,sp[0x0]
8001a3b0:	e8 0a 01 0a 	sub	r10,r4,r10
8001a3b4:	e4 09 00 08 	add	r8,r2,r9
8001a3b8:	8f 54       	st.w	r7[0x14],r4
8001a3ba:	8f 2a       	st.w	r7[0x8],r10
8001a3bc:	8f 08       	st.w	r7[0x0],r8
8001a3be:	8f 42       	st.w	r7[0x10],r2
8001a3c0:	0c 94       	mov	r4,r6
8001a3c2:	08 36       	cp.w	r6,r4
8001a3c4:	ec 04 17 30 	movlo	r4,r6
8001a3c8:	06 9b       	mov	r11,r3
8001a3ca:	08 9a       	mov	r10,r4
8001a3cc:	6e 0c       	ld.w	r12,r7[0x0]
8001a3ce:	c9 cd       	rcall	8001a706 <memmove>
8001a3d0:	6e 08       	ld.w	r8,r7[0x0]
8001a3d2:	08 08       	add	r8,r4
8001a3d4:	8f 08       	st.w	r7[0x0],r8
8001a3d6:	6e 28       	ld.w	r8,r7[0x8]
8001a3d8:	08 18       	sub	r8,r4
8001a3da:	0c 94       	mov	r4,r6
8001a3dc:	8f 28       	st.w	r7[0x8],r8
8001a3de:	c2 e8       	rjmp	8001a43a <__sfvwrite_r+0x1b2>
8001a3e0:	08 36       	cp.w	r6,r4
8001a3e2:	5f ba       	srhi	r10
8001a3e4:	6e 0c       	ld.w	r12,r7[0x0]
8001a3e6:	6e 48       	ld.w	r8,r7[0x10]
8001a3e8:	10 3c       	cp.w	r12,r8
8001a3ea:	5f b8       	srhi	r8
8001a3ec:	f5 e8 00 08 	and	r8,r10,r8
8001a3f0:	f2 08 18 00 	cp.b	r8,r9
8001a3f4:	c0 d0       	breq	8001a40e <__sfvwrite_r+0x186>
8001a3f6:	06 9b       	mov	r11,r3
8001a3f8:	08 9a       	mov	r10,r4
8001a3fa:	c8 6d       	rcall	8001a706 <memmove>
8001a3fc:	6e 08       	ld.w	r8,r7[0x0]
8001a3fe:	08 08       	add	r8,r4
8001a400:	0e 9b       	mov	r11,r7
8001a402:	8f 08       	st.w	r7[0x0],r8
8001a404:	0a 9c       	mov	r12,r5
8001a406:	fe b0 fc 9d 	rcall	80019d40 <_fflush_r>
8001a40a:	c1 80       	breq	8001a43a <__sfvwrite_r+0x1b2>
8001a40c:	c8 08       	rjmp	8001a50c <__sfvwrite_r+0x284>
8001a40e:	6e 59       	ld.w	r9,r7[0x14]
8001a410:	12 36       	cp.w	r6,r9
8001a412:	c0 a3       	brcs	8001a426 <__sfvwrite_r+0x19e>
8001a414:	6e a8       	ld.w	r8,r7[0x28]
8001a416:	06 9a       	mov	r10,r3
8001a418:	6e 8b       	ld.w	r11,r7[0x20]
8001a41a:	0a 9c       	mov	r12,r5
8001a41c:	5d 18       	icall	r8
8001a41e:	18 94       	mov	r4,r12
8001a420:	e0 89 00 0d 	brgt	8001a43a <__sfvwrite_r+0x1b2>
8001a424:	c7 48       	rjmp	8001a50c <__sfvwrite_r+0x284>
8001a426:	0c 9a       	mov	r10,r6
8001a428:	06 9b       	mov	r11,r3
8001a42a:	c6 ed       	rcall	8001a706 <memmove>
8001a42c:	6e 08       	ld.w	r8,r7[0x0]
8001a42e:	0c 08       	add	r8,r6
8001a430:	0c 94       	mov	r4,r6
8001a432:	8f 08       	st.w	r7[0x0],r8
8001a434:	6e 28       	ld.w	r8,r7[0x8]
8001a436:	0c 18       	sub	r8,r6
8001a438:	8f 28       	st.w	r7[0x8],r8
8001a43a:	62 28       	ld.w	r8,r1[0x8]
8001a43c:	08 18       	sub	r8,r4
8001a43e:	83 28       	st.w	r1[0x8],r8
8001a440:	c6 b0       	breq	8001a516 <__sfvwrite_r+0x28e>
8001a442:	08 16       	sub	r6,r4
8001a444:	08 03       	add	r3,r4
8001a446:	c7 1b       	rjmp	8001a328 <__sfvwrite_r+0xa0>
8001a448:	60 03       	ld.w	r3,r0[0x0]
8001a44a:	60 11       	ld.w	r1,r0[0x4]
8001a44c:	30 08       	mov	r8,0
8001a44e:	2f 80       	sub	r0,-8
8001a450:	50 08       	stdsp	sp[0x0],r8
8001a452:	58 01       	cp.w	r1,0
8001a454:	cf a0       	breq	8001a448 <__sfvwrite_r+0x1c0>
8001a456:	40 0a       	lddsp	r10,sp[0x0]
8001a458:	58 0a       	cp.w	r10,0
8001a45a:	c1 41       	brne	8001a482 <__sfvwrite_r+0x1fa>
8001a45c:	e2 c6 ff ff 	sub	r6,r1,-1
8001a460:	02 9a       	mov	r10,r1
8001a462:	30 ab       	mov	r11,10
8001a464:	06 9c       	mov	r12,r3
8001a466:	c4 5d       	rcall	8001a6f0 <memchr>
8001a468:	f8 c8 ff ff 	sub	r8,r12,-1
8001a46c:	58 0c       	cp.w	r12,0
8001a46e:	f1 d3 e1 16 	subne	r6,r8,r3
8001a472:	f9 b9 01 01 	movne	r9,1
8001a476:	fb f9 1a 00 	st.wne	sp[0x0],r9
8001a47a:	f9 b8 00 01 	moveq	r8,1
8001a47e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8001a482:	02 36       	cp.w	r6,r1
8001a484:	ec 04 17 80 	movls	r4,r6
8001a488:	e2 04 17 b0 	movhi	r4,r1
8001a48c:	6e 59       	ld.w	r9,r7[0x14]
8001a48e:	6e 25       	ld.w	r5,r7[0x8]
8001a490:	f2 05 00 05 	add	r5,r9,r5
8001a494:	0a 34       	cp.w	r4,r5
8001a496:	5f 9a       	srgt	r10
8001a498:	6e 0c       	ld.w	r12,r7[0x0]
8001a49a:	6e 48       	ld.w	r8,r7[0x10]
8001a49c:	10 3c       	cp.w	r12,r8
8001a49e:	5f b8       	srhi	r8
8001a4a0:	f5 e8 00 08 	and	r8,r10,r8
8001a4a4:	30 0a       	mov	r10,0
8001a4a6:	f4 08 18 00 	cp.b	r8,r10
8001a4aa:	c0 d0       	breq	8001a4c4 <__sfvwrite_r+0x23c>
8001a4ac:	06 9b       	mov	r11,r3
8001a4ae:	0a 9a       	mov	r10,r5
8001a4b0:	c2 bd       	rcall	8001a706 <memmove>
8001a4b2:	6e 08       	ld.w	r8,r7[0x0]
8001a4b4:	0a 08       	add	r8,r5
8001a4b6:	0e 9b       	mov	r11,r7
8001a4b8:	8f 08       	st.w	r7[0x0],r8
8001a4ba:	40 1c       	lddsp	r12,sp[0x4]
8001a4bc:	fe b0 fc 42 	rcall	80019d40 <_fflush_r>
8001a4c0:	c1 70       	breq	8001a4ee <__sfvwrite_r+0x266>
8001a4c2:	c2 58       	rjmp	8001a50c <__sfvwrite_r+0x284>
8001a4c4:	12 34       	cp.w	r4,r9
8001a4c6:	c0 a5       	brlt	8001a4da <__sfvwrite_r+0x252>
8001a4c8:	6e a8       	ld.w	r8,r7[0x28]
8001a4ca:	06 9a       	mov	r10,r3
8001a4cc:	6e 8b       	ld.w	r11,r7[0x20]
8001a4ce:	40 1c       	lddsp	r12,sp[0x4]
8001a4d0:	5d 18       	icall	r8
8001a4d2:	18 95       	mov	r5,r12
8001a4d4:	e0 89 00 0d 	brgt	8001a4ee <__sfvwrite_r+0x266>
8001a4d8:	c1 a8       	rjmp	8001a50c <__sfvwrite_r+0x284>
8001a4da:	08 9a       	mov	r10,r4
8001a4dc:	06 9b       	mov	r11,r3
8001a4de:	c1 4d       	rcall	8001a706 <memmove>
8001a4e0:	6e 08       	ld.w	r8,r7[0x0]
8001a4e2:	08 08       	add	r8,r4
8001a4e4:	08 95       	mov	r5,r4
8001a4e6:	8f 08       	st.w	r7[0x0],r8
8001a4e8:	6e 28       	ld.w	r8,r7[0x8]
8001a4ea:	08 18       	sub	r8,r4
8001a4ec:	8f 28       	st.w	r7[0x8],r8
8001a4ee:	0a 16       	sub	r6,r5
8001a4f0:	c0 71       	brne	8001a4fe <__sfvwrite_r+0x276>
8001a4f2:	0e 9b       	mov	r11,r7
8001a4f4:	40 1c       	lddsp	r12,sp[0x4]
8001a4f6:	fe b0 fc 25 	rcall	80019d40 <_fflush_r>
8001a4fa:	c0 91       	brne	8001a50c <__sfvwrite_r+0x284>
8001a4fc:	50 06       	stdsp	sp[0x0],r6
8001a4fe:	64 28       	ld.w	r8,r2[0x8]
8001a500:	0a 18       	sub	r8,r5
8001a502:	85 28       	st.w	r2[0x8],r8
8001a504:	c0 90       	breq	8001a516 <__sfvwrite_r+0x28e>
8001a506:	0a 11       	sub	r1,r5
8001a508:	0a 03       	add	r3,r5
8001a50a:	ca 4b       	rjmp	8001a452 <__sfvwrite_r+0x1ca>
8001a50c:	8e 68       	ld.sh	r8,r7[0xc]
8001a50e:	a7 a8       	sbr	r8,0x6
8001a510:	ae 68       	st.h	r7[0xc],r8
8001a512:	3f fc       	mov	r12,-1
8001a514:	c0 28       	rjmp	8001a518 <__sfvwrite_r+0x290>
8001a516:	30 0c       	mov	r12,0
8001a518:	2f dd       	sub	sp,-12
8001a51a:	d8 32       	popm	r0-r7,pc

8001a51c <_fwalk_reent>:
8001a51c:	d4 31       	pushm	r0-r7,lr
8001a51e:	30 05       	mov	r5,0
8001a520:	18 93       	mov	r3,r12
8001a522:	16 90       	mov	r0,r11
8001a524:	0a 91       	mov	r1,r5
8001a526:	fe b0 fc a5 	rcall	80019e70 <__sfp_lock_acquire>
8001a52a:	3f f2       	mov	r2,-1
8001a52c:	e6 c7 ff 28 	sub	r7,r3,-216
8001a530:	c1 78       	rjmp	8001a55e <_fwalk_reent+0x42>
8001a532:	6e 26       	ld.w	r6,r7[0x8]
8001a534:	6e 14       	ld.w	r4,r7[0x4]
8001a536:	2f 46       	sub	r6,-12
8001a538:	c0 d8       	rjmp	8001a552 <_fwalk_reent+0x36>
8001a53a:	8c 08       	ld.sh	r8,r6[0x0]
8001a53c:	e2 08 19 00 	cp.h	r8,r1
8001a540:	c0 80       	breq	8001a550 <_fwalk_reent+0x34>
8001a542:	8c 18       	ld.sh	r8,r6[0x2]
8001a544:	e4 08 19 00 	cp.h	r8,r2
8001a548:	c0 40       	breq	8001a550 <_fwalk_reent+0x34>
8001a54a:	06 9c       	mov	r12,r3
8001a54c:	5d 10       	icall	r0
8001a54e:	18 45       	or	r5,r12
8001a550:	2a 46       	sub	r6,-92
8001a552:	20 14       	sub	r4,1
8001a554:	ec cb 00 0c 	sub	r11,r6,12
8001a558:	58 04       	cp.w	r4,0
8001a55a:	cf 04       	brge	8001a53a <_fwalk_reent+0x1e>
8001a55c:	6e 07       	ld.w	r7,r7[0x0]
8001a55e:	58 07       	cp.w	r7,0
8001a560:	ce 91       	brne	8001a532 <_fwalk_reent+0x16>
8001a562:	fe b0 fc 88 	rcall	80019e72 <__sfp_lock_release>
8001a566:	0a 9c       	mov	r12,r5
8001a568:	d8 32       	popm	r0-r7,pc
8001a56a:	d7 03       	nop

8001a56c <_fwalk>:
8001a56c:	d4 31       	pushm	r0-r7,lr
8001a56e:	30 05       	mov	r5,0
8001a570:	16 91       	mov	r1,r11
8001a572:	f8 c7 ff 28 	sub	r7,r12,-216
8001a576:	0a 92       	mov	r2,r5
8001a578:	fe b0 fc 7c 	rcall	80019e70 <__sfp_lock_acquire>
8001a57c:	3f f3       	mov	r3,-1
8001a57e:	c1 68       	rjmp	8001a5aa <_fwalk+0x3e>
8001a580:	6e 26       	ld.w	r6,r7[0x8]
8001a582:	6e 14       	ld.w	r4,r7[0x4]
8001a584:	2f 46       	sub	r6,-12
8001a586:	c0 c8       	rjmp	8001a59e <_fwalk+0x32>
8001a588:	8c 08       	ld.sh	r8,r6[0x0]
8001a58a:	e4 08 19 00 	cp.h	r8,r2
8001a58e:	c0 70       	breq	8001a59c <_fwalk+0x30>
8001a590:	8c 18       	ld.sh	r8,r6[0x2]
8001a592:	e6 08 19 00 	cp.h	r8,r3
8001a596:	c0 30       	breq	8001a59c <_fwalk+0x30>
8001a598:	5d 11       	icall	r1
8001a59a:	18 45       	or	r5,r12
8001a59c:	2a 46       	sub	r6,-92
8001a59e:	20 14       	sub	r4,1
8001a5a0:	ec cc 00 0c 	sub	r12,r6,12
8001a5a4:	58 04       	cp.w	r4,0
8001a5a6:	cf 14       	brge	8001a588 <_fwalk+0x1c>
8001a5a8:	6e 07       	ld.w	r7,r7[0x0]
8001a5aa:	58 07       	cp.w	r7,0
8001a5ac:	ce a1       	brne	8001a580 <_fwalk+0x14>
8001a5ae:	fe b0 fc 62 	rcall	80019e72 <__sfp_lock_release>
8001a5b2:	0a 9c       	mov	r12,r5
8001a5b4:	d8 32       	popm	r0-r7,pc
8001a5b6:	d7 03       	nop

8001a5b8 <iswspace>:
8001a5b8:	e0 4c 00 ff 	cp.w	r12,255
8001a5bc:	e0 88 00 03 	brls	8001a5c2 <iswspace+0xa>
8001a5c0:	5e fd       	retal	0
8001a5c2:	32 c8       	mov	r8,44
8001a5c4:	70 08       	ld.w	r8,r8[0x0]
8001a5c6:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
8001a5ca:	e2 1c 00 08 	andl	r12,0x8,COH
8001a5ce:	5e fc       	retal	r12

8001a5d0 <_localeconv_r>:
8001a5d0:	fe cc a1 14 	sub	r12,pc,-24300
8001a5d4:	5e fc       	retal	r12
8001a5d6:	d7 03       	nop

8001a5d8 <__smakebuf_r>:
8001a5d8:	d4 21       	pushm	r4-r7,lr
8001a5da:	20 fd       	sub	sp,60
8001a5dc:	96 68       	ld.sh	r8,r11[0xc]
8001a5de:	16 97       	mov	r7,r11
8001a5e0:	18 96       	mov	r6,r12
8001a5e2:	e2 18 00 02 	andl	r8,0x2,COH
8001a5e6:	c3 d1       	brne	8001a660 <__smakebuf_r+0x88>
8001a5e8:	96 7b       	ld.sh	r11,r11[0xe]
8001a5ea:	f0 0b 19 00 	cp.h	r11,r8
8001a5ee:	c0 55       	brlt	8001a5f8 <__smakebuf_r+0x20>
8001a5f0:	1a 9a       	mov	r10,sp
8001a5f2:	e0 a0 11 6f 	rcall	8001c8d0 <_fstat_r>
8001a5f6:	c0 f4       	brge	8001a614 <__smakebuf_r+0x3c>
8001a5f8:	8e 65       	ld.sh	r5,r7[0xc]
8001a5fa:	0a 98       	mov	r8,r5
8001a5fc:	ab b8       	sbr	r8,0xb
8001a5fe:	e2 15 00 80 	andl	r5,0x80,COH
8001a602:	ae 68       	st.h	r7[0xc],r8
8001a604:	30 04       	mov	r4,0
8001a606:	e0 68 04 00 	mov	r8,1024
8001a60a:	f9 b5 01 40 	movne	r5,64
8001a60e:	f0 05 17 00 	moveq	r5,r8
8001a612:	c1 c8       	rjmp	8001a64a <__smakebuf_r+0x72>
8001a614:	40 18       	lddsp	r8,sp[0x4]
8001a616:	e2 18 f0 00 	andl	r8,0xf000,COH
8001a61a:	e0 48 20 00 	cp.w	r8,8192
8001a61e:	5f 04       	sreq	r4
8001a620:	e0 48 80 00 	cp.w	r8,32768
8001a624:	c0 e1       	brne	8001a640 <__smakebuf_r+0x68>
8001a626:	6e b9       	ld.w	r9,r7[0x2c]
8001a628:	fe c8 f2 30 	sub	r8,pc,-3536
8001a62c:	10 39       	cp.w	r9,r8
8001a62e:	c0 91       	brne	8001a640 <__smakebuf_r+0x68>
8001a630:	8e 68       	ld.sh	r8,r7[0xc]
8001a632:	e0 65 04 00 	mov	r5,1024
8001a636:	ab a8       	sbr	r8,0xa
8001a638:	ef 45 00 50 	st.w	r7[80],r5
8001a63c:	ae 68       	st.h	r7[0xc],r8
8001a63e:	c0 68       	rjmp	8001a64a <__smakebuf_r+0x72>
8001a640:	8e 68       	ld.sh	r8,r7[0xc]
8001a642:	e0 65 04 00 	mov	r5,1024
8001a646:	ab b8       	sbr	r8,0xb
8001a648:	ae 68       	st.h	r7[0xc],r8
8001a64a:	0a 9b       	mov	r11,r5
8001a64c:	0c 9c       	mov	r12,r6
8001a64e:	fe b0 d5 0d 	rcall	80015068 <_malloc_r>
8001a652:	8e 68       	ld.sh	r8,r7[0xc]
8001a654:	c0 d1       	brne	8001a66e <__smakebuf_r+0x96>
8001a656:	ed b8 00 09 	bld	r8,0x9
8001a65a:	c1 b0       	breq	8001a690 <__smakebuf_r+0xb8>
8001a65c:	a1 b8       	sbr	r8,0x1
8001a65e:	ae 68       	st.h	r7[0xc],r8
8001a660:	ee c8 ff b9 	sub	r8,r7,-71
8001a664:	8f 48       	st.w	r7[0x10],r8
8001a666:	8f 08       	st.w	r7[0x0],r8
8001a668:	30 18       	mov	r8,1
8001a66a:	8f 58       	st.w	r7[0x14],r8
8001a66c:	c1 28       	rjmp	8001a690 <__smakebuf_r+0xb8>
8001a66e:	a7 b8       	sbr	r8,0x7
8001a670:	8f 4c       	st.w	r7[0x10],r12
8001a672:	ae 68       	st.h	r7[0xc],r8
8001a674:	8f 55       	st.w	r7[0x14],r5
8001a676:	fe c8 08 02 	sub	r8,pc,2050
8001a67a:	8f 0c       	st.w	r7[0x0],r12
8001a67c:	8d a8       	st.w	r6[0x28],r8
8001a67e:	58 04       	cp.w	r4,0
8001a680:	c0 80       	breq	8001a690 <__smakebuf_r+0xb8>
8001a682:	8e 7c       	ld.sh	r12,r7[0xe]
8001a684:	fe b0 d8 66 	rcall	80015750 <isatty>
8001a688:	c0 40       	breq	8001a690 <__smakebuf_r+0xb8>
8001a68a:	8e 68       	ld.sh	r8,r7[0xc]
8001a68c:	a1 a8       	sbr	r8,0x0
8001a68e:	ae 68       	st.h	r7[0xc],r8
8001a690:	2f 1d       	sub	sp,-60
8001a692:	d8 22       	popm	r4-r7,pc

8001a694 <_mbrtowc_r>:
8001a694:	d4 21       	pushm	r4-r7,lr
8001a696:	18 97       	mov	r7,r12
8001a698:	10 96       	mov	r6,r8
8001a69a:	58 0a       	cp.w	r10,0
8001a69c:	c0 51       	brne	8001a6a6 <_mbrtowc_r+0x12>
8001a69e:	14 9b       	mov	r11,r10
8001a6a0:	30 19       	mov	r9,1
8001a6a2:	fe ca b9 5a 	sub	r10,pc,-18086
8001a6a6:	c0 9c       	rcall	8001a6b8 <_mbtowc_r>
8001a6a8:	5b fc       	cp.w	r12,-1
8001a6aa:	c0 61       	brne	8001a6b6 <_mbrtowc_r+0x22>
8001a6ac:	30 08       	mov	r8,0
8001a6ae:	8d 08       	st.w	r6[0x0],r8
8001a6b0:	e0 68 00 8a 	mov	r8,138
8001a6b4:	8f 38       	st.w	r7[0xc],r8
8001a6b6:	d8 22       	popm	r4-r7,pc

8001a6b8 <_mbtowc_r>:
8001a6b8:	20 1d       	sub	sp,4
8001a6ba:	58 09       	cp.w	r9,0
8001a6bc:	5f 09       	sreq	r9
8001a6be:	58 0a       	cp.w	r10,0
8001a6c0:	5f 18       	srne	r8
8001a6c2:	58 0b       	cp.w	r11,0
8001a6c4:	fa 0b 17 00 	moveq	r11,sp
8001a6c8:	f3 e8 00 08 	and	r8,r9,r8
8001a6cc:	30 09       	mov	r9,0
8001a6ce:	f2 08 18 00 	cp.b	r8,r9
8001a6d2:	c0 30       	breq	8001a6d8 <_mbtowc_r+0x20>
8001a6d4:	3f ec       	mov	r12,-2
8001a6d6:	c0 b8       	rjmp	8001a6ec <_mbtowc_r+0x34>
8001a6d8:	58 0a       	cp.w	r10,0
8001a6da:	c0 31       	brne	8001a6e0 <_mbtowc_r+0x28>
8001a6dc:	14 9c       	mov	r12,r10
8001a6de:	c0 78       	rjmp	8001a6ec <_mbtowc_r+0x34>
8001a6e0:	15 89       	ld.ub	r9,r10[0x0]
8001a6e2:	97 09       	st.w	r11[0x0],r9
8001a6e4:	15 89       	ld.ub	r9,r10[0x0]
8001a6e6:	f0 09 18 00 	cp.b	r9,r8
8001a6ea:	5f 1c       	srne	r12
8001a6ec:	2f fd       	sub	sp,-4
8001a6ee:	5e fc       	retal	r12

8001a6f0 <memchr>:
8001a6f0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8001a6f4:	c0 68       	rjmp	8001a700 <memchr+0x10>
8001a6f6:	20 1a       	sub	r10,1
8001a6f8:	19 88       	ld.ub	r8,r12[0x0]
8001a6fa:	16 38       	cp.w	r8,r11
8001a6fc:	5e 0c       	reteq	r12
8001a6fe:	2f fc       	sub	r12,-1
8001a700:	58 0a       	cp.w	r10,0
8001a702:	cf a1       	brne	8001a6f6 <memchr+0x6>
8001a704:	5e fa       	retal	r10

8001a706 <memmove>:
8001a706:	d4 01       	pushm	lr
8001a708:	18 3b       	cp.w	r11,r12
8001a70a:	c1 92       	brcc	8001a73c <memmove+0x36>
8001a70c:	f6 0a 00 09 	add	r9,r11,r10
8001a710:	12 3c       	cp.w	r12,r9
8001a712:	c1 52       	brcc	8001a73c <memmove+0x36>
8001a714:	f8 0a 00 0b 	add	r11,r12,r10
8001a718:	30 08       	mov	r8,0
8001a71a:	c0 68       	rjmp	8001a726 <memmove+0x20>
8001a71c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8001a720:	20 1a       	sub	r10,1
8001a722:	f6 08 0b 0e 	st.b	r11[r8],lr
8001a726:	20 18       	sub	r8,1
8001a728:	58 0a       	cp.w	r10,0
8001a72a:	cf 91       	brne	8001a71c <memmove+0x16>
8001a72c:	d8 02       	popm	pc
8001a72e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8001a732:	20 1a       	sub	r10,1
8001a734:	f8 08 0b 09 	st.b	r12[r8],r9
8001a738:	2f f8       	sub	r8,-1
8001a73a:	c0 28       	rjmp	8001a73e <memmove+0x38>
8001a73c:	30 08       	mov	r8,0
8001a73e:	58 0a       	cp.w	r10,0
8001a740:	cf 71       	brne	8001a72e <memmove+0x28>
8001a742:	d8 02       	popm	pc

8001a744 <__hi0bits>:
8001a744:	18 98       	mov	r8,r12
8001a746:	e0 1c 00 00 	andl	r12,0x0
8001a74a:	f0 09 15 10 	lsl	r9,r8,0x10
8001a74e:	58 0c       	cp.w	r12,0
8001a750:	f2 08 17 00 	moveq	r8,r9
8001a754:	f9 bc 00 10 	moveq	r12,16
8001a758:	f9 bc 01 00 	movne	r12,0
8001a75c:	10 9a       	mov	r10,r8
8001a75e:	f0 09 15 08 	lsl	r9,r8,0x8
8001a762:	e6 1a ff 00 	andh	r10,0xff00,COH
8001a766:	f7 bc 00 f8 	subeq	r12,-8
8001a76a:	f2 08 17 00 	moveq	r8,r9
8001a76e:	10 9a       	mov	r10,r8
8001a770:	f0 09 15 04 	lsl	r9,r8,0x4
8001a774:	e6 1a f0 00 	andh	r10,0xf000,COH
8001a778:	f7 bc 00 fc 	subeq	r12,-4
8001a77c:	f2 08 17 00 	moveq	r8,r9
8001a780:	10 9a       	mov	r10,r8
8001a782:	f0 09 15 02 	lsl	r9,r8,0x2
8001a786:	e6 1a c0 00 	andh	r10,0xc000,COH
8001a78a:	f7 bc 00 fe 	subeq	r12,-2
8001a78e:	f2 08 17 00 	moveq	r8,r9
8001a792:	58 08       	cp.w	r8,0
8001a794:	5e 5c       	retlt	r12
8001a796:	ed b8 00 1e 	bld	r8,0x1e
8001a79a:	f9 bc 01 20 	movne	r12,32
8001a79e:	f7 bc 00 ff 	subeq	r12,-1
8001a7a2:	5e fc       	retal	r12

8001a7a4 <__lo0bits>:
8001a7a4:	18 99       	mov	r9,r12
8001a7a6:	78 08       	ld.w	r8,r12[0x0]
8001a7a8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8001a7ac:	c1 50       	breq	8001a7d6 <__lo0bits+0x32>
8001a7ae:	ed b8 00 00 	bld	r8,0x0
8001a7b2:	c0 21       	brne	8001a7b6 <__lo0bits+0x12>
8001a7b4:	5e fd       	retal	0
8001a7b6:	10 9b       	mov	r11,r8
8001a7b8:	f0 0a 16 01 	lsr	r10,r8,0x1
8001a7bc:	e2 1b 00 02 	andl	r11,0x2,COH
8001a7c0:	a3 88       	lsr	r8,0x2
8001a7c2:	58 0b       	cp.w	r11,0
8001a7c4:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8001a7c8:	f9 bc 01 01 	movne	r12,1
8001a7cc:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8001a7d0:	f9 bc 00 02 	moveq	r12,2
8001a7d4:	5e fc       	retal	r12
8001a7d6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8001a7da:	f0 0b 16 10 	lsr	r11,r8,0x10
8001a7de:	58 0a       	cp.w	r10,0
8001a7e0:	f6 08 17 00 	moveq	r8,r11
8001a7e4:	f9 bc 00 10 	moveq	r12,16
8001a7e8:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8001a7ec:	f0 0a 16 08 	lsr	r10,r8,0x8
8001a7f0:	58 0b       	cp.w	r11,0
8001a7f2:	f7 bc 00 f8 	subeq	r12,-8
8001a7f6:	f4 08 17 00 	moveq	r8,r10
8001a7fa:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8001a7fe:	f0 0a 16 04 	lsr	r10,r8,0x4
8001a802:	58 0b       	cp.w	r11,0
8001a804:	f7 bc 00 fc 	subeq	r12,-4
8001a808:	f4 08 17 00 	moveq	r8,r10
8001a80c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8001a810:	f0 0a 16 02 	lsr	r10,r8,0x2
8001a814:	58 0b       	cp.w	r11,0
8001a816:	f7 bc 00 fe 	subeq	r12,-2
8001a81a:	f4 08 17 00 	moveq	r8,r10
8001a81e:	ed b8 00 00 	bld	r8,0x0
8001a822:	c0 60       	breq	8001a82e <__lo0bits+0x8a>
8001a824:	a1 98       	lsr	r8,0x1
8001a826:	c0 31       	brne	8001a82c <__lo0bits+0x88>
8001a828:	32 0c       	mov	r12,32
8001a82a:	5e fc       	retal	r12
8001a82c:	2f fc       	sub	r12,-1
8001a82e:	93 08       	st.w	r9[0x0],r8
8001a830:	5e fc       	retal	r12

8001a832 <__mcmp>:
8001a832:	d4 01       	pushm	lr
8001a834:	18 98       	mov	r8,r12
8001a836:	76 49       	ld.w	r9,r11[0x10]
8001a838:	78 4c       	ld.w	r12,r12[0x10]
8001a83a:	12 1c       	sub	r12,r9
8001a83c:	c1 31       	brne	8001a862 <__mcmp+0x30>
8001a83e:	2f b9       	sub	r9,-5
8001a840:	a3 69       	lsl	r9,0x2
8001a842:	12 0b       	add	r11,r9
8001a844:	f0 09 00 09 	add	r9,r8,r9
8001a848:	2e c8       	sub	r8,-20
8001a84a:	13 4e       	ld.w	lr,--r9
8001a84c:	17 4a       	ld.w	r10,--r11
8001a84e:	14 3e       	cp.w	lr,r10
8001a850:	c0 60       	breq	8001a85c <__mcmp+0x2a>
8001a852:	f9 bc 03 ff 	movlo	r12,-1
8001a856:	f9 bc 02 01 	movhs	r12,1
8001a85a:	d8 02       	popm	pc
8001a85c:	10 39       	cp.w	r9,r8
8001a85e:	fe 9b ff f6 	brhi	8001a84a <__mcmp+0x18>
8001a862:	d8 02       	popm	pc

8001a864 <__ulp>:
8001a864:	e6 1b 7f f0 	andh	r11,0x7ff0,COH
8001a868:	fc 18 fc c0 	movh	r8,0xfcc0
8001a86c:	f6 08 00 08 	add	r8,r11,r8
8001a870:	58 08       	cp.w	r8,0
8001a872:	e0 8a 00 04 	brle	8001a87a <__ulp+0x16>
8001a876:	10 9b       	mov	r11,r8
8001a878:	c0 a8       	rjmp	8001a88c <__ulp+0x28>
8001a87a:	5c 38       	neg	r8
8001a87c:	b5 48       	asr	r8,0x14
8001a87e:	59 38       	cp.w	r8,19
8001a880:	e0 89 00 08 	brgt	8001a890 <__ulp+0x2c>
8001a884:	e8 69 00 00 	mov	r9,524288
8001a888:	f2 08 08 4b 	asr	r11,r9,r8
8001a88c:	30 0a       	mov	r10,0
8001a88e:	5e fc       	retal	r12
8001a890:	21 48       	sub	r8,20
8001a892:	59 e8       	cp.w	r8,30
8001a894:	e0 8a 00 04 	brle	8001a89c <__ulp+0x38>
8001a898:	30 18       	mov	r8,1
8001a89a:	c0 68       	rjmp	8001a8a6 <__ulp+0x42>
8001a89c:	f0 08 11 1f 	rsub	r8,r8,31
8001a8a0:	30 19       	mov	r9,1
8001a8a2:	f2 08 09 48 	lsl	r8,r9,r8
8001a8a6:	30 0b       	mov	r11,0
8001a8a8:	10 9a       	mov	r10,r8
8001a8aa:	5e fc       	retal	r12

8001a8ac <__b2d>:
8001a8ac:	d4 21       	pushm	r4-r7,lr
8001a8ae:	78 47       	ld.w	r7,r12[0x10]
8001a8b0:	16 94       	mov	r4,r11
8001a8b2:	2f b7       	sub	r7,-5
8001a8b4:	f8 c5 ff ec 	sub	r5,r12,-20
8001a8b8:	f8 07 00 27 	add	r7,r12,r7<<0x2
8001a8bc:	0f 46       	ld.w	r6,--r7
8001a8be:	0c 9c       	mov	r12,r6
8001a8c0:	c4 2f       	rcall	8001a744 <__hi0bits>
8001a8c2:	f8 08 11 20 	rsub	r8,r12,32
8001a8c6:	89 08       	st.w	r4[0x0],r8
8001a8c8:	58 ac       	cp.w	r12,10
8001a8ca:	e0 89 00 18 	brgt	8001a8fa <__b2d+0x4e>
8001a8ce:	f8 08 11 0b 	rsub	r8,r12,11
8001a8d2:	0a 37       	cp.w	r7,r5
8001a8d4:	e0 8b 00 04 	brhi	8001a8dc <__b2d+0x30>
8001a8d8:	30 09       	mov	r9,0
8001a8da:	c0 38       	rjmp	8001a8e0 <__b2d+0x34>
8001a8dc:	ee f9 ff fc 	ld.w	r9,r7[-4]
8001a8e0:	f2 08 0a 49 	lsr	r9,r9,r8
8001a8e4:	2e bc       	sub	r12,-21
8001a8e6:	ec 0c 09 4c 	lsl	r12,r6,r12
8001a8ea:	ec 08 0a 46 	lsr	r6,r6,r8
8001a8ee:	f3 ec 10 0a 	or	r10,r9,r12
8001a8f2:	0c 9b       	mov	r11,r6
8001a8f4:	ea 1b 3f f0 	orh	r11,0x3ff0
8001a8f8:	d8 22       	popm	r4-r7,pc
8001a8fa:	0a 37       	cp.w	r7,r5
8001a8fc:	e0 8b 00 04 	brhi	8001a904 <__b2d+0x58>
8001a900:	30 08       	mov	r8,0
8001a902:	c0 28       	rjmp	8001a906 <__b2d+0x5a>
8001a904:	0f 48       	ld.w	r8,--r7
8001a906:	20 bc       	sub	r12,11
8001a908:	c1 90       	breq	8001a93a <__b2d+0x8e>
8001a90a:	f8 09 11 20 	rsub	r9,r12,32
8001a90e:	0a 37       	cp.w	r7,r5
8001a910:	e0 8b 00 04 	brhi	8001a918 <__b2d+0x6c>
8001a914:	30 0a       	mov	r10,0
8001a916:	c0 38       	rjmp	8001a91c <__b2d+0x70>
8001a918:	ee fa ff fc 	ld.w	r10,r7[-4]
8001a91c:	f0 0c 09 47 	lsl	r7,r8,r12
8001a920:	f4 09 0a 45 	lsr	r5,r10,r9
8001a924:	ec 0c 09 4c 	lsl	r12,r6,r12
8001a928:	f0 09 0a 48 	lsr	r8,r8,r9
8001a92c:	ea 1c 3f f0 	orh	r12,0x3ff0
8001a930:	eb e7 10 0a 	or	r10,r5,r7
8001a934:	f9 e8 10 0b 	or	r11,r12,r8
8001a938:	d8 22       	popm	r4-r7,pc
8001a93a:	0c 9b       	mov	r11,r6
8001a93c:	10 9a       	mov	r10,r8
8001a93e:	ea 1b 3f f0 	orh	r11,0x3ff0
8001a942:	d8 22       	popm	r4-r7,pc

8001a944 <__ratio>:
8001a944:	d4 21       	pushm	r4-r7,lr
8001a946:	20 2d       	sub	sp,8
8001a948:	16 95       	mov	r5,r11
8001a94a:	18 94       	mov	r4,r12
8001a94c:	fa cb ff fc 	sub	r11,sp,-4
8001a950:	ca ef       	rcall	8001a8ac <__b2d>
8001a952:	16 99       	mov	r9,r11
8001a954:	0a 9c       	mov	r12,r5
8001a956:	12 97       	mov	r7,r9
8001a958:	14 96       	mov	r6,r10
8001a95a:	1a 9b       	mov	r11,sp
8001a95c:	ca 8f       	rcall	8001a8ac <__b2d>
8001a95e:	14 98       	mov	r8,r10
8001a960:	6a 4a       	ld.w	r10,r5[0x10]
8001a962:	16 99       	mov	r9,r11
8001a964:	40 1c       	lddsp	r12,sp[0x4]
8001a966:	68 4b       	ld.w	r11,r4[0x10]
8001a968:	14 1b       	sub	r11,r10
8001a96a:	40 0a       	lddsp	r10,sp[0x0]
8001a96c:	a5 7b       	lsl	r11,0x5
8001a96e:	f8 0a 01 0a 	sub	r10,r12,r10
8001a972:	16 0a       	add	r10,r11
8001a974:	58 0a       	cp.w	r10,0
8001a976:	e0 8a 00 06 	brle	8001a982 <__ratio+0x3e>
8001a97a:	b5 6a       	lsl	r10,0x14
8001a97c:	0e 0a       	add	r10,r7
8001a97e:	14 97       	mov	r7,r10
8001a980:	c0 38       	rjmp	8001a986 <__ratio+0x42>
8001a982:	b5 6a       	lsl	r10,0x14
8001a984:	14 19       	sub	r9,r10
8001a986:	0c 9a       	mov	r10,r6
8001a988:	0e 9b       	mov	r11,r7
8001a98a:	e0 a0 14 e7 	rcall	8001d358 <__avr32_f64_div>
8001a98e:	2f ed       	sub	sp,-8
8001a990:	d8 22       	popm	r4-r7,pc
8001a992:	d7 03       	nop

8001a994 <__copybits>:
8001a994:	74 48       	ld.w	r8,r10[0x10]
8001a996:	f6 c9 00 01 	sub	r9,r11,1
8001a99a:	2f b8       	sub	r8,-5
8001a99c:	a5 59       	asr	r9,0x5
8001a99e:	f4 08 00 28 	add	r8,r10,r8<<0x2
8001a9a2:	2f f9       	sub	r9,-1
8001a9a4:	2e ca       	sub	r10,-20
8001a9a6:	f8 09 00 29 	add	r9,r12,r9<<0x2
8001a9aa:	c0 38       	rjmp	8001a9b0 <__copybits+0x1c>
8001a9ac:	15 0b       	ld.w	r11,r10++
8001a9ae:	18 ab       	st.w	r12++,r11
8001a9b0:	10 3a       	cp.w	r10,r8
8001a9b2:	cf d3       	brcs	8001a9ac <__copybits+0x18>
8001a9b4:	c0 38       	rjmp	8001a9ba <__copybits+0x26>
8001a9b6:	18 a8       	st.w	r12++,r8
8001a9b8:	c0 28       	rjmp	8001a9bc <__copybits+0x28>
8001a9ba:	30 08       	mov	r8,0
8001a9bc:	12 3c       	cp.w	r12,r9
8001a9be:	cf c3       	brcs	8001a9b6 <__copybits+0x22>
8001a9c0:	5e fc       	retal	r12

8001a9c2 <__any_on>:
8001a9c2:	d4 01       	pushm	lr
8001a9c4:	f8 ca ff ec 	sub	r10,r12,-20
8001a9c8:	78 49       	ld.w	r9,r12[0x10]
8001a9ca:	f6 08 14 05 	asr	r8,r11,0x5
8001a9ce:	12 38       	cp.w	r8,r9
8001a9d0:	e0 8a 00 04 	brle	8001a9d8 <__any_on+0x16>
8001a9d4:	12 98       	mov	r8,r9
8001a9d6:	c1 08       	rjmp	8001a9f6 <__any_on+0x34>
8001a9d8:	12 38       	cp.w	r8,r9
8001a9da:	c0 e4       	brge	8001a9f6 <__any_on+0x34>
8001a9dc:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8001a9e0:	c0 b0       	breq	8001a9f6 <__any_on+0x34>
8001a9e2:	f0 c9 ff fb 	sub	r9,r8,-5
8001a9e6:	f8 09 03 29 	ld.w	r9,r12[r9<<0x2]
8001a9ea:	f2 0b 0a 4e 	lsr	lr,r9,r11
8001a9ee:	fc 0b 09 4b 	lsl	r11,lr,r11
8001a9f2:	12 3b       	cp.w	r11,r9
8001a9f4:	c0 c1       	brne	8001aa0c <__any_on+0x4a>
8001a9f6:	2f b8       	sub	r8,-5
8001a9f8:	f8 08 00 2c 	add	r12,r12,r8<<0x2
8001a9fc:	c0 48       	rjmp	8001aa04 <__any_on+0x42>
8001a9fe:	19 48       	ld.w	r8,--r12
8001aa00:	58 08       	cp.w	r8,0
8001aa02:	c0 51       	brne	8001aa0c <__any_on+0x4a>
8001aa04:	14 3c       	cp.w	r12,r10
8001aa06:	fe 9b ff fc 	brhi	8001a9fe <__any_on+0x3c>
8001aa0a:	d8 0a       	popm	pc,r12=0
8001aa0c:	da 0a       	popm	pc,r12=1
8001aa0e:	d7 03       	nop

8001aa10 <_Bfree>:
8001aa10:	d4 21       	pushm	r4-r7,lr
8001aa12:	18 97       	mov	r7,r12
8001aa14:	16 95       	mov	r5,r11
8001aa16:	78 96       	ld.w	r6,r12[0x24]
8001aa18:	58 06       	cp.w	r6,0
8001aa1a:	c0 91       	brne	8001aa2c <_Bfree+0x1c>
8001aa1c:	31 0c       	mov	r12,16
8001aa1e:	fe b0 d3 1d 	rcall	80015058 <malloc>
8001aa22:	99 36       	st.w	r12[0xc],r6
8001aa24:	8f 9c       	st.w	r7[0x24],r12
8001aa26:	99 16       	st.w	r12[0x4],r6
8001aa28:	99 26       	st.w	r12[0x8],r6
8001aa2a:	99 06       	st.w	r12[0x0],r6
8001aa2c:	58 05       	cp.w	r5,0
8001aa2e:	c0 90       	breq	8001aa40 <_Bfree+0x30>
8001aa30:	6a 19       	ld.w	r9,r5[0x4]
8001aa32:	6e 98       	ld.w	r8,r7[0x24]
8001aa34:	70 38       	ld.w	r8,r8[0xc]
8001aa36:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8001aa3a:	8b 0a       	st.w	r5[0x0],r10
8001aa3c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8001aa40:	d8 22       	popm	r4-r7,pc
8001aa42:	d7 03       	nop

8001aa44 <_Balloc>:
8001aa44:	d4 21       	pushm	r4-r7,lr
8001aa46:	18 97       	mov	r7,r12
8001aa48:	16 96       	mov	r6,r11
8001aa4a:	78 95       	ld.w	r5,r12[0x24]
8001aa4c:	58 05       	cp.w	r5,0
8001aa4e:	c0 91       	brne	8001aa60 <_Balloc+0x1c>
8001aa50:	31 0c       	mov	r12,16
8001aa52:	fe b0 d3 03 	rcall	80015058 <malloc>
8001aa56:	99 35       	st.w	r12[0xc],r5
8001aa58:	8f 9c       	st.w	r7[0x24],r12
8001aa5a:	99 15       	st.w	r12[0x4],r5
8001aa5c:	99 25       	st.w	r12[0x8],r5
8001aa5e:	99 05       	st.w	r12[0x0],r5
8001aa60:	6e 95       	ld.w	r5,r7[0x24]
8001aa62:	6a 38       	ld.w	r8,r5[0xc]
8001aa64:	58 08       	cp.w	r8,0
8001aa66:	c0 b1       	brne	8001aa7c <_Balloc+0x38>
8001aa68:	31 0a       	mov	r10,16
8001aa6a:	30 4b       	mov	r11,4
8001aa6c:	0e 9c       	mov	r12,r7
8001aa6e:	e0 a0 0e 91 	rcall	8001c790 <_calloc_r>
8001aa72:	8b 3c       	st.w	r5[0xc],r12
8001aa74:	6e 98       	ld.w	r8,r7[0x24]
8001aa76:	70 3c       	ld.w	r12,r8[0xc]
8001aa78:	58 0c       	cp.w	r12,0
8001aa7a:	c1 b0       	breq	8001aab0 <_Balloc+0x6c>
8001aa7c:	6e 98       	ld.w	r8,r7[0x24]
8001aa7e:	70 38       	ld.w	r8,r8[0xc]
8001aa80:	f0 06 00 28 	add	r8,r8,r6<<0x2
8001aa84:	70 0c       	ld.w	r12,r8[0x0]
8001aa86:	58 0c       	cp.w	r12,0
8001aa88:	c0 40       	breq	8001aa90 <_Balloc+0x4c>
8001aa8a:	78 09       	ld.w	r9,r12[0x0]
8001aa8c:	91 09       	st.w	r8[0x0],r9
8001aa8e:	c0 e8       	rjmp	8001aaaa <_Balloc+0x66>
8001aa90:	0e 9c       	mov	r12,r7
8001aa92:	30 17       	mov	r7,1
8001aa94:	0e 9b       	mov	r11,r7
8001aa96:	ee 06 09 47 	lsl	r7,r7,r6
8001aa9a:	ee ca ff fb 	sub	r10,r7,-5
8001aa9e:	a3 6a       	lsl	r10,0x2
8001aaa0:	e0 a0 0e 78 	rcall	8001c790 <_calloc_r>
8001aaa4:	c0 60       	breq	8001aab0 <_Balloc+0x6c>
8001aaa6:	99 16       	st.w	r12[0x4],r6
8001aaa8:	99 27       	st.w	r12[0x8],r7
8001aaaa:	30 08       	mov	r8,0
8001aaac:	99 38       	st.w	r12[0xc],r8
8001aaae:	99 48       	st.w	r12[0x10],r8
8001aab0:	d8 22       	popm	r4-r7,pc
8001aab2:	d7 03       	nop

8001aab4 <__d2b>:
8001aab4:	d4 31       	pushm	r0-r7,lr
8001aab6:	20 2d       	sub	sp,8
8001aab8:	16 93       	mov	r3,r11
8001aaba:	12 96       	mov	r6,r9
8001aabc:	10 95       	mov	r5,r8
8001aabe:	14 92       	mov	r2,r10
8001aac0:	30 1b       	mov	r11,1
8001aac2:	cc 1f       	rcall	8001aa44 <_Balloc>
8001aac4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8001aac8:	50 09       	stdsp	sp[0x0],r9
8001aaca:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8001aace:	b5 a9       	sbr	r9,0x14
8001aad0:	f0 01 16 14 	lsr	r1,r8,0x14
8001aad4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8001aad8:	18 94       	mov	r4,r12
8001aada:	58 02       	cp.w	r2,0
8001aadc:	c1 d0       	breq	8001ab16 <__d2b+0x62>
8001aade:	fa cc ff f8 	sub	r12,sp,-8
8001aae2:	18 d2       	st.w	--r12,r2
8001aae4:	c6 0e       	rcall	8001a7a4 <__lo0bits>
8001aae6:	40 18       	lddsp	r8,sp[0x4]
8001aae8:	c0 d0       	breq	8001ab02 <__d2b+0x4e>
8001aaea:	40 09       	lddsp	r9,sp[0x0]
8001aaec:	f8 0a 11 20 	rsub	r10,r12,32
8001aaf0:	f2 0a 09 4a 	lsl	r10,r9,r10
8001aaf4:	f5 e8 10 08 	or	r8,r10,r8
8001aaf8:	89 58       	st.w	r4[0x14],r8
8001aafa:	f2 0c 0a 49 	lsr	r9,r9,r12
8001aafe:	50 09       	stdsp	sp[0x0],r9
8001ab00:	c0 28       	rjmp	8001ab04 <__d2b+0x50>
8001ab02:	89 58       	st.w	r4[0x14],r8
8001ab04:	40 08       	lddsp	r8,sp[0x0]
8001ab06:	58 08       	cp.w	r8,0
8001ab08:	f9 b3 01 02 	movne	r3,2
8001ab0c:	f9 b3 00 01 	moveq	r3,1
8001ab10:	89 68       	st.w	r4[0x18],r8
8001ab12:	89 43       	st.w	r4[0x10],r3
8001ab14:	c0 88       	rjmp	8001ab24 <__d2b+0x70>
8001ab16:	1a 9c       	mov	r12,sp
8001ab18:	c4 6e       	rcall	8001a7a4 <__lo0bits>
8001ab1a:	30 13       	mov	r3,1
8001ab1c:	40 08       	lddsp	r8,sp[0x0]
8001ab1e:	2e 0c       	sub	r12,-32
8001ab20:	89 43       	st.w	r4[0x10],r3
8001ab22:	89 58       	st.w	r4[0x14],r8
8001ab24:	58 01       	cp.w	r1,0
8001ab26:	c0 90       	breq	8001ab38 <__d2b+0x84>
8001ab28:	e2 c1 04 33 	sub	r1,r1,1075
8001ab2c:	18 01       	add	r1,r12
8001ab2e:	8d 01       	st.w	r6[0x0],r1
8001ab30:	f8 0c 11 35 	rsub	r12,r12,53
8001ab34:	8b 0c       	st.w	r5[0x0],r12
8001ab36:	c0 d8       	rjmp	8001ab50 <__d2b+0x9c>
8001ab38:	e6 c8 ff fc 	sub	r8,r3,-4
8001ab3c:	f8 cc 04 32 	sub	r12,r12,1074
8001ab40:	a5 73       	lsl	r3,0x5
8001ab42:	8d 0c       	st.w	r6[0x0],r12
8001ab44:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8001ab48:	fe b0 fd fe 	rcall	8001a744 <__hi0bits>
8001ab4c:	18 13       	sub	r3,r12
8001ab4e:	8b 03       	st.w	r5[0x0],r3
8001ab50:	08 9c       	mov	r12,r4
8001ab52:	2f ed       	sub	sp,-8
8001ab54:	d8 32       	popm	r0-r7,pc
8001ab56:	d7 03       	nop

8001ab58 <__mdiff>:
8001ab58:	d4 31       	pushm	r0-r7,lr
8001ab5a:	74 48       	ld.w	r8,r10[0x10]
8001ab5c:	76 45       	ld.w	r5,r11[0x10]
8001ab5e:	16 97       	mov	r7,r11
8001ab60:	14 96       	mov	r6,r10
8001ab62:	10 15       	sub	r5,r8
8001ab64:	c1 31       	brne	8001ab8a <__mdiff+0x32>
8001ab66:	2f b8       	sub	r8,-5
8001ab68:	ee ce ff ec 	sub	lr,r7,-20
8001ab6c:	a3 68       	lsl	r8,0x2
8001ab6e:	f4 08 00 0b 	add	r11,r10,r8
8001ab72:	ee 08 00 08 	add	r8,r7,r8
8001ab76:	11 4a       	ld.w	r10,--r8
8001ab78:	17 49       	ld.w	r9,--r11
8001ab7a:	12 3a       	cp.w	r10,r9
8001ab7c:	c0 30       	breq	8001ab82 <__mdiff+0x2a>
8001ab7e:	c0 e2       	brcc	8001ab9a <__mdiff+0x42>
8001ab80:	c0 78       	rjmp	8001ab8e <__mdiff+0x36>
8001ab82:	1c 38       	cp.w	r8,lr
8001ab84:	fe 9b ff f9 	brhi	8001ab76 <__mdiff+0x1e>
8001ab88:	c4 98       	rjmp	8001ac1a <__mdiff+0xc2>
8001ab8a:	58 05       	cp.w	r5,0
8001ab8c:	c0 64       	brge	8001ab98 <__mdiff+0x40>
8001ab8e:	0e 98       	mov	r8,r7
8001ab90:	30 15       	mov	r5,1
8001ab92:	0c 97       	mov	r7,r6
8001ab94:	10 96       	mov	r6,r8
8001ab96:	c0 28       	rjmp	8001ab9a <__mdiff+0x42>
8001ab98:	30 05       	mov	r5,0
8001ab9a:	6e 1b       	ld.w	r11,r7[0x4]
8001ab9c:	c5 4f       	rcall	8001aa44 <_Balloc>
8001ab9e:	6e 49       	ld.w	r9,r7[0x10]
8001aba0:	6c 44       	ld.w	r4,r6[0x10]
8001aba2:	99 35       	st.w	r12[0xc],r5
8001aba4:	2f b4       	sub	r4,-5
8001aba6:	f2 c5 ff fb 	sub	r5,r9,-5
8001abaa:	ec 04 00 24 	add	r4,r6,r4<<0x2
8001abae:	ee 05 00 25 	add	r5,r7,r5<<0x2
8001abb2:	2e c6       	sub	r6,-20
8001abb4:	2e c7       	sub	r7,-20
8001abb6:	f8 c8 ff ec 	sub	r8,r12,-20
8001abba:	30 0a       	mov	r10,0
8001abbc:	0f 0e       	ld.w	lr,r7++
8001abbe:	0d 0b       	ld.w	r11,r6++
8001abc0:	fc 02 16 10 	lsr	r2,lr,0x10
8001abc4:	f6 03 16 10 	lsr	r3,r11,0x10
8001abc8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001abcc:	e4 03 01 03 	sub	r3,r2,r3
8001abd0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8001abd4:	fc 0b 01 0b 	sub	r11,lr,r11
8001abd8:	f6 0a 00 0a 	add	r10,r11,r10
8001abdc:	b0 1a       	st.h	r8[0x2],r10
8001abde:	b1 4a       	asr	r10,0x10
8001abe0:	e6 0a 00 0a 	add	r10,r3,r10
8001abe4:	b0 0a       	st.h	r8[0x0],r10
8001abe6:	2f c8       	sub	r8,-4
8001abe8:	b1 4a       	asr	r10,0x10
8001abea:	08 36       	cp.w	r6,r4
8001abec:	ce 83       	brcs	8001abbc <__mdiff+0x64>
8001abee:	c0 d8       	rjmp	8001ac08 <__mdiff+0xb0>
8001abf0:	0f 0b       	ld.w	r11,r7++
8001abf2:	f6 0e 16 10 	lsr	lr,r11,0x10
8001abf6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8001abfa:	16 0a       	add	r10,r11
8001abfc:	b0 1a       	st.h	r8[0x2],r10
8001abfe:	b1 4a       	asr	r10,0x10
8001ac00:	1c 0a       	add	r10,lr
8001ac02:	b0 0a       	st.h	r8[0x0],r10
8001ac04:	2f c8       	sub	r8,-4
8001ac06:	b1 4a       	asr	r10,0x10
8001ac08:	0a 37       	cp.w	r7,r5
8001ac0a:	cf 33       	brcs	8001abf0 <__mdiff+0x98>
8001ac0c:	c0 28       	rjmp	8001ac10 <__mdiff+0xb8>
8001ac0e:	20 19       	sub	r9,1
8001ac10:	11 4a       	ld.w	r10,--r8
8001ac12:	58 0a       	cp.w	r10,0
8001ac14:	cf d0       	breq	8001ac0e <__mdiff+0xb6>
8001ac16:	99 49       	st.w	r12[0x10],r9
8001ac18:	d8 32       	popm	r0-r7,pc
8001ac1a:	30 0b       	mov	r11,0
8001ac1c:	c1 4f       	rcall	8001aa44 <_Balloc>
8001ac1e:	30 18       	mov	r8,1
8001ac20:	99 48       	st.w	r12[0x10],r8
8001ac22:	30 08       	mov	r8,0
8001ac24:	99 58       	st.w	r12[0x14],r8
8001ac26:	d8 32       	popm	r0-r7,pc

8001ac28 <__lshift>:
8001ac28:	d4 31       	pushm	r0-r7,lr
8001ac2a:	16 97       	mov	r7,r11
8001ac2c:	76 46       	ld.w	r6,r11[0x10]
8001ac2e:	f4 02 14 05 	asr	r2,r10,0x5
8001ac32:	2f f6       	sub	r6,-1
8001ac34:	14 93       	mov	r3,r10
8001ac36:	18 94       	mov	r4,r12
8001ac38:	04 06       	add	r6,r2
8001ac3a:	76 1b       	ld.w	r11,r11[0x4]
8001ac3c:	6e 28       	ld.w	r8,r7[0x8]
8001ac3e:	c0 38       	rjmp	8001ac44 <__lshift+0x1c>
8001ac40:	2f fb       	sub	r11,-1
8001ac42:	a1 78       	lsl	r8,0x1
8001ac44:	10 36       	cp.w	r6,r8
8001ac46:	fe 99 ff fd 	brgt	8001ac40 <__lshift+0x18>
8001ac4a:	08 9c       	mov	r12,r4
8001ac4c:	cf ce       	rcall	8001aa44 <_Balloc>
8001ac4e:	30 09       	mov	r9,0
8001ac50:	18 95       	mov	r5,r12
8001ac52:	f8 c8 ff ec 	sub	r8,r12,-20
8001ac56:	12 9a       	mov	r10,r9
8001ac58:	c0 38       	rjmp	8001ac5e <__lshift+0x36>
8001ac5a:	10 aa       	st.w	r8++,r10
8001ac5c:	2f f9       	sub	r9,-1
8001ac5e:	04 39       	cp.w	r9,r2
8001ac60:	cf d5       	brlt	8001ac5a <__lshift+0x32>
8001ac62:	6e 4b       	ld.w	r11,r7[0x10]
8001ac64:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8001ac68:	2f bb       	sub	r11,-5
8001ac6a:	ee c9 ff ec 	sub	r9,r7,-20
8001ac6e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8001ac72:	58 03       	cp.w	r3,0
8001ac74:	c1 30       	breq	8001ac9a <__lshift+0x72>
8001ac76:	e6 0c 11 20 	rsub	r12,r3,32
8001ac7a:	30 0a       	mov	r10,0
8001ac7c:	72 02       	ld.w	r2,r9[0x0]
8001ac7e:	e4 03 09 42 	lsl	r2,r2,r3
8001ac82:	04 4a       	or	r10,r2
8001ac84:	10 aa       	st.w	r8++,r10
8001ac86:	13 0a       	ld.w	r10,r9++
8001ac88:	f4 0c 0a 4a 	lsr	r10,r10,r12
8001ac8c:	16 39       	cp.w	r9,r11
8001ac8e:	cf 73       	brcs	8001ac7c <__lshift+0x54>
8001ac90:	91 0a       	st.w	r8[0x0],r10
8001ac92:	58 0a       	cp.w	r10,0
8001ac94:	c0 70       	breq	8001aca2 <__lshift+0x7a>
8001ac96:	2f f6       	sub	r6,-1
8001ac98:	c0 58       	rjmp	8001aca2 <__lshift+0x7a>
8001ac9a:	13 0a       	ld.w	r10,r9++
8001ac9c:	10 aa       	st.w	r8++,r10
8001ac9e:	16 39       	cp.w	r9,r11
8001aca0:	cf d3       	brcs	8001ac9a <__lshift+0x72>
8001aca2:	08 9c       	mov	r12,r4
8001aca4:	20 16       	sub	r6,1
8001aca6:	0e 9b       	mov	r11,r7
8001aca8:	8b 46       	st.w	r5[0x10],r6
8001acaa:	cb 3e       	rcall	8001aa10 <_Bfree>
8001acac:	0a 9c       	mov	r12,r5
8001acae:	d8 32       	popm	r0-r7,pc

8001acb0 <__multiply>:
8001acb0:	d4 31       	pushm	r0-r7,lr
8001acb2:	20 2d       	sub	sp,8
8001acb4:	76 49       	ld.w	r9,r11[0x10]
8001acb6:	74 48       	ld.w	r8,r10[0x10]
8001acb8:	16 96       	mov	r6,r11
8001acba:	14 95       	mov	r5,r10
8001acbc:	10 39       	cp.w	r9,r8
8001acbe:	ec 08 17 50 	movlt	r8,r6
8001acc2:	ea 06 17 50 	movlt	r6,r5
8001acc6:	f0 05 17 50 	movlt	r5,r8
8001acca:	6c 28       	ld.w	r8,r6[0x8]
8001accc:	76 43       	ld.w	r3,r11[0x10]
8001acce:	74 42       	ld.w	r2,r10[0x10]
8001acd0:	76 1b       	ld.w	r11,r11[0x4]
8001acd2:	e4 03 00 07 	add	r7,r2,r3
8001acd6:	10 37       	cp.w	r7,r8
8001acd8:	f7 bb 09 ff 	subgt	r11,-1
8001acdc:	cb 4e       	rcall	8001aa44 <_Balloc>
8001acde:	ee c4 ff fb 	sub	r4,r7,-5
8001ace2:	f8 c9 ff ec 	sub	r9,r12,-20
8001ace6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8001acea:	30 0a       	mov	r10,0
8001acec:	12 98       	mov	r8,r9
8001acee:	c0 28       	rjmp	8001acf2 <__multiply+0x42>
8001acf0:	10 aa       	st.w	r8++,r10
8001acf2:	08 38       	cp.w	r8,r4
8001acf4:	cf e3       	brcs	8001acf0 <__multiply+0x40>
8001acf6:	2f b3       	sub	r3,-5
8001acf8:	2f b2       	sub	r2,-5
8001acfa:	ec 03 00 23 	add	r3,r6,r3<<0x2
8001acfe:	ea 02 00 22 	add	r2,r5,r2<<0x2
8001ad02:	ec cb ff ec 	sub	r11,r6,-20
8001ad06:	50 12       	stdsp	sp[0x4],r2
8001ad08:	ea ca ff ec 	sub	r10,r5,-20
8001ad0c:	c4 48       	rjmp	8001ad94 <__multiply+0xe4>
8001ad0e:	94 95       	ld.uh	r5,r10[0x2]
8001ad10:	58 05       	cp.w	r5,0
8001ad12:	c2 00       	breq	8001ad52 <__multiply+0xa2>
8001ad14:	12 98       	mov	r8,r9
8001ad16:	16 96       	mov	r6,r11
8001ad18:	30 0e       	mov	lr,0
8001ad1a:	50 09       	stdsp	sp[0x0],r9
8001ad1c:	0d 02       	ld.w	r2,r6++
8001ad1e:	e4 00 16 10 	lsr	r0,r2,0x10
8001ad22:	70 01       	ld.w	r1,r8[0x0]
8001ad24:	70 09       	ld.w	r9,r8[0x0]
8001ad26:	b1 81       	lsr	r1,0x10
8001ad28:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8001ad2c:	e0 05 03 41 	mac	r1,r0,r5
8001ad30:	ab 32       	mul	r2,r5
8001ad32:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8001ad36:	00 02       	add	r2,r0
8001ad38:	e4 0e 00 0e 	add	lr,r2,lr
8001ad3c:	b0 1e       	st.h	r8[0x2],lr
8001ad3e:	b1 8e       	lsr	lr,0x10
8001ad40:	1c 01       	add	r1,lr
8001ad42:	b0 01       	st.h	r8[0x0],r1
8001ad44:	e2 0e 16 10 	lsr	lr,r1,0x10
8001ad48:	2f c8       	sub	r8,-4
8001ad4a:	06 36       	cp.w	r6,r3
8001ad4c:	ce 83       	brcs	8001ad1c <__multiply+0x6c>
8001ad4e:	40 09       	lddsp	r9,sp[0x0]
8001ad50:	91 0e       	st.w	r8[0x0],lr
8001ad52:	94 86       	ld.uh	r6,r10[0x0]
8001ad54:	58 06       	cp.w	r6,0
8001ad56:	c1 d0       	breq	8001ad90 <__multiply+0xe0>
8001ad58:	72 02       	ld.w	r2,r9[0x0]
8001ad5a:	12 98       	mov	r8,r9
8001ad5c:	16 9e       	mov	lr,r11
8001ad5e:	30 05       	mov	r5,0
8001ad60:	b0 12       	st.h	r8[0x2],r2
8001ad62:	1d 01       	ld.w	r1,lr++
8001ad64:	90 82       	ld.uh	r2,r8[0x0]
8001ad66:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8001ad6a:	ad 30       	mul	r0,r6
8001ad6c:	e0 02 00 02 	add	r2,r0,r2
8001ad70:	e4 05 00 05 	add	r5,r2,r5
8001ad74:	b0 05       	st.h	r8[0x0],r5
8001ad76:	b1 85       	lsr	r5,0x10
8001ad78:	b1 81       	lsr	r1,0x10
8001ad7a:	2f c8       	sub	r8,-4
8001ad7c:	ad 31       	mul	r1,r6
8001ad7e:	90 92       	ld.uh	r2,r8[0x2]
8001ad80:	e2 02 00 02 	add	r2,r1,r2
8001ad84:	0a 02       	add	r2,r5
8001ad86:	e4 05 16 10 	lsr	r5,r2,0x10
8001ad8a:	06 3e       	cp.w	lr,r3
8001ad8c:	ce a3       	brcs	8001ad60 <__multiply+0xb0>
8001ad8e:	91 02       	st.w	r8[0x0],r2
8001ad90:	2f ca       	sub	r10,-4
8001ad92:	2f c9       	sub	r9,-4
8001ad94:	40 18       	lddsp	r8,sp[0x4]
8001ad96:	10 3a       	cp.w	r10,r8
8001ad98:	cb b3       	brcs	8001ad0e <__multiply+0x5e>
8001ad9a:	c0 28       	rjmp	8001ad9e <__multiply+0xee>
8001ad9c:	20 17       	sub	r7,1
8001ad9e:	58 07       	cp.w	r7,0
8001ada0:	e0 8a 00 05 	brle	8001adaa <__multiply+0xfa>
8001ada4:	09 48       	ld.w	r8,--r4
8001ada6:	58 08       	cp.w	r8,0
8001ada8:	cf a0       	breq	8001ad9c <__multiply+0xec>
8001adaa:	99 47       	st.w	r12[0x10],r7
8001adac:	2f ed       	sub	sp,-8
8001adae:	d8 32       	popm	r0-r7,pc

8001adb0 <__i2b>:
8001adb0:	d4 21       	pushm	r4-r7,lr
8001adb2:	16 97       	mov	r7,r11
8001adb4:	30 1b       	mov	r11,1
8001adb6:	c4 7e       	rcall	8001aa44 <_Balloc>
8001adb8:	30 19       	mov	r9,1
8001adba:	99 57       	st.w	r12[0x14],r7
8001adbc:	99 49       	st.w	r12[0x10],r9
8001adbe:	d8 22       	popm	r4-r7,pc

8001adc0 <__multadd>:
8001adc0:	d4 31       	pushm	r0-r7,lr
8001adc2:	30 08       	mov	r8,0
8001adc4:	12 95       	mov	r5,r9
8001adc6:	16 97       	mov	r7,r11
8001adc8:	18 96       	mov	r6,r12
8001adca:	76 44       	ld.w	r4,r11[0x10]
8001adcc:	f6 c9 ff ec 	sub	r9,r11,-20
8001add0:	72 0b       	ld.w	r11,r9[0x0]
8001add2:	f6 0c 16 10 	lsr	r12,r11,0x10
8001add6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8001adda:	f4 0c 02 4c 	mul	r12,r10,r12
8001adde:	f4 0b 03 45 	mac	r5,r10,r11
8001ade2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8001ade6:	b1 85       	lsr	r5,0x10
8001ade8:	18 05       	add	r5,r12
8001adea:	ea 0c 15 10 	lsl	r12,r5,0x10
8001adee:	f8 0b 00 0b 	add	r11,r12,r11
8001adf2:	12 ab       	st.w	r9++,r11
8001adf4:	2f f8       	sub	r8,-1
8001adf6:	b1 85       	lsr	r5,0x10
8001adf8:	08 38       	cp.w	r8,r4
8001adfa:	ce b5       	brlt	8001add0 <__multadd+0x10>
8001adfc:	58 05       	cp.w	r5,0
8001adfe:	c1 c0       	breq	8001ae36 <__multadd+0x76>
8001ae00:	6e 28       	ld.w	r8,r7[0x8]
8001ae02:	10 34       	cp.w	r4,r8
8001ae04:	c1 35       	brlt	8001ae2a <__multadd+0x6a>
8001ae06:	6e 1b       	ld.w	r11,r7[0x4]
8001ae08:	0c 9c       	mov	r12,r6
8001ae0a:	2f fb       	sub	r11,-1
8001ae0c:	c1 ce       	rcall	8001aa44 <_Balloc>
8001ae0e:	6e 4a       	ld.w	r10,r7[0x10]
8001ae10:	ee cb ff f4 	sub	r11,r7,-12
8001ae14:	18 93       	mov	r3,r12
8001ae16:	2f ea       	sub	r10,-2
8001ae18:	2f 4c       	sub	r12,-12
8001ae1a:	a3 6a       	lsl	r10,0x2
8001ae1c:	fe b0 d3 4f 	rcall	800154ba <memcpy>
8001ae20:	0e 9b       	mov	r11,r7
8001ae22:	0c 9c       	mov	r12,r6
8001ae24:	fe b0 fd f6 	rcall	8001aa10 <_Bfree>
8001ae28:	06 97       	mov	r7,r3
8001ae2a:	e8 c8 ff ff 	sub	r8,r4,-1
8001ae2e:	2f b4       	sub	r4,-5
8001ae30:	8f 48       	st.w	r7[0x10],r8
8001ae32:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8001ae36:	0e 9c       	mov	r12,r7
8001ae38:	d8 32       	popm	r0-r7,pc
8001ae3a:	d7 03       	nop

8001ae3c <__pow5mult>:
8001ae3c:	d4 31       	pushm	r0-r7,lr
8001ae3e:	14 96       	mov	r6,r10
8001ae40:	18 97       	mov	r7,r12
8001ae42:	16 94       	mov	r4,r11
8001ae44:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8001ae48:	c0 90       	breq	8001ae5a <__pow5mult+0x1e>
8001ae4a:	20 18       	sub	r8,1
8001ae4c:	fe c9 a9 50 	sub	r9,pc,-22192
8001ae50:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8001ae54:	30 09       	mov	r9,0
8001ae56:	cb 5f       	rcall	8001adc0 <__multadd>
8001ae58:	18 94       	mov	r4,r12
8001ae5a:	a3 46       	asr	r6,0x2
8001ae5c:	c3 40       	breq	8001aec4 <__pow5mult+0x88>
8001ae5e:	6e 95       	ld.w	r5,r7[0x24]
8001ae60:	58 05       	cp.w	r5,0
8001ae62:	c0 91       	brne	8001ae74 <__pow5mult+0x38>
8001ae64:	31 0c       	mov	r12,16
8001ae66:	fe b0 d0 f9 	rcall	80015058 <malloc>
8001ae6a:	99 35       	st.w	r12[0xc],r5
8001ae6c:	8f 9c       	st.w	r7[0x24],r12
8001ae6e:	99 15       	st.w	r12[0x4],r5
8001ae70:	99 25       	st.w	r12[0x8],r5
8001ae72:	99 05       	st.w	r12[0x0],r5
8001ae74:	6e 93       	ld.w	r3,r7[0x24]
8001ae76:	66 25       	ld.w	r5,r3[0x8]
8001ae78:	58 05       	cp.w	r5,0
8001ae7a:	c0 c1       	brne	8001ae92 <__pow5mult+0x56>
8001ae7c:	e0 6b 02 71 	mov	r11,625
8001ae80:	0e 9c       	mov	r12,r7
8001ae82:	c9 7f       	rcall	8001adb0 <__i2b>
8001ae84:	87 2c       	st.w	r3[0x8],r12
8001ae86:	30 08       	mov	r8,0
8001ae88:	18 95       	mov	r5,r12
8001ae8a:	99 08       	st.w	r12[0x0],r8
8001ae8c:	c0 38       	rjmp	8001ae92 <__pow5mult+0x56>
8001ae8e:	06 9c       	mov	r12,r3
8001ae90:	18 95       	mov	r5,r12
8001ae92:	ed b6 00 00 	bld	r6,0x0
8001ae96:	c0 b1       	brne	8001aeac <__pow5mult+0x70>
8001ae98:	08 9b       	mov	r11,r4
8001ae9a:	0a 9a       	mov	r10,r5
8001ae9c:	0e 9c       	mov	r12,r7
8001ae9e:	c0 9f       	rcall	8001acb0 <__multiply>
8001aea0:	08 9b       	mov	r11,r4
8001aea2:	18 93       	mov	r3,r12
8001aea4:	0e 9c       	mov	r12,r7
8001aea6:	06 94       	mov	r4,r3
8001aea8:	fe b0 fd b4 	rcall	8001aa10 <_Bfree>
8001aeac:	a1 56       	asr	r6,0x1
8001aeae:	c0 b0       	breq	8001aec4 <__pow5mult+0x88>
8001aeb0:	6a 03       	ld.w	r3,r5[0x0]
8001aeb2:	58 03       	cp.w	r3,0
8001aeb4:	ce d1       	brne	8001ae8e <__pow5mult+0x52>
8001aeb6:	0a 9a       	mov	r10,r5
8001aeb8:	0a 9b       	mov	r11,r5
8001aeba:	0e 9c       	mov	r12,r7
8001aebc:	cf ae       	rcall	8001acb0 <__multiply>
8001aebe:	8b 0c       	st.w	r5[0x0],r12
8001aec0:	99 03       	st.w	r12[0x0],r3
8001aec2:	ce 7b       	rjmp	8001ae90 <__pow5mult+0x54>
8001aec4:	08 9c       	mov	r12,r4
8001aec6:	d8 32       	popm	r0-r7,pc

8001aec8 <__s2b>:
8001aec8:	d4 31       	pushm	r0-r7,lr
8001aeca:	12 93       	mov	r3,r9
8001aecc:	10 94       	mov	r4,r8
8001aece:	f2 c8 ff f8 	sub	r8,r9,-8
8001aed2:	30 99       	mov	r9,9
8001aed4:	f0 09 0c 08 	divs	r8,r8,r9
8001aed8:	16 95       	mov	r5,r11
8001aeda:	10 99       	mov	r9,r8
8001aedc:	18 96       	mov	r6,r12
8001aede:	14 97       	mov	r7,r10
8001aee0:	30 18       	mov	r8,1
8001aee2:	30 0b       	mov	r11,0
8001aee4:	c0 38       	rjmp	8001aeea <__s2b+0x22>
8001aee6:	a1 78       	lsl	r8,0x1
8001aee8:	2f fb       	sub	r11,-1
8001aeea:	10 39       	cp.w	r9,r8
8001aeec:	fe 99 ff fd 	brgt	8001aee6 <__s2b+0x1e>
8001aef0:	0c 9c       	mov	r12,r6
8001aef2:	fe b0 fd a9 	rcall	8001aa44 <_Balloc>
8001aef6:	30 18       	mov	r8,1
8001aef8:	99 54       	st.w	r12[0x14],r4
8001aefa:	99 48       	st.w	r12[0x10],r8
8001aefc:	58 97       	cp.w	r7,9
8001aefe:	e0 8a 00 13 	brle	8001af24 <__s2b+0x5c>
8001af02:	ea c2 ff f7 	sub	r2,r5,-9
8001af06:	30 94       	mov	r4,9
8001af08:	ea 04 07 09 	ld.ub	r9,r5[r4]
8001af0c:	18 9b       	mov	r11,r12
8001af0e:	2f f4       	sub	r4,-1
8001af10:	23 09       	sub	r9,48
8001af12:	30 aa       	mov	r10,10
8001af14:	0c 9c       	mov	r12,r6
8001af16:	c5 5f       	rcall	8001adc0 <__multadd>
8001af18:	0e 34       	cp.w	r4,r7
8001af1a:	cf 75       	brlt	8001af08 <__s2b+0x40>
8001af1c:	e4 07 00 05 	add	r5,r2,r7
8001af20:	20 85       	sub	r5,8
8001af22:	c0 b8       	rjmp	8001af38 <__s2b+0x70>
8001af24:	2f 65       	sub	r5,-10
8001af26:	30 97       	mov	r7,9
8001af28:	c0 88       	rjmp	8001af38 <__s2b+0x70>
8001af2a:	18 9b       	mov	r11,r12
8001af2c:	0b 39       	ld.ub	r9,r5++
8001af2e:	2f f7       	sub	r7,-1
8001af30:	23 09       	sub	r9,48
8001af32:	30 aa       	mov	r10,10
8001af34:	0c 9c       	mov	r12,r6
8001af36:	c4 5f       	rcall	8001adc0 <__multadd>
8001af38:	06 37       	cp.w	r7,r3
8001af3a:	cf 85       	brlt	8001af2a <__s2b+0x62>
8001af3c:	d8 32       	popm	r0-r7,pc
8001af3e:	d7 03       	nop

8001af40 <_realloc_r>:
8001af40:	d4 31       	pushm	r0-r7,lr
8001af42:	20 1d       	sub	sp,4
8001af44:	16 94       	mov	r4,r11
8001af46:	18 92       	mov	r2,r12
8001af48:	14 9b       	mov	r11,r10
8001af4a:	58 04       	cp.w	r4,0
8001af4c:	c0 51       	brne	8001af56 <_realloc_r+0x16>
8001af4e:	fe b0 d0 8d 	rcall	80015068 <_malloc_r>
8001af52:	18 95       	mov	r5,r12
8001af54:	c5 39       	rjmp	8001b1fa <_realloc_r+0x2ba>
8001af56:	50 0a       	stdsp	sp[0x0],r10
8001af58:	fe b0 d3 5c 	rcall	80015610 <__malloc_lock>
8001af5c:	40 0b       	lddsp	r11,sp[0x0]
8001af5e:	f6 c8 ff f5 	sub	r8,r11,-11
8001af62:	e8 c1 00 08 	sub	r1,r4,8
8001af66:	10 96       	mov	r6,r8
8001af68:	62 1c       	ld.w	r12,r1[0x4]
8001af6a:	e0 16 ff f8 	andl	r6,0xfff8
8001af6e:	59 68       	cp.w	r8,22
8001af70:	f9 b6 08 10 	movls	r6,16
8001af74:	16 36       	cp.w	r6,r11
8001af76:	5f 38       	srlo	r8
8001af78:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8001af7c:	c0 50       	breq	8001af86 <_realloc_r+0x46>
8001af7e:	30 c8       	mov	r8,12
8001af80:	30 05       	mov	r5,0
8001af82:	85 38       	st.w	r2[0xc],r8
8001af84:	c3 b9       	rjmp	8001b1fa <_realloc_r+0x2ba>
8001af86:	18 90       	mov	r0,r12
8001af88:	e0 10 ff fc 	andl	r0,0xfffc
8001af8c:	0c 30       	cp.w	r0,r6
8001af8e:	e0 84 01 0b 	brge	8001b1a4 <_realloc_r+0x264>
8001af92:	e0 68 01 24 	mov	r8,292
8001af96:	e2 00 00 09 	add	r9,r1,r0
8001af9a:	70 25       	ld.w	r5,r8[0x8]
8001af9c:	0a 39       	cp.w	r9,r5
8001af9e:	c0 90       	breq	8001afb0 <_realloc_r+0x70>
8001afa0:	72 1a       	ld.w	r10,r9[0x4]
8001afa2:	a1 ca       	cbr	r10,0x0
8001afa4:	f2 0a 00 0a 	add	r10,r9,r10
8001afa8:	74 1a       	ld.w	r10,r10[0x4]
8001afaa:	ed ba 00 00 	bld	r10,0x0
8001afae:	c2 20       	breq	8001aff2 <_realloc_r+0xb2>
8001afb0:	72 1a       	ld.w	r10,r9[0x4]
8001afb2:	e0 1a ff fc 	andl	r10,0xfffc
8001afb6:	f4 00 00 03 	add	r3,r10,r0
8001afba:	0a 39       	cp.w	r9,r5
8001afbc:	c1 31       	brne	8001afe2 <_realloc_r+0xa2>
8001afbe:	ec c7 ff f0 	sub	r7,r6,-16
8001afc2:	0e 33       	cp.w	r3,r7
8001afc4:	c1 95       	brlt	8001aff6 <_realloc_r+0xb6>
8001afc6:	e2 06 00 09 	add	r9,r1,r6
8001afca:	0c 13       	sub	r3,r6
8001afcc:	a1 a3       	sbr	r3,0x0
8001afce:	93 13       	st.w	r9[0x4],r3
8001afd0:	91 29       	st.w	r8[0x8],r9
8001afd2:	04 9c       	mov	r12,r2
8001afd4:	62 18       	ld.w	r8,r1[0x4]
8001afd6:	08 95       	mov	r5,r4
8001afd8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001afdc:	10 46       	or	r6,r8
8001afde:	83 16       	st.w	r1[0x4],r6
8001afe0:	c0 b9       	rjmp	8001b1f6 <_realloc_r+0x2b6>
8001afe2:	0c 33       	cp.w	r3,r6
8001afe4:	c0 95       	brlt	8001aff6 <_realloc_r+0xb6>
8001afe6:	72 28       	ld.w	r8,r9[0x8]
8001afe8:	02 97       	mov	r7,r1
8001afea:	72 39       	ld.w	r9,r9[0xc]
8001afec:	93 28       	st.w	r9[0x8],r8
8001afee:	91 39       	st.w	r8[0xc],r9
8001aff0:	cd c8       	rjmp	8001b1a8 <_realloc_r+0x268>
8001aff2:	30 0a       	mov	r10,0
8001aff4:	14 99       	mov	r9,r10
8001aff6:	ed bc 00 00 	bld	r12,0x0
8001affa:	e0 80 00 95 	breq	8001b124 <_realloc_r+0x1e4>
8001affe:	62 07       	ld.w	r7,r1[0x0]
8001b000:	e2 07 01 07 	sub	r7,r1,r7
8001b004:	6e 1c       	ld.w	r12,r7[0x4]
8001b006:	e0 1c ff fc 	andl	r12,0xfffc
8001b00a:	58 09       	cp.w	r9,0
8001b00c:	c5 60       	breq	8001b0b8 <_realloc_r+0x178>
8001b00e:	f8 00 00 03 	add	r3,r12,r0
8001b012:	0a 39       	cp.w	r9,r5
8001b014:	c4 81       	brne	8001b0a4 <_realloc_r+0x164>
8001b016:	14 03       	add	r3,r10
8001b018:	ec c9 ff f0 	sub	r9,r6,-16
8001b01c:	12 33       	cp.w	r3,r9
8001b01e:	c4 d5       	brlt	8001b0b8 <_realloc_r+0x178>
8001b020:	6e 3a       	ld.w	r10,r7[0xc]
8001b022:	6e 29       	ld.w	r9,r7[0x8]
8001b024:	95 29       	st.w	r10[0x8],r9
8001b026:	93 3a       	st.w	r9[0xc],r10
8001b028:	ee c5 ff f8 	sub	r5,r7,-8
8001b02c:	e0 ca 00 04 	sub	r10,r0,4
8001b030:	e0 4a 00 24 	cp.w	r10,36
8001b034:	e0 8b 00 25 	brhi	8001b07e <_realloc_r+0x13e>
8001b038:	0a 99       	mov	r9,r5
8001b03a:	59 3a       	cp.w	r10,19
8001b03c:	e0 88 00 1a 	brls	8001b070 <_realloc_r+0x130>
8001b040:	09 09       	ld.w	r9,r4++
8001b042:	8b 09       	st.w	r5[0x0],r9
8001b044:	09 09       	ld.w	r9,r4++
8001b046:	8f 39       	st.w	r7[0xc],r9
8001b048:	ee c9 ff f0 	sub	r9,r7,-16
8001b04c:	59 ba       	cp.w	r10,27
8001b04e:	e0 88 00 11 	brls	8001b070 <_realloc_r+0x130>
8001b052:	09 0b       	ld.w	r11,r4++
8001b054:	93 0b       	st.w	r9[0x0],r11
8001b056:	09 09       	ld.w	r9,r4++
8001b058:	8f 59       	st.w	r7[0x14],r9
8001b05a:	ee c9 ff e8 	sub	r9,r7,-24
8001b05e:	e0 4a 00 24 	cp.w	r10,36
8001b062:	c0 71       	brne	8001b070 <_realloc_r+0x130>
8001b064:	09 0a       	ld.w	r10,r4++
8001b066:	93 0a       	st.w	r9[0x0],r10
8001b068:	ee c9 ff e0 	sub	r9,r7,-32
8001b06c:	09 0a       	ld.w	r10,r4++
8001b06e:	8f 7a       	st.w	r7[0x1c],r10
8001b070:	09 0a       	ld.w	r10,r4++
8001b072:	12 aa       	st.w	r9++,r10
8001b074:	68 0a       	ld.w	r10,r4[0x0]
8001b076:	93 0a       	st.w	r9[0x0],r10
8001b078:	68 1a       	ld.w	r10,r4[0x4]
8001b07a:	93 1a       	st.w	r9[0x4],r10
8001b07c:	c0 78       	rjmp	8001b08a <_realloc_r+0x14a>
8001b07e:	50 08       	stdsp	sp[0x0],r8
8001b080:	08 9b       	mov	r11,r4
8001b082:	0a 9c       	mov	r12,r5
8001b084:	fe b0 fb 41 	rcall	8001a706 <memmove>
8001b088:	40 08       	lddsp	r8,sp[0x0]
8001b08a:	ee 06 00 09 	add	r9,r7,r6
8001b08e:	0c 13       	sub	r3,r6
8001b090:	a1 a3       	sbr	r3,0x0
8001b092:	93 13       	st.w	r9[0x4],r3
8001b094:	91 29       	st.w	r8[0x8],r9
8001b096:	04 9c       	mov	r12,r2
8001b098:	6e 18       	ld.w	r8,r7[0x4]
8001b09a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001b09e:	10 46       	or	r6,r8
8001b0a0:	8f 16       	st.w	r7[0x4],r6
8001b0a2:	ca a8       	rjmp	8001b1f6 <_realloc_r+0x2b6>
8001b0a4:	14 03       	add	r3,r10
8001b0a6:	0c 33       	cp.w	r3,r6
8001b0a8:	c0 85       	brlt	8001b0b8 <_realloc_r+0x178>
8001b0aa:	72 28       	ld.w	r8,r9[0x8]
8001b0ac:	72 39       	ld.w	r9,r9[0xc]
8001b0ae:	93 28       	st.w	r9[0x8],r8
8001b0b0:	91 39       	st.w	r8[0xc],r9
8001b0b2:	6e 28       	ld.w	r8,r7[0x8]
8001b0b4:	6e 39       	ld.w	r9,r7[0xc]
8001b0b6:	c0 78       	rjmp	8001b0c4 <_realloc_r+0x184>
8001b0b8:	f8 00 00 03 	add	r3,r12,r0
8001b0bc:	0c 33       	cp.w	r3,r6
8001b0be:	c3 35       	brlt	8001b124 <_realloc_r+0x1e4>
8001b0c0:	6e 39       	ld.w	r9,r7[0xc]
8001b0c2:	6e 28       	ld.w	r8,r7[0x8]
8001b0c4:	93 28       	st.w	r9[0x8],r8
8001b0c6:	91 39       	st.w	r8[0xc],r9
8001b0c8:	e0 ca 00 04 	sub	r10,r0,4
8001b0cc:	ee cc ff f8 	sub	r12,r7,-8
8001b0d0:	e0 4a 00 24 	cp.w	r10,36
8001b0d4:	e0 8b 00 24 	brhi	8001b11c <_realloc_r+0x1dc>
8001b0d8:	59 3a       	cp.w	r10,19
8001b0da:	e0 88 00 1a 	brls	8001b10e <_realloc_r+0x1ce>
8001b0de:	09 08       	ld.w	r8,r4++
8001b0e0:	99 08       	st.w	r12[0x0],r8
8001b0e2:	09 08       	ld.w	r8,r4++
8001b0e4:	8f 38       	st.w	r7[0xc],r8
8001b0e6:	ee cc ff f0 	sub	r12,r7,-16
8001b0ea:	59 ba       	cp.w	r10,27
8001b0ec:	e0 88 00 11 	brls	8001b10e <_realloc_r+0x1ce>
8001b0f0:	09 08       	ld.w	r8,r4++
8001b0f2:	99 08       	st.w	r12[0x0],r8
8001b0f4:	09 08       	ld.w	r8,r4++
8001b0f6:	8f 58       	st.w	r7[0x14],r8
8001b0f8:	ee cc ff e8 	sub	r12,r7,-24
8001b0fc:	e0 4a 00 24 	cp.w	r10,36
8001b100:	c0 71       	brne	8001b10e <_realloc_r+0x1ce>
8001b102:	09 08       	ld.w	r8,r4++
8001b104:	99 08       	st.w	r12[0x0],r8
8001b106:	ee cc ff e0 	sub	r12,r7,-32
8001b10a:	09 08       	ld.w	r8,r4++
8001b10c:	8f 78       	st.w	r7[0x1c],r8
8001b10e:	09 08       	ld.w	r8,r4++
8001b110:	18 a8       	st.w	r12++,r8
8001b112:	68 08       	ld.w	r8,r4[0x0]
8001b114:	99 08       	st.w	r12[0x0],r8
8001b116:	68 18       	ld.w	r8,r4[0x4]
8001b118:	99 18       	st.w	r12[0x4],r8
8001b11a:	c4 78       	rjmp	8001b1a8 <_realloc_r+0x268>
8001b11c:	08 9b       	mov	r11,r4
8001b11e:	fe b0 fa f4 	rcall	8001a706 <memmove>
8001b122:	c4 38       	rjmp	8001b1a8 <_realloc_r+0x268>
8001b124:	04 9c       	mov	r12,r2
8001b126:	fe b0 cf a1 	rcall	80015068 <_malloc_r>
8001b12a:	18 95       	mov	r5,r12
8001b12c:	c3 a0       	breq	8001b1a0 <_realloc_r+0x260>
8001b12e:	62 18       	ld.w	r8,r1[0x4]
8001b130:	f8 c9 00 08 	sub	r9,r12,8
8001b134:	a1 c8       	cbr	r8,0x0
8001b136:	e2 08 00 08 	add	r8,r1,r8
8001b13a:	10 39       	cp.w	r9,r8
8001b13c:	c0 71       	brne	8001b14a <_realloc_r+0x20a>
8001b13e:	72 13       	ld.w	r3,r9[0x4]
8001b140:	02 97       	mov	r7,r1
8001b142:	e0 13 ff fc 	andl	r3,0xfffc
8001b146:	00 03       	add	r3,r0
8001b148:	c3 08       	rjmp	8001b1a8 <_realloc_r+0x268>
8001b14a:	e0 ca 00 04 	sub	r10,r0,4
8001b14e:	e0 4a 00 24 	cp.w	r10,36
8001b152:	e0 8b 00 20 	brhi	8001b192 <_realloc_r+0x252>
8001b156:	08 99       	mov	r9,r4
8001b158:	18 98       	mov	r8,r12
8001b15a:	59 3a       	cp.w	r10,19
8001b15c:	e0 88 00 14 	brls	8001b184 <_realloc_r+0x244>
8001b160:	13 0b       	ld.w	r11,r9++
8001b162:	10 ab       	st.w	r8++,r11
8001b164:	13 0b       	ld.w	r11,r9++
8001b166:	10 ab       	st.w	r8++,r11
8001b168:	59 ba       	cp.w	r10,27
8001b16a:	e0 88 00 0d 	brls	8001b184 <_realloc_r+0x244>
8001b16e:	13 0b       	ld.w	r11,r9++
8001b170:	10 ab       	st.w	r8++,r11
8001b172:	13 0b       	ld.w	r11,r9++
8001b174:	10 ab       	st.w	r8++,r11
8001b176:	e0 4a 00 24 	cp.w	r10,36
8001b17a:	c0 51       	brne	8001b184 <_realloc_r+0x244>
8001b17c:	13 0a       	ld.w	r10,r9++
8001b17e:	10 aa       	st.w	r8++,r10
8001b180:	13 0a       	ld.w	r10,r9++
8001b182:	10 aa       	st.w	r8++,r10
8001b184:	13 0a       	ld.w	r10,r9++
8001b186:	10 aa       	st.w	r8++,r10
8001b188:	72 0a       	ld.w	r10,r9[0x0]
8001b18a:	91 0a       	st.w	r8[0x0],r10
8001b18c:	72 19       	ld.w	r9,r9[0x4]
8001b18e:	91 19       	st.w	r8[0x4],r9
8001b190:	c0 48       	rjmp	8001b198 <_realloc_r+0x258>
8001b192:	08 9b       	mov	r11,r4
8001b194:	fe b0 fa b9 	rcall	8001a706 <memmove>
8001b198:	08 9b       	mov	r11,r4
8001b19a:	04 9c       	mov	r12,r2
8001b19c:	fe b0 f7 b0 	rcall	8001a0fc <_free_r>
8001b1a0:	04 9c       	mov	r12,r2
8001b1a2:	c2 a8       	rjmp	8001b1f6 <_realloc_r+0x2b6>
8001b1a4:	00 93       	mov	r3,r0
8001b1a6:	02 97       	mov	r7,r1
8001b1a8:	e6 06 01 09 	sub	r9,r3,r6
8001b1ac:	6e 18       	ld.w	r8,r7[0x4]
8001b1ae:	58 f9       	cp.w	r9,15
8001b1b0:	e0 88 00 16 	brls	8001b1dc <_realloc_r+0x29c>
8001b1b4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001b1b8:	ed e8 10 08 	or	r8,r6,r8
8001b1bc:	8f 18       	st.w	r7[0x4],r8
8001b1be:	12 98       	mov	r8,r9
8001b1c0:	a1 a8       	sbr	r8,0x0
8001b1c2:	ee 06 00 0b 	add	r11,r7,r6
8001b1c6:	f6 09 00 09 	add	r9,r11,r9
8001b1ca:	97 18       	st.w	r11[0x4],r8
8001b1cc:	72 18       	ld.w	r8,r9[0x4]
8001b1ce:	a1 a8       	sbr	r8,0x0
8001b1d0:	2f 8b       	sub	r11,-8
8001b1d2:	93 18       	st.w	r9[0x4],r8
8001b1d4:	04 9c       	mov	r12,r2
8001b1d6:	fe b0 f7 93 	rcall	8001a0fc <_free_r>
8001b1da:	c0 b8       	rjmp	8001b1f0 <_realloc_r+0x2b0>
8001b1dc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8001b1e0:	e7 e8 10 08 	or	r8,r3,r8
8001b1e4:	8f 18       	st.w	r7[0x4],r8
8001b1e6:	ee 03 00 03 	add	r3,r7,r3
8001b1ea:	66 18       	ld.w	r8,r3[0x4]
8001b1ec:	a1 a8       	sbr	r8,0x0
8001b1ee:	87 18       	st.w	r3[0x4],r8
8001b1f0:	04 9c       	mov	r12,r2
8001b1f2:	ee c5 ff f8 	sub	r5,r7,-8
8001b1f6:	fe b0 d2 0e 	rcall	80015612 <__malloc_unlock>
8001b1fa:	0a 9c       	mov	r12,r5
8001b1fc:	2f fd       	sub	sp,-4
8001b1fe:	d8 32       	popm	r0-r7,pc

8001b200 <__srefill_r>:
8001b200:	d4 21       	pushm	r4-r7,lr
8001b202:	16 97       	mov	r7,r11
8001b204:	18 96       	mov	r6,r12
8001b206:	58 0c       	cp.w	r12,0
8001b208:	c0 60       	breq	8001b214 <__srefill_r+0x14>
8001b20a:	78 68       	ld.w	r8,r12[0x18]
8001b20c:	58 08       	cp.w	r8,0
8001b20e:	c0 31       	brne	8001b214 <__srefill_r+0x14>
8001b210:	fe b0 f6 82 	rcall	80019f14 <__sinit>
8001b214:	fe c8 ad b8 	sub	r8,pc,-21064
8001b218:	10 37       	cp.w	r7,r8
8001b21a:	c0 31       	brne	8001b220 <__srefill_r+0x20>
8001b21c:	6c 07       	ld.w	r7,r6[0x0]
8001b21e:	c0 c8       	rjmp	8001b236 <__srefill_r+0x36>
8001b220:	fe c8 ad a4 	sub	r8,pc,-21084
8001b224:	10 37       	cp.w	r7,r8
8001b226:	c0 31       	brne	8001b22c <__srefill_r+0x2c>
8001b228:	6c 17       	ld.w	r7,r6[0x4]
8001b22a:	c0 68       	rjmp	8001b236 <__srefill_r+0x36>
8001b22c:	fe c8 ad 90 	sub	r8,pc,-21104
8001b230:	10 37       	cp.w	r7,r8
8001b232:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8001b236:	30 08       	mov	r8,0
8001b238:	8f 18       	st.w	r7[0x4],r8
8001b23a:	8e 68       	ld.sh	r8,r7[0xc]
8001b23c:	ed b8 00 05 	bld	r8,0x5
8001b240:	c5 b0       	breq	8001b2f6 <__srefill_r+0xf6>
8001b242:	ed b8 00 02 	bld	r8,0x2
8001b246:	c1 a0       	breq	8001b27a <__srefill_r+0x7a>
8001b248:	ed b8 00 04 	bld	r8,0x4
8001b24c:	c0 60       	breq	8001b258 <__srefill_r+0x58>
8001b24e:	a7 a8       	sbr	r8,0x6
8001b250:	ae 68       	st.h	r7[0xc],r8
8001b252:	30 98       	mov	r8,9
8001b254:	8d 38       	st.w	r6[0xc],r8
8001b256:	c4 f8       	rjmp	8001b2f4 <__srefill_r+0xf4>
8001b258:	ed b8 00 03 	bld	r8,0x3
8001b25c:	c0 b1       	brne	8001b272 <__srefill_r+0x72>
8001b25e:	0e 9b       	mov	r11,r7
8001b260:	0c 9c       	mov	r12,r6
8001b262:	fe b0 f5 6f 	rcall	80019d40 <_fflush_r>
8001b266:	c4 81       	brne	8001b2f6 <__srefill_r+0xf6>
8001b268:	8e 68       	ld.sh	r8,r7[0xc]
8001b26a:	8f 6c       	st.w	r7[0x18],r12
8001b26c:	a3 d8       	cbr	r8,0x3
8001b26e:	8f 2c       	st.w	r7[0x8],r12
8001b270:	ae 68       	st.h	r7[0xc],r8
8001b272:	8e 68       	ld.sh	r8,r7[0xc]
8001b274:	a3 a8       	sbr	r8,0x2
8001b276:	ae 68       	st.h	r7[0xc],r8
8001b278:	c1 48       	rjmp	8001b2a0 <__srefill_r+0xa0>
8001b27a:	6e db       	ld.w	r11,r7[0x34]
8001b27c:	58 0b       	cp.w	r11,0
8001b27e:	c1 10       	breq	8001b2a0 <__srefill_r+0xa0>
8001b280:	ee c8 ff bc 	sub	r8,r7,-68
8001b284:	10 3b       	cp.w	r11,r8
8001b286:	c0 40       	breq	8001b28e <__srefill_r+0x8e>
8001b288:	0c 9c       	mov	r12,r6
8001b28a:	fe b0 f7 39 	rcall	8001a0fc <_free_r>
8001b28e:	30 0c       	mov	r12,0
8001b290:	6f 08       	ld.w	r8,r7[0x40]
8001b292:	8f dc       	st.w	r7[0x34],r12
8001b294:	8f 18       	st.w	r7[0x4],r8
8001b296:	58 08       	cp.w	r8,0
8001b298:	c0 40       	breq	8001b2a0 <__srefill_r+0xa0>
8001b29a:	6e f8       	ld.w	r8,r7[0x3c]
8001b29c:	8f 08       	st.w	r7[0x0],r8
8001b29e:	d8 22       	popm	r4-r7,pc
8001b2a0:	6e 48       	ld.w	r8,r7[0x10]
8001b2a2:	58 08       	cp.w	r8,0
8001b2a4:	c0 51       	brne	8001b2ae <__srefill_r+0xae>
8001b2a6:	0e 9b       	mov	r11,r7
8001b2a8:	0c 9c       	mov	r12,r6
8001b2aa:	fe b0 f9 97 	rcall	8001a5d8 <__smakebuf_r>
8001b2ae:	8e 68       	ld.sh	r8,r7[0xc]
8001b2b0:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8001b2b4:	c0 80       	breq	8001b2c4 <__srefill_r+0xc4>
8001b2b6:	fe c8 b2 6e 	sub	r8,pc,-19858
8001b2ba:	fe cb ff c2 	sub	r11,pc,-62
8001b2be:	70 0c       	ld.w	r12,r8[0x0]
8001b2c0:	fe b0 f9 56 	rcall	8001a56c <_fwalk>
8001b2c4:	6e 4a       	ld.w	r10,r7[0x10]
8001b2c6:	6e 98       	ld.w	r8,r7[0x24]
8001b2c8:	0c 9c       	mov	r12,r6
8001b2ca:	8f 0a       	st.w	r7[0x0],r10
8001b2cc:	6e 59       	ld.w	r9,r7[0x14]
8001b2ce:	6e 8b       	ld.w	r11,r7[0x20]
8001b2d0:	5d 18       	icall	r8
8001b2d2:	8e 68       	ld.sh	r8,r7[0xc]
8001b2d4:	8f 1c       	st.w	r7[0x4],r12
8001b2d6:	ad d8       	cbr	r8,0xd
8001b2d8:	ae 68       	st.h	r7[0xc],r8
8001b2da:	58 0c       	cp.w	r12,0
8001b2dc:	e0 8a 00 03 	brle	8001b2e2 <__srefill_r+0xe2>
8001b2e0:	d8 2a       	popm	r4-r7,pc,r12=0
8001b2e2:	58 0c       	cp.w	r12,0
8001b2e4:	c0 41       	brne	8001b2ec <__srefill_r+0xec>
8001b2e6:	a5 b8       	sbr	r8,0x5
8001b2e8:	ae 68       	st.h	r7[0xc],r8
8001b2ea:	c0 58       	rjmp	8001b2f4 <__srefill_r+0xf4>
8001b2ec:	a7 a8       	sbr	r8,0x6
8001b2ee:	ae 68       	st.h	r7[0xc],r8
8001b2f0:	30 08       	mov	r8,0
8001b2f2:	8f 18       	st.w	r7[0x4],r8
8001b2f4:	dc 2a       	popm	r4-r7,pc,r12=-1
8001b2f6:	dc 2a       	popm	r4-r7,pc,r12=-1

8001b2f8 <lflush>:
8001b2f8:	d4 01       	pushm	lr
8001b2fa:	98 68       	ld.sh	r8,r12[0xc]
8001b2fc:	e2 18 00 09 	andl	r8,0x9,COH
8001b300:	58 98       	cp.w	r8,9
8001b302:	c0 20       	breq	8001b306 <lflush+0xe>
8001b304:	d8 0a       	popm	pc,r12=0
8001b306:	fe b0 f5 a3 	rcall	80019e4c <fflush>
8001b30a:	d8 02       	popm	pc

8001b30c <__isinfd>:
8001b30c:	14 98       	mov	r8,r10
8001b30e:	fc 19 7f f0 	movh	r9,0x7ff0
8001b312:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8001b316:	f0 0b 11 00 	rsub	r11,r8,0
8001b31a:	f7 e8 10 08 	or	r8,r11,r8
8001b31e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8001b322:	f2 08 01 08 	sub	r8,r9,r8
8001b326:	f0 0c 11 00 	rsub	r12,r8,0
8001b32a:	f9 e8 10 08 	or	r8,r12,r8
8001b32e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8001b332:	2f fc       	sub	r12,-1
8001b334:	5e fc       	retal	r12

8001b336 <__isnand>:
8001b336:	14 98       	mov	r8,r10
8001b338:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8001b33c:	f0 0c 11 00 	rsub	r12,r8,0
8001b340:	10 4c       	or	r12,r8
8001b342:	fc 18 7f f0 	movh	r8,0x7ff0
8001b346:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8001b34a:	f0 0c 01 0c 	sub	r12,r8,r12
8001b34e:	bf 9c       	lsr	r12,0x1f
8001b350:	5e fc       	retal	r12

8001b352 <__sccl>:
8001b352:	d4 31       	pushm	r0-r7,lr
8001b354:	18 9e       	mov	lr,r12
8001b356:	17 38       	ld.ub	r8,r11++
8001b358:	e0 48 00 5e 	cp.w	r8,94
8001b35c:	c0 30       	breq	8001b362 <__sccl+0x10>
8001b35e:	30 0a       	mov	r10,0
8001b360:	c0 38       	rjmp	8001b366 <__sccl+0x14>
8001b362:	17 38       	ld.ub	r8,r11++
8001b364:	30 1a       	mov	r10,1
8001b366:	30 09       	mov	r9,0
8001b368:	fc 09 0b 0a 	st.b	lr[r9],r10
8001b36c:	2f f9       	sub	r9,-1
8001b36e:	e0 49 01 00 	cp.w	r9,256
8001b372:	cf b1       	brne	8001b368 <__sccl+0x16>
8001b374:	58 08       	cp.w	r8,0
8001b376:	c0 41       	brne	8001b37e <__sccl+0x2c>
8001b378:	f6 cc 00 01 	sub	r12,r11,1
8001b37c:	d8 32       	popm	r0-r7,pc
8001b37e:	14 96       	mov	r6,r10
8001b380:	32 d4       	mov	r4,45
8001b382:	ec 16 00 01 	eorl	r6,0x1
8001b386:	30 07       	mov	r7,0
8001b388:	35 d5       	mov	r5,93
8001b38a:	c0 38       	rjmp	8001b390 <__sccl+0x3e>
8001b38c:	14 98       	mov	r8,r10
8001b38e:	12 9b       	mov	r11,r9
8001b390:	fc 08 0b 06 	st.b	lr[r8],r6
8001b394:	f6 c9 ff ff 	sub	r9,r11,-1
8001b398:	17 8a       	ld.ub	r10,r11[0x0]
8001b39a:	12 9c       	mov	r12,r9
8001b39c:	e8 0a 18 00 	cp.b	r10,r4
8001b3a0:	c0 90       	breq	8001b3b2 <__sccl+0x60>
8001b3a2:	ea 0a 18 00 	cp.b	r10,r5
8001b3a6:	c1 e0       	breq	8001b3e2 <__sccl+0x90>
8001b3a8:	ee 0a 18 00 	cp.b	r10,r7
8001b3ac:	cf 01       	brne	8001b38c <__sccl+0x3a>
8001b3ae:	16 9c       	mov	r12,r11
8001b3b0:	d8 32       	popm	r0-r7,pc
8001b3b2:	13 8c       	ld.ub	r12,r9[0x0]
8001b3b4:	10 3c       	cp.w	r12,r8
8001b3b6:	5f 53       	srlt	r3
8001b3b8:	e0 4c 00 5d 	cp.w	r12,93
8001b3bc:	5f 0a       	sreq	r10
8001b3be:	e7 ea 10 0a 	or	r10,r3,r10
8001b3c2:	ee 0a 18 00 	cp.b	r10,r7
8001b3c6:	c0 30       	breq	8001b3cc <__sccl+0x7a>
8001b3c8:	32 d8       	mov	r8,45
8001b3ca:	ce 2b       	rjmp	8001b38e <__sccl+0x3c>
8001b3cc:	f0 ca ff ff 	sub	r10,r8,-1
8001b3d0:	fc 0a 00 0a 	add	r10,lr,r10
8001b3d4:	14 c6       	st.b	r10++,r6
8001b3d6:	2f f8       	sub	r8,-1
8001b3d8:	18 38       	cp.w	r8,r12
8001b3da:	cf d5       	brlt	8001b3d4 <__sccl+0x82>
8001b3dc:	2f eb       	sub	r11,-2
8001b3de:	2f e9       	sub	r9,-2
8001b3e0:	cd cb       	rjmp	8001b398 <__sccl+0x46>
8001b3e2:	d8 32       	popm	r0-r7,pc

8001b3e4 <nanf>:
8001b3e4:	fc 1c 7f c0 	movh	r12,0x7fc0
8001b3e8:	5e fc       	retal	r12
8001b3ea:	d7 03       	nop

8001b3ec <__sclose>:
8001b3ec:	d4 01       	pushm	lr
8001b3ee:	96 7b       	ld.sh	r11,r11[0xe]
8001b3f0:	e0 a0 09 fc 	rcall	8001c7e8 <_close_r>
8001b3f4:	d8 02       	popm	pc
8001b3f6:	d7 03       	nop

8001b3f8 <__sseek>:
8001b3f8:	d4 21       	pushm	r4-r7,lr
8001b3fa:	16 97       	mov	r7,r11
8001b3fc:	96 7b       	ld.sh	r11,r11[0xe]
8001b3fe:	e0 a0 0d b1 	rcall	8001cf60 <_lseek_r>
8001b402:	8e 68       	ld.sh	r8,r7[0xc]
8001b404:	10 99       	mov	r9,r8
8001b406:	ad c8       	cbr	r8,0xc
8001b408:	ad a9       	sbr	r9,0xc
8001b40a:	5b fc       	cp.w	r12,-1
8001b40c:	ef f8 0c 06 	st.heq	r7[0xc],r8
8001b410:	ef f9 1c 06 	st.hne	r7[0xc],r9
8001b414:	ef fc 1a 15 	st.wne	r7[0x54],r12
8001b418:	d8 22       	popm	r4-r7,pc
8001b41a:	d7 03       	nop

8001b41c <__swrite>:
8001b41c:	d4 21       	pushm	r4-r7,lr
8001b41e:	96 68       	ld.sh	r8,r11[0xc]
8001b420:	16 97       	mov	r7,r11
8001b422:	14 95       	mov	r5,r10
8001b424:	12 94       	mov	r4,r9
8001b426:	e2 18 01 00 	andl	r8,0x100,COH
8001b42a:	18 96       	mov	r6,r12
8001b42c:	c0 60       	breq	8001b438 <__swrite+0x1c>
8001b42e:	30 29       	mov	r9,2
8001b430:	30 0a       	mov	r10,0
8001b432:	96 7b       	ld.sh	r11,r11[0xe]
8001b434:	e0 a0 0d 96 	rcall	8001cf60 <_lseek_r>
8001b438:	8e 68       	ld.sh	r8,r7[0xc]
8001b43a:	ad c8       	cbr	r8,0xc
8001b43c:	08 99       	mov	r9,r4
8001b43e:	0a 9a       	mov	r10,r5
8001b440:	8e 7b       	ld.sh	r11,r7[0xe]
8001b442:	0c 9c       	mov	r12,r6
8001b444:	ae 68       	st.h	r7[0xc],r8
8001b446:	e0 a0 09 91 	rcall	8001c768 <_write_r>
8001b44a:	d8 22       	popm	r4-r7,pc

8001b44c <__sread>:
8001b44c:	d4 21       	pushm	r4-r7,lr
8001b44e:	16 97       	mov	r7,r11
8001b450:	96 7b       	ld.sh	r11,r11[0xe]
8001b452:	e0 a0 0d 9b 	rcall	8001cf88 <_read_r>
8001b456:	c0 65       	brlt	8001b462 <__sread+0x16>
8001b458:	6f 58       	ld.w	r8,r7[0x54]
8001b45a:	18 08       	add	r8,r12
8001b45c:	ef 48 00 54 	st.w	r7[84],r8
8001b460:	d8 22       	popm	r4-r7,pc
8001b462:	8e 68       	ld.sh	r8,r7[0xc]
8001b464:	ad c8       	cbr	r8,0xc
8001b466:	ae 68       	st.h	r7[0xc],r8
8001b468:	d8 22       	popm	r4-r7,pc
8001b46a:	d7 03       	nop

8001b46c <_strtod_r>:
8001b46c:	d4 31       	pushm	r0-r7,lr
8001b46e:	21 bd       	sub	sp,108
8001b470:	50 ba       	stdsp	sp[0x2c],r10
8001b472:	51 8b       	stdsp	sp[0x60],r11
8001b474:	16 92       	mov	r2,r11
8001b476:	18 96       	mov	r6,r12
8001b478:	fa c7 ff b8 	sub	r7,sp,-72
8001b47c:	30 08       	mov	r8,0
8001b47e:	30 09       	mov	r9,0
8001b480:	30 d5       	mov	r5,13
8001b482:	ee e9 00 00 	st.d	r7[0],r8
8001b486:	32 be       	mov	lr,43
8001b488:	32 dc       	mov	r12,45
8001b48a:	32 0b       	mov	r11,32
8001b48c:	30 9a       	mov	r10,9
8001b48e:	41 89       	lddsp	r9,sp[0x60]
8001b490:	13 88       	ld.ub	r8,r9[0x0]
8001b492:	ea 08 18 00 	cp.b	r8,r5
8001b496:	e0 8b 00 0b 	brhi	8001b4ac <_strtod_r+0x40>
8001b49a:	f4 08 18 00 	cp.b	r8,r10
8001b49e:	c1 f2       	brcc	8001b4dc <_strtod_r+0x70>
8001b4a0:	30 09       	mov	r9,0
8001b4a2:	f2 08 18 00 	cp.b	r8,r9
8001b4a6:	c1 e1       	brne	8001b4e2 <_strtod_r+0x76>
8001b4a8:	e0 8f 01 fe 	bral	8001b8a4 <_strtod_r+0x438>
8001b4ac:	fc 08 18 00 	cp.b	r8,lr
8001b4b0:	c0 80       	breq	8001b4c0 <_strtod_r+0x54>
8001b4b2:	f8 08 18 00 	cp.b	r8,r12
8001b4b6:	c0 80       	breq	8001b4c6 <_strtod_r+0x5a>
8001b4b8:	f6 08 18 00 	cp.b	r8,r11
8001b4bc:	c1 31       	brne	8001b4e2 <_strtod_r+0x76>
8001b4be:	c0 f8       	rjmp	8001b4dc <_strtod_r+0x70>
8001b4c0:	30 0e       	mov	lr,0
8001b4c2:	50 8e       	stdsp	sp[0x20],lr
8001b4c4:	c0 38       	rjmp	8001b4ca <_strtod_r+0x5e>
8001b4c6:	30 1c       	mov	r12,1
8001b4c8:	50 8c       	stdsp	sp[0x20],r12
8001b4ca:	2f f9       	sub	r9,-1
8001b4cc:	51 89       	stdsp	sp[0x60],r9
8001b4ce:	30 08       	mov	r8,0
8001b4d0:	13 89       	ld.ub	r9,r9[0x0]
8001b4d2:	f0 09 18 00 	cp.b	r9,r8
8001b4d6:	c0 81       	brne	8001b4e6 <_strtod_r+0x7a>
8001b4d8:	e0 8f 01 e6 	bral	8001b8a4 <_strtod_r+0x438>
8001b4dc:	2f f9       	sub	r9,-1
8001b4de:	51 89       	stdsp	sp[0x60],r9
8001b4e0:	cd 7b       	rjmp	8001b48e <_strtod_r+0x22>
8001b4e2:	30 0b       	mov	r11,0
8001b4e4:	50 8b       	stdsp	sp[0x20],r11
8001b4e6:	41 89       	lddsp	r9,sp[0x60]
8001b4e8:	33 0a       	mov	r10,48
8001b4ea:	13 88       	ld.ub	r8,r9[0x0]
8001b4ec:	f4 08 18 00 	cp.b	r8,r10
8001b4f0:	c0 30       	breq	8001b4f6 <_strtod_r+0x8a>
8001b4f2:	30 00       	mov	r0,0
8001b4f4:	c6 b8       	rjmp	8001b5ca <_strtod_r+0x15e>
8001b4f6:	13 99       	ld.ub	r9,r9[0x1]
8001b4f8:	35 8a       	mov	r10,88
8001b4fa:	f4 09 18 00 	cp.b	r9,r10
8001b4fe:	c0 50       	breq	8001b508 <_strtod_r+0x9c>
8001b500:	37 8a       	mov	r10,120
8001b502:	f4 09 18 00 	cp.b	r9,r10
8001b506:	c5 61       	brne	8001b5b2 <_strtod_r+0x146>
8001b508:	40 8a       	lddsp	r10,sp[0x20]
8001b50a:	e0 67 05 50 	mov	r7,1360
8001b50e:	1a da       	st.w	--sp,r10
8001b510:	0c 9c       	mov	r12,r6
8001b512:	fa c8 ff a0 	sub	r8,sp,-96
8001b516:	fa c9 ff a4 	sub	r9,sp,-92
8001b51a:	fa cb ff 9c 	sub	r11,sp,-100
8001b51e:	0e 9a       	mov	r10,r7
8001b520:	e0 a0 0a 4e 	rcall	8001c9bc <__gethex>
8001b524:	2f fd       	sub	sp,-4
8001b526:	18 94       	mov	r4,r12
8001b528:	eb dc c0 03 	bfextu	r5,r12,0x0,0x3
8001b52c:	e0 80 05 be 	breq	8001c0a8 <_strtod_r+0xc3c>
8001b530:	58 65       	cp.w	r5,6
8001b532:	c0 61       	brne	8001b53e <_strtod_r+0xd2>
8001b534:	30 09       	mov	r9,0
8001b536:	51 82       	stdsp	sp[0x60],r2
8001b538:	50 89       	stdsp	sp[0x20],r9
8001b53a:	e0 8f 05 b7 	bral	8001c0a8 <_strtod_r+0xc3c>
8001b53e:	41 7a       	lddsp	r10,sp[0x5c]
8001b540:	58 0a       	cp.w	r10,0
8001b542:	c0 a0       	breq	8001b556 <_strtod_r+0xea>
8001b544:	6e 0b       	ld.w	r11,r7[0x0]
8001b546:	fa cc ff c8 	sub	r12,sp,-56
8001b54a:	fe b0 fa 25 	rcall	8001a994 <__copybits>
8001b54e:	0c 9c       	mov	r12,r6
8001b550:	41 7b       	lddsp	r11,sp[0x5c]
8001b552:	fe b0 fa 5f 	rcall	8001aa10 <_Bfree>
8001b556:	41 69       	lddsp	r9,sp[0x58]
8001b558:	58 65       	cp.w	r5,6
8001b55a:	e0 8b 00 23 	brhi	8001b5a0 <_strtod_r+0x134>
8001b55e:	fe c8 af 66 	sub	r8,pc,-20634
8001b562:	f0 05 03 2f 	ld.w	pc,r8[r5<<0x2]
8001b566:	30 08       	mov	r8,0
8001b568:	51 28       	stdsp	sp[0x48],r8
8001b56a:	c1 a8       	rjmp	8001b59e <_strtod_r+0x132>
8001b56c:	40 e8       	lddsp	r8,sp[0x38]
8001b56e:	51 38       	stdsp	sp[0x4c],r8
8001b570:	40 f8       	lddsp	r8,sp[0x3c]
8001b572:	c0 98       	rjmp	8001b584 <_strtod_r+0x118>
8001b574:	40 e8       	lddsp	r8,sp[0x38]
8001b576:	f2 c9 fb cd 	sub	r9,r9,-1075
8001b57a:	51 38       	stdsp	sp[0x4c],r8
8001b57c:	40 f8       	lddsp	r8,sp[0x3c]
8001b57e:	b5 c8       	cbr	r8,0x14
8001b580:	f1 e9 11 48 	or	r8,r8,r9<<0x14
8001b584:	51 28       	stdsp	sp[0x48],r8
8001b586:	c0 d8       	rjmp	8001b5a0 <_strtod_r+0x134>
8001b588:	fc 18 7f f0 	movh	r8,0x7ff0
8001b58c:	51 28       	stdsp	sp[0x48],r8
8001b58e:	30 08       	mov	r8,0
8001b590:	c0 78       	rjmp	8001b59e <_strtod_r+0x132>
8001b592:	e0 68 ff ff 	mov	r8,65535
8001b596:	ea 18 7f ff 	orh	r8,0x7fff
8001b59a:	51 28       	stdsp	sp[0x48],r8
8001b59c:	3f f8       	mov	r8,-1
8001b59e:	51 38       	stdsp	sp[0x4c],r8
8001b5a0:	e2 14 00 08 	andl	r4,0x8,COH
8001b5a4:	e0 80 05 82 	breq	8001c0a8 <_strtod_r+0xc3c>
8001b5a8:	41 28       	lddsp	r8,sp[0x48]
8001b5aa:	bf b8       	sbr	r8,0x1f
8001b5ac:	51 28       	stdsp	sp[0x48],r8
8001b5ae:	e0 8f 05 7d 	bral	8001c0a8 <_strtod_r+0xc3c>
8001b5b2:	10 9a       	mov	r10,r8
8001b5b4:	41 88       	lddsp	r8,sp[0x60]
8001b5b6:	2f f8       	sub	r8,-1
8001b5b8:	51 88       	stdsp	sp[0x60],r8
8001b5ba:	11 88       	ld.ub	r8,r8[0x0]
8001b5bc:	f4 08 18 00 	cp.b	r8,r10
8001b5c0:	cf a0       	breq	8001b5b4 <_strtod_r+0x148>
8001b5c2:	58 08       	cp.w	r8,0
8001b5c4:	e0 80 05 72 	breq	8001c0a8 <_strtod_r+0xc3c>
8001b5c8:	30 10       	mov	r0,1
8001b5ca:	30 04       	mov	r4,0
8001b5cc:	41 88       	lddsp	r8,sp[0x60]
8001b5ce:	08 93       	mov	r3,r4
8001b5d0:	50 78       	stdsp	sp[0x1c],r8
8001b5d2:	08 9a       	mov	r10,r4
8001b5d4:	c1 38       	rjmp	8001b5fa <_strtod_r+0x18e>
8001b5d6:	58 8a       	cp.w	r10,8
8001b5d8:	e0 89 00 06 	brgt	8001b5e4 <_strtod_r+0x178>
8001b5dc:	23 08       	sub	r8,48
8001b5de:	f0 0b 00 13 	add	r3,r8,r11<<0x1
8001b5e2:	c0 98       	rjmp	8001b5f4 <_strtod_r+0x188>
8001b5e4:	58 fa       	cp.w	r10,15
8001b5e6:	e0 89 00 07 	brgt	8001b5f4 <_strtod_r+0x188>
8001b5ea:	e8 04 00 24 	add	r4,r4,r4<<0x2
8001b5ee:	23 08       	sub	r8,48
8001b5f0:	f0 04 00 14 	add	r4,r8,r4<<0x1
8001b5f4:	2f f9       	sub	r9,-1
8001b5f6:	2f fa       	sub	r10,-1
8001b5f8:	51 89       	stdsp	sp[0x60],r9
8001b5fa:	41 89       	lddsp	r9,sp[0x60]
8001b5fc:	e6 03 00 2b 	add	r11,r3,r3<<0x2
8001b600:	13 88       	ld.ub	r8,r9[0x0]
8001b602:	e0 48 00 2f 	cp.w	r8,47
8001b606:	e0 8a 00 07 	brle	8001b614 <_strtod_r+0x1a8>
8001b60a:	e0 48 00 39 	cp.w	r8,57
8001b60e:	fe 9a ff e4 	brle	8001b5d6 <_strtod_r+0x16a>
8001b612:	c5 b8       	rjmp	8001b6c8 <_strtod_r+0x25c>
8001b614:	14 95       	mov	r5,r10
8001b616:	e0 48 00 2e 	cp.w	r8,46
8001b61a:	c5 71       	brne	8001b6c8 <_strtod_r+0x25c>
8001b61c:	2f f9       	sub	r9,-1
8001b61e:	51 89       	stdsp	sp[0x60],r9
8001b620:	13 88       	ld.ub	r8,r9[0x0]
8001b622:	58 0a       	cp.w	r10,0
8001b624:	c0 40       	breq	8001b62c <_strtod_r+0x1c0>
8001b626:	30 09       	mov	r9,0
8001b628:	12 9b       	mov	r11,r9
8001b62a:	c4 78       	rjmp	8001b6b8 <_strtod_r+0x24c>
8001b62c:	14 99       	mov	r9,r10
8001b62e:	c0 68       	rjmp	8001b63a <_strtod_r+0x1ce>
8001b630:	41 88       	lddsp	r8,sp[0x60]
8001b632:	2f f9       	sub	r9,-1
8001b634:	2f f8       	sub	r8,-1
8001b636:	51 88       	stdsp	sp[0x60],r8
8001b638:	11 88       	ld.ub	r8,r8[0x0]
8001b63a:	e0 48 00 30 	cp.w	r8,48
8001b63e:	cf 90       	breq	8001b630 <_strtod_r+0x1c4>
8001b640:	f0 cb 00 31 	sub	r11,r8,49
8001b644:	58 8b       	cp.w	r11,8
8001b646:	e0 88 00 07 	brls	8001b654 <_strtod_r+0x1e8>
8001b64a:	30 0a       	mov	r10,0
8001b64c:	30 11       	mov	r1,1
8001b64e:	14 9b       	mov	r11,r10
8001b650:	50 11       	stdsp	sp[0x4],r1
8001b652:	c3 f8       	rjmp	8001b6d0 <_strtod_r+0x264>
8001b654:	12 9b       	mov	r11,r9
8001b656:	41 8e       	lddsp	lr,sp[0x60]
8001b658:	30 09       	mov	r9,0
8001b65a:	50 7e       	stdsp	sp[0x1c],lr
8001b65c:	2f f9       	sub	r9,-1
8001b65e:	23 08       	sub	r8,48
8001b660:	c2 80       	breq	8001b6b0 <_strtod_r+0x244>
8001b662:	12 0b       	add	r11,r9
8001b664:	30 1e       	mov	lr,1
8001b666:	c1 08       	rjmp	8001b686 <_strtod_r+0x21a>
8001b668:	18 95       	mov	r5,r12
8001b66a:	20 1c       	sub	r12,1
8001b66c:	58 8c       	cp.w	r12,8
8001b66e:	e0 89 00 05 	brgt	8001b678 <_strtod_r+0x20c>
8001b672:	e2 03 15 01 	lsl	r3,r1,0x1
8001b676:	c0 78       	rjmp	8001b684 <_strtod_r+0x218>
8001b678:	59 05       	cp.w	r5,16
8001b67a:	e0 89 00 05 	brgt	8001b684 <_strtod_r+0x218>
8001b67e:	e8 04 00 24 	add	r4,r4,r4<<0x2
8001b682:	a1 74       	lsl	r4,0x1
8001b684:	2f fe       	sub	lr,-1
8001b686:	e6 03 00 21 	add	r1,r3,r3<<0x2
8001b68a:	ea cc ff ff 	sub	r12,r5,-1
8001b68e:	12 3e       	cp.w	lr,r9
8001b690:	ce c5       	brlt	8001b668 <_strtod_r+0x1fc>
8001b692:	58 85       	cp.w	r5,8
8001b694:	e0 89 00 05 	brgt	8001b69e <_strtod_r+0x232>
8001b698:	f0 01 00 13 	add	r3,r8,r1<<0x1
8001b69c:	c0 88       	rjmp	8001b6ac <_strtod_r+0x240>
8001b69e:	59 0c       	cp.w	r12,16
8001b6a0:	e0 89 00 06 	brgt	8001b6ac <_strtod_r+0x240>
8001b6a4:	e8 04 00 24 	add	r4,r4,r4<<0x2
8001b6a8:	f0 04 00 14 	add	r4,r8,r4<<0x1
8001b6ac:	18 95       	mov	r5,r12
8001b6ae:	30 09       	mov	r9,0
8001b6b0:	41 88       	lddsp	r8,sp[0x60]
8001b6b2:	2f f8       	sub	r8,-1
8001b6b4:	51 88       	stdsp	sp[0x60],r8
8001b6b6:	11 88       	ld.ub	r8,r8[0x0]
8001b6b8:	f0 cc 00 30 	sub	r12,r8,48
8001b6bc:	58 9c       	cp.w	r12,9
8001b6be:	fe 98 ff cf 	brls	8001b65c <_strtod_r+0x1f0>
8001b6c2:	30 1c       	mov	r12,1
8001b6c4:	50 1c       	stdsp	sp[0x4],r12
8001b6c6:	c0 58       	rjmp	8001b6d0 <_strtod_r+0x264>
8001b6c8:	30 09       	mov	r9,0
8001b6ca:	14 95       	mov	r5,r10
8001b6cc:	12 9b       	mov	r11,r9
8001b6ce:	50 19       	stdsp	sp[0x4],r9
8001b6d0:	e0 48 00 45 	cp.w	r8,69
8001b6d4:	5f 0e       	sreq	lr
8001b6d6:	e0 48 00 65 	cp.w	r8,101
8001b6da:	5f 0c       	sreq	r12
8001b6dc:	fd ec 10 0c 	or	r12,lr,r12
8001b6e0:	c6 60       	breq	8001b7ac <_strtod_r+0x340>
8001b6e2:	eb e9 10 08 	or	r8,r5,r9
8001b6e6:	00 48       	or	r8,r0
8001b6e8:	e0 80 00 de 	breq	8001b8a4 <_strtod_r+0x438>
8001b6ec:	41 82       	lddsp	r2,sp[0x60]
8001b6ee:	e4 cc ff ff 	sub	r12,r2,-1
8001b6f2:	51 8c       	stdsp	sp[0x60],r12
8001b6f4:	32 be       	mov	lr,43
8001b6f6:	19 88       	ld.ub	r8,r12[0x0]
8001b6f8:	fc 08 18 00 	cp.b	r8,lr
8001b6fc:	c0 60       	breq	8001b708 <_strtod_r+0x29c>
8001b6fe:	32 de       	mov	lr,45
8001b700:	fc 08 18 00 	cp.b	r8,lr
8001b704:	c0 51       	brne	8001b70e <_strtod_r+0x2a2>
8001b706:	c0 78       	rjmp	8001b714 <_strtod_r+0x2a8>
8001b708:	30 08       	mov	r8,0
8001b70a:	50 c8       	stdsp	sp[0x30],r8
8001b70c:	c0 68       	rjmp	8001b718 <_strtod_r+0x2ac>
8001b70e:	30 01       	mov	r1,0
8001b710:	50 c1       	stdsp	sp[0x30],r1
8001b712:	c0 68       	rjmp	8001b71e <_strtod_r+0x2b2>
8001b714:	30 1e       	mov	lr,1
8001b716:	50 ce       	stdsp	sp[0x30],lr
8001b718:	2f fc       	sub	r12,-1
8001b71a:	51 8c       	stdsp	sp[0x60],r12
8001b71c:	19 88       	ld.ub	r8,r12[0x0]
8001b71e:	f0 cc 00 30 	sub	r12,r8,48
8001b722:	58 9c       	cp.w	r12,9
8001b724:	e0 88 00 08 	brls	8001b734 <_strtod_r+0x2c8>
8001b728:	c3 e8       	rjmp	8001b7a4 <_strtod_r+0x338>
8001b72a:	41 88       	lddsp	r8,sp[0x60]
8001b72c:	2f f8       	sub	r8,-1
8001b72e:	51 88       	stdsp	sp[0x60],r8
8001b730:	11 88       	ld.ub	r8,r8[0x0]
8001b732:	c0 28       	rjmp	8001b736 <_strtod_r+0x2ca>
8001b734:	40 ce       	lddsp	lr,sp[0x30]
8001b736:	e0 48 00 30 	cp.w	r8,48
8001b73a:	cf 80       	breq	8001b72a <_strtod_r+0x2be>
8001b73c:	50 ce       	stdsp	sp[0x30],lr
8001b73e:	f0 cc 00 31 	sub	r12,r8,49
8001b742:	58 8c       	cp.w	r12,8
8001b744:	e0 8b 00 34 	brhi	8001b7ac <_strtod_r+0x340>
8001b748:	41 8c       	lddsp	r12,sp[0x60]
8001b74a:	23 08       	sub	r8,48
8001b74c:	50 3c       	stdsp	sp[0xc],r12
8001b74e:	50 98       	stdsp	sp[0x24],r8
8001b750:	10 9c       	mov	r12,r8
8001b752:	c0 58       	rjmp	8001b75c <_strtod_r+0x2f0>
8001b754:	23 08       	sub	r8,48
8001b756:	40 51       	lddsp	r1,sp[0x14]
8001b758:	f0 01 00 1c 	add	r12,r8,r1<<0x1
8001b75c:	41 81       	lddsp	r1,sp[0x60]
8001b75e:	f8 0c 00 28 	add	r8,r12,r12<<0x2
8001b762:	2f f1       	sub	r1,-1
8001b764:	50 58       	stdsp	sp[0x14],r8
8001b766:	51 81       	stdsp	sp[0x60],r1
8001b768:	03 88       	ld.ub	r8,r1[0x0]
8001b76a:	e0 48 00 2f 	cp.w	r8,47
8001b76e:	e0 8a 00 06 	brle	8001b77a <_strtod_r+0x30e>
8001b772:	e0 48 00 39 	cp.w	r8,57
8001b776:	fe 9a ff ef 	brle	8001b754 <_strtod_r+0x2e8>
8001b77a:	50 ce       	stdsp	sp[0x30],lr
8001b77c:	40 3e       	lddsp	lr,sp[0xc]
8001b77e:	1c 11       	sub	r1,lr
8001b780:	50 9c       	stdsp	sp[0x24],r12
8001b782:	58 81       	cp.w	r1,8
8001b784:	5f 9c       	srgt	r12
8001b786:	40 91       	lddsp	r1,sp[0x24]
8001b788:	e0 41 4e 1f 	cp.w	r1,19999
8001b78c:	5f 9e       	srgt	lr
8001b78e:	1c 4c       	or	r12,lr
8001b790:	e0 6e 4e 1f 	mov	lr,19999
8001b794:	fc 01 17 10 	movne	r1,lr
8001b798:	50 31       	stdsp	sp[0xc],r1
8001b79a:	40 cc       	lddsp	r12,sp[0x30]
8001b79c:	58 0c       	cp.w	r12,0
8001b79e:	c0 90       	breq	8001b7b0 <_strtod_r+0x344>
8001b7a0:	5c 31       	neg	r1
8001b7a2:	c0 38       	rjmp	8001b7a8 <_strtod_r+0x33c>
8001b7a4:	51 82       	stdsp	sp[0x60],r2
8001b7a6:	30 01       	mov	r1,0
8001b7a8:	50 31       	stdsp	sp[0xc],r1
8001b7aa:	c0 38       	rjmp	8001b7b0 <_strtod_r+0x344>
8001b7ac:	30 0e       	mov	lr,0
8001b7ae:	50 3e       	stdsp	sp[0xc],lr
8001b7b0:	58 05       	cp.w	r5,0
8001b7b2:	c7 e1       	brne	8001b8ae <_strtod_r+0x442>
8001b7b4:	00 49       	or	r9,r0
8001b7b6:	e0 81 04 79 	brne	8001c0a8 <_strtod_r+0xc3c>
8001b7ba:	40 1c       	lddsp	r12,sp[0x4]
8001b7bc:	58 0c       	cp.w	r12,0
8001b7be:	c7 31       	brne	8001b8a4 <_strtod_r+0x438>
8001b7c0:	e0 48 00 4e 	cp.w	r8,78
8001b7c4:	c3 e0       	breq	8001b840 <_strtod_r+0x3d4>
8001b7c6:	e0 89 00 06 	brgt	8001b7d2 <_strtod_r+0x366>
8001b7ca:	e0 48 00 49 	cp.w	r8,73
8001b7ce:	c6 b1       	brne	8001b8a4 <_strtod_r+0x438>
8001b7d0:	c0 88       	rjmp	8001b7e0 <_strtod_r+0x374>
8001b7d2:	e0 48 00 69 	cp.w	r8,105
8001b7d6:	c0 50       	breq	8001b7e0 <_strtod_r+0x374>
8001b7d8:	e0 48 00 6e 	cp.w	r8,110
8001b7dc:	c6 41       	brne	8001b8a4 <_strtod_r+0x438>
8001b7de:	c3 18       	rjmp	8001b840 <_strtod_r+0x3d4>
8001b7e0:	41 88       	lddsp	r8,sp[0x60]
8001b7e2:	fe ca b1 ce 	sub	r10,pc,-20018
8001b7e6:	c0 d8       	rjmp	8001b800 <_strtod_r+0x394>
8001b7e8:	2f f8       	sub	r8,-1
8001b7ea:	11 89       	ld.ub	r9,r8[0x0]
8001b7ec:	e0 49 00 40 	cp.w	r9,64
8001b7f0:	e0 8a 00 06 	brle	8001b7fc <_strtod_r+0x390>
8001b7f4:	e0 49 00 5a 	cp.w	r9,90
8001b7f8:	f7 b9 0a e0 	suble	r9,-32
8001b7fc:	16 39       	cp.w	r9,r11
8001b7fe:	c5 31       	brne	8001b8a4 <_strtod_r+0x438>
8001b800:	15 3b       	ld.ub	r11,r10++
8001b802:	58 0b       	cp.w	r11,0
8001b804:	cf 21       	brne	8001b7e8 <_strtod_r+0x37c>
8001b806:	51 88       	stdsp	sp[0x60],r8
8001b808:	10 9a       	mov	r10,r8
8001b80a:	fe cb b1 f2 	sub	r11,pc,-19982
8001b80e:	c0 c8       	rjmp	8001b826 <_strtod_r+0x3ba>
8001b810:	15 89       	ld.ub	r9,r10[0x0]
8001b812:	e0 49 00 40 	cp.w	r9,64
8001b816:	e0 8a 00 06 	brle	8001b822 <_strtod_r+0x3b6>
8001b81a:	e0 49 00 5a 	cp.w	r9,90
8001b81e:	f7 b9 0a e0 	suble	r9,-32
8001b822:	18 39       	cp.w	r9,r12
8001b824:	c0 91       	brne	8001b836 <_strtod_r+0x3ca>
8001b826:	f4 c9 ff ff 	sub	r9,r10,-1
8001b82a:	17 3c       	ld.ub	r12,r11++
8001b82c:	12 9a       	mov	r10,r9
8001b82e:	58 0c       	cp.w	r12,0
8001b830:	cf 01       	brne	8001b810 <_strtod_r+0x3a4>
8001b832:	51 89       	stdsp	sp[0x60],r9
8001b834:	c0 38       	rjmp	8001b83a <_strtod_r+0x3ce>
8001b836:	2f f8       	sub	r8,-1
8001b838:	51 88       	stdsp	sp[0x60],r8
8001b83a:	fc 18 7f f0 	movh	r8,0x7ff0
8001b83e:	c2 e8       	rjmp	8001b89a <_strtod_r+0x42e>
8001b840:	41 89       	lddsp	r9,sp[0x60]
8001b842:	fe ca b2 22 	sub	r10,pc,-19934
8001b846:	c0 c8       	rjmp	8001b85e <_strtod_r+0x3f2>
8001b848:	13 88       	ld.ub	r8,r9[0x0]
8001b84a:	e0 48 00 40 	cp.w	r8,64
8001b84e:	e0 8a 00 06 	brle	8001b85a <_strtod_r+0x3ee>
8001b852:	e0 48 00 5a 	cp.w	r8,90
8001b856:	f7 b8 0a e0 	suble	r8,-32
8001b85a:	16 38       	cp.w	r8,r11
8001b85c:	c2 41       	brne	8001b8a4 <_strtod_r+0x438>
8001b85e:	f2 c8 ff ff 	sub	r8,r9,-1
8001b862:	15 3b       	ld.ub	r11,r10++
8001b864:	10 99       	mov	r9,r8
8001b866:	58 0b       	cp.w	r11,0
8001b868:	cf 01       	brne	8001b848 <_strtod_r+0x3dc>
8001b86a:	51 88       	stdsp	sp[0x60],r8
8001b86c:	11 89       	ld.ub	r9,r8[0x0]
8001b86e:	32 88       	mov	r8,40
8001b870:	f0 09 18 00 	cp.b	r9,r8
8001b874:	c1 11       	brne	8001b896 <_strtod_r+0x42a>
8001b876:	fa ca ff c8 	sub	r10,sp,-56
8001b87a:	e0 6b 05 3c 	mov	r11,1340
8001b87e:	fa cc ff a0 	sub	r12,sp,-96
8001b882:	e0 a0 0a b1 	rcall	8001cde4 <__hexnan>
8001b886:	58 5c       	cp.w	r12,5
8001b888:	c0 71       	brne	8001b896 <_strtod_r+0x42a>
8001b88a:	40 f8       	lddsp	r8,sp[0x3c]
8001b88c:	ea 18 7f f0 	orh	r8,0x7ff0
8001b890:	8f 08       	st.w	r7[0x0],r8
8001b892:	40 e8       	lddsp	r8,sp[0x38]
8001b894:	c0 58       	rjmp	8001b89e <_strtod_r+0x432>
8001b896:	fc 18 7f f8 	movh	r8,0x7ff8
8001b89a:	8f 08       	st.w	r7[0x0],r8
8001b89c:	30 08       	mov	r8,0
8001b89e:	8f 18       	st.w	r7[0x4],r8
8001b8a0:	e0 8f 04 04 	bral	8001c0a8 <_strtod_r+0xc3c>
8001b8a4:	30 0b       	mov	r11,0
8001b8a6:	51 82       	stdsp	sp[0x60],r2
8001b8a8:	50 8b       	stdsp	sp[0x20],r11
8001b8aa:	e0 8f 03 ff 	bral	8001c0a8 <_strtod_r+0xc3c>
8001b8ae:	58 0a       	cp.w	r10,0
8001b8b0:	ea 0a 17 00 	moveq	r10,r5
8001b8b4:	40 31       	lddsp	r1,sp[0xc]
8001b8b6:	50 5a       	stdsp	sp[0x14],r10
8001b8b8:	16 11       	sub	r1,r11
8001b8ba:	06 9c       	mov	r12,r3
8001b8bc:	fe b0 c9 cf 	rcall	80014c5a <__avr32_u32_to_f64>
8001b8c0:	ee eb 00 00 	st.d	r7[0],r10
8001b8c4:	31 02       	mov	r2,16
8001b8c6:	ea 02 0d 42 	min	r2,r5,r2
8001b8ca:	58 92       	cp.w	r2,9
8001b8cc:	e0 8a 00 19 	brle	8001b8fe <_strtod_r+0x492>
8001b8d0:	fa e8 00 48 	ld.d	r8,sp[72]
8001b8d4:	e4 cb 00 09 	sub	r11,r2,9
8001b8d8:	fe ca b3 d0 	sub	r10,pc,-19504
8001b8dc:	f4 0b 02 3a 	ld.d	r10,r10[r11<<0x3]
8001b8e0:	fe b0 c8 be 	rcall	80014a5c <__avr32_f64_mul>
8001b8e4:	08 9c       	mov	r12,r4
8001b8e6:	fa eb 00 04 	st.d	sp[4],r10
8001b8ea:	fe b0 c9 b8 	rcall	80014c5a <__avr32_u32_to_f64>
8001b8ee:	14 98       	mov	r8,r10
8001b8f0:	16 99       	mov	r9,r11
8001b8f2:	fa ea 00 04 	ld.d	r10,sp[4]
8001b8f6:	e0 a0 0c 2d 	rcall	8001d150 <__avr32_f64_add>
8001b8fa:	ee eb 00 00 	st.d	r7[0],r10
8001b8fe:	58 f5       	cp.w	r5,15
8001b900:	e0 89 00 2b 	brgt	8001b956 <_strtod_r+0x4ea>
8001b904:	58 01       	cp.w	r1,0
8001b906:	e0 80 03 d1 	breq	8001c0a8 <_strtod_r+0xc3c>
8001b90a:	e0 8a 00 19 	brle	8001b93c <_strtod_r+0x4d0>
8001b90e:	59 61       	cp.w	r1,22
8001b910:	e0 8a 00 0a 	brle	8001b924 <_strtod_r+0x4b8>
8001b914:	ea 08 11 0f 	rsub	r8,r5,15
8001b918:	f0 c9 ff ea 	sub	r9,r8,-22
8001b91c:	12 31       	cp.w	r1,r9
8001b91e:	e0 89 00 1c 	brgt	8001b956 <_strtod_r+0x4ea>
8001b922:	10 11       	sub	r1,r8
8001b924:	fe c8 b4 1c 	sub	r8,pc,-19428
8001b928:	fa ea 00 48 	ld.d	r10,sp[72]
8001b92c:	f0 01 02 38 	ld.d	r8,r8[r1<<0x3]
8001b930:	fe b0 c8 96 	rcall	80014a5c <__avr32_f64_mul>
8001b934:	ee eb 00 00 	st.d	r7[0],r10
8001b938:	e0 8f 03 b8 	bral	8001c0a8 <_strtod_r+0xc3c>
8001b93c:	5a a1       	cp.w	r1,-22
8001b93e:	c0 c5       	brlt	8001b956 <_strtod_r+0x4ea>
8001b940:	fe c8 b4 38 	sub	r8,pc,-19400
8001b944:	fa ea 00 48 	ld.d	r10,sp[72]
8001b948:	f0 01 01 31 	sub	r1,r8,r1<<0x3
8001b94c:	e2 e8 00 00 	ld.d	r8,r1[0]
8001b950:	e0 a0 0d 04 	rcall	8001d358 <__avr32_f64_div>
8001b954:	cf 0b       	rjmp	8001b934 <_strtod_r+0x4c8>
8001b956:	ea 02 01 04 	sub	r4,r5,r2
8001b95a:	02 04       	add	r4,r1
8001b95c:	58 04       	cp.w	r4,0
8001b95e:	e0 8a 00 72 	brle	8001ba42 <_strtod_r+0x5d6>
8001b962:	f1 d4 c0 04 	bfextu	r8,r4,0x0,0x4
8001b966:	c0 b0       	breq	8001b97c <_strtod_r+0x510>
8001b968:	fa ea 00 48 	ld.d	r10,sp[72]
8001b96c:	fe c9 b4 64 	sub	r9,pc,-19356
8001b970:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8001b974:	fe b0 c8 74 	rcall	80014a5c <__avr32_f64_mul>
8001b978:	ee eb 00 00 	st.d	r7[0],r10
8001b97c:	e0 14 ff f0 	andl	r4,0xfff0
8001b980:	e0 80 00 d2 	breq	8001bb24 <_strtod_r+0x6b8>
8001b984:	e0 44 01 34 	cp.w	r4,308
8001b988:	e0 8a 00 15 	brle	8001b9b2 <_strtod_r+0x546>
8001b98c:	30 05       	mov	r5,0
8001b98e:	0a 92       	mov	r2,r5
8001b990:	50 75       	stdsp	sp[0x1c],r5
8001b992:	0a 90       	mov	r0,r5
8001b994:	c0 28       	rjmp	8001b998 <_strtod_r+0x52c>
8001b996:	06 95       	mov	r5,r3
8001b998:	32 28       	mov	r8,34
8001b99a:	8d 38       	st.w	r6[0xc],r8
8001b99c:	fc 18 7f f0 	movh	r8,0x7ff0
8001b9a0:	8f 08       	st.w	r7[0x0],r8
8001b9a2:	30 08       	mov	r8,0
8001b9a4:	8f 18       	st.w	r7[0x4],r8
8001b9a6:	40 7a       	lddsp	r10,sp[0x1c]
8001b9a8:	58 0a       	cp.w	r10,0
8001b9aa:	e0 81 03 6b 	brne	8001c080 <_strtod_r+0xc14>
8001b9ae:	e0 8f 03 7d 	bral	8001c0a8 <_strtod_r+0xc3c>
8001b9b2:	fa e8 00 48 	ld.d	r8,sp[72]
8001b9b6:	a5 44       	asr	r4,0x4
8001b9b8:	fa e9 00 04 	st.d	sp[4],r8
8001b9bc:	fe c2 b3 ec 	sub	r2,pc,-19476
8001b9c0:	30 00       	mov	r0,0
8001b9c2:	c0 f8       	rjmp	8001b9e0 <_strtod_r+0x574>
8001b9c4:	2f f0       	sub	r0,-1
8001b9c6:	ed b4 00 00 	bld	r4,0x0
8001b9ca:	c0 91       	brne	8001b9dc <_strtod_r+0x570>
8001b9cc:	fa ea 00 04 	ld.d	r10,sp[4]
8001b9d0:	e4 e8 00 00 	ld.d	r8,r2[0]
8001b9d4:	fe b0 c8 44 	rcall	80014a5c <__avr32_f64_mul>
8001b9d8:	ee eb 00 00 	st.d	r7[0],r10
8001b9dc:	a1 54       	asr	r4,0x1
8001b9de:	2f 82       	sub	r2,-8
8001b9e0:	58 14       	cp.w	r4,1
8001b9e2:	fe 99 ff f1 	brgt	8001b9c4 <_strtod_r+0x558>
8001b9e6:	41 24       	lddsp	r4,sp[0x48]
8001b9e8:	fc 18 fc b0 	movh	r8,0xfcb0
8001b9ec:	e8 08 00 08 	add	r8,r4,r8
8001b9f0:	8f 08       	st.w	r7[0x0],r8
8001b9f2:	fe c8 b4 22 	sub	r8,pc,-19422
8001b9f6:	fa ea 00 48 	ld.d	r10,sp[72]
8001b9fa:	f0 00 02 38 	ld.d	r8,r8[r0<<0x3]
8001b9fe:	fe b0 c8 2f 	rcall	80014a5c <__avr32_f64_mul>
8001ba02:	ee eb 00 00 	st.d	r7[0],r10
8001ba06:	08 98       	mov	r8,r4
8001ba08:	fc 1e 7c a0 	movh	lr,0x7ca0
8001ba0c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001ba10:	1c 38       	cp.w	r8,lr
8001ba12:	fe 9b ff bd 	brhi	8001b98c <_strtod_r+0x520>
8001ba16:	fc 1c 7c 90 	movh	r12,0x7c90
8001ba1a:	18 38       	cp.w	r8,r12
8001ba1c:	e0 88 00 0c 	brls	8001ba34 <_strtod_r+0x5c8>
8001ba20:	e0 68 ff ff 	mov	r8,65535
8001ba24:	ea 18 7f ef 	orh	r8,0x7fef
8001ba28:	8f 08       	st.w	r7[0x0],r8
8001ba2a:	3f f8       	mov	r8,-1
8001ba2c:	8f 18       	st.w	r7[0x4],r8
8001ba2e:	30 0b       	mov	r11,0
8001ba30:	50 1b       	stdsp	sp[0x4],r11
8001ba32:	c7 b8       	rjmp	8001bb28 <_strtod_r+0x6bc>
8001ba34:	fc 18 03 50 	movh	r8,0x350
8001ba38:	10 04       	add	r4,r8
8001ba3a:	8f 04       	st.w	r7[0x0],r4
8001ba3c:	30 0a       	mov	r10,0
8001ba3e:	50 1a       	stdsp	sp[0x4],r10
8001ba40:	c7 48       	rjmp	8001bb28 <_strtod_r+0x6bc>
8001ba42:	58 04       	cp.w	r4,0
8001ba44:	c7 00       	breq	8001bb24 <_strtod_r+0x6b8>
8001ba46:	5c 34       	neg	r4
8001ba48:	f1 d4 c0 04 	bfextu	r8,r4,0x0,0x4
8001ba4c:	c0 b0       	breq	8001ba62 <_strtod_r+0x5f6>
8001ba4e:	fa ea 00 48 	ld.d	r10,sp[72]
8001ba52:	fe c9 b5 4a 	sub	r9,pc,-19126
8001ba56:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8001ba5a:	e0 a0 0c 7f 	rcall	8001d358 <__avr32_f64_div>
8001ba5e:	ee eb 00 00 	st.d	r7[0],r10
8001ba62:	a5 44       	asr	r4,0x4
8001ba64:	c6 00       	breq	8001bb24 <_strtod_r+0x6b8>
8001ba66:	59 f4       	cp.w	r4,31
8001ba68:	e0 89 00 4c 	brgt	8001bb00 <_strtod_r+0x694>
8001ba6c:	08 98       	mov	r8,r4
8001ba6e:	e2 18 00 10 	andl	r8,0x10,COH
8001ba72:	f9 b8 01 6a 	movne	r8,106
8001ba76:	fe c2 b4 52 	sub	r2,pc,-19374
8001ba7a:	50 18       	stdsp	sp[0x4],r8
8001ba7c:	fa e8 00 48 	ld.d	r8,sp[72]
8001ba80:	fa e9 00 0c 	st.d	sp[12],r8
8001ba84:	c0 f8       	rjmp	8001baa2 <_strtod_r+0x636>
8001ba86:	d7 03       	nop
8001ba88:	ed b4 00 00 	bld	r4,0x0
8001ba8c:	c0 91       	brne	8001ba9e <_strtod_r+0x632>
8001ba8e:	fa ea 00 0c 	ld.d	r10,sp[12]
8001ba92:	e4 e8 00 00 	ld.d	r8,r2[0]
8001ba96:	fe b0 c7 e3 	rcall	80014a5c <__avr32_f64_mul>
8001ba9a:	ee eb 00 00 	st.d	r7[0],r10
8001ba9e:	a1 54       	asr	r4,0x1
8001baa0:	2f 82       	sub	r2,-8
8001baa2:	58 04       	cp.w	r4,0
8001baa4:	fe 99 ff f2 	brgt	8001ba88 <_strtod_r+0x61c>
8001baa8:	40 18       	lddsp	r8,sp[0x4]
8001baaa:	58 08       	cp.w	r8,0
8001baac:	c2 30       	breq	8001baf2 <_strtod_r+0x686>
8001baae:	41 29       	lddsp	r9,sp[0x48]
8001bab0:	f1 d9 c2 8b 	bfextu	r8,r9,0x14,0xb
8001bab4:	f0 08 11 6b 	rsub	r8,r8,107
8001bab8:	58 08       	cp.w	r8,0
8001baba:	e0 8a 00 1c 	brle	8001baf2 <_strtod_r+0x686>
8001babe:	59 f8       	cp.w	r8,31
8001bac0:	e0 8a 00 13 	brle	8001bae6 <_strtod_r+0x67a>
8001bac4:	30 0a       	mov	r10,0
8001bac6:	8f 1a       	st.w	r7[0x4],r10
8001bac8:	e0 48 00 34 	cp.w	r8,52
8001bacc:	e0 8a 00 06 	brle	8001bad8 <_strtod_r+0x66c>
8001bad0:	fc 18 03 70 	movh	r8,0x370
8001bad4:	8f 08       	st.w	r7[0x0],r8
8001bad6:	c0 e8       	rjmp	8001baf2 <_strtod_r+0x686>
8001bad8:	3f fa       	mov	r10,-1
8001bada:	f4 08 09 48 	lsl	r8,r10,r8
8001bade:	f1 e9 00 09 	and	r9,r8,r9
8001bae2:	8f 09       	st.w	r7[0x0],r9
8001bae4:	c0 78       	rjmp	8001baf2 <_strtod_r+0x686>
8001bae6:	3f f9       	mov	r9,-1
8001bae8:	f2 08 09 48 	lsl	r8,r9,r8
8001baec:	41 39       	lddsp	r9,sp[0x4c]
8001baee:	12 68       	and	r8,r9
8001baf0:	8f 18       	st.w	r7[0x4],r8
8001baf2:	30 08       	mov	r8,0
8001baf4:	30 09       	mov	r9,0
8001baf6:	fa ea 00 48 	ld.d	r10,sp[72]
8001bafa:	e0 a0 0b b3 	rcall	8001d260 <__avr32_f64_cmp_eq>
8001bafe:	c1 50       	breq	8001bb28 <_strtod_r+0x6bc>
8001bb00:	30 05       	mov	r5,0
8001bb02:	0a 92       	mov	r2,r5
8001bb04:	50 75       	stdsp	sp[0x1c],r5
8001bb06:	0a 90       	mov	r0,r5
8001bb08:	c0 28       	rjmp	8001bb0c <_strtod_r+0x6a0>
8001bb0a:	06 95       	mov	r5,r3
8001bb0c:	30 08       	mov	r8,0
8001bb0e:	30 09       	mov	r9,0
8001bb10:	ee e9 00 00 	st.d	r7[0],r8
8001bb14:	32 28       	mov	r8,34
8001bb16:	8d 38       	st.w	r6[0xc],r8
8001bb18:	40 71       	lddsp	r1,sp[0x1c]
8001bb1a:	58 01       	cp.w	r1,0
8001bb1c:	e0 81 02 b2 	brne	8001c080 <_strtod_r+0xc14>
8001bb20:	e0 8f 02 c4 	bral	8001c0a8 <_strtod_r+0xc3c>
8001bb24:	30 0e       	mov	lr,0
8001bb26:	50 1e       	stdsp	sp[0x4],lr
8001bb28:	06 98       	mov	r8,r3
8001bb2a:	0a 99       	mov	r9,r5
8001bb2c:	40 5a       	lddsp	r10,sp[0x14]
8001bb2e:	40 7b       	lddsp	r11,sp[0x1c]
8001bb30:	0c 9c       	mov	r12,r6
8001bb32:	fe b0 f9 cb 	rcall	8001aec8 <__s2b>
8001bb36:	50 7c       	stdsp	sp[0x1c],r12
8001bb38:	2f 4c       	sub	r12,-12
8001bb3a:	50 dc       	stdsp	sp[0x34],r12
8001bb3c:	e2 0c 11 00 	rsub	r12,r1,0
8001bb40:	50 cc       	stdsp	sp[0x30],r12
8001bb42:	40 7a       	lddsp	r10,sp[0x1c]
8001bb44:	0c 9c       	mov	r12,r6
8001bb46:	74 1b       	ld.w	r11,r10[0x4]
8001bb48:	fe b0 f7 7e 	rcall	8001aa44 <_Balloc>
8001bb4c:	40 79       	lddsp	r9,sp[0x1c]
8001bb4e:	40 db       	lddsp	r11,sp[0x34]
8001bb50:	72 4a       	ld.w	r10,r9[0x10]
8001bb52:	18 90       	mov	r0,r12
8001bb54:	2f ea       	sub	r10,-2
8001bb56:	2f 4c       	sub	r12,-12
8001bb58:	a3 6a       	lsl	r10,0x2
8001bb5a:	fe b0 cc b0 	rcall	800154ba <memcpy>
8001bb5e:	fa ea 00 48 	ld.d	r10,sp[72]
8001bb62:	fa c8 ff 9c 	sub	r8,sp,-100
8001bb66:	fa c9 ff 98 	sub	r9,sp,-104
8001bb6a:	0c 9c       	mov	r12,r6
8001bb6c:	fe b0 f7 a4 	rcall	8001aab4 <__d2b>
8001bb70:	30 1b       	mov	r11,1
8001bb72:	51 7c       	stdsp	sp[0x5c],r12
8001bb74:	0c 9c       	mov	r12,r6
8001bb76:	fe b0 f9 1d 	rcall	8001adb0 <__i2b>
8001bb7a:	41 ab       	lddsp	r11,sp[0x68]
8001bb7c:	58 01       	cp.w	r1,0
8001bb7e:	f9 ba 04 00 	movge	r10,0
8001bb82:	e2 03 17 40 	movge	r3,r1
8001bb86:	e2 05 17 40 	movge	r5,r1
8001bb8a:	f4 08 17 40 	movge	r8,r10
8001bb8e:	f9 b3 05 00 	movlt	r3,0
8001bb92:	fb fa 50 0c 	ld.wlt	r10,sp[0x30]
8001bb96:	f4 08 17 50 	movlt	r8,r10
8001bb9a:	e6 05 17 50 	movlt	r5,r3
8001bb9e:	18 92       	mov	r2,r12
8001bba0:	58 0b       	cp.w	r11,0
8001bba2:	c0 45       	brlt	8001bbaa <_strtod_r+0x73e>
8001bba4:	f4 0b 00 08 	add	r8,r10,r11
8001bba8:	c0 28       	rjmp	8001bbac <_strtod_r+0x740>
8001bbaa:	16 15       	sub	r5,r11
8001bbac:	40 1e       	lddsp	lr,sp[0x4]
8001bbae:	41 99       	lddsp	r9,sp[0x64]
8001bbb0:	1c 1b       	sub	r11,lr
8001bbb2:	1c 05       	add	r5,lr
8001bbb4:	f6 cc fb cd 	sub	r12,r11,-1075
8001bbb8:	f2 0e 11 36 	rsub	lr,r9,54
8001bbbc:	f6 09 00 09 	add	r9,r11,r9
8001bbc0:	fe 59 fc 02 	cp.w	r9,-1022
8001bbc4:	fc 09 17 90 	movgt	r9,lr
8001bbc8:	f8 09 17 a0 	movle	r9,r12
8001bbcc:	12 05       	add	r5,r9
8001bbce:	f2 08 00 04 	add	r4,r9,r8
8001bbd2:	e8 05 0d 49 	min	r9,r4,r5
8001bbd6:	f2 08 0d 49 	min	r9,r9,r8
8001bbda:	58 09       	cp.w	r9,0
8001bbdc:	e0 89 00 04 	brgt	8001bbe4 <_strtod_r+0x778>
8001bbe0:	50 38       	stdsp	sp[0xc],r8
8001bbe2:	c0 58       	rjmp	8001bbec <_strtod_r+0x780>
8001bbe4:	12 18       	sub	r8,r9
8001bbe6:	12 14       	sub	r4,r9
8001bbe8:	50 38       	stdsp	sp[0xc],r8
8001bbea:	12 15       	sub	r5,r9
8001bbec:	58 0a       	cp.w	r10,0
8001bbee:	c1 30       	breq	8001bc14 <_strtod_r+0x7a8>
8001bbf0:	04 9b       	mov	r11,r2
8001bbf2:	0c 9c       	mov	r12,r6
8001bbf4:	fe b0 f9 24 	rcall	8001ae3c <__pow5mult>
8001bbf8:	41 7a       	lddsp	r10,sp[0x5c]
8001bbfa:	18 9b       	mov	r11,r12
8001bbfc:	18 92       	mov	r2,r12
8001bbfe:	0c 9c       	mov	r12,r6
8001bc00:	fe b0 f8 58 	rcall	8001acb0 <__multiply>
8001bc04:	18 98       	mov	r8,r12
8001bc06:	41 7b       	lddsp	r11,sp[0x5c]
8001bc08:	50 08       	stdsp	sp[0x0],r8
8001bc0a:	0c 9c       	mov	r12,r6
8001bc0c:	fe b0 f7 02 	rcall	8001aa10 <_Bfree>
8001bc10:	40 08       	lddsp	r8,sp[0x0]
8001bc12:	51 78       	stdsp	sp[0x5c],r8
8001bc14:	58 04       	cp.w	r4,0
8001bc16:	e0 8a 00 08 	brle	8001bc26 <_strtod_r+0x7ba>
8001bc1a:	08 9a       	mov	r10,r4
8001bc1c:	41 7b       	lddsp	r11,sp[0x5c]
8001bc1e:	0c 9c       	mov	r12,r6
8001bc20:	fe b0 f8 04 	rcall	8001ac28 <__lshift>
8001bc24:	51 7c       	stdsp	sp[0x5c],r12
8001bc26:	58 03       	cp.w	r3,0
8001bc28:	c0 70       	breq	8001bc36 <_strtod_r+0x7ca>
8001bc2a:	00 9b       	mov	r11,r0
8001bc2c:	06 9a       	mov	r10,r3
8001bc2e:	0c 9c       	mov	r12,r6
8001bc30:	fe b0 f9 06 	rcall	8001ae3c <__pow5mult>
8001bc34:	18 90       	mov	r0,r12
8001bc36:	58 05       	cp.w	r5,0
8001bc38:	e0 8a 00 08 	brle	8001bc48 <_strtod_r+0x7dc>
8001bc3c:	00 9b       	mov	r11,r0
8001bc3e:	0a 9a       	mov	r10,r5
8001bc40:	0c 9c       	mov	r12,r6
8001bc42:	fe b0 f7 f3 	rcall	8001ac28 <__lshift>
8001bc46:	18 90       	mov	r0,r12
8001bc48:	40 3c       	lddsp	r12,sp[0xc]
8001bc4a:	58 0c       	cp.w	r12,0
8001bc4c:	e0 8a 00 08 	brle	8001bc5c <_strtod_r+0x7f0>
8001bc50:	18 9a       	mov	r10,r12
8001bc52:	04 9b       	mov	r11,r2
8001bc54:	0c 9c       	mov	r12,r6
8001bc56:	fe b0 f7 e9 	rcall	8001ac28 <__lshift>
8001bc5a:	18 92       	mov	r2,r12
8001bc5c:	00 9a       	mov	r10,r0
8001bc5e:	41 7b       	lddsp	r11,sp[0x5c]
8001bc60:	0c 9c       	mov	r12,r6
8001bc62:	fe b0 f7 7b 	rcall	8001ab58 <__mdiff>
8001bc66:	30 09       	mov	r9,0
8001bc68:	78 3a       	ld.w	r10,r12[0xc]
8001bc6a:	18 93       	mov	r3,r12
8001bc6c:	04 9b       	mov	r11,r2
8001bc6e:	50 3a       	stdsp	sp[0xc],r10
8001bc70:	99 39       	st.w	r12[0xc],r9
8001bc72:	fe b0 f5 e0 	rcall	8001a832 <__mcmp>
8001bc76:	c2 a4       	brge	8001bcca <_strtod_r+0x85e>
8001bc78:	06 95       	mov	r5,r3
8001bc7a:	40 38       	lddsp	r8,sp[0xc]
8001bc7c:	58 08       	cp.w	r8,0
8001bc7e:	e0 81 01 e5 	brne	8001c048 <_strtod_r+0xbdc>
8001bc82:	41 38       	lddsp	r8,sp[0x4c]
8001bc84:	58 08       	cp.w	r8,0
8001bc86:	e0 81 01 e1 	brne	8001c048 <_strtod_r+0xbdc>
8001bc8a:	41 28       	lddsp	r8,sp[0x48]
8001bc8c:	f3 d8 c0 14 	bfextu	r9,r8,0x0,0x14
8001bc90:	e0 81 01 dc 	brne	8001c048 <_strtod_r+0xbdc>
8001bc94:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001bc98:	fc 11 06 b0 	movh	r1,0x6b0
8001bc9c:	02 38       	cp.w	r8,r1
8001bc9e:	e0 88 01 d5 	brls	8001c048 <_strtod_r+0xbdc>
8001bca2:	66 58       	ld.w	r8,r3[0x14]
8001bca4:	58 08       	cp.w	r8,0
8001bca6:	c0 51       	brne	8001bcb0 <_strtod_r+0x844>
8001bca8:	66 48       	ld.w	r8,r3[0x10]
8001bcaa:	58 18       	cp.w	r8,1
8001bcac:	e0 8a 01 ce 	brle	8001c048 <_strtod_r+0xbdc>
8001bcb0:	0a 9b       	mov	r11,r5
8001bcb2:	30 1a       	mov	r10,1
8001bcb4:	0c 9c       	mov	r12,r6
8001bcb6:	fe b0 f7 b9 	rcall	8001ac28 <__lshift>
8001bcba:	04 9b       	mov	r11,r2
8001bcbc:	18 95       	mov	r5,r12
8001bcbe:	fe b0 f5 ba 	rcall	8001a832 <__mcmp>
8001bcc2:	e0 89 00 33 	brgt	8001bd28 <_strtod_r+0x8bc>
8001bcc6:	e0 8f 01 c1 	bral	8001c048 <_strtod_r+0xbdc>
8001bcca:	58 0c       	cp.w	r12,0
8001bccc:	c7 91       	brne	8001bdbe <_strtod_r+0x952>
8001bcce:	06 95       	mov	r5,r3
8001bcd0:	41 28       	lddsp	r8,sp[0x48]
8001bcd2:	40 3e       	lddsp	lr,sp[0xc]
8001bcd4:	58 0e       	cp.w	lr,0
8001bcd6:	c2 30       	breq	8001bd1c <_strtod_r+0x8b0>
8001bcd8:	f3 d8 c0 14 	bfextu	r9,r8,0x0,0x14
8001bcdc:	ee 59 ff ff 	cp.w	r9,1048575
8001bce0:	c4 31       	brne	8001bd66 <_strtod_r+0x8fa>
8001bce2:	41 3a       	lddsp	r10,sp[0x4c]
8001bce4:	40 1c       	lddsp	r12,sp[0x4]
8001bce6:	58 0c       	cp.w	r12,0
8001bce8:	c1 00       	breq	8001bd08 <_strtod_r+0x89c>
8001bcea:	10 99       	mov	r9,r8
8001bcec:	fc 1b 06 a0 	movh	r11,0x6a0
8001bcf0:	e6 19 7f f0 	andh	r9,0x7ff0,COH
8001bcf4:	16 39       	cp.w	r9,r11
8001bcf6:	e0 8b 00 09 	brhi	8001bd08 <_strtod_r+0x89c>
8001bcfa:	b5 89       	lsr	r9,0x14
8001bcfc:	3f fb       	mov	r11,-1
8001bcfe:	f2 09 11 6b 	rsub	r9,r9,107
8001bd02:	f6 09 09 49 	lsl	r9,r11,r9
8001bd06:	c0 28       	rjmp	8001bd0a <_strtod_r+0x89e>
8001bd08:	3f f9       	mov	r9,-1
8001bd0a:	12 3a       	cp.w	r10,r9
8001bd0c:	c2 d1       	brne	8001bd66 <_strtod_r+0x8fa>
8001bd0e:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001bd12:	f0 28 00 00 	sub	r8,-1048576
8001bd16:	8f 08       	st.w	r7[0x0],r8
8001bd18:	30 08       	mov	r8,0
8001bd1a:	c2 48       	rjmp	8001bd62 <_strtod_r+0x8f6>
8001bd1c:	f1 d8 c0 14 	bfextu	r8,r8,0x0,0x14
8001bd20:	c2 31       	brne	8001bd66 <_strtod_r+0x8fa>
8001bd22:	41 38       	lddsp	r8,sp[0x4c]
8001bd24:	58 08       	cp.w	r8,0
8001bd26:	c2 01       	brne	8001bd66 <_strtod_r+0x8fa>
8001bd28:	40 1a       	lddsp	r10,sp[0x4]
8001bd2a:	58 0a       	cp.w	r10,0
8001bd2c:	c0 f0       	breq	8001bd4a <_strtod_r+0x8de>
8001bd2e:	41 28       	lddsp	r8,sp[0x48]
8001bd30:	fc 19 06 b0 	movh	r9,0x6b0
8001bd34:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001bd38:	12 38       	cp.w	r8,r9
8001bd3a:	e0 8b 00 08 	brhi	8001bd4a <_strtod_r+0x8de>
8001bd3e:	fc 11 03 70 	movh	r1,0x370
8001bd42:	02 38       	cp.w	r8,r1
8001bd44:	e0 8b 01 85 	brhi	8001c04e <_strtod_r+0xbe2>
8001bd48:	ce 2a       	rjmp	8001bb0c <_strtod_r+0x6a0>
8001bd4a:	41 28       	lddsp	r8,sp[0x48]
8001bd4c:	f0 69 00 00 	mov	r9,-1048576
8001bd50:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001bd54:	12 08       	add	r8,r9
8001bd56:	ea 18 00 0f 	orh	r8,0xf
8001bd5a:	e8 18 ff ff 	orl	r8,0xffff
8001bd5e:	8f 08       	st.w	r7[0x0],r8
8001bd60:	3f f8       	mov	r8,-1
8001bd62:	8f 18       	st.w	r7[0x4],r8
8001bd64:	c7 29       	rjmp	8001c048 <_strtod_r+0xbdc>
8001bd66:	41 38       	lddsp	r8,sp[0x4c]
8001bd68:	ed b8 00 00 	bld	r8,0x0
8001bd6c:	e0 81 01 6e 	brne	8001c048 <_strtod_r+0xbdc>
8001bd70:	fa ea 00 48 	ld.d	r10,sp[72]
8001bd74:	fa eb 00 14 	st.d	sp[20],r10
8001bd78:	40 3a       	lddsp	r10,sp[0xc]
8001bd7a:	58 0a       	cp.w	r10,0
8001bd7c:	c0 e0       	breq	8001bd98 <_strtod_r+0x92c>
8001bd7e:	fa ea 00 14 	ld.d	r10,sp[20]
8001bd82:	fe b0 f5 71 	rcall	8001a864 <__ulp>
8001bd86:	14 98       	mov	r8,r10
8001bd88:	16 99       	mov	r9,r11
8001bd8a:	fa ea 00 14 	ld.d	r10,sp[20]
8001bd8e:	e0 a0 09 e1 	rcall	8001d150 <__avr32_f64_add>
8001bd92:	ee eb 00 00 	st.d	r7[0],r10
8001bd96:	c5 99       	rjmp	8001c048 <_strtod_r+0xbdc>
8001bd98:	fa ea 00 14 	ld.d	r10,sp[20]
8001bd9c:	fe b0 f5 64 	rcall	8001a864 <__ulp>
8001bda0:	14 98       	mov	r8,r10
8001bda2:	16 99       	mov	r9,r11
8001bda4:	fa ea 00 14 	ld.d	r10,sp[20]
8001bda8:	e0 a0 09 06 	rcall	8001cfb4 <__avr32_f64_sub>
8001bdac:	30 08       	mov	r8,0
8001bdae:	ee eb 00 00 	st.d	r7[0],r10
8001bdb2:	30 09       	mov	r9,0
8001bdb4:	e0 a0 0a 56 	rcall	8001d260 <__avr32_f64_cmp_eq>
8001bdb8:	e0 80 01 48 	breq	8001c048 <_strtod_r+0xbdc>
8001bdbc:	ca 8a       	rjmp	8001bb0c <_strtod_r+0x6a0>
8001bdbe:	04 9b       	mov	r11,r2
8001bdc0:	06 9c       	mov	r12,r3
8001bdc2:	fe b0 f5 c1 	rcall	8001a944 <__ratio>
8001bdc6:	16 95       	mov	r5,r11
8001bdc8:	14 94       	mov	r4,r10
8001bdca:	14 98       	mov	r8,r10
8001bdcc:	0a 99       	mov	r9,r5
8001bdce:	30 0a       	mov	r10,0
8001bdd0:	fc 1b 40 00 	movh	r11,0x4000
8001bdd4:	e0 a0 0a 59 	rcall	8001d286 <__avr32_f64_cmp_ge>
8001bdd8:	c3 a0       	breq	8001be4c <_strtod_r+0x9e0>
8001bdda:	40 39       	lddsp	r9,sp[0xc]
8001bddc:	58 09       	cp.w	r9,0
8001bdde:	c0 50       	breq	8001bde8 <_strtod_r+0x97c>
8001bde0:	30 08       	mov	r8,0
8001bde2:	fc 19 3f f0 	movh	r9,0x3ff0
8001bde6:	c1 28       	rjmp	8001be0a <_strtod_r+0x99e>
8001bde8:	41 38       	lddsp	r8,sp[0x4c]
8001bdea:	58 08       	cp.w	r8,0
8001bdec:	c0 61       	brne	8001bdf8 <_strtod_r+0x98c>
8001bdee:	41 28       	lddsp	r8,sp[0x48]
8001bdf0:	f1 d8 c0 14 	bfextu	r8,r8,0x0,0x14
8001bdf4:	c0 81       	brne	8001be04 <_strtod_r+0x998>
8001bdf6:	c1 08       	rjmp	8001be16 <_strtod_r+0x9aa>
8001bdf8:	58 18       	cp.w	r8,1
8001bdfa:	c0 51       	brne	8001be04 <_strtod_r+0x998>
8001bdfc:	41 28       	lddsp	r8,sp[0x48]
8001bdfe:	58 08       	cp.w	r8,0
8001be00:	fe 90 fe 85 	breq	8001bb0a <_strtod_r+0x69e>
8001be04:	30 08       	mov	r8,0
8001be06:	fc 19 bf f0 	movh	r9,0xbff0
8001be0a:	fa e9 00 50 	st.d	sp[80],r8
8001be0e:	fc 15 3f f0 	movh	r5,0x3ff0
8001be12:	30 04       	mov	r4,0
8001be14:	c3 18       	rjmp	8001be76 <_strtod_r+0xa0a>
8001be16:	30 08       	mov	r8,0
8001be18:	fc 19 3f f0 	movh	r9,0x3ff0
8001be1c:	08 9a       	mov	r10,r4
8001be1e:	0a 9b       	mov	r11,r5
8001be20:	e0 a0 0a 67 	rcall	8001d2ee <__avr32_f64_cmp_lt>
8001be24:	c0 50       	breq	8001be2e <_strtod_r+0x9c2>
8001be26:	fc 15 3f e0 	movh	r5,0x3fe0
8001be2a:	30 04       	mov	r4,0
8001be2c:	c0 a8       	rjmp	8001be40 <_strtod_r+0x9d4>
8001be2e:	08 9a       	mov	r10,r4
8001be30:	0a 9b       	mov	r11,r5
8001be32:	30 08       	mov	r8,0
8001be34:	fc 19 3f e0 	movh	r9,0x3fe0
8001be38:	fe b0 c6 12 	rcall	80014a5c <__avr32_f64_mul>
8001be3c:	16 95       	mov	r5,r11
8001be3e:	14 94       	mov	r4,r10
8001be40:	0a 98       	mov	r8,r5
8001be42:	51 54       	stdsp	sp[0x54],r4
8001be44:	ee 18 80 00 	eorh	r8,0x8000
8001be48:	51 48       	stdsp	sp[0x50],r8
8001be4a:	c1 68       	rjmp	8001be76 <_strtod_r+0xa0a>
8001be4c:	08 9a       	mov	r10,r4
8001be4e:	0a 9b       	mov	r11,r5
8001be50:	30 08       	mov	r8,0
8001be52:	fc 19 3f e0 	movh	r9,0x3fe0
8001be56:	fe b0 c6 03 	rcall	80014a5c <__avr32_f64_mul>
8001be5a:	40 3e       	lddsp	lr,sp[0xc]
8001be5c:	16 95       	mov	r5,r11
8001be5e:	14 94       	mov	r4,r10
8001be60:	0a 9a       	mov	r10,r5
8001be62:	08 98       	mov	r8,r4
8001be64:	ee 1a 80 00 	eorh	r10,0x8000
8001be68:	58 0e       	cp.w	lr,0
8001be6a:	f4 09 17 00 	moveq	r9,r10
8001be6e:	ea 09 17 10 	movne	r9,r5
8001be72:	fa e9 00 50 	st.d	sp[80],r8
8001be76:	41 29       	lddsp	r9,sp[0x48]
8001be78:	12 9c       	mov	r12,r9
8001be7a:	e6 1c 7f f0 	andh	r12,0x7ff0,COH
8001be7e:	50 5c       	stdsp	sp[0x14],r12
8001be80:	fc 1b 7f e0 	movh	r11,0x7fe0
8001be84:	16 3c       	cp.w	r12,r11
8001be86:	c4 11       	brne	8001bf08 <_strtod_r+0xa9c>
8001be88:	fa ea 00 48 	ld.d	r10,sp[72]
8001be8c:	fc 18 fc b0 	movh	r8,0xfcb0
8001be90:	fa eb 00 40 	st.d	sp[64],r10
8001be94:	f2 08 00 08 	add	r8,r9,r8
8001be98:	8f 08       	st.w	r7[0x0],r8
8001be9a:	fa e8 00 50 	ld.d	r8,sp[80]
8001be9e:	fa e9 00 24 	st.d	sp[36],r8
8001bea2:	fe b0 f4 e1 	rcall	8001a864 <__ulp>
8001bea6:	14 98       	mov	r8,r10
8001bea8:	16 99       	mov	r9,r11
8001beaa:	fa ea 00 24 	ld.d	r10,sp[36]
8001beae:	fe b0 c5 d7 	rcall	80014a5c <__avr32_f64_mul>
8001beb2:	14 98       	mov	r8,r10
8001beb4:	16 99       	mov	r9,r11
8001beb6:	fa ea 00 48 	ld.d	r10,sp[72]
8001beba:	e0 a0 09 4b 	rcall	8001d150 <__avr32_f64_add>
8001bebe:	ee eb 00 00 	st.d	r7[0],r10
8001bec2:	e0 6e ff ff 	mov	lr,65535
8001bec6:	ea 1e 7c 9f 	orh	lr,0x7c9f
8001beca:	41 28       	lddsp	r8,sp[0x48]
8001becc:	10 99       	mov	r9,r8
8001bece:	e6 19 7f f0 	andh	r9,0x7ff0,COH
8001bed2:	1c 39       	cp.w	r9,lr
8001bed4:	e0 88 00 15 	brls	8001befe <_strtod_r+0xa92>
8001bed8:	41 08       	lddsp	r8,sp[0x40]
8001beda:	e0 6c ff ff 	mov	r12,65535
8001bede:	ea 1c 7f ef 	orh	r12,0x7fef
8001bee2:	18 38       	cp.w	r8,r12
8001bee4:	c0 51       	brne	8001beee <_strtod_r+0xa82>
8001bee6:	41 18       	lddsp	r8,sp[0x44]
8001bee8:	5b f8       	cp.w	r8,-1
8001beea:	fe 90 fd 56 	breq	8001b996 <_strtod_r+0x52a>
8001beee:	e0 68 ff ff 	mov	r8,65535
8001bef2:	ea 18 7f ef 	orh	r8,0x7fef
8001bef6:	8f 08       	st.w	r7[0x0],r8
8001bef8:	3f f8       	mov	r8,-1
8001befa:	8f 18       	st.w	r7[0x4],r8
8001befc:	c9 48       	rjmp	8001c024 <_strtod_r+0xbb8>
8001befe:	fc 19 03 50 	movh	r9,0x350
8001bf02:	12 08       	add	r8,r9
8001bf04:	8f 08       	st.w	r7[0x0],r8
8001bf06:	c4 b8       	rjmp	8001bf9c <_strtod_r+0xb30>
8001bf08:	40 1b       	lddsp	r11,sp[0x4]
8001bf0a:	40 5a       	lddsp	r10,sp[0x14]
8001bf0c:	58 0b       	cp.w	r11,0
8001bf0e:	5f 19       	srne	r9
8001bf10:	fc 18 06 a0 	movh	r8,0x6a0
8001bf14:	10 3a       	cp.w	r10,r8
8001bf16:	5f 88       	srls	r8
8001bf18:	f3 e8 00 08 	and	r8,r9,r8
8001bf1c:	c2 a0       	breq	8001bf70 <_strtod_r+0xb04>
8001bf1e:	fc 1a ff c0 	movh	r10,0xffc0
8001bf22:	e0 6b ff ff 	mov	r11,65535
8001bf26:	ea 1b 41 df 	orh	r11,0x41df
8001bf2a:	0a 99       	mov	r9,r5
8001bf2c:	08 98       	mov	r8,r4
8001bf2e:	e0 a0 09 ac 	rcall	8001d286 <__avr32_f64_cmp_ge>
8001bf32:	c1 70       	breq	8001bf60 <_strtod_r+0xaf4>
8001bf34:	0a 9b       	mov	r11,r5
8001bf36:	08 9a       	mov	r10,r4
8001bf38:	fe b0 c6 7c 	rcall	80014c30 <__avr32_f64_to_u32>
8001bf3c:	f9 bc 00 01 	moveq	r12,1
8001bf40:	fe b0 c6 8d 	rcall	80014c5a <__avr32_u32_to_f64>
8001bf44:	40 3e       	lddsp	lr,sp[0xc]
8001bf46:	16 95       	mov	r5,r11
8001bf48:	14 94       	mov	r4,r10
8001bf4a:	0a 9a       	mov	r10,r5
8001bf4c:	08 98       	mov	r8,r4
8001bf4e:	ee 1a 80 00 	eorh	r10,0x8000
8001bf52:	58 0e       	cp.w	lr,0
8001bf54:	f4 09 17 00 	moveq	r9,r10
8001bf58:	ea 09 17 10 	movne	r9,r5
8001bf5c:	fa e9 00 50 	st.d	sp[80],r8
8001bf60:	41 49       	lddsp	r9,sp[0x50]
8001bf62:	fc 18 06 b0 	movh	r8,0x6b0
8001bf66:	40 5c       	lddsp	r12,sp[0x14]
8001bf68:	f2 08 00 08 	add	r8,r9,r8
8001bf6c:	18 18       	sub	r8,r12
8001bf6e:	51 48       	stdsp	sp[0x50],r8
8001bf70:	fa ea 00 50 	ld.d	r10,sp[80]
8001bf74:	fa eb 00 24 	st.d	sp[36],r10
8001bf78:	fa ea 00 48 	ld.d	r10,sp[72]
8001bf7c:	fe b0 f4 74 	rcall	8001a864 <__ulp>
8001bf80:	14 98       	mov	r8,r10
8001bf82:	16 99       	mov	r9,r11
8001bf84:	fa ea 00 24 	ld.d	r10,sp[36]
8001bf88:	fe b0 c5 6a 	rcall	80014a5c <__avr32_f64_mul>
8001bf8c:	14 98       	mov	r8,r10
8001bf8e:	16 99       	mov	r9,r11
8001bf90:	fa ea 00 48 	ld.d	r10,sp[72]
8001bf94:	e0 a0 08 de 	rcall	8001d150 <__avr32_f64_add>
8001bf98:	ee eb 00 00 	st.d	r7[0],r10
8001bf9c:	41 2a       	lddsp	r10,sp[0x48]
8001bf9e:	50 9a       	stdsp	sp[0x24],r10
8001bfa0:	40 19       	lddsp	r9,sp[0x4]
8001bfa2:	58 09       	cp.w	r9,0
8001bfa4:	c4 01       	brne	8001c024 <_strtod_r+0xbb8>
8001bfa6:	14 98       	mov	r8,r10
8001bfa8:	40 5e       	lddsp	lr,sp[0x14]
8001bfaa:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001bfae:	10 3e       	cp.w	lr,r8
8001bfb0:	c3 a1       	brne	8001c024 <_strtod_r+0xbb8>
8001bfb2:	0a 9b       	mov	r11,r5
8001bfb4:	08 9a       	mov	r10,r4
8001bfb6:	fe b0 c6 3f 	rcall	80014c34 <__avr32_f64_to_s32>
8001bfba:	fe b0 c6 54 	rcall	80014c62 <__avr32_s32_to_f64>
8001bfbe:	14 98       	mov	r8,r10
8001bfc0:	16 99       	mov	r9,r11
8001bfc2:	08 9a       	mov	r10,r4
8001bfc4:	0a 9b       	mov	r11,r5
8001bfc6:	e0 a0 07 f7 	rcall	8001cfb4 <__avr32_f64_sub>
8001bfca:	40 3c       	lddsp	r12,sp[0xc]
8001bfcc:	14 94       	mov	r4,r10
8001bfce:	16 95       	mov	r5,r11
8001bfd0:	58 0c       	cp.w	r12,0
8001bfd2:	c0 81       	brne	8001bfe2 <_strtod_r+0xb76>
8001bfd4:	41 38       	lddsp	r8,sp[0x4c]
8001bfd6:	58 08       	cp.w	r8,0
8001bfd8:	c0 51       	brne	8001bfe2 <_strtod_r+0xb76>
8001bfda:	40 99       	lddsp	r9,sp[0x24]
8001bfdc:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8001bfe0:	c1 70       	breq	8001c00e <_strtod_r+0xba2>
8001bfe2:	e0 68 35 95 	mov	r8,13717
8001bfe6:	ea 18 94 a0 	orh	r8,0x94a0
8001bfea:	e0 69 ff ff 	mov	r9,65535
8001bfee:	ea 19 3f df 	orh	r9,0x3fdf
8001bff2:	08 9a       	mov	r10,r4
8001bff4:	0a 9b       	mov	r11,r5
8001bff6:	e0 a0 09 7c 	rcall	8001d2ee <__avr32_f64_cmp_lt>
8001bffa:	c4 21       	brne	8001c07e <_strtod_r+0xc12>
8001bffc:	08 98       	mov	r8,r4
8001bffe:	0a 99       	mov	r9,r5
8001c000:	e0 6a e5 35 	mov	r10,58677
8001c004:	ea 1a 35 af 	orh	r10,0x35af
8001c008:	fc 1b 3f e0 	movh	r11,0x3fe0
8001c00c:	c0 98       	rjmp	8001c01e <_strtod_r+0xbb2>
8001c00e:	e0 68 35 95 	mov	r8,13717
8001c012:	ea 18 94 a0 	orh	r8,0x94a0
8001c016:	e0 69 ff ff 	mov	r9,65535
8001c01a:	ea 19 3f cf 	orh	r9,0x3fcf
8001c01e:	e0 a0 09 68 	rcall	8001d2ee <__avr32_f64_cmp_lt>
8001c022:	c2 e1       	brne	8001c07e <_strtod_r+0xc12>
8001c024:	41 7b       	lddsp	r11,sp[0x5c]
8001c026:	0c 9c       	mov	r12,r6
8001c028:	fe b0 f4 f4 	rcall	8001aa10 <_Bfree>
8001c02c:	00 9b       	mov	r11,r0
8001c02e:	0c 9c       	mov	r12,r6
8001c030:	fe b0 f4 f0 	rcall	8001aa10 <_Bfree>
8001c034:	04 9b       	mov	r11,r2
8001c036:	0c 9c       	mov	r12,r6
8001c038:	fe b0 f4 ec 	rcall	8001aa10 <_Bfree>
8001c03c:	06 9b       	mov	r11,r3
8001c03e:	0c 9c       	mov	r12,r6
8001c040:	fe b0 f4 e8 	rcall	8001aa10 <_Bfree>
8001c044:	fe 9f fd 7f 	bral	8001bb42 <_strtod_r+0x6d6>
8001c048:	40 18       	lddsp	r8,sp[0x4]
8001c04a:	58 08       	cp.w	r8,0
8001c04c:	c1 a0       	breq	8001c080 <_strtod_r+0xc14>
8001c04e:	fc 19 39 50 	movh	r9,0x3950
8001c052:	fa ea 00 48 	ld.d	r10,sp[72]
8001c056:	fa c8 ff c0 	sub	r8,sp,-64
8001c05a:	91 09       	st.w	r8[0x0],r9
8001c05c:	30 09       	mov	r9,0
8001c05e:	91 19       	st.w	r8[0x4],r9
8001c060:	fa e8 00 40 	ld.d	r8,sp[64]
8001c064:	fe b0 c4 fc 	rcall	80014a5c <__avr32_f64_mul>
8001c068:	ee eb 00 00 	st.d	r7[0],r10
8001c06c:	41 28       	lddsp	r8,sp[0x48]
8001c06e:	58 08       	cp.w	r8,0
8001c070:	c0 81       	brne	8001c080 <_strtod_r+0xc14>
8001c072:	41 38       	lddsp	r8,sp[0x4c]
8001c074:	58 08       	cp.w	r8,0
8001c076:	c0 51       	brne	8001c080 <_strtod_r+0xc14>
8001c078:	32 28       	mov	r8,34
8001c07a:	8d 38       	st.w	r6[0xc],r8
8001c07c:	c0 28       	rjmp	8001c080 <_strtod_r+0xc14>
8001c07e:	06 95       	mov	r5,r3
8001c080:	41 7b       	lddsp	r11,sp[0x5c]
8001c082:	0c 9c       	mov	r12,r6
8001c084:	fe b0 f4 c6 	rcall	8001aa10 <_Bfree>
8001c088:	00 9b       	mov	r11,r0
8001c08a:	0c 9c       	mov	r12,r6
8001c08c:	fe b0 f4 c2 	rcall	8001aa10 <_Bfree>
8001c090:	04 9b       	mov	r11,r2
8001c092:	0c 9c       	mov	r12,r6
8001c094:	fe b0 f4 be 	rcall	8001aa10 <_Bfree>
8001c098:	40 7b       	lddsp	r11,sp[0x1c]
8001c09a:	0c 9c       	mov	r12,r6
8001c09c:	fe b0 f4 ba 	rcall	8001aa10 <_Bfree>
8001c0a0:	0a 9b       	mov	r11,r5
8001c0a2:	0c 9c       	mov	r12,r6
8001c0a4:	fe b0 f4 b6 	rcall	8001aa10 <_Bfree>
8001c0a8:	40 b1       	lddsp	r1,sp[0x2c]
8001c0aa:	58 01       	cp.w	r1,0
8001c0ac:	fb f8 10 18 	ld.wne	r8,sp[0x60]
8001c0b0:	e3 f8 1a 00 	st.wne	r1[0x0],r8
8001c0b4:	40 8e       	lddsp	lr,sp[0x20]
8001c0b6:	41 28       	lddsp	r8,sp[0x48]
8001c0b8:	41 3a       	lddsp	r10,sp[0x4c]
8001c0ba:	10 99       	mov	r9,r8
8001c0bc:	ee 19 80 00 	eorh	r9,0x8000
8001c0c0:	58 0e       	cp.w	lr,0
8001c0c2:	f0 0b 17 00 	moveq	r11,r8
8001c0c6:	f2 0b 17 10 	movne	r11,r9
8001c0ca:	2e 5d       	sub	sp,-108
8001c0cc:	d8 32       	popm	r0-r7,pc
8001c0ce:	d7 03       	nop

8001c0d0 <_strtol_r>:
8001c0d0:	d4 31       	pushm	r0-r7,lr
8001c0d2:	20 3d       	sub	sp,12
8001c0d4:	32 c8       	mov	r8,44
8001c0d6:	50 2c       	stdsp	sp[0x8],r12
8001c0d8:	70 01       	ld.w	r1,r8[0x0]
8001c0da:	16 98       	mov	r8,r11
8001c0dc:	11 3e       	ld.ub	lr,r8++
8001c0de:	e2 0e 07 06 	ld.ub	r6,r1[lr]
8001c0e2:	e2 16 00 08 	andl	r6,0x8,COH
8001c0e6:	cf b1       	brne	8001c0dc <_strtol_r+0xc>
8001c0e8:	e0 4e 00 2d 	cp.w	lr,45
8001c0ec:	c0 41       	brne	8001c0f4 <_strtol_r+0x24>
8001c0ee:	11 3e       	ld.ub	lr,r8++
8001c0f0:	30 16       	mov	r6,1
8001c0f2:	c0 58       	rjmp	8001c0fc <_strtol_r+0x2c>
8001c0f4:	e0 4e 00 2b 	cp.w	lr,43
8001c0f8:	c0 21       	brne	8001c0fc <_strtol_r+0x2c>
8001c0fa:	11 3e       	ld.ub	lr,r8++
8001c0fc:	58 09       	cp.w	r9,0
8001c0fe:	5f 0c       	sreq	r12
8001c100:	59 09       	cp.w	r9,16
8001c102:	5f 05       	sreq	r5
8001c104:	30 07       	mov	r7,0
8001c106:	f9 e5 10 05 	or	r5,r12,r5
8001c10a:	ee 05 18 00 	cp.b	r5,r7
8001c10e:	c1 e0       	breq	8001c14a <_strtol_r+0x7a>
8001c110:	e0 4e 00 30 	cp.w	lr,48
8001c114:	c1 31       	brne	8001c13a <_strtol_r+0x6a>
8001c116:	11 85       	ld.ub	r5,r8[0x0]
8001c118:	35 84       	mov	r4,88
8001c11a:	37 83       	mov	r3,120
8001c11c:	e8 05 18 00 	cp.b	r5,r4
8001c120:	5f 04       	sreq	r4
8001c122:	e6 05 18 00 	cp.b	r5,r3
8001c126:	5f 05       	sreq	r5
8001c128:	e9 e5 10 05 	or	r5,r4,r5
8001c12c:	ee 05 18 00 	cp.b	r5,r7
8001c130:	c0 50       	breq	8001c13a <_strtol_r+0x6a>
8001c132:	11 9e       	ld.ub	lr,r8[0x1]
8001c134:	31 09       	mov	r9,16
8001c136:	2f e8       	sub	r8,-2
8001c138:	c0 98       	rjmp	8001c14a <_strtol_r+0x7a>
8001c13a:	58 0c       	cp.w	r12,0
8001c13c:	c0 70       	breq	8001c14a <_strtol_r+0x7a>
8001c13e:	e0 4e 00 30 	cp.w	lr,48
8001c142:	f9 b9 00 08 	moveq	r9,8
8001c146:	f9 b9 01 0a 	movne	r9,10
8001c14a:	e0 6c ff ff 	mov	r12,65535
8001c14e:	ea 1c 7f ff 	orh	r12,0x7fff
8001c152:	30 07       	mov	r7,0
8001c154:	fc 15 80 00 	movh	r5,0x8000
8001c158:	0e 93       	mov	r3,r7
8001c15a:	0e 36       	cp.w	r6,r7
8001c15c:	f8 05 17 00 	moveq	r5,r12
8001c160:	0e 9c       	mov	r12,r7
8001c162:	ea 09 0d 04 	divu	r4,r5,r9
8001c166:	08 92       	mov	r2,r4
8001c168:	50 05       	stdsp	sp[0x0],r5
8001c16a:	e2 0e 07 04 	ld.ub	r4,r1[lr]
8001c16e:	e1 d4 c0 01 	bfextu	r0,r4,0x0,0x1
8001c172:	f9 b0 01 37 	movne	r0,55
8001c176:	f9 b0 00 57 	moveq	r0,87
8001c17a:	50 10       	stdsp	sp[0x4],r0
8001c17c:	fc c5 00 30 	sub	r5,lr,48
8001c180:	08 90       	mov	r0,r4
8001c182:	e2 10 00 04 	andl	r0,0x4,COH
8001c186:	c0 81       	brne	8001c196 <_strtol_r+0xc6>
8001c188:	40 10       	lddsp	r0,sp[0x4]
8001c18a:	e9 d4 c0 02 	bfextu	r4,r4,0x0,0x2
8001c18e:	fc 00 01 05 	sub	r5,lr,r0
8001c192:	58 04       	cp.w	r4,0
8001c194:	c1 c0       	breq	8001c1cc <_strtol_r+0xfc>
8001c196:	12 35       	cp.w	r5,r9
8001c198:	c1 a4       	brge	8001c1cc <_strtol_r+0xfc>
8001c19a:	04 3c       	cp.w	r12,r2
8001c19c:	5f be       	srhi	lr
8001c19e:	fd e7 13 fe 	or	lr,lr,r7>>0x1f
8001c1a2:	e6 0e 18 00 	cp.b	lr,r3
8001c1a6:	c1 01       	brne	8001c1c6 <_strtol_r+0xf6>
8001c1a8:	04 3c       	cp.w	r12,r2
8001c1aa:	5f 0e       	sreq	lr
8001c1ac:	40 07       	lddsp	r7,sp[0x0]
8001c1ae:	0e 35       	cp.w	r5,r7
8001c1b0:	5f 97       	srgt	r7
8001c1b2:	ef ee 00 0e 	and	lr,r7,lr
8001c1b6:	e6 0e 18 00 	cp.b	lr,r3
8001c1ba:	c0 61       	brne	8001c1c6 <_strtol_r+0xf6>
8001c1bc:	b3 3c       	mul	r12,r9
8001c1be:	30 17       	mov	r7,1
8001c1c0:	ea 0c 00 0c 	add	r12,r5,r12
8001c1c4:	c0 28       	rjmp	8001c1c8 <_strtol_r+0xf8>
8001c1c6:	3f f7       	mov	r7,-1
8001c1c8:	11 3e       	ld.ub	lr,r8++
8001c1ca:	cd 0b       	rjmp	8001c16a <_strtol_r+0x9a>
8001c1cc:	5b f7       	cp.w	r7,-1
8001c1ce:	c0 e1       	brne	8001c1ea <_strtol_r+0x11a>
8001c1d0:	e0 69 ff ff 	mov	r9,65535
8001c1d4:	ea 19 7f ff 	orh	r9,0x7fff
8001c1d8:	fc 1c 80 00 	movh	r12,0x8000
8001c1dc:	40 20       	lddsp	r0,sp[0x8]
8001c1de:	58 06       	cp.w	r6,0
8001c1e0:	f2 0c 17 00 	moveq	r12,r9
8001c1e4:	32 29       	mov	r9,34
8001c1e6:	81 39       	st.w	r0[0xc],r9
8001c1e8:	c0 48       	rjmp	8001c1f0 <_strtol_r+0x120>
8001c1ea:	58 06       	cp.w	r6,0
8001c1ec:	fb bc 01 00 	rsubne	r12,0
8001c1f0:	58 0a       	cp.w	r10,0
8001c1f2:	c0 60       	breq	8001c1fe <_strtol_r+0x12e>
8001c1f4:	20 18       	sub	r8,1
8001c1f6:	58 07       	cp.w	r7,0
8001c1f8:	f0 0b 17 10 	movne	r11,r8
8001c1fc:	95 0b       	st.w	r10[0x0],r11
8001c1fe:	2f dd       	sub	sp,-12
8001c200:	d8 32       	popm	r0-r7,pc
8001c202:	d7 03       	nop

8001c204 <_strtoll_r>:
8001c204:	d4 31       	pushm	r0-r7,lr
8001c206:	20 8d       	sub	sp,32
8001c208:	32 c8       	mov	r8,44
8001c20a:	16 93       	mov	r3,r11
8001c20c:	70 08       	ld.w	r8,r8[0x0]
8001c20e:	50 7c       	stdsp	sp[0x1c],r12
8001c210:	50 2a       	stdsp	sp[0x8],r10
8001c212:	12 95       	mov	r5,r9
8001c214:	50 18       	stdsp	sp[0x4],r8
8001c216:	16 97       	mov	r7,r11
8001c218:	0f 36       	ld.ub	r6,r7++
8001c21a:	40 1a       	lddsp	r10,sp[0x4]
8001c21c:	f4 06 07 04 	ld.ub	r4,r10[r6]
8001c220:	e2 14 00 08 	andl	r4,0x8,COH
8001c224:	cf a1       	brne	8001c218 <_strtoll_r+0x14>
8001c226:	e0 46 00 2d 	cp.w	r6,45
8001c22a:	c0 41       	brne	8001c232 <_strtoll_r+0x2e>
8001c22c:	0f 36       	ld.ub	r6,r7++
8001c22e:	30 14       	mov	r4,1
8001c230:	c0 58       	rjmp	8001c23a <_strtoll_r+0x36>
8001c232:	e0 46 00 2b 	cp.w	r6,43
8001c236:	c0 21       	brne	8001c23a <_strtoll_r+0x36>
8001c238:	0f 36       	ld.ub	r6,r7++
8001c23a:	58 05       	cp.w	r5,0
8001c23c:	5f 08       	sreq	r8
8001c23e:	59 05       	cp.w	r5,16
8001c240:	5f 0a       	sreq	r10
8001c242:	30 09       	mov	r9,0
8001c244:	f1 ea 10 0a 	or	r10,r8,r10
8001c248:	f2 0a 18 00 	cp.b	r10,r9
8001c24c:	c1 d0       	breq	8001c286 <_strtoll_r+0x82>
8001c24e:	e0 46 00 30 	cp.w	r6,48
8001c252:	c1 21       	brne	8001c276 <_strtoll_r+0x72>
8001c254:	0f 8a       	ld.ub	r10,r7[0x0]
8001c256:	35 8b       	mov	r11,88
8001c258:	37 8c       	mov	r12,120
8001c25a:	f6 0a 18 00 	cp.b	r10,r11
8001c25e:	5f 0b       	sreq	r11
8001c260:	f8 0a 18 00 	cp.b	r10,r12
8001c264:	5f 0a       	sreq	r10
8001c266:	14 4b       	or	r11,r10
8001c268:	f2 0b 18 00 	cp.b	r11,r9
8001c26c:	c0 50       	breq	8001c276 <_strtoll_r+0x72>
8001c26e:	0f 96       	ld.ub	r6,r7[0x1]
8001c270:	31 05       	mov	r5,16
8001c272:	2f e7       	sub	r7,-2
8001c274:	c0 98       	rjmp	8001c286 <_strtoll_r+0x82>
8001c276:	58 08       	cp.w	r8,0
8001c278:	c0 70       	breq	8001c286 <_strtoll_r+0x82>
8001c27a:	e0 46 00 30 	cp.w	r6,48
8001c27e:	f9 b5 00 08 	moveq	r5,8
8001c282:	f9 b5 01 0a 	movne	r5,10
8001c286:	58 04       	cp.w	r4,0
8001c288:	c0 71       	brne	8001c296 <_strtoll_r+0x92>
8001c28a:	3f f0       	mov	r0,-1
8001c28c:	e0 61 ff ff 	mov	r1,65535
8001c290:	ea 11 7f ff 	orh	r1,0x7fff
8001c294:	c0 48       	rjmp	8001c29c <_strtoll_r+0x98>
8001c296:	30 00       	mov	r0,0
8001c298:	fc 11 80 00 	movh	r1,0x8000
8001c29c:	ea 09 14 1f 	asr	r9,r5,0x1f
8001c2a0:	0a 98       	mov	r8,r5
8001c2a2:	50 09       	stdsp	sp[0x0],r9
8001c2a4:	00 9a       	mov	r10,r0
8001c2a6:	02 9b       	mov	r11,r1
8001c2a8:	e0 a0 0a 29 	rcall	8001d6fa <__avr32_umod64>
8001c2ac:	40 09       	lddsp	r9,sp[0x0]
8001c2ae:	50 5a       	stdsp	sp[0x14],r10
8001c2b0:	0a 98       	mov	r8,r5
8001c2b2:	00 9a       	mov	r10,r0
8001c2b4:	02 9b       	mov	r11,r1
8001c2b6:	fe b0 c5 46 	rcall	80014d42 <__avr32_udiv64>
8001c2ba:	06 9c       	mov	r12,r3
8001c2bc:	14 98       	mov	r8,r10
8001c2be:	16 99       	mov	r9,r11
8001c2c0:	30 0a       	mov	r10,0
8001c2c2:	30 00       	mov	r0,0
8001c2c4:	30 01       	mov	r1,0
8001c2c6:	14 9e       	mov	lr,r10
8001c2c8:	10 92       	mov	r2,r8
8001c2ca:	12 93       	mov	r3,r9
8001c2cc:	40 19       	lddsp	r9,sp[0x4]
8001c2ce:	f2 06 07 0b 	ld.ub	r11,r9[r6]
8001c2d2:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
8001c2d6:	f9 b9 01 37 	movne	r9,55
8001c2da:	f9 b9 00 57 	moveq	r9,87
8001c2de:	50 69       	stdsp	sp[0x18],r9
8001c2e0:	ec c8 00 30 	sub	r8,r6,48
8001c2e4:	ed bb 00 02 	bld	r11,0x2
8001c2e8:	c0 80       	breq	8001c2f8 <_strtoll_r+0xf4>
8001c2ea:	40 69       	lddsp	r9,sp[0x18]
8001c2ec:	f7 db c0 02 	bfextu	r11,r11,0x0,0x2
8001c2f0:	ec 09 01 08 	sub	r8,r6,r9
8001c2f4:	58 0b       	cp.w	r11,0
8001c2f6:	c2 e0       	breq	8001c352 <_strtoll_r+0x14e>
8001c2f8:	0a 38       	cp.w	r8,r5
8001c2fa:	c2 c4       	brge	8001c352 <_strtoll_r+0x14e>
8001c2fc:	04 30       	cp.w	r0,r2
8001c2fe:	e6 01 13 00 	cpc	r1,r3
8001c302:	5f b9       	srhi	r9
8001c304:	f3 ea 13 fa 	or	r10,r9,r10>>0x1f
8001c308:	fc 0a 18 00 	cp.b	r10,lr
8001c30c:	c2 01       	brne	8001c34c <_strtoll_r+0x148>
8001c30e:	04 30       	cp.w	r0,r2
8001c310:	e6 01 13 00 	cpc	r1,r3
8001c314:	5f 09       	sreq	r9
8001c316:	40 56       	lddsp	r6,sp[0x14]
8001c318:	0c 38       	cp.w	r8,r6
8001c31a:	5f 9a       	srgt	r10
8001c31c:	f5 e9 00 09 	and	r9,r10,r9
8001c320:	fc 09 18 00 	cp.b	r9,lr
8001c324:	c1 41       	brne	8001c34c <_strtoll_r+0x148>
8001c326:	e0 05 06 4a 	mulu.d	r10,r0,r5
8001c32a:	ea 01 02 49 	mul	r9,r5,r1
8001c32e:	50 48       	stdsp	sp[0x10],r8
8001c330:	40 06       	lddsp	r6,sp[0x0]
8001c332:	bf 58       	asr	r8,0x1f
8001c334:	ec 00 03 49 	mac	r9,r6,r0
8001c338:	50 38       	stdsp	sp[0xc],r8
8001c33a:	f2 0b 00 0b 	add	r11,r9,r11
8001c33e:	fa e0 00 0c 	ld.d	r0,sp[12]
8001c342:	14 00       	add	r0,r10
8001c344:	e2 0b 00 41 	adc	r1,r1,r11
8001c348:	30 1a       	mov	r10,1
8001c34a:	c0 28       	rjmp	8001c34e <_strtoll_r+0x14a>
8001c34c:	3f fa       	mov	r10,-1
8001c34e:	0f 36       	ld.ub	r6,r7++
8001c350:	cb eb       	rjmp	8001c2cc <_strtoll_r+0xc8>
8001c352:	18 93       	mov	r3,r12
8001c354:	5b fa       	cp.w	r10,-1
8001c356:	c1 11       	brne	8001c378 <_strtoll_r+0x174>
8001c358:	58 04       	cp.w	r4,0
8001c35a:	c0 71       	brne	8001c368 <_strtoll_r+0x164>
8001c35c:	3f f0       	mov	r0,-1
8001c35e:	e0 61 ff ff 	mov	r1,65535
8001c362:	ea 11 7f ff 	orh	r1,0x7fff
8001c366:	c0 48       	rjmp	8001c36e <_strtoll_r+0x16a>
8001c368:	30 00       	mov	r0,0
8001c36a:	fc 11 80 00 	movh	r1,0x8000
8001c36e:	32 28       	mov	r8,34
8001c370:	40 76       	lddsp	r6,sp[0x1c]
8001c372:	8d 38       	st.w	r6[0xc],r8
8001c374:	c0 a8       	rjmp	8001c388 <_strtoll_r+0x184>
8001c376:	d7 03       	nop
8001c378:	58 04       	cp.w	r4,0
8001c37a:	c0 70       	breq	8001c388 <_strtoll_r+0x184>
8001c37c:	30 08       	mov	r8,0
8001c37e:	30 09       	mov	r9,0
8001c380:	f0 00 01 00 	sub	r0,r8,r0
8001c384:	f2 01 01 41 	sbc	r1,r9,r1
8001c388:	40 29       	lddsp	r9,sp[0x8]
8001c38a:	58 09       	cp.w	r9,0
8001c38c:	c0 60       	breq	8001c398 <_strtoll_r+0x194>
8001c38e:	20 17       	sub	r7,1
8001c390:	58 0a       	cp.w	r10,0
8001c392:	ee 03 17 10 	movne	r3,r7
8001c396:	93 03       	st.w	r9[0x0],r3
8001c398:	00 9a       	mov	r10,r0
8001c39a:	02 9b       	mov	r11,r1
8001c39c:	2f 8d       	sub	sp,-32
8001c39e:	d8 32       	popm	r0-r7,pc

8001c3a0 <_strtoul_r>:
8001c3a0:	d4 31       	pushm	r0-r7,lr
8001c3a2:	20 3d       	sub	sp,12
8001c3a4:	32 c8       	mov	r8,44
8001c3a6:	50 2c       	stdsp	sp[0x8],r12
8001c3a8:	70 01       	ld.w	r1,r8[0x0]
8001c3aa:	16 98       	mov	r8,r11
8001c3ac:	11 3e       	ld.ub	lr,r8++
8001c3ae:	e2 0e 07 05 	ld.ub	r5,r1[lr]
8001c3b2:	e2 15 00 08 	andl	r5,0x8,COH
8001c3b6:	cf b1       	brne	8001c3ac <_strtoul_r+0xc>
8001c3b8:	e0 4e 00 2d 	cp.w	lr,45
8001c3bc:	c0 41       	brne	8001c3c4 <_strtoul_r+0x24>
8001c3be:	11 3e       	ld.ub	lr,r8++
8001c3c0:	30 15       	mov	r5,1
8001c3c2:	c0 58       	rjmp	8001c3cc <_strtoul_r+0x2c>
8001c3c4:	e0 4e 00 2b 	cp.w	lr,43
8001c3c8:	c0 21       	brne	8001c3cc <_strtoul_r+0x2c>
8001c3ca:	11 3e       	ld.ub	lr,r8++
8001c3cc:	58 09       	cp.w	r9,0
8001c3ce:	5f 0c       	sreq	r12
8001c3d0:	59 09       	cp.w	r9,16
8001c3d2:	5f 06       	sreq	r6
8001c3d4:	30 07       	mov	r7,0
8001c3d6:	f9 e6 10 06 	or	r6,r12,r6
8001c3da:	ee 06 18 00 	cp.b	r6,r7
8001c3de:	c1 e0       	breq	8001c41a <_strtoul_r+0x7a>
8001c3e0:	e0 4e 00 30 	cp.w	lr,48
8001c3e4:	c1 31       	brne	8001c40a <_strtoul_r+0x6a>
8001c3e6:	11 86       	ld.ub	r6,r8[0x0]
8001c3e8:	35 84       	mov	r4,88
8001c3ea:	37 83       	mov	r3,120
8001c3ec:	e8 06 18 00 	cp.b	r6,r4
8001c3f0:	5f 04       	sreq	r4
8001c3f2:	e6 06 18 00 	cp.b	r6,r3
8001c3f6:	5f 06       	sreq	r6
8001c3f8:	e9 e6 10 06 	or	r6,r4,r6
8001c3fc:	ee 06 18 00 	cp.b	r6,r7
8001c400:	c0 50       	breq	8001c40a <_strtoul_r+0x6a>
8001c402:	11 9e       	ld.ub	lr,r8[0x1]
8001c404:	31 09       	mov	r9,16
8001c406:	2f e8       	sub	r8,-2
8001c408:	c0 98       	rjmp	8001c41a <_strtoul_r+0x7a>
8001c40a:	58 0c       	cp.w	r12,0
8001c40c:	c0 70       	breq	8001c41a <_strtoul_r+0x7a>
8001c40e:	e0 4e 00 30 	cp.w	lr,48
8001c412:	f9 b9 00 08 	moveq	r9,8
8001c416:	f9 b9 01 0a 	movne	r9,10
8001c41a:	3f f3       	mov	r3,-1
8001c41c:	e6 09 0d 02 	divu	r2,r3,r9
8001c420:	30 07       	mov	r7,0
8001c422:	50 03       	stdsp	sp[0x0],r3
8001c424:	0e 9c       	mov	r12,r7
8001c426:	0e 93       	mov	r3,r7
8001c428:	e2 0e 07 04 	ld.ub	r4,r1[lr]
8001c42c:	e1 d4 c0 01 	bfextu	r0,r4,0x0,0x1
8001c430:	f9 b0 01 37 	movne	r0,55
8001c434:	f9 b0 00 57 	moveq	r0,87
8001c438:	50 10       	stdsp	sp[0x4],r0
8001c43a:	fc c6 00 30 	sub	r6,lr,48
8001c43e:	08 90       	mov	r0,r4
8001c440:	e2 10 00 04 	andl	r0,0x4,COH
8001c444:	c0 81       	brne	8001c454 <_strtoul_r+0xb4>
8001c446:	40 10       	lddsp	r0,sp[0x4]
8001c448:	e9 d4 c0 02 	bfextu	r4,r4,0x0,0x2
8001c44c:	fc 00 01 06 	sub	r6,lr,r0
8001c450:	58 04       	cp.w	r4,0
8001c452:	c1 c0       	breq	8001c48a <_strtoul_r+0xea>
8001c454:	12 36       	cp.w	r6,r9
8001c456:	c1 a4       	brge	8001c48a <_strtoul_r+0xea>
8001c458:	04 3c       	cp.w	r12,r2
8001c45a:	5f be       	srhi	lr
8001c45c:	fd e7 13 fe 	or	lr,lr,r7>>0x1f
8001c460:	e6 0e 18 00 	cp.b	lr,r3
8001c464:	c1 01       	brne	8001c484 <_strtoul_r+0xe4>
8001c466:	04 3c       	cp.w	r12,r2
8001c468:	5f 0e       	sreq	lr
8001c46a:	40 07       	lddsp	r7,sp[0x0]
8001c46c:	0e 36       	cp.w	r6,r7
8001c46e:	5f 97       	srgt	r7
8001c470:	ef ee 00 0e 	and	lr,r7,lr
8001c474:	e6 0e 18 00 	cp.b	lr,r3
8001c478:	c0 61       	brne	8001c484 <_strtoul_r+0xe4>
8001c47a:	b3 3c       	mul	r12,r9
8001c47c:	30 17       	mov	r7,1
8001c47e:	ec 0c 00 0c 	add	r12,r6,r12
8001c482:	c0 28       	rjmp	8001c486 <_strtoul_r+0xe6>
8001c484:	3f f7       	mov	r7,-1
8001c486:	11 3e       	ld.ub	lr,r8++
8001c488:	cd 0b       	rjmp	8001c428 <_strtoul_r+0x88>
8001c48a:	5b f7       	cp.w	r7,-1
8001c48c:	c0 61       	brne	8001c498 <_strtoul_r+0xf8>
8001c48e:	32 29       	mov	r9,34
8001c490:	40 20       	lddsp	r0,sp[0x8]
8001c492:	0e 9c       	mov	r12,r7
8001c494:	81 39       	st.w	r0[0xc],r9
8001c496:	c0 48       	rjmp	8001c49e <_strtoul_r+0xfe>
8001c498:	58 05       	cp.w	r5,0
8001c49a:	fb bc 01 00 	rsubne	r12,0
8001c49e:	58 0a       	cp.w	r10,0
8001c4a0:	c0 60       	breq	8001c4ac <_strtoul_r+0x10c>
8001c4a2:	20 18       	sub	r8,1
8001c4a4:	58 07       	cp.w	r7,0
8001c4a6:	f0 0b 17 10 	movne	r11,r8
8001c4aa:	95 0b       	st.w	r10[0x0],r11
8001c4ac:	2f dd       	sub	sp,-12
8001c4ae:	d8 32       	popm	r0-r7,pc

8001c4b0 <_strtoull_r>:
8001c4b0:	d4 31       	pushm	r0-r7,lr
8001c4b2:	20 9d       	sub	sp,36
8001c4b4:	32 c8       	mov	r8,44
8001c4b6:	16 97       	mov	r7,r11
8001c4b8:	70 08       	ld.w	r8,r8[0x0]
8001c4ba:	50 8c       	stdsp	sp[0x20],r12
8001c4bc:	50 5a       	stdsp	sp[0x14],r10
8001c4be:	12 94       	mov	r4,r9
8001c4c0:	50 48       	stdsp	sp[0x10],r8
8001c4c2:	16 96       	mov	r6,r11
8001c4c4:	0d 35       	ld.ub	r5,r6++
8001c4c6:	40 4e       	lddsp	lr,sp[0x10]
8001c4c8:	fc 05 07 02 	ld.ub	r2,lr[r5]
8001c4cc:	e2 12 00 08 	andl	r2,0x8,COH
8001c4d0:	cf a1       	brne	8001c4c4 <_strtoull_r+0x14>
8001c4d2:	e0 45 00 2d 	cp.w	r5,45
8001c4d6:	c0 41       	brne	8001c4de <_strtoull_r+0x2e>
8001c4d8:	0d 35       	ld.ub	r5,r6++
8001c4da:	30 12       	mov	r2,1
8001c4dc:	c0 58       	rjmp	8001c4e6 <_strtoull_r+0x36>
8001c4de:	e0 45 00 2b 	cp.w	r5,43
8001c4e2:	c0 21       	brne	8001c4e6 <_strtoull_r+0x36>
8001c4e4:	0d 35       	ld.ub	r5,r6++
8001c4e6:	58 04       	cp.w	r4,0
8001c4e8:	5f 08       	sreq	r8
8001c4ea:	59 04       	cp.w	r4,16
8001c4ec:	5f 0a       	sreq	r10
8001c4ee:	30 09       	mov	r9,0
8001c4f0:	f1 ea 10 0a 	or	r10,r8,r10
8001c4f4:	f2 0a 18 00 	cp.b	r10,r9
8001c4f8:	c1 d0       	breq	8001c532 <_strtoull_r+0x82>
8001c4fa:	e0 45 00 30 	cp.w	r5,48
8001c4fe:	c1 21       	brne	8001c522 <_strtoull_r+0x72>
8001c500:	0d 8a       	ld.ub	r10,r6[0x0]
8001c502:	35 8b       	mov	r11,88
8001c504:	37 8c       	mov	r12,120
8001c506:	f6 0a 18 00 	cp.b	r10,r11
8001c50a:	5f 0b       	sreq	r11
8001c50c:	f8 0a 18 00 	cp.b	r10,r12
8001c510:	5f 0a       	sreq	r10
8001c512:	14 4b       	or	r11,r10
8001c514:	f2 0b 18 00 	cp.b	r11,r9
8001c518:	c0 50       	breq	8001c522 <_strtoull_r+0x72>
8001c51a:	0d 95       	ld.ub	r5,r6[0x1]
8001c51c:	31 04       	mov	r4,16
8001c51e:	2f e6       	sub	r6,-2
8001c520:	c0 98       	rjmp	8001c532 <_strtoull_r+0x82>
8001c522:	58 08       	cp.w	r8,0
8001c524:	c0 70       	breq	8001c532 <_strtoull_r+0x82>
8001c526:	e0 45 00 30 	cp.w	r5,48
8001c52a:	f9 b4 00 08 	moveq	r4,8
8001c52e:	f9 b4 01 0a 	movne	r4,10
8001c532:	e8 03 14 1f 	asr	r3,r4,0x1f
8001c536:	08 98       	mov	r8,r4
8001c538:	06 99       	mov	r9,r3
8001c53a:	3f fa       	mov	r10,-1
8001c53c:	3f fb       	mov	r11,-1
8001c53e:	fe b0 c4 02 	rcall	80014d42 <__avr32_udiv64>
8001c542:	06 99       	mov	r9,r3
8001c544:	50 2b       	stdsp	sp[0x8],r11
8001c546:	50 3a       	stdsp	sp[0xc],r10
8001c548:	08 98       	mov	r8,r4
8001c54a:	3f fa       	mov	r10,-1
8001c54c:	3f fb       	mov	r11,-1
8001c54e:	e0 a0 08 d6 	rcall	8001d6fa <__avr32_umod64>
8001c552:	30 0b       	mov	r11,0
8001c554:	30 08       	mov	r8,0
8001c556:	30 09       	mov	r9,0
8001c558:	40 41       	lddsp	r1,sp[0x10]
8001c55a:	e2 05 07 0e 	ld.ub	lr,r1[r5]
8001c55e:	e1 de c0 01 	bfextu	r0,lr,0x0,0x1
8001c562:	ea cc 00 30 	sub	r12,r5,48
8001c566:	58 00       	cp.w	r0,0
8001c568:	f9 b1 01 37 	movne	r1,55
8001c56c:	f9 b1 00 57 	moveq	r1,87
8001c570:	1c 90       	mov	r0,lr
8001c572:	e2 10 00 04 	andl	r0,0x4,COH
8001c576:	c0 61       	brne	8001c582 <_strtoull_r+0xd2>
8001c578:	ea 01 01 0c 	sub	r12,r5,r1
8001c57c:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
8001c580:	c3 70       	breq	8001c5ee <_strtoull_r+0x13e>
8001c582:	08 3c       	cp.w	r12,r4
8001c584:	c3 54       	brge	8001c5ee <_strtoull_r+0x13e>
8001c586:	fa e0 00 08 	ld.d	r0,sp[8]
8001c58a:	00 38       	cp.w	r8,r0
8001c58c:	e2 09 13 00 	cpc	r9,r1
8001c590:	5f be       	srhi	lr
8001c592:	30 00       	mov	r0,0
8001c594:	fd eb 13 fb 	or	r11,lr,r11>>0x1f
8001c598:	e0 0b 18 00 	cp.b	r11,r0
8001c59c:	c2 61       	brne	8001c5e8 <_strtoull_r+0x138>
8001c59e:	fa e0 00 08 	ld.d	r0,sp[8]
8001c5a2:	14 3c       	cp.w	r12,r10
8001c5a4:	5f 9e       	srgt	lr
8001c5a6:	00 38       	cp.w	r8,r0
8001c5a8:	e2 09 13 00 	cpc	r9,r1
8001c5ac:	5f 0b       	sreq	r11
8001c5ae:	30 00       	mov	r0,0
8001c5b0:	fd eb 00 0b 	and	r11,lr,r11
8001c5b4:	e0 0b 18 00 	cp.b	r11,r0
8001c5b8:	c1 81       	brne	8001c5e8 <_strtoull_r+0x138>
8001c5ba:	f0 04 06 40 	mulu.d	r0,r8,r4
8001c5be:	e8 09 02 4b 	mul	r11,r4,r9
8001c5c2:	fa e1 00 00 	st.d	sp[0],r0
8001c5c6:	e6 08 03 4b 	mac	r11,r3,r8
8001c5ca:	f6 01 00 01 	add	r1,r11,r1
8001c5ce:	50 7c       	stdsp	sp[0x1c],r12
8001c5d0:	50 01       	stdsp	sp[0x0],r1
8001c5d2:	bf 5c       	asr	r12,0x1f
8001c5d4:	fa e0 00 00 	ld.d	r0,sp[0]
8001c5d8:	50 6c       	stdsp	sp[0x18],r12
8001c5da:	30 1b       	mov	r11,1
8001c5dc:	fa e8 00 18 	ld.d	r8,sp[24]
8001c5e0:	00 08       	add	r8,r0
8001c5e2:	f2 01 00 49 	adc	r9,r9,r1
8001c5e6:	c0 28       	rjmp	8001c5ea <_strtoull_r+0x13a>
8001c5e8:	3f fb       	mov	r11,-1
8001c5ea:	0d 35       	ld.ub	r5,r6++
8001c5ec:	cb 6b       	rjmp	8001c558 <_strtoull_r+0xa8>
8001c5ee:	5b fb       	cp.w	r11,-1
8001c5f0:	c0 71       	brne	8001c5fe <_strtoull_r+0x14e>
8001c5f2:	32 28       	mov	r8,34
8001c5f4:	40 80       	lddsp	r0,sp[0x20]
8001c5f6:	3f f9       	mov	r9,-1
8001c5f8:	81 38       	st.w	r0[0xc],r8
8001c5fa:	3f f8       	mov	r8,-1
8001c5fc:	c0 98       	rjmp	8001c60e <_strtoull_r+0x15e>
8001c5fe:	58 02       	cp.w	r2,0
8001c600:	c0 70       	breq	8001c60e <_strtoull_r+0x15e>
8001c602:	30 04       	mov	r4,0
8001c604:	30 05       	mov	r5,0
8001c606:	e8 08 01 08 	sub	r8,r4,r8
8001c60a:	ea 09 01 49 	sbc	r9,r5,r9
8001c60e:	40 5e       	lddsp	lr,sp[0x14]
8001c610:	58 0e       	cp.w	lr,0
8001c612:	c0 60       	breq	8001c61e <_strtoull_r+0x16e>
8001c614:	20 16       	sub	r6,1
8001c616:	58 0b       	cp.w	r11,0
8001c618:	ec 07 17 10 	movne	r7,r6
8001c61c:	9d 07       	st.w	lr[0x0],r7
8001c61e:	10 9a       	mov	r10,r8
8001c620:	12 9b       	mov	r11,r9
8001c622:	2f 7d       	sub	sp,-36
8001c624:	d8 32       	popm	r0-r7,pc
8001c626:	d7 03       	nop

8001c628 <__submore>:
8001c628:	d4 21       	pushm	r4-r7,lr
8001c62a:	16 97       	mov	r7,r11
8001c62c:	76 db       	ld.w	r11,r11[0x34]
8001c62e:	ee c8 ff bc 	sub	r8,r7,-68
8001c632:	10 3b       	cp.w	r11,r8
8001c634:	c1 71       	brne	8001c662 <__submore+0x3a>
8001c636:	e0 6b 04 00 	mov	r11,1024
8001c63a:	fe b0 c5 17 	rcall	80015068 <_malloc_r>
8001c63e:	c2 50       	breq	8001c688 <__submore+0x60>
8001c640:	e0 68 04 00 	mov	r8,1024
8001c644:	8f dc       	st.w	r7[0x34],r12
8001c646:	8f e8       	st.w	r7[0x38],r8
8001c648:	ef 38 00 46 	ld.ub	r8,r7[70]
8001c64c:	f8 cc fc 03 	sub	r12,r12,-1021
8001c650:	b8 a8       	st.b	r12[0x2],r8
8001c652:	ef 38 00 45 	ld.ub	r8,r7[69]
8001c656:	b8 98       	st.b	r12[0x1],r8
8001c658:	ef 38 00 44 	ld.ub	r8,r7[68]
8001c65c:	b8 88       	st.b	r12[0x0],r8
8001c65e:	8f 0c       	st.w	r7[0x0],r12
8001c660:	c1 38       	rjmp	8001c686 <__submore+0x5e>
8001c662:	6e e5       	ld.w	r5,r7[0x38]
8001c664:	ea 04 15 01 	lsl	r4,r5,0x1
8001c668:	08 9a       	mov	r10,r4
8001c66a:	fe b0 f4 6b 	rcall	8001af40 <_realloc_r>
8001c66e:	18 96       	mov	r6,r12
8001c670:	c0 c0       	breq	8001c688 <__submore+0x60>
8001c672:	0a 9a       	mov	r10,r5
8001c674:	18 9b       	mov	r11,r12
8001c676:	f8 05 00 05 	add	r5,r12,r5
8001c67a:	0a 9c       	mov	r12,r5
8001c67c:	fe b0 c7 1f 	rcall	800154ba <memcpy>
8001c680:	8f e4       	st.w	r7[0x38],r4
8001c682:	8f 05       	st.w	r7[0x0],r5
8001c684:	8f d6       	st.w	r7[0x34],r6
8001c686:	d8 2a       	popm	r4-r7,pc,r12=0
8001c688:	dc 2a       	popm	r4-r7,pc,r12=-1
8001c68a:	d7 03       	nop

8001c68c <_ungetc_r>:
8001c68c:	d4 21       	pushm	r4-r7,lr
8001c68e:	16 97       	mov	r7,r11
8001c690:	14 96       	mov	r6,r10
8001c692:	18 95       	mov	r5,r12
8001c694:	5b fb       	cp.w	r11,-1
8001c696:	c6 70       	breq	8001c764 <_ungetc_r+0xd8>
8001c698:	58 0c       	cp.w	r12,0
8001c69a:	c0 60       	breq	8001c6a6 <_ungetc_r+0x1a>
8001c69c:	78 68       	ld.w	r8,r12[0x18]
8001c69e:	58 08       	cp.w	r8,0
8001c6a0:	c0 31       	brne	8001c6a6 <_ungetc_r+0x1a>
8001c6a2:	fe b0 ec 39 	rcall	80019f14 <__sinit>
8001c6a6:	fe c8 c2 4a 	sub	r8,pc,-15798
8001c6aa:	10 36       	cp.w	r6,r8
8001c6ac:	c0 31       	brne	8001c6b2 <_ungetc_r+0x26>
8001c6ae:	6a 06       	ld.w	r6,r5[0x0]
8001c6b0:	c0 c8       	rjmp	8001c6c8 <_ungetc_r+0x3c>
8001c6b2:	fe c8 c2 36 	sub	r8,pc,-15818
8001c6b6:	10 36       	cp.w	r6,r8
8001c6b8:	c0 31       	brne	8001c6be <_ungetc_r+0x32>
8001c6ba:	6a 16       	ld.w	r6,r5[0x4]
8001c6bc:	c0 68       	rjmp	8001c6c8 <_ungetc_r+0x3c>
8001c6be:	fe c8 c2 22 	sub	r8,pc,-15838
8001c6c2:	10 36       	cp.w	r6,r8
8001c6c4:	eb f6 00 02 	ld.weq	r6,r5[0x8]
8001c6c8:	8c 68       	ld.sh	r8,r6[0xc]
8001c6ca:	a5 d8       	cbr	r8,0x5
8001c6cc:	ac 68       	st.h	r6[0xc],r8
8001c6ce:	ed b8 00 02 	bld	r8,0x2
8001c6d2:	c1 40       	breq	8001c6fa <_ungetc_r+0x6e>
8001c6d4:	ed b8 00 04 	bld	r8,0x4
8001c6d8:	c4 51       	brne	8001c762 <_ungetc_r+0xd6>
8001c6da:	ed b8 00 03 	bld	r8,0x3
8001c6de:	c0 b1       	brne	8001c6f4 <_ungetc_r+0x68>
8001c6e0:	0c 9b       	mov	r11,r6
8001c6e2:	0a 9c       	mov	r12,r5
8001c6e4:	fe b0 eb 2e 	rcall	80019d40 <_fflush_r>
8001c6e8:	c3 d1       	brne	8001c762 <_ungetc_r+0xd6>
8001c6ea:	8c 68       	ld.sh	r8,r6[0xc]
8001c6ec:	8d 6c       	st.w	r6[0x18],r12
8001c6ee:	a3 d8       	cbr	r8,0x3
8001c6f0:	8d 2c       	st.w	r6[0x8],r12
8001c6f2:	ac 68       	st.h	r6[0xc],r8
8001c6f4:	8c 68       	ld.sh	r8,r6[0xc]
8001c6f6:	a3 a8       	sbr	r8,0x2
8001c6f8:	ac 68       	st.h	r6[0xc],r8
8001c6fa:	0e 94       	mov	r4,r7
8001c6fc:	6c d8       	ld.w	r8,r6[0x34]
8001c6fe:	5c 54       	castu.b	r4
8001c700:	58 08       	cp.w	r8,0
8001c702:	c0 f0       	breq	8001c720 <_ungetc_r+0x94>
8001c704:	6c 19       	ld.w	r9,r6[0x4]
8001c706:	6c e8       	ld.w	r8,r6[0x38]
8001c708:	10 39       	cp.w	r9,r8
8001c70a:	c0 55       	brlt	8001c714 <_ungetc_r+0x88>
8001c70c:	0a 9c       	mov	r12,r5
8001c70e:	0c 9b       	mov	r11,r6
8001c710:	c8 cf       	rcall	8001c628 <__submore>
8001c712:	c2 81       	brne	8001c762 <_ungetc_r+0xd6>
8001c714:	6c 08       	ld.w	r8,r6[0x0]
8001c716:	20 18       	sub	r8,1
8001c718:	8d 08       	st.w	r6[0x0],r8
8001c71a:	b0 84       	st.b	r8[0x0],r4
8001c71c:	08 97       	mov	r7,r4
8001c71e:	c0 c8       	rjmp	8001c736 <_ungetc_r+0xaa>
8001c720:	6c 49       	ld.w	r9,r6[0x10]
8001c722:	58 09       	cp.w	r9,0
8001c724:	c0 c0       	breq	8001c73c <_ungetc_r+0xb0>
8001c726:	6c 08       	ld.w	r8,r6[0x0]
8001c728:	12 38       	cp.w	r8,r9
8001c72a:	e0 88 00 09 	brls	8001c73c <_ungetc_r+0xb0>
8001c72e:	11 77       	ld.ub	r7,--r8
8001c730:	08 37       	cp.w	r7,r4
8001c732:	c0 51       	brne	8001c73c <_ungetc_r+0xb0>
8001c734:	8d 08       	st.w	r6[0x0],r8
8001c736:	6c 18       	ld.w	r8,r6[0x4]
8001c738:	2f f8       	sub	r8,-1
8001c73a:	c1 28       	rjmp	8001c75e <_ungetc_r+0xd2>
8001c73c:	6c 18       	ld.w	r8,r6[0x4]
8001c73e:	ed 48 00 40 	st.w	r6[64],r8
8001c742:	6c 08       	ld.w	r8,r6[0x0]
8001c744:	8d f8       	st.w	r6[0x3c],r8
8001c746:	ec c8 ff bc 	sub	r8,r6,-68
8001c74a:	8d d8       	st.w	r6[0x34],r8
8001c74c:	30 38       	mov	r8,3
8001c74e:	8d e8       	st.w	r6[0x38],r8
8001c750:	ec c8 ff ba 	sub	r8,r6,-70
8001c754:	ed 64 00 46 	st.b	r6[70],r4
8001c758:	8d 08       	st.w	r6[0x0],r8
8001c75a:	08 97       	mov	r7,r4
8001c75c:	30 18       	mov	r8,1
8001c75e:	8d 18       	st.w	r6[0x4],r8
8001c760:	c0 28       	rjmp	8001c764 <_ungetc_r+0xd8>
8001c762:	3f f7       	mov	r7,-1
8001c764:	0e 9c       	mov	r12,r7
8001c766:	d8 22       	popm	r4-r7,pc

8001c768 <_write_r>:
8001c768:	d4 21       	pushm	r4-r7,lr
8001c76a:	16 98       	mov	r8,r11
8001c76c:	18 97       	mov	r7,r12
8001c76e:	10 9c       	mov	r12,r8
8001c770:	30 08       	mov	r8,0
8001c772:	14 9b       	mov	r11,r10
8001c774:	e0 66 0d 38 	mov	r6,3384
8001c778:	12 9a       	mov	r10,r9
8001c77a:	8d 08       	st.w	r6[0x0],r8
8001c77c:	fe b0 c7 e0 	rcall	8001573c <_write>
8001c780:	5b fc       	cp.w	r12,-1
8001c782:	c0 51       	brne	8001c78c <_write_r+0x24>
8001c784:	6c 08       	ld.w	r8,r6[0x0]
8001c786:	58 08       	cp.w	r8,0
8001c788:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001c78c:	d8 22       	popm	r4-r7,pc
8001c78e:	d7 03       	nop

8001c790 <_calloc_r>:
8001c790:	d4 21       	pushm	r4-r7,lr
8001c792:	f4 0b 02 4b 	mul	r11,r10,r11
8001c796:	fe b0 c4 69 	rcall	80015068 <_malloc_r>
8001c79a:	18 97       	mov	r7,r12
8001c79c:	c2 30       	breq	8001c7e2 <_calloc_r+0x52>
8001c79e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8001c7a2:	e0 1a ff fc 	andl	r10,0xfffc
8001c7a6:	20 4a       	sub	r10,4
8001c7a8:	e0 4a 00 24 	cp.w	r10,36
8001c7ac:	e0 8b 00 18 	brhi	8001c7dc <_calloc_r+0x4c>
8001c7b0:	18 98       	mov	r8,r12
8001c7b2:	59 3a       	cp.w	r10,19
8001c7b4:	e0 88 00 0f 	brls	8001c7d2 <_calloc_r+0x42>
8001c7b8:	30 09       	mov	r9,0
8001c7ba:	10 a9       	st.w	r8++,r9
8001c7bc:	10 a9       	st.w	r8++,r9
8001c7be:	59 ba       	cp.w	r10,27
8001c7c0:	e0 88 00 09 	brls	8001c7d2 <_calloc_r+0x42>
8001c7c4:	10 a9       	st.w	r8++,r9
8001c7c6:	10 a9       	st.w	r8++,r9
8001c7c8:	e0 4a 00 24 	cp.w	r10,36
8001c7cc:	c0 31       	brne	8001c7d2 <_calloc_r+0x42>
8001c7ce:	10 a9       	st.w	r8++,r9
8001c7d0:	10 a9       	st.w	r8++,r9
8001c7d2:	30 09       	mov	r9,0
8001c7d4:	10 a9       	st.w	r8++,r9
8001c7d6:	91 19       	st.w	r8[0x4],r9
8001c7d8:	91 09       	st.w	r8[0x0],r9
8001c7da:	c0 48       	rjmp	8001c7e2 <_calloc_r+0x52>
8001c7dc:	30 0b       	mov	r11,0
8001c7de:	fe b0 c7 12 	rcall	80015602 <memset>
8001c7e2:	0e 9c       	mov	r12,r7
8001c7e4:	d8 22       	popm	r4-r7,pc
8001c7e6:	d7 03       	nop

8001c7e8 <_close_r>:
8001c7e8:	d4 21       	pushm	r4-r7,lr
8001c7ea:	30 08       	mov	r8,0
8001c7ec:	18 97       	mov	r7,r12
8001c7ee:	e0 66 0d 38 	mov	r6,3384
8001c7f2:	16 9c       	mov	r12,r11
8001c7f4:	8d 08       	st.w	r6[0x0],r8
8001c7f6:	fe b0 c7 85 	rcall	80015700 <_close>
8001c7fa:	5b fc       	cp.w	r12,-1
8001c7fc:	c0 51       	brne	8001c806 <_close_r+0x1e>
8001c7fe:	6c 08       	ld.w	r8,r6[0x0]
8001c800:	58 08       	cp.w	r8,0
8001c802:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001c806:	d8 22       	popm	r4-r7,pc

8001c808 <_fclose_r>:
8001c808:	d4 21       	pushm	r4-r7,lr
8001c80a:	18 96       	mov	r6,r12
8001c80c:	16 97       	mov	r7,r11
8001c80e:	58 0b       	cp.w	r11,0
8001c810:	c0 31       	brne	8001c816 <_fclose_r+0xe>
8001c812:	16 95       	mov	r5,r11
8001c814:	c5 38       	rjmp	8001c8ba <_fclose_r+0xb2>
8001c816:	fe b0 eb 2d 	rcall	80019e70 <__sfp_lock_acquire>
8001c81a:	58 06       	cp.w	r6,0
8001c81c:	c0 70       	breq	8001c82a <_fclose_r+0x22>
8001c81e:	6c 68       	ld.w	r8,r6[0x18]
8001c820:	58 08       	cp.w	r8,0
8001c822:	c0 41       	brne	8001c82a <_fclose_r+0x22>
8001c824:	0c 9c       	mov	r12,r6
8001c826:	fe b0 eb 77 	rcall	80019f14 <__sinit>
8001c82a:	fe c8 c3 ce 	sub	r8,pc,-15410
8001c82e:	10 37       	cp.w	r7,r8
8001c830:	c0 31       	brne	8001c836 <_fclose_r+0x2e>
8001c832:	6c 07       	ld.w	r7,r6[0x0]
8001c834:	c0 c8       	rjmp	8001c84c <_fclose_r+0x44>
8001c836:	fe c8 c3 ba 	sub	r8,pc,-15430
8001c83a:	10 37       	cp.w	r7,r8
8001c83c:	c0 31       	brne	8001c842 <_fclose_r+0x3a>
8001c83e:	6c 17       	ld.w	r7,r6[0x4]
8001c840:	c0 68       	rjmp	8001c84c <_fclose_r+0x44>
8001c842:	fe c8 c3 a6 	sub	r8,pc,-15450
8001c846:	10 37       	cp.w	r7,r8
8001c848:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8001c84c:	8e 69       	ld.sh	r9,r7[0xc]
8001c84e:	30 08       	mov	r8,0
8001c850:	f0 09 19 00 	cp.h	r9,r8
8001c854:	c0 51       	brne	8001c85e <_fclose_r+0x56>
8001c856:	fe b0 eb 0e 	rcall	80019e72 <__sfp_lock_release>
8001c85a:	30 05       	mov	r5,0
8001c85c:	c2 f8       	rjmp	8001c8ba <_fclose_r+0xb2>
8001c85e:	0e 9b       	mov	r11,r7
8001c860:	0c 9c       	mov	r12,r6
8001c862:	fe b0 ea 6f 	rcall	80019d40 <_fflush_r>
8001c866:	6e c8       	ld.w	r8,r7[0x30]
8001c868:	18 95       	mov	r5,r12
8001c86a:	58 08       	cp.w	r8,0
8001c86c:	c0 60       	breq	8001c878 <_fclose_r+0x70>
8001c86e:	6e 8b       	ld.w	r11,r7[0x20]
8001c870:	0c 9c       	mov	r12,r6
8001c872:	5d 18       	icall	r8
8001c874:	f9 b5 05 ff 	movlt	r5,-1
8001c878:	8e 68       	ld.sh	r8,r7[0xc]
8001c87a:	ed b8 00 07 	bld	r8,0x7
8001c87e:	c0 51       	brne	8001c888 <_fclose_r+0x80>
8001c880:	6e 4b       	ld.w	r11,r7[0x10]
8001c882:	0c 9c       	mov	r12,r6
8001c884:	fe b0 ec 3c 	rcall	8001a0fc <_free_r>
8001c888:	6e db       	ld.w	r11,r7[0x34]
8001c88a:	58 0b       	cp.w	r11,0
8001c88c:	c0 a0       	breq	8001c8a0 <_fclose_r+0x98>
8001c88e:	ee c8 ff bc 	sub	r8,r7,-68
8001c892:	10 3b       	cp.w	r11,r8
8001c894:	c0 40       	breq	8001c89c <_fclose_r+0x94>
8001c896:	0c 9c       	mov	r12,r6
8001c898:	fe b0 ec 32 	rcall	8001a0fc <_free_r>
8001c89c:	30 08       	mov	r8,0
8001c89e:	8f d8       	st.w	r7[0x34],r8
8001c8a0:	6f 2b       	ld.w	r11,r7[0x48]
8001c8a2:	58 0b       	cp.w	r11,0
8001c8a4:	c0 70       	breq	8001c8b2 <_fclose_r+0xaa>
8001c8a6:	0c 9c       	mov	r12,r6
8001c8a8:	fe b0 ec 2a 	rcall	8001a0fc <_free_r>
8001c8ac:	30 08       	mov	r8,0
8001c8ae:	ef 48 00 48 	st.w	r7[72],r8
8001c8b2:	30 08       	mov	r8,0
8001c8b4:	ae 68       	st.h	r7[0xc],r8
8001c8b6:	fe b0 ea de 	rcall	80019e72 <__sfp_lock_release>
8001c8ba:	0a 9c       	mov	r12,r5
8001c8bc:	d8 22       	popm	r4-r7,pc
8001c8be:	d7 03       	nop

8001c8c0 <fclose>:
8001c8c0:	d4 01       	pushm	lr
8001c8c2:	e0 68 01 20 	mov	r8,288
8001c8c6:	18 9b       	mov	r11,r12
8001c8c8:	70 0c       	ld.w	r12,r8[0x0]
8001c8ca:	c9 ff       	rcall	8001c808 <_fclose_r>
8001c8cc:	d8 02       	popm	pc
8001c8ce:	d7 03       	nop

8001c8d0 <_fstat_r>:
8001c8d0:	d4 21       	pushm	r4-r7,lr
8001c8d2:	16 98       	mov	r8,r11
8001c8d4:	18 97       	mov	r7,r12
8001c8d6:	10 9c       	mov	r12,r8
8001c8d8:	30 08       	mov	r8,0
8001c8da:	e0 66 0d 38 	mov	r6,3384
8001c8de:	14 9b       	mov	r11,r10
8001c8e0:	8d 08       	st.w	r6[0x0],r8
8001c8e2:	fe b0 c7 4b 	rcall	80015778 <_fstat>
8001c8e6:	5b fc       	cp.w	r12,-1
8001c8e8:	c0 51       	brne	8001c8f2 <_fstat_r+0x22>
8001c8ea:	6c 08       	ld.w	r8,r6[0x0]
8001c8ec:	58 08       	cp.w	r8,0
8001c8ee:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001c8f2:	d8 22       	popm	r4-r7,pc

8001c8f4 <__hexdig_init>:
8001c8f4:	fe c9 c2 98 	sub	r9,pc,-15720
8001c8f8:	31 08       	mov	r8,16
8001c8fa:	e0 6b 0d 3c 	mov	r11,3388
8001c8fe:	c0 58       	rjmp	8001c908 <__hexdig_init+0x14>
8001c900:	f6 0a 0b 08 	st.b	r11[r10],r8
8001c904:	f1 dc c0 08 	bfextu	r8,r12,0x0,0x8
8001c908:	f0 cc ff ff 	sub	r12,r8,-1
8001c90c:	13 3a       	ld.ub	r10,r9++
8001c90e:	58 0a       	cp.w	r10,0
8001c910:	cf 81       	brne	8001c900 <__hexdig_init+0xc>
8001c912:	fe c9 c2 be 	sub	r9,pc,-15682
8001c916:	31 a8       	mov	r8,26
8001c918:	e0 6b 0d 3c 	mov	r11,3388
8001c91c:	c0 58       	rjmp	8001c926 <__hexdig_init+0x32>
8001c91e:	f6 0a 0b 08 	st.b	r11[r10],r8
8001c922:	f1 dc c0 08 	bfextu	r8,r12,0x0,0x8
8001c926:	f0 cc ff ff 	sub	r12,r8,-1
8001c92a:	13 3a       	ld.ub	r10,r9++
8001c92c:	58 0a       	cp.w	r10,0
8001c92e:	cf 81       	brne	8001c91e <__hexdig_init+0x2a>
8001c930:	fe c9 c2 e4 	sub	r9,pc,-15644
8001c934:	31 a8       	mov	r8,26
8001c936:	e0 6b 0d 3c 	mov	r11,3388
8001c93a:	c0 58       	rjmp	8001c944 <__hexdig_init+0x50>
8001c93c:	f6 0a 0b 08 	st.b	r11[r10],r8
8001c940:	f1 dc c0 08 	bfextu	r8,r12,0x0,0x8
8001c944:	f0 cc ff ff 	sub	r12,r8,-1
8001c948:	13 3a       	ld.ub	r10,r9++
8001c94a:	58 0a       	cp.w	r10,0
8001c94c:	cf 81       	brne	8001c93c <__hexdig_init+0x48>
8001c94e:	5e fc       	retal	r12

8001c950 <rshift>:
8001c950:	d4 21       	pushm	r4-r7,lr
8001c952:	f8 c8 ff ec 	sub	r8,r12,-20
8001c956:	f6 09 14 05 	asr	r9,r11,0x5
8001c95a:	78 4e       	ld.w	lr,r12[0x10]
8001c95c:	1c 39       	cp.w	r9,lr
8001c95e:	c2 64       	brge	8001c9aa <rshift+0x5a>
8001c960:	2f be       	sub	lr,-5
8001c962:	2f b9       	sub	r9,-5
8001c964:	f8 0e 00 2e 	add	lr,r12,lr<<0x2
8001c968:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8001c96c:	f8 09 00 2a 	add	r10,r12,r9<<0x2
8001c970:	58 0b       	cp.w	r11,0
8001c972:	c1 a0       	breq	8001c9a6 <rshift+0x56>
8001c974:	f8 09 03 29 	ld.w	r9,r12[r9<<0x2]
8001c978:	2f ca       	sub	r10,-4
8001c97a:	f2 0b 0a 49 	lsr	r9,r9,r11
8001c97e:	f6 07 11 20 	rsub	r7,r11,32
8001c982:	c0 98       	rjmp	8001c994 <rshift+0x44>
8001c984:	74 06       	ld.w	r6,r10[0x0]
8001c986:	ec 07 09 46 	lsl	r6,r6,r7
8001c98a:	0c 49       	or	r9,r6
8001c98c:	10 a9       	st.w	r8++,r9
8001c98e:	15 09       	ld.w	r9,r10++
8001c990:	f2 0b 0a 49 	lsr	r9,r9,r11
8001c994:	1c 3a       	cp.w	r10,lr
8001c996:	cf 73       	brcs	8001c984 <rshift+0x34>
8001c998:	91 09       	st.w	r8[0x0],r9
8001c99a:	58 09       	cp.w	r9,0
8001c99c:	c0 70       	breq	8001c9aa <rshift+0x5a>
8001c99e:	2f c8       	sub	r8,-4
8001c9a0:	c0 58       	rjmp	8001c9aa <rshift+0x5a>
8001c9a2:	15 09       	ld.w	r9,r10++
8001c9a4:	10 a9       	st.w	r8++,r9
8001c9a6:	1c 3a       	cp.w	r10,lr
8001c9a8:	cf d3       	brcs	8001c9a2 <rshift+0x52>
8001c9aa:	f8 c9 ff ec 	sub	r9,r12,-20
8001c9ae:	12 18       	sub	r8,r9
8001c9b0:	a3 48       	asr	r8,0x2
8001c9b2:	99 48       	st.w	r12[0x10],r8
8001c9b4:	f9 f8 0a 05 	st.weq	r12[0x14],r8
8001c9b8:	d8 22       	popm	r4-r7,pc
8001c9ba:	d7 03       	nop

8001c9bc <__gethex>:
8001c9bc:	d4 31       	pushm	r0-r7,lr
8001c9be:	20 3d       	sub	sp,12
8001c9c0:	50 29       	stdsp	sp[0x8],r9
8001c9c2:	50 08       	stdsp	sp[0x0],r8
8001c9c4:	40 c9       	lddsp	r9,sp[0x30]
8001c9c6:	e0 68 0d 3c 	mov	r8,3388
8001c9ca:	50 19       	stdsp	sp[0x4],r9
8001c9cc:	18 91       	mov	r1,r12
8001c9ce:	f1 39 00 30 	ld.ub	r9,r8[48]
8001c9d2:	16 96       	mov	r6,r11
8001c9d4:	14 97       	mov	r7,r10
8001c9d6:	30 08       	mov	r8,0
8001c9d8:	f0 09 18 00 	cp.b	r9,r8
8001c9dc:	c0 21       	brne	8001c9e0 <__gethex+0x24>
8001c9de:	c8 bf       	rcall	8001c8f4 <__hexdig_init>
8001c9e0:	6c 05       	ld.w	r5,r6[0x0]
8001c9e2:	30 03       	mov	r3,0
8001c9e4:	2f e5       	sub	r5,-2
8001c9e6:	33 09       	mov	r9,48
8001c9e8:	c0 28       	rjmp	8001c9ec <__gethex+0x30>
8001c9ea:	2f f3       	sub	r3,-1
8001c9ec:	0a 94       	mov	r4,r5
8001c9ee:	0b 88       	ld.ub	r8,r5[0x0]
8001c9f0:	2f f5       	sub	r5,-1
8001c9f2:	f2 08 18 00 	cp.b	r8,r9
8001c9f6:	cf a0       	breq	8001c9ea <__gethex+0x2e>
8001c9f8:	e0 6a 0d 3c 	mov	r10,3388
8001c9fc:	30 0b       	mov	r11,0
8001c9fe:	f4 08 07 09 	ld.ub	r9,r10[r8]
8001ca02:	f6 09 18 00 	cp.b	r9,r11
8001ca06:	c0 50       	breq	8001ca10 <__gethex+0x54>
8001ca08:	30 0b       	mov	r11,0
8001ca0a:	08 92       	mov	r2,r4
8001ca0c:	16 95       	mov	r5,r11
8001ca0e:	c2 c8       	rjmp	8001ca66 <__gethex+0xaa>
8001ca10:	32 eb       	mov	r11,46
8001ca12:	f6 08 18 00 	cp.b	r8,r11
8001ca16:	c0 30       	breq	8001ca1c <__gethex+0x60>
8001ca18:	08 92       	mov	r2,r4
8001ca1a:	c0 88       	rjmp	8001ca2a <__gethex+0x6e>
8001ca1c:	0b 88       	ld.ub	r8,r5[0x0]
8001ca1e:	0a 92       	mov	r2,r5
8001ca20:	f4 08 07 08 	ld.ub	r8,r10[r8]
8001ca24:	f2 08 18 00 	cp.b	r8,r9
8001ca28:	c0 41       	brne	8001ca30 <__gethex+0x74>
8001ca2a:	30 05       	mov	r5,0
8001ca2c:	30 1b       	mov	r11,1
8001ca2e:	c4 38       	rjmp	8001cab4 <__gethex+0xf8>
8001ca30:	0a 92       	mov	r2,r5
8001ca32:	33 09       	mov	r9,48
8001ca34:	c0 28       	rjmp	8001ca38 <__gethex+0x7c>
8001ca36:	2f f2       	sub	r2,-1
8001ca38:	05 88       	ld.ub	r8,r2[0x0]
8001ca3a:	f2 08 18 00 	cp.b	r8,r9
8001ca3e:	cf c0       	breq	8001ca36 <__gethex+0x7a>
8001ca40:	e0 69 0d 3c 	mov	r9,3388
8001ca44:	f2 08 07 09 	ld.ub	r9,r9[r8]
8001ca48:	30 08       	mov	r8,0
8001ca4a:	f0 09 18 00 	cp.b	r9,r8
8001ca4e:	e4 04 17 10 	movne	r4,r2
8001ca52:	f9 bb 01 00 	movne	r11,0
8001ca56:	f9 b3 01 01 	movne	r3,1
8001ca5a:	f9 bb 00 01 	moveq	r11,1
8001ca5e:	e4 04 17 00 	moveq	r4,r2
8001ca62:	f6 03 17 00 	moveq	r3,r11
8001ca66:	e0 6a 0d 3c 	mov	r10,3388
8001ca6a:	30 08       	mov	r8,0
8001ca6c:	c0 28       	rjmp	8001ca70 <__gethex+0xb4>
8001ca6e:	2f f2       	sub	r2,-1
8001ca70:	05 89       	ld.ub	r9,r2[0x0]
8001ca72:	f4 09 07 0c 	ld.ub	r12,r10[r9]
8001ca76:	f0 0c 18 00 	cp.b	r12,r8
8001ca7a:	cf a1       	brne	8001ca6e <__gethex+0xb2>
8001ca7c:	58 05       	cp.w	r5,0
8001ca7e:	5f 0a       	sreq	r10
8001ca80:	32 ec       	mov	r12,46
8001ca82:	f8 09 18 00 	cp.b	r9,r12
8001ca86:	5f 09       	sreq	r9
8001ca88:	f3 ea 00 0a 	and	r10,r9,r10
8001ca8c:	f0 0a 18 00 	cp.b	r10,r8
8001ca90:	c0 e0       	breq	8001caac <__gethex+0xf0>
8001ca92:	2f f2       	sub	r2,-1
8001ca94:	e0 69 0d 3c 	mov	r9,3388
8001ca98:	04 95       	mov	r5,r2
8001ca9a:	30 08       	mov	r8,0
8001ca9c:	c0 28       	rjmp	8001caa0 <__gethex+0xe4>
8001ca9e:	2f f2       	sub	r2,-1
8001caa0:	05 8a       	ld.ub	r10,r2[0x0]
8001caa2:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
8001caa6:	f0 0a 18 00 	cp.b	r10,r8
8001caaa:	cf a1       	brne	8001ca9e <__gethex+0xe2>
8001caac:	58 05       	cp.w	r5,0
8001caae:	c0 30       	breq	8001cab4 <__gethex+0xf8>
8001cab0:	04 15       	sub	r5,r2
8001cab2:	a3 65       	lsl	r5,0x2
8001cab4:	05 88       	ld.ub	r8,r2[0x0]
8001cab6:	35 09       	mov	r9,80
8001cab8:	f2 08 18 00 	cp.b	r8,r9
8001cabc:	c0 50       	breq	8001cac6 <__gethex+0x10a>
8001cabe:	37 09       	mov	r9,112
8001cac0:	f2 08 18 00 	cp.b	r8,r9
8001cac4:	c3 21       	brne	8001cb28 <__gethex+0x16c>
8001cac6:	e4 c8 ff ff 	sub	r8,r2,-1
8001caca:	32 ba       	mov	r10,43
8001cacc:	11 89       	ld.ub	r9,r8[0x0]
8001cace:	f4 09 18 00 	cp.b	r9,r10
8001cad2:	c0 90       	breq	8001cae4 <__gethex+0x128>
8001cad4:	32 da       	mov	r10,45
8001cad6:	f4 09 18 00 	cp.b	r9,r10
8001cada:	c0 30       	breq	8001cae0 <__gethex+0x124>
8001cadc:	30 0a       	mov	r10,0
8001cade:	c0 58       	rjmp	8001cae8 <__gethex+0x12c>
8001cae0:	30 1a       	mov	r10,1
8001cae2:	c0 28       	rjmp	8001cae6 <__gethex+0x12a>
8001cae4:	30 0a       	mov	r10,0
8001cae6:	2f f8       	sub	r8,-1
8001cae8:	e0 6e 0d 3c 	mov	lr,3388
8001caec:	11 89       	ld.ub	r9,r8[0x0]
8001caee:	fc 09 07 09 	ld.ub	r9,lr[r9]
8001caf2:	58 09       	cp.w	r9,0
8001caf4:	c1 a0       	breq	8001cb28 <__gethex+0x16c>
8001caf6:	59 99       	cp.w	r9,25
8001caf8:	e0 89 00 18 	brgt	8001cb28 <__gethex+0x16c>
8001cafc:	21 09       	sub	r9,16
8001cafe:	c0 48       	rjmp	8001cb06 <__gethex+0x14a>
8001cb00:	21 0c       	sub	r12,16
8001cb02:	f8 00 00 19 	add	r9,r12,r0<<0x1
8001cb06:	2f f8       	sub	r8,-1
8001cb08:	f2 09 00 20 	add	r0,r9,r9<<0x2
8001cb0c:	11 8c       	ld.ub	r12,r8[0x0]
8001cb0e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8001cb12:	58 0c       	cp.w	r12,0
8001cb14:	c0 40       	breq	8001cb1c <__gethex+0x160>
8001cb16:	59 9c       	cp.w	r12,25
8001cb18:	fe 9a ff f4 	brle	8001cb00 <__gethex+0x144>
8001cb1c:	58 0a       	cp.w	r10,0
8001cb1e:	fb b9 01 00 	rsubne	r9,0
8001cb22:	12 05       	add	r5,r9
8001cb24:	c0 38       	rjmp	8001cb2a <__gethex+0x16e>
8001cb26:	d7 03       	nop
8001cb28:	04 98       	mov	r8,r2
8001cb2a:	8d 08       	st.w	r6[0x0],r8
8001cb2c:	58 0b       	cp.w	r11,0
8001cb2e:	c0 70       	breq	8001cb3c <__gethex+0x180>
8001cb30:	58 03       	cp.w	r3,0
8001cb32:	f9 b3 01 00 	movne	r3,0
8001cb36:	f9 b3 00 06 	moveq	r3,6
8001cb3a:	c5 19       	rjmp	8001cddc <__gethex+0x420>
8001cb3c:	e4 c8 00 01 	sub	r8,r2,1
8001cb40:	08 18       	sub	r8,r4
8001cb42:	c0 38       	rjmp	8001cb48 <__gethex+0x18c>
8001cb44:	2f fb       	sub	r11,-1
8001cb46:	a1 58       	asr	r8,0x1
8001cb48:	58 78       	cp.w	r8,7
8001cb4a:	fe 99 ff fd 	brgt	8001cb44 <__gethex+0x188>
8001cb4e:	02 9c       	mov	r12,r1
8001cb50:	fe b0 ef 7a 	rcall	8001aa44 <_Balloc>
8001cb54:	30 08       	mov	r8,0
8001cb56:	f8 c0 ff ec 	sub	r0,r12,-20
8001cb5a:	18 96       	mov	r6,r12
8001cb5c:	00 9a       	mov	r10,r0
8001cb5e:	10 99       	mov	r9,r8
8001cb60:	32 eb       	mov	r11,46
8001cb62:	e0 6e 0d 3c 	mov	lr,3388
8001cb66:	c1 48       	rjmp	8001cb8e <__gethex+0x1d2>
8001cb68:	05 7c       	ld.ub	r12,--r2
8001cb6a:	f6 0c 18 00 	cp.b	r12,r11
8001cb6e:	c1 00       	breq	8001cb8e <__gethex+0x1d2>
8001cb70:	e0 49 00 20 	cp.w	r9,32
8001cb74:	c0 41       	brne	8001cb7c <__gethex+0x1c0>
8001cb76:	14 a8       	st.w	r10++,r8
8001cb78:	30 08       	mov	r8,0
8001cb7a:	10 99       	mov	r9,r8
8001cb7c:	05 8c       	ld.ub	r12,r2[0x0]
8001cb7e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8001cb82:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
8001cb86:	f8 09 09 4c 	lsl	r12,r12,r9
8001cb8a:	2f c9       	sub	r9,-4
8001cb8c:	18 48       	or	r8,r12
8001cb8e:	08 32       	cp.w	r2,r4
8001cb90:	fe 9b ff ec 	brhi	8001cb68 <__gethex+0x1ac>
8001cb94:	14 a8       	st.w	r10++,r8
8001cb96:	10 9c       	mov	r12,r8
8001cb98:	ec c8 ff ec 	sub	r8,r6,-20
8001cb9c:	10 1a       	sub	r10,r8
8001cb9e:	a3 4a       	asr	r10,0x2
8001cba0:	f4 03 15 05 	lsl	r3,r10,0x5
8001cba4:	8d 4a       	st.w	r6[0x10],r10
8001cba6:	fe b0 ed cf 	rcall	8001a744 <__hi0bits>
8001cbaa:	6e 04       	ld.w	r4,r7[0x0]
8001cbac:	18 13       	sub	r3,r12
8001cbae:	08 33       	cp.w	r3,r4
8001cbb0:	e0 8a 00 27 	brle	8001cbfe <__gethex+0x242>
8001cbb4:	08 13       	sub	r3,r4
8001cbb6:	0c 9c       	mov	r12,r6
8001cbb8:	06 9b       	mov	r11,r3
8001cbba:	fe b0 ef 04 	rcall	8001a9c2 <__any_on>
8001cbbe:	c0 31       	brne	8001cbc4 <__gethex+0x208>
8001cbc0:	18 92       	mov	r2,r12
8001cbc2:	c1 98       	rjmp	8001cbf4 <__gethex+0x238>
8001cbc4:	e6 cb 00 01 	sub	r11,r3,1
8001cbc8:	30 12       	mov	r2,1
8001cbca:	f6 08 14 05 	asr	r8,r11,0x5
8001cbce:	e4 0b 09 49 	lsl	r9,r2,r11
8001cbd2:	2f b8       	sub	r8,-5
8001cbd4:	ec 08 03 28 	ld.w	r8,r6[r8<<0x2]
8001cbd8:	f3 e8 00 08 	and	r8,r9,r8
8001cbdc:	c0 c0       	breq	8001cbf4 <__gethex+0x238>
8001cbde:	04 3b       	cp.w	r11,r2
8001cbe0:	e0 8a 00 09 	brle	8001cbf2 <__gethex+0x236>
8001cbe4:	20 1b       	sub	r11,1
8001cbe6:	0c 9c       	mov	r12,r6
8001cbe8:	fe b0 ee ed 	rcall	8001a9c2 <__any_on>
8001cbec:	c0 30       	breq	8001cbf2 <__gethex+0x236>
8001cbee:	30 32       	mov	r2,3
8001cbf0:	c0 28       	rjmp	8001cbf4 <__gethex+0x238>
8001cbf2:	30 22       	mov	r2,2
8001cbf4:	06 05       	add	r5,r3
8001cbf6:	06 9b       	mov	r11,r3
8001cbf8:	0c 9c       	mov	r12,r6
8001cbfa:	ca be       	rcall	8001c950 <rshift>
8001cbfc:	c1 08       	rjmp	8001cc1c <__gethex+0x260>
8001cbfe:	08 33       	cp.w	r3,r4
8001cc00:	c0 35       	brlt	8001cc06 <__gethex+0x24a>
8001cc02:	30 02       	mov	r2,0
8001cc04:	c0 c8       	rjmp	8001cc1c <__gethex+0x260>
8001cc06:	e8 03 01 0a 	sub	r10,r4,r3
8001cc0a:	0c 9b       	mov	r11,r6
8001cc0c:	14 15       	sub	r5,r10
8001cc0e:	02 9c       	mov	r12,r1
8001cc10:	30 02       	mov	r2,0
8001cc12:	fe b0 f0 0b 	rcall	8001ac28 <__lshift>
8001cc16:	18 96       	mov	r6,r12
8001cc18:	f8 c0 ff ec 	sub	r0,r12,-20
8001cc1c:	6e 28       	ld.w	r8,r7[0x8]
8001cc1e:	10 35       	cp.w	r5,r8
8001cc20:	e0 8a 00 09 	brle	8001cc32 <__gethex+0x276>
8001cc24:	0c 9b       	mov	r11,r6
8001cc26:	02 9c       	mov	r12,r1
8001cc28:	e0 63 00 a3 	mov	r3,163
8001cc2c:	fe b0 ee f2 	rcall	8001aa10 <_Bfree>
8001cc30:	c3 38       	rjmp	8001cc96 <__gethex+0x2da>
8001cc32:	6e 18       	ld.w	r8,r7[0x4]
8001cc34:	10 35       	cp.w	r5,r8
8001cc36:	c0 35       	brlt	8001cc3c <__gethex+0x280>
8001cc38:	30 13       	mov	r3,1
8001cc3a:	c5 38       	rjmp	8001cce0 <__gethex+0x324>
8001cc3c:	f0 05 01 05 	sub	r5,r8,r5
8001cc40:	08 35       	cp.w	r5,r4
8001cc42:	c2 e5       	brlt	8001cc9e <__gethex+0x2e2>
8001cc44:	6e 38       	ld.w	r8,r7[0xc]
8001cc46:	58 28       	cp.w	r8,2
8001cc48:	c1 10       	breq	8001cc6a <__gethex+0x2ae>
8001cc4a:	58 38       	cp.w	r8,3
8001cc4c:	c1 30       	breq	8001cc72 <__gethex+0x2b6>
8001cc4e:	58 18       	cp.w	r8,1
8001cc50:	c1 e1       	brne	8001cc8c <__gethex+0x2d0>
8001cc52:	08 35       	cp.w	r5,r4
8001cc54:	c1 c1       	brne	8001cc8c <__gethex+0x2d0>
8001cc56:	58 14       	cp.w	r4,1
8001cc58:	e0 8a 00 10 	brle	8001cc78 <__gethex+0x2bc>
8001cc5c:	e8 cb 00 01 	sub	r11,r4,1
8001cc60:	0c 9c       	mov	r12,r6
8001cc62:	fe b0 ee b0 	rcall	8001a9c2 <__any_on>
8001cc66:	c0 91       	brne	8001cc78 <__gethex+0x2bc>
8001cc68:	c1 28       	rjmp	8001cc8c <__gethex+0x2d0>
8001cc6a:	40 18       	lddsp	r8,sp[0x4]
8001cc6c:	58 08       	cp.w	r8,0
8001cc6e:	c0 50       	breq	8001cc78 <__gethex+0x2bc>
8001cc70:	c0 e8       	rjmp	8001cc8c <__gethex+0x2d0>
8001cc72:	40 19       	lddsp	r9,sp[0x4]
8001cc74:	58 09       	cp.w	r9,0
8001cc76:	c0 b0       	breq	8001cc8c <__gethex+0x2d0>
8001cc78:	6e 18       	ld.w	r8,r7[0x4]
8001cc7a:	40 29       	lddsp	r9,sp[0x8]
8001cc7c:	93 08       	st.w	r9[0x0],r8
8001cc7e:	40 08       	lddsp	r8,sp[0x0]
8001cc80:	36 23       	mov	r3,98
8001cc82:	91 06       	st.w	r8[0x0],r6
8001cc84:	30 18       	mov	r8,1
8001cc86:	81 08       	st.w	r0[0x0],r8
8001cc88:	8d 48       	st.w	r6[0x10],r8
8001cc8a:	ca 98       	rjmp	8001cddc <__gethex+0x420>
8001cc8c:	0c 9b       	mov	r11,r6
8001cc8e:	02 9c       	mov	r12,r1
8001cc90:	35 03       	mov	r3,80
8001cc92:	fe b0 ee bf 	rcall	8001aa10 <_Bfree>
8001cc96:	30 08       	mov	r8,0
8001cc98:	40 09       	lddsp	r9,sp[0x0]
8001cc9a:	93 08       	st.w	r9[0x0],r8
8001cc9c:	ca 08       	rjmp	8001cddc <__gethex+0x420>
8001cc9e:	ea c3 00 01 	sub	r3,r5,1
8001cca2:	58 02       	cp.w	r2,0
8001cca4:	c0 30       	breq	8001ccaa <__gethex+0x2ee>
8001cca6:	30 12       	mov	r2,1
8001cca8:	c0 98       	rjmp	8001ccba <__gethex+0x2fe>
8001ccaa:	58 03       	cp.w	r3,0
8001ccac:	e0 8a 00 07 	brle	8001ccba <__gethex+0x2fe>
8001ccb0:	06 9b       	mov	r11,r3
8001ccb2:	0c 9c       	mov	r12,r6
8001ccb4:	fe b0 ee 87 	rcall	8001a9c2 <__any_on>
8001ccb8:	18 92       	mov	r2,r12
8001ccba:	e6 08 14 05 	asr	r8,r3,0x5
8001ccbe:	e0 08 03 28 	ld.w	r8,r0[r8<<0x2]
8001ccc2:	30 19       	mov	r9,1
8001ccc4:	f2 03 09 43 	lsl	r3,r9,r3
8001ccc8:	10 63       	and	r3,r8
8001ccca:	04 98       	mov	r8,r2
8001cccc:	a1 b8       	sbr	r8,0x1
8001ccce:	0a 9b       	mov	r11,r5
8001ccd0:	58 03       	cp.w	r3,0
8001ccd2:	f0 02 17 10 	movne	r2,r8
8001ccd6:	0a 14       	sub	r4,r5
8001ccd8:	0c 9c       	mov	r12,r6
8001ccda:	30 23       	mov	r3,2
8001ccdc:	c3 ae       	rcall	8001c950 <rshift>
8001ccde:	6e 15       	ld.w	r5,r7[0x4]
8001cce0:	58 02       	cp.w	r2,0
8001cce2:	c7 90       	breq	8001cdd4 <__gethex+0x418>
8001cce4:	6e 38       	ld.w	r8,r7[0xc]
8001cce6:	58 28       	cp.w	r8,2
8001cce8:	c1 10       	breq	8001cd0a <__gethex+0x34e>
8001ccea:	58 38       	cp.w	r8,3
8001ccec:	c0 40       	breq	8001ccf4 <__gethex+0x338>
8001ccee:	58 18       	cp.w	r8,1
8001ccf0:	c7 11       	brne	8001cdd2 <__gethex+0x416>
8001ccf2:	c0 38       	rjmp	8001ccf8 <__gethex+0x33c>
8001ccf4:	40 18       	lddsp	r8,sp[0x4]
8001ccf6:	c0 d8       	rjmp	8001cd10 <__gethex+0x354>
8001ccf8:	ed b2 00 01 	bld	r2,0x1
8001ccfc:	c6 b1       	brne	8001cdd2 <__gethex+0x416>
8001ccfe:	60 08       	ld.w	r8,r0[0x0]
8001cd00:	10 42       	or	r2,r8
8001cd02:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8001cd06:	c0 71       	brne	8001cd14 <__gethex+0x358>
8001cd08:	c6 58       	rjmp	8001cdd2 <__gethex+0x416>
8001cd0a:	40 19       	lddsp	r9,sp[0x4]
8001cd0c:	f2 08 11 01 	rsub	r8,r9,1
8001cd10:	58 08       	cp.w	r8,0
8001cd12:	c6 00       	breq	8001cdd2 <__gethex+0x416>
8001cd14:	6c 40       	ld.w	r0,r6[0x10]
8001cd16:	ec c8 ff ec 	sub	r8,r6,-20
8001cd1a:	e0 cb ff fb 	sub	r11,r0,-5
8001cd1e:	30 0a       	mov	r10,0
8001cd20:	ec 0b 00 2b 	add	r11,r6,r11<<0x2
8001cd24:	70 09       	ld.w	r9,r8[0x0]
8001cd26:	5b f9       	cp.w	r9,-1
8001cd28:	c0 40       	breq	8001cd30 <__gethex+0x374>
8001cd2a:	2f f9       	sub	r9,-1
8001cd2c:	91 09       	st.w	r8[0x0],r9
8001cd2e:	c2 58       	rjmp	8001cd78 <__gethex+0x3bc>
8001cd30:	10 aa       	st.w	r8++,r10
8001cd32:	16 38       	cp.w	r8,r11
8001cd34:	cf 83       	brcs	8001cd24 <__gethex+0x368>
8001cd36:	6c 49       	ld.w	r9,r6[0x10]
8001cd38:	6c 28       	ld.w	r8,r6[0x8]
8001cd3a:	10 39       	cp.w	r9,r8
8001cd3c:	c0 34       	brge	8001cd42 <__gethex+0x386>
8001cd3e:	0c 92       	mov	r2,r6
8001cd40:	c1 38       	rjmp	8001cd66 <__gethex+0x3aa>
8001cd42:	6c 1b       	ld.w	r11,r6[0x4]
8001cd44:	02 9c       	mov	r12,r1
8001cd46:	2f fb       	sub	r11,-1
8001cd48:	fe b0 ee 7e 	rcall	8001aa44 <_Balloc>
8001cd4c:	6c 4a       	ld.w	r10,r6[0x10]
8001cd4e:	ec cb ff f4 	sub	r11,r6,-12
8001cd52:	18 92       	mov	r2,r12
8001cd54:	2f ea       	sub	r10,-2
8001cd56:	2f 4c       	sub	r12,-12
8001cd58:	a3 6a       	lsl	r10,0x2
8001cd5a:	fe b0 c3 b0 	rcall	800154ba <memcpy>
8001cd5e:	0c 9b       	mov	r11,r6
8001cd60:	02 9c       	mov	r12,r1
8001cd62:	fe b0 ee 57 	rcall	8001aa10 <_Bfree>
8001cd66:	64 48       	ld.w	r8,r2[0x10]
8001cd68:	f0 c9 ff ff 	sub	r9,r8,-1
8001cd6c:	04 96       	mov	r6,r2
8001cd6e:	85 49       	st.w	r2[0x10],r9
8001cd70:	2f b8       	sub	r8,-5
8001cd72:	30 19       	mov	r9,1
8001cd74:	e4 08 09 29 	st.w	r2[r8<<0x2],r9
8001cd78:	58 23       	cp.w	r3,2
8001cd7a:	c1 01       	brne	8001cd9a <__gethex+0x3de>
8001cd7c:	6e 08       	ld.w	r8,r7[0x0]
8001cd7e:	20 18       	sub	r8,1
8001cd80:	10 34       	cp.w	r4,r8
8001cd82:	c2 61       	brne	8001cdce <__gethex+0x412>
8001cd84:	e8 08 14 05 	asr	r8,r4,0x5
8001cd88:	30 19       	mov	r9,1
8001cd8a:	2f b8       	sub	r8,-5
8001cd8c:	f2 04 09 44 	lsl	r4,r9,r4
8001cd90:	ec 08 03 28 	ld.w	r8,r6[r8<<0x2]
8001cd94:	10 64       	and	r4,r8
8001cd96:	c1 b1       	brne	8001cdcc <__gethex+0x410>
8001cd98:	c1 b8       	rjmp	8001cdce <__gethex+0x412>
8001cd9a:	6c 48       	ld.w	r8,r6[0x10]
8001cd9c:	00 38       	cp.w	r8,r0
8001cd9e:	e0 89 00 0e 	brgt	8001cdba <__gethex+0x3fe>
8001cda2:	e9 d4 c0 05 	bfextu	r4,r4,0x0,0x5
8001cda6:	c1 30       	breq	8001cdcc <__gethex+0x410>
8001cda8:	2f c0       	sub	r0,-4
8001cdaa:	e8 04 11 20 	rsub	r4,r4,32
8001cdae:	ec 00 03 2c 	ld.w	r12,r6[r0<<0x2]
8001cdb2:	fe b0 ec c9 	rcall	8001a744 <__hi0bits>
8001cdb6:	08 3c       	cp.w	r12,r4
8001cdb8:	c0 a4       	brge	8001cdcc <__gethex+0x410>
8001cdba:	30 1b       	mov	r11,1
8001cdbc:	0c 9c       	mov	r12,r6
8001cdbe:	fe b0 fd c9 	rcall	8001c950 <rshift>
8001cdc2:	2f f5       	sub	r5,-1
8001cdc4:	6e 28       	ld.w	r8,r7[0x8]
8001cdc6:	10 35       	cp.w	r5,r8
8001cdc8:	fe 99 ff 2e 	brgt	8001cc24 <__gethex+0x268>
8001cdcc:	30 13       	mov	r3,1
8001cdce:	a5 b3       	sbr	r3,0x5
8001cdd0:	c0 28       	rjmp	8001cdd4 <__gethex+0x418>
8001cdd2:	a5 a3       	sbr	r3,0x4
8001cdd4:	40 08       	lddsp	r8,sp[0x0]
8001cdd6:	40 29       	lddsp	r9,sp[0x8]
8001cdd8:	91 06       	st.w	r8[0x0],r6
8001cdda:	93 05       	st.w	r9[0x0],r5
8001cddc:	06 9c       	mov	r12,r3
8001cdde:	2f dd       	sub	sp,-12
8001cde0:	d8 32       	popm	r0-r7,pc
8001cde2:	d7 03       	nop

8001cde4 <__hexnan>:
8001cde4:	d4 31       	pushm	r0-r7,lr
8001cde6:	20 2d       	sub	sp,8
8001cde8:	e0 68 0d 3c 	mov	r8,3388
8001cdec:	18 97       	mov	r7,r12
8001cdee:	f1 39 00 30 	ld.ub	r9,r8[48]
8001cdf2:	16 95       	mov	r5,r11
8001cdf4:	14 96       	mov	r6,r10
8001cdf6:	30 08       	mov	r8,0
8001cdf8:	f0 09 18 00 	cp.b	r9,r8
8001cdfc:	c0 31       	brne	8001ce02 <__hexnan+0x1e>
8001cdfe:	fe b0 fd 7b 	rcall	8001c8f4 <__hexdig_init>
8001ce02:	30 08       	mov	r8,0
8001ce04:	6a 09       	ld.w	r9,r5[0x0]
8001ce06:	10 9b       	mov	r11,r8
8001ce08:	e9 d9 c0 05 	bfextu	r4,r9,0x0,0x5
8001ce0c:	6e 05       	ld.w	r5,r7[0x0]
8001ce0e:	a5 59       	asr	r9,0x5
8001ce10:	16 9a       	mov	r10,r11
8001ce12:	ec 09 00 29 	add	r9,r6,r9<<0x2
8001ce16:	16 92       	mov	r2,r11
8001ce18:	58 04       	cp.w	r4,0
8001ce1a:	f7 b9 01 fc 	subne	r9,-4
8001ce1e:	16 93       	mov	r3,r11
8001ce20:	12 d8       	st.w	--r9,r8
8001ce22:	12 9e       	mov	lr,r9
8001ce24:	12 98       	mov	r8,r9
8001ce26:	c5 48       	rjmp	8001cece <__hexnan+0xea>
8001ce28:	e0 60 0d 3c 	mov	r0,3388
8001ce2c:	e0 0c 07 01 	ld.ub	r1,r0[r12]
8001ce30:	58 01       	cp.w	r1,0
8001ce32:	c3 e1       	brne	8001ceae <__hexnan+0xca>
8001ce34:	e0 4c 00 20 	cp.w	r12,32
8001ce38:	e0 8b 00 2e 	brhi	8001ce94 <__hexnan+0xb0>
8001ce3c:	14 3b       	cp.w	r11,r10
8001ce3e:	c4 84       	brge	8001cece <__hexnan+0xea>
8001ce40:	58 72       	cp.w	r2,7
8001ce42:	5f a1       	srle	r1
8001ce44:	1c 38       	cp.w	r8,lr
8001ce46:	5f 3c       	srlo	r12
8001ce48:	e3 ec 00 0c 	and	r12,r1,r12
8001ce4c:	30 01       	mov	r1,0
8001ce4e:	e2 0c 18 00 	cp.b	r12,r1
8001ce52:	c1 70       	breq	8001ce80 <__hexnan+0x9c>
8001ce54:	e4 02 11 08 	rsub	r2,r2,8
8001ce58:	10 9c       	mov	r12,r8
8001ce5a:	a3 62       	lsl	r2,0x2
8001ce5c:	e4 00 11 20 	rsub	r0,r2,32
8001ce60:	50 10       	stdsp	sp[0x4],r0
8001ce62:	19 01       	ld.w	r1,r12++
8001ce64:	50 01       	stdsp	sp[0x0],r1
8001ce66:	78 01       	ld.w	r1,r12[0x0]
8001ce68:	e2 02 0a 40 	lsr	r0,r1,r2
8001ce6c:	99 00       	st.w	r12[0x0],r0
8001ce6e:	40 10       	lddsp	r0,sp[0x4]
8001ce70:	e2 00 09 41 	lsl	r1,r1,r0
8001ce74:	40 00       	lddsp	r0,sp[0x0]
8001ce76:	00 41       	or	r1,r0
8001ce78:	f9 41 ff fc 	st.w	r12[-4],r1
8001ce7c:	1c 3c       	cp.w	r12,lr
8001ce7e:	cf 23       	brcs	8001ce62 <__hexnan+0x7e>
8001ce80:	0c 38       	cp.w	r8,r6
8001ce82:	e0 8b 00 04 	brhi	8001ce8a <__hexnan+0xa6>
8001ce86:	30 82       	mov	r2,8
8001ce88:	c2 38       	rjmp	8001cece <__hexnan+0xea>
8001ce8a:	10 d3       	st.w	--r8,r3
8001ce8c:	14 9b       	mov	r11,r10
8001ce8e:	10 9e       	mov	lr,r8
8001ce90:	06 92       	mov	r2,r3
8001ce92:	c1 e8       	rjmp	8001cece <__hexnan+0xea>
8001ce94:	58 0a       	cp.w	r10,0
8001ce96:	5f 1b       	srne	r11
8001ce98:	e0 4c 00 29 	cp.w	r12,41
8001ce9c:	5f 0a       	sreq	r10
8001ce9e:	f7 ea 00 0a 	and	r10,r11,r10
8001cea2:	e2 0a 18 00 	cp.b	r10,r1
8001cea6:	c5 90       	breq	8001cf58 <__hexnan+0x174>
8001cea8:	2f f5       	sub	r5,-1
8001ceaa:	8f 05       	st.w	r7[0x0],r5
8001ceac:	c1 78       	rjmp	8001ceda <__hexnan+0xf6>
8001ceae:	2f fa       	sub	r10,-1
8001ceb0:	2f f2       	sub	r2,-1
8001ceb2:	58 82       	cp.w	r2,8
8001ceb4:	e0 8a 00 07 	brle	8001cec2 <__hexnan+0xde>
8001ceb8:	0c 38       	cp.w	r8,r6
8001ceba:	e0 88 00 0a 	brls	8001cece <__hexnan+0xea>
8001cebe:	10 d3       	st.w	--r8,r3
8001cec0:	30 12       	mov	r2,1
8001cec2:	70 0c       	ld.w	r12,r8[0x0]
8001cec4:	e3 d1 c0 04 	bfextu	r1,r1,0x0,0x4
8001cec8:	e3 ec 10 41 	or	r1,r1,r12<<0x4
8001cecc:	91 01       	st.w	r8[0x0],r1
8001cece:	2f f5       	sub	r5,-1
8001ced0:	0b 8c       	ld.ub	r12,r5[0x0]
8001ced2:	58 0c       	cp.w	r12,0
8001ced4:	ca a1       	brne	8001ce28 <__hexnan+0x44>
8001ced6:	58 0a       	cp.w	r10,0
8001ced8:	c4 00       	breq	8001cf58 <__hexnan+0x174>
8001ceda:	58 72       	cp.w	r2,7
8001cedc:	5f ab       	srle	r11
8001cede:	1c 38       	cp.w	r8,lr
8001cee0:	5f 3a       	srlo	r10
8001cee2:	f7 ea 00 0a 	and	r10,r11,r10
8001cee6:	c1 30       	breq	8001cf0c <__hexnan+0x128>
8001cee8:	e4 02 11 08 	rsub	r2,r2,8
8001ceec:	10 9a       	mov	r10,r8
8001ceee:	a3 62       	lsl	r2,0x2
8001cef0:	e4 0c 11 20 	rsub	r12,r2,32
8001cef4:	15 07       	ld.w	r7,r10++
8001cef6:	74 0b       	ld.w	r11,r10[0x0]
8001cef8:	f6 02 0a 45 	lsr	r5,r11,r2
8001cefc:	f6 0c 09 4b 	lsl	r11,r11,r12
8001cf00:	95 05       	st.w	r10[0x0],r5
8001cf02:	0e 4b       	or	r11,r7
8001cf04:	f5 4b ff fc 	st.w	r10[-4],r11
8001cf08:	1c 3a       	cp.w	r10,lr
8001cf0a:	cf 53       	brcs	8001cef4 <__hexnan+0x110>
8001cf0c:	0c 38       	cp.w	r8,r6
8001cf0e:	e0 88 00 0f 	brls	8001cf2c <__hexnan+0x148>
8001cf12:	0c 9a       	mov	r10,r6
8001cf14:	11 0b       	ld.w	r11,r8++
8001cf16:	14 ab       	st.w	r10++,r11
8001cf18:	12 38       	cp.w	r8,r9
8001cf1a:	fe 98 ff fd 	brls	8001cf14 <__hexnan+0x130>
8001cf1e:	30 08       	mov	r8,0
8001cf20:	14 a8       	st.w	r10++,r8
8001cf22:	12 3a       	cp.w	r10,r9
8001cf24:	fe 98 ff fe 	brls	8001cf20 <__hexnan+0x13c>
8001cf28:	c0 d8       	rjmp	8001cf42 <__hexnan+0x15e>
8001cf2a:	d7 03       	nop
8001cf2c:	58 04       	cp.w	r4,0
8001cf2e:	c0 a0       	breq	8001cf42 <__hexnan+0x15e>
8001cf30:	72 08       	ld.w	r8,r9[0x0]
8001cf32:	e8 04 11 20 	rsub	r4,r4,32
8001cf36:	3f fa       	mov	r10,-1
8001cf38:	f4 04 0a 44 	lsr	r4,r10,r4
8001cf3c:	f1 e4 00 04 	and	r4,r8,r4
8001cf40:	93 04       	st.w	r9[0x0],r4
8001cf42:	72 08       	ld.w	r8,r9[0x0]
8001cf44:	58 08       	cp.w	r8,0
8001cf46:	c0 51       	brne	8001cf50 <__hexnan+0x16c>
8001cf48:	0c 39       	cp.w	r9,r6
8001cf4a:	c0 51       	brne	8001cf54 <__hexnan+0x170>
8001cf4c:	30 18       	mov	r8,1
8001cf4e:	93 08       	st.w	r9[0x0],r8
8001cf50:	30 5c       	mov	r12,5
8001cf52:	c0 48       	rjmp	8001cf5a <__hexnan+0x176>
8001cf54:	20 49       	sub	r9,4
8001cf56:	cf 6b       	rjmp	8001cf42 <__hexnan+0x15e>
8001cf58:	30 4c       	mov	r12,4
8001cf5a:	2f ed       	sub	sp,-8
8001cf5c:	d8 32       	popm	r0-r7,pc
8001cf5e:	d7 03       	nop

8001cf60 <_lseek_r>:
8001cf60:	d4 21       	pushm	r4-r7,lr
8001cf62:	16 98       	mov	r8,r11
8001cf64:	18 97       	mov	r7,r12
8001cf66:	10 9c       	mov	r12,r8
8001cf68:	30 08       	mov	r8,0
8001cf6a:	14 9b       	mov	r11,r10
8001cf6c:	e0 66 0d 38 	mov	r6,3384
8001cf70:	12 9a       	mov	r10,r9
8001cf72:	8d 08       	st.w	r6[0x0],r8
8001cf74:	fe b0 c3 d0 	rcall	80015714 <_lseek>
8001cf78:	5b fc       	cp.w	r12,-1
8001cf7a:	c0 51       	brne	8001cf84 <_lseek_r+0x24>
8001cf7c:	6c 08       	ld.w	r8,r6[0x0]
8001cf7e:	58 08       	cp.w	r8,0
8001cf80:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001cf84:	d8 22       	popm	r4-r7,pc
8001cf86:	d7 03       	nop

8001cf88 <_read_r>:
8001cf88:	d4 21       	pushm	r4-r7,lr
8001cf8a:	16 98       	mov	r8,r11
8001cf8c:	18 97       	mov	r7,r12
8001cf8e:	10 9c       	mov	r12,r8
8001cf90:	30 08       	mov	r8,0
8001cf92:	14 9b       	mov	r11,r10
8001cf94:	e0 66 0d 38 	mov	r6,3384
8001cf98:	12 9a       	mov	r10,r9
8001cf9a:	8d 08       	st.w	r6[0x0],r8
8001cf9c:	fe b0 c3 c6 	rcall	80015728 <_read>
8001cfa0:	5b fc       	cp.w	r12,-1
8001cfa2:	c0 51       	brne	8001cfac <_read_r+0x24>
8001cfa4:	6c 08       	ld.w	r8,r6[0x0]
8001cfa6:	58 08       	cp.w	r8,0
8001cfa8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001cfac:	d8 22       	popm	r4-r7,pc
8001cfae:	d7 03       	nop

8001cfb0 <__avr32_f64_sub_from_add>:
8001cfb0:	ee 19 80 00 	eorh	r9,0x8000

8001cfb4 <__avr32_f64_sub>:
8001cfb4:	f7 e9 20 0c 	eor	r12,r11,r9
8001cfb8:	e0 86 00 ca 	brmi	8001d14c <__avr32_f64_add_from_sub>
8001cfbc:	eb cd 40 e0 	pushm	r5-r7,lr
8001cfc0:	16 9c       	mov	r12,r11
8001cfc2:	e6 1c 80 00 	andh	r12,0x8000,COH
8001cfc6:	bf db       	cbr	r11,0x1f
8001cfc8:	bf d9       	cbr	r9,0x1f
8001cfca:	10 3a       	cp.w	r10,r8
8001cfcc:	f2 0b 13 00 	cpc	r11,r9
8001cfd0:	c0 92       	brcc	8001cfe2 <__avr32_f64_sub+0x2e>
8001cfd2:	16 97       	mov	r7,r11
8001cfd4:	12 9b       	mov	r11,r9
8001cfd6:	0e 99       	mov	r9,r7
8001cfd8:	14 97       	mov	r7,r10
8001cfda:	10 9a       	mov	r10,r8
8001cfdc:	0e 98       	mov	r8,r7
8001cfde:	ee 1c 80 00 	eorh	r12,0x8000
8001cfe2:	f6 07 16 14 	lsr	r7,r11,0x14
8001cfe6:	ab 7b       	lsl	r11,0xb
8001cfe8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8001cfec:	ab 7a       	lsl	r10,0xb
8001cfee:	bf bb       	sbr	r11,0x1f
8001cff0:	f2 06 16 14 	lsr	r6,r9,0x14
8001cff4:	c4 40       	breq	8001d07c <__avr32_f64_sub_opL_subnormal>
8001cff6:	ab 79       	lsl	r9,0xb
8001cff8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8001cffc:	ab 78       	lsl	r8,0xb
8001cffe:	bf b9       	sbr	r9,0x1f

8001d000 <__avr32_f64_sub_opL_subnormal_done>:
8001d000:	e0 47 07 ff 	cp.w	r7,2047
8001d004:	c4 f0       	breq	8001d0a2 <__avr32_f64_sub_opH_nan_or_inf>
8001d006:	0e 26       	rsub	r6,r7
8001d008:	c1 20       	breq	8001d02c <__avr32_f64_sub_shift_done>
8001d00a:	ec 05 11 20 	rsub	r5,r6,32
8001d00e:	e0 46 00 20 	cp.w	r6,32
8001d012:	c7 c2       	brcc	8001d10a <__avr32_f64_sub_longshift>
8001d014:	f0 05 09 4e 	lsl	lr,r8,r5
8001d018:	f2 05 09 45 	lsl	r5,r9,r5
8001d01c:	f0 06 0a 48 	lsr	r8,r8,r6
8001d020:	f2 06 0a 49 	lsr	r9,r9,r6
8001d024:	0a 48       	or	r8,r5
8001d026:	58 0e       	cp.w	lr,0
8001d028:	5f 1e       	srne	lr
8001d02a:	1c 48       	or	r8,lr

8001d02c <__avr32_f64_sub_shift_done>:
8001d02c:	10 1a       	sub	r10,r8
8001d02e:	f6 09 01 4b 	sbc	r11,r11,r9
8001d032:	f6 06 12 00 	clz	r6,r11
8001d036:	c0 e0       	breq	8001d052 <__avr32_f64_sub_longnormalize_done>
8001d038:	c7 83       	brcs	8001d128 <__avr32_f64_sub_longnormalize>
8001d03a:	ec 0e 11 20 	rsub	lr,r6,32
8001d03e:	f6 06 09 4b 	lsl	r11,r11,r6
8001d042:	f4 0e 0a 4e 	lsr	lr,r10,lr
8001d046:	1c 4b       	or	r11,lr
8001d048:	f4 06 09 4a 	lsl	r10,r10,r6
8001d04c:	0c 17       	sub	r7,r6
8001d04e:	e0 8a 00 39 	brle	8001d0c0 <__avr32_f64_sub_subnormal_result>

8001d052 <__avr32_f64_sub_longnormalize_done>:
8001d052:	f4 09 15 15 	lsl	r9,r10,0x15
8001d056:	ab 9a       	lsr	r10,0xb
8001d058:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8001d05c:	ab 9b       	lsr	r11,0xb
8001d05e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8001d062:	18 4b       	or	r11,r12

8001d064 <__avr32_f64_sub_round>:
8001d064:	fc 17 80 00 	movh	r7,0x8000
8001d068:	ed ba 00 00 	bld	r10,0x0
8001d06c:	f7 b7 01 ff 	subne	r7,-1
8001d070:	0e 39       	cp.w	r9,r7
8001d072:	5f 29       	srhs	r9
8001d074:	12 0a       	add	r10,r9
8001d076:	5c 0b       	acr	r11
8001d078:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d07c <__avr32_f64_sub_opL_subnormal>:
8001d07c:	ab 79       	lsl	r9,0xb
8001d07e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8001d082:	ab 78       	lsl	r8,0xb
8001d084:	f3 e8 10 0e 	or	lr,r9,r8
8001d088:	f9 b6 01 01 	movne	r6,1
8001d08c:	ee 0e 11 00 	rsub	lr,r7,0
8001d090:	f9 b7 00 01 	moveq	r7,1
8001d094:	ef bb 00 1f 	bst	r11,0x1f
8001d098:	f7 ea 10 0e 	or	lr,r11,r10
8001d09c:	f9 b7 00 00 	moveq	r7,0
8001d0a0:	cb 0b       	rjmp	8001d000 <__avr32_f64_sub_opL_subnormal_done>

8001d0a2 <__avr32_f64_sub_opH_nan_or_inf>:
8001d0a2:	bf db       	cbr	r11,0x1f
8001d0a4:	f7 ea 10 0e 	or	lr,r11,r10
8001d0a8:	c0 81       	brne	8001d0b8 <__avr32_f64_sub_return_nan>
8001d0aa:	e0 46 07 ff 	cp.w	r6,2047
8001d0ae:	c0 50       	breq	8001d0b8 <__avr32_f64_sub_return_nan>
8001d0b0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8001d0b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d0b8 <__avr32_f64_sub_return_nan>:
8001d0b8:	3f fa       	mov	r10,-1
8001d0ba:	3f fb       	mov	r11,-1
8001d0bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d0c0 <__avr32_f64_sub_subnormal_result>:
8001d0c0:	5c 37       	neg	r7
8001d0c2:	2f f7       	sub	r7,-1
8001d0c4:	f1 b7 04 c0 	satu	r7,0x6
8001d0c8:	e0 47 00 20 	cp.w	r7,32
8001d0cc:	c1 14       	brge	8001d0ee <__avr32_f64_sub_subnormal_result+0x2e>
8001d0ce:	ee 08 11 20 	rsub	r8,r7,32
8001d0d2:	f4 08 09 49 	lsl	r9,r10,r8
8001d0d6:	5f 16       	srne	r6
8001d0d8:	f4 07 0a 4a 	lsr	r10,r10,r7
8001d0dc:	0c 4a       	or	r10,r6
8001d0de:	f6 08 09 49 	lsl	r9,r11,r8
8001d0e2:	f5 e9 10 0a 	or	r10,r10,r9
8001d0e6:	f4 07 0a 4b 	lsr	r11,r10,r7
8001d0ea:	30 07       	mov	r7,0
8001d0ec:	cb 3b       	rjmp	8001d052 <__avr32_f64_sub_longnormalize_done>
8001d0ee:	ee 08 11 40 	rsub	r8,r7,64
8001d0f2:	f6 08 09 49 	lsl	r9,r11,r8
8001d0f6:	14 49       	or	r9,r10
8001d0f8:	5f 16       	srne	r6
8001d0fa:	f6 07 0a 4a 	lsr	r10,r11,r7
8001d0fe:	0c 4a       	or	r10,r6
8001d100:	30 0b       	mov	r11,0
8001d102:	30 07       	mov	r7,0
8001d104:	ca 7b       	rjmp	8001d052 <__avr32_f64_sub_longnormalize_done>
8001d106:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d10a <__avr32_f64_sub_longshift>:
8001d10a:	f1 b6 04 c0 	satu	r6,0x6
8001d10e:	f0 0e 17 00 	moveq	lr,r8
8001d112:	c0 40       	breq	8001d11a <__avr32_f64_sub_longshift+0x10>
8001d114:	f2 05 09 4e 	lsl	lr,r9,r5
8001d118:	10 4e       	or	lr,r8
8001d11a:	f2 06 0a 48 	lsr	r8,r9,r6
8001d11e:	30 09       	mov	r9,0
8001d120:	58 0e       	cp.w	lr,0
8001d122:	5f 1e       	srne	lr
8001d124:	1c 48       	or	r8,lr
8001d126:	c8 3b       	rjmp	8001d02c <__avr32_f64_sub_shift_done>

8001d128 <__avr32_f64_sub_longnormalize>:
8001d128:	f4 06 12 00 	clz	r6,r10
8001d12c:	f9 b7 03 00 	movlo	r7,0
8001d130:	f9 b6 03 00 	movlo	r6,0
8001d134:	f9 bc 03 00 	movlo	r12,0
8001d138:	f7 b6 02 e0 	subhs	r6,-32
8001d13c:	f4 06 09 4b 	lsl	r11,r10,r6
8001d140:	30 0a       	mov	r10,0
8001d142:	0c 17       	sub	r7,r6
8001d144:	fe 9a ff be 	brle	8001d0c0 <__avr32_f64_sub_subnormal_result>
8001d148:	c8 5b       	rjmp	8001d052 <__avr32_f64_sub_longnormalize_done>
8001d14a:	d7 03       	nop

8001d14c <__avr32_f64_add_from_sub>:
8001d14c:	ee 19 80 00 	eorh	r9,0x8000

8001d150 <__avr32_f64_add>:
8001d150:	f7 e9 20 0c 	eor	r12,r11,r9
8001d154:	fe 96 ff 2e 	brmi	8001cfb0 <__avr32_f64_sub_from_add>
8001d158:	eb cd 40 e0 	pushm	r5-r7,lr
8001d15c:	16 9c       	mov	r12,r11
8001d15e:	e6 1c 80 00 	andh	r12,0x8000,COH
8001d162:	bf db       	cbr	r11,0x1f
8001d164:	bf d9       	cbr	r9,0x1f
8001d166:	12 3b       	cp.w	r11,r9
8001d168:	c0 72       	brcc	8001d176 <__avr32_f64_add+0x26>
8001d16a:	16 97       	mov	r7,r11
8001d16c:	12 9b       	mov	r11,r9
8001d16e:	0e 99       	mov	r9,r7
8001d170:	14 97       	mov	r7,r10
8001d172:	10 9a       	mov	r10,r8
8001d174:	0e 98       	mov	r8,r7
8001d176:	30 0e       	mov	lr,0
8001d178:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8001d17c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8001d180:	b5 ab       	sbr	r11,0x14
8001d182:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8001d186:	c6 20       	breq	8001d24a <__avr32_f64_add_op2_subnormal>
8001d188:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8001d18c:	b5 a9       	sbr	r9,0x14
8001d18e:	e0 47 07 ff 	cp.w	r7,2047
8001d192:	c2 80       	breq	8001d1e2 <__avr32_f64_add_opH_nan_or_inf>
8001d194:	0e 26       	rsub	r6,r7
8001d196:	c1 20       	breq	8001d1ba <__avr32_f64_add_shift_done>
8001d198:	e0 46 00 36 	cp.w	r6,54
8001d19c:	c1 52       	brcc	8001d1c6 <__avr32_f64_add_res_of_done>
8001d19e:	ec 05 11 20 	rsub	r5,r6,32
8001d1a2:	e0 46 00 20 	cp.w	r6,32
8001d1a6:	c3 52       	brcc	8001d210 <__avr32_f64_add_longshift>
8001d1a8:	f0 05 09 4e 	lsl	lr,r8,r5
8001d1ac:	f2 05 09 45 	lsl	r5,r9,r5
8001d1b0:	f0 06 0a 48 	lsr	r8,r8,r6
8001d1b4:	f2 06 0a 49 	lsr	r9,r9,r6
8001d1b8:	0a 48       	or	r8,r5

8001d1ba <__avr32_f64_add_shift_done>:
8001d1ba:	10 0a       	add	r10,r8
8001d1bc:	f6 09 00 4b 	adc	r11,r11,r9
8001d1c0:	ed bb 00 15 	bld	r11,0x15
8001d1c4:	c3 40       	breq	8001d22c <__avr32_f64_add_res_of>

8001d1c6 <__avr32_f64_add_res_of_done>:
8001d1c6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8001d1ca:	18 4b       	or	r11,r12

8001d1cc <__avr32_f64_add_round>:
8001d1cc:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8001d1d0:	18 4e       	or	lr,r12
8001d1d2:	ee 1e 80 00 	eorh	lr,0x8000
8001d1d6:	f1 be 04 20 	satu	lr,0x1
8001d1da:	1c 0a       	add	r10,lr
8001d1dc:	5c 0b       	acr	r11
8001d1de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d1e2 <__avr32_f64_add_opH_nan_or_inf>:
8001d1e2:	b5 cb       	cbr	r11,0x14
8001d1e4:	f7 ea 10 0e 	or	lr,r11,r10
8001d1e8:	c1 01       	brne	8001d208 <__avr32_f64_add_return_nan>
8001d1ea:	e0 46 07 ff 	cp.w	r6,2047
8001d1ee:	c0 30       	breq	8001d1f4 <__avr32_f64_add_opL_nan_or_inf>
8001d1f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d1f4 <__avr32_f64_add_opL_nan_or_inf>:
8001d1f4:	b5 c9       	cbr	r9,0x14
8001d1f6:	f3 e8 10 0e 	or	lr,r9,r8
8001d1fa:	c0 71       	brne	8001d208 <__avr32_f64_add_return_nan>
8001d1fc:	30 0a       	mov	r10,0
8001d1fe:	fc 1b 7f f0 	movh	r11,0x7ff0
8001d202:	18 4b       	or	r11,r12
8001d204:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d208 <__avr32_f64_add_return_nan>:
8001d208:	3f fa       	mov	r10,-1
8001d20a:	3f fb       	mov	r11,-1
8001d20c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8001d210 <__avr32_f64_add_longshift>:
8001d210:	f1 b6 04 c0 	satu	r6,0x6
8001d214:	f0 0e 17 00 	moveq	lr,r8
8001d218:	c0 60       	breq	8001d224 <__avr32_f64_add_longshift+0x14>
8001d21a:	f2 05 09 4e 	lsl	lr,r9,r5
8001d21e:	58 08       	cp.w	r8,0
8001d220:	5f 18       	srne	r8
8001d222:	10 4e       	or	lr,r8
8001d224:	f2 06 0a 48 	lsr	r8,r9,r6
8001d228:	30 09       	mov	r9,0
8001d22a:	cc 8b       	rjmp	8001d1ba <__avr32_f64_add_shift_done>

8001d22c <__avr32_f64_add_res_of>:
8001d22c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8001d230:	a1 9b       	lsr	r11,0x1
8001d232:	5d 0a       	ror	r10
8001d234:	5d 0e       	ror	lr
8001d236:	2f f7       	sub	r7,-1
8001d238:	e0 47 07 ff 	cp.w	r7,2047
8001d23c:	f9 ba 00 00 	moveq	r10,0
8001d240:	f9 bb 00 00 	moveq	r11,0
8001d244:	f9 be 00 00 	moveq	lr,0
8001d248:	cb fb       	rjmp	8001d1c6 <__avr32_f64_add_res_of_done>

8001d24a <__avr32_f64_add_op2_subnormal>:
8001d24a:	30 16       	mov	r6,1
8001d24c:	58 07       	cp.w	r7,0
8001d24e:	ca 01       	brne	8001d18e <__avr32_f64_add+0x3e>
8001d250:	b5 cb       	cbr	r11,0x14
8001d252:	10 0a       	add	r10,r8
8001d254:	f6 09 00 4b 	adc	r11,r11,r9
8001d258:	18 4b       	or	r11,r12
8001d25a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8001d25e:	d7 03       	nop

8001d260 <__avr32_f64_cmp_eq>:
8001d260:	10 3a       	cp.w	r10,r8
8001d262:	f2 0b 13 00 	cpc	r11,r9
8001d266:	c0 80       	breq	8001d276 <__avr32_f64_cmp_eq+0x16>
8001d268:	a1 7b       	lsl	r11,0x1
8001d26a:	a1 79       	lsl	r9,0x1
8001d26c:	14 4b       	or	r11,r10
8001d26e:	12 4b       	or	r11,r9
8001d270:	10 4b       	or	r11,r8
8001d272:	5e 0f       	reteq	1
8001d274:	5e fd       	retal	0
8001d276:	a1 7b       	lsl	r11,0x1
8001d278:	fc 1c ff e0 	movh	r12,0xffe0
8001d27c:	58 0a       	cp.w	r10,0
8001d27e:	f8 0b 13 00 	cpc	r11,r12
8001d282:	5e 8f       	retls	1
8001d284:	5e fd       	retal	0

8001d286 <__avr32_f64_cmp_ge>:
8001d286:	1a de       	st.w	--sp,lr
8001d288:	1a d7       	st.w	--sp,r7
8001d28a:	a1 7b       	lsl	r11,0x1
8001d28c:	5f 3c       	srlo	r12
8001d28e:	a1 79       	lsl	r9,0x1
8001d290:	5f 37       	srlo	r7
8001d292:	5c fc       	rol	r12
8001d294:	fc 1e ff e0 	movh	lr,0xffe0
8001d298:	58 0a       	cp.w	r10,0
8001d29a:	fc 0b 13 00 	cpc	r11,lr
8001d29e:	e0 8b 00 1d 	brhi	8001d2d8 <__avr32_f64_cmp_ge+0x52>
8001d2a2:	58 08       	cp.w	r8,0
8001d2a4:	fc 09 13 00 	cpc	r9,lr
8001d2a8:	e0 8b 00 18 	brhi	8001d2d8 <__avr32_f64_cmp_ge+0x52>
8001d2ac:	58 0b       	cp.w	r11,0
8001d2ae:	f5 ba 00 00 	subfeq	r10,0
8001d2b2:	c1 50       	breq	8001d2dc <__avr32_f64_cmp_ge+0x56>
8001d2b4:	1b 07       	ld.w	r7,sp++
8001d2b6:	1b 0e       	ld.w	lr,sp++
8001d2b8:	58 3c       	cp.w	r12,3
8001d2ba:	c0 a0       	breq	8001d2ce <__avr32_f64_cmp_ge+0x48>
8001d2bc:	58 1c       	cp.w	r12,1
8001d2be:	c0 33       	brcs	8001d2c4 <__avr32_f64_cmp_ge+0x3e>
8001d2c0:	5e 0f       	reteq	1
8001d2c2:	5e 1d       	retne	0
8001d2c4:	10 3a       	cp.w	r10,r8
8001d2c6:	f2 0b 13 00 	cpc	r11,r9
8001d2ca:	5e 2f       	reths	1
8001d2cc:	5e 3d       	retlo	0
8001d2ce:	14 38       	cp.w	r8,r10
8001d2d0:	f6 09 13 00 	cpc	r9,r11
8001d2d4:	5e 2f       	reths	1
8001d2d6:	5e 3d       	retlo	0
8001d2d8:	1b 07       	ld.w	r7,sp++
8001d2da:	d8 0a       	popm	pc,r12=0
8001d2dc:	58 17       	cp.w	r7,1
8001d2de:	5f 0c       	sreq	r12
8001d2e0:	58 09       	cp.w	r9,0
8001d2e2:	f5 b8 00 00 	subfeq	r8,0
8001d2e6:	1b 07       	ld.w	r7,sp++
8001d2e8:	1b 0e       	ld.w	lr,sp++
8001d2ea:	5e 0f       	reteq	1
8001d2ec:	5e fc       	retal	r12

8001d2ee <__avr32_f64_cmp_lt>:
8001d2ee:	1a de       	st.w	--sp,lr
8001d2f0:	1a d7       	st.w	--sp,r7
8001d2f2:	a1 7b       	lsl	r11,0x1
8001d2f4:	5f 3c       	srlo	r12
8001d2f6:	a1 79       	lsl	r9,0x1
8001d2f8:	5f 37       	srlo	r7
8001d2fa:	5c fc       	rol	r12
8001d2fc:	fc 1e ff e0 	movh	lr,0xffe0
8001d300:	58 0a       	cp.w	r10,0
8001d302:	fc 0b 13 00 	cpc	r11,lr
8001d306:	e0 8b 00 1d 	brhi	8001d340 <__avr32_f64_cmp_lt+0x52>
8001d30a:	58 08       	cp.w	r8,0
8001d30c:	fc 09 13 00 	cpc	r9,lr
8001d310:	e0 8b 00 18 	brhi	8001d340 <__avr32_f64_cmp_lt+0x52>
8001d314:	58 0b       	cp.w	r11,0
8001d316:	f5 ba 00 00 	subfeq	r10,0
8001d31a:	c1 50       	breq	8001d344 <__avr32_f64_cmp_lt+0x56>
8001d31c:	1b 07       	ld.w	r7,sp++
8001d31e:	1b 0e       	ld.w	lr,sp++
8001d320:	58 3c       	cp.w	r12,3
8001d322:	c0 a0       	breq	8001d336 <__avr32_f64_cmp_lt+0x48>
8001d324:	58 1c       	cp.w	r12,1
8001d326:	c0 33       	brcs	8001d32c <__avr32_f64_cmp_lt+0x3e>
8001d328:	5e 0d       	reteq	0
8001d32a:	5e 1f       	retne	1
8001d32c:	10 3a       	cp.w	r10,r8
8001d32e:	f2 0b 13 00 	cpc	r11,r9
8001d332:	5e 2d       	reths	0
8001d334:	5e 3f       	retlo	1
8001d336:	14 38       	cp.w	r8,r10
8001d338:	f6 09 13 00 	cpc	r9,r11
8001d33c:	5e 2d       	reths	0
8001d33e:	5e 3f       	retlo	1
8001d340:	1b 07       	ld.w	r7,sp++
8001d342:	d8 0a       	popm	pc,r12=0
8001d344:	58 17       	cp.w	r7,1
8001d346:	5f 1c       	srne	r12
8001d348:	58 09       	cp.w	r9,0
8001d34a:	f5 b8 00 00 	subfeq	r8,0
8001d34e:	1b 07       	ld.w	r7,sp++
8001d350:	1b 0e       	ld.w	lr,sp++
8001d352:	5e 0d       	reteq	0
8001d354:	5e fc       	retal	r12
8001d356:	d7 03       	nop

8001d358 <__avr32_f64_div>:
8001d358:	eb cd 40 ff 	pushm	r0-r7,lr
8001d35c:	f7 e9 20 0e 	eor	lr,r11,r9
8001d360:	f6 07 16 14 	lsr	r7,r11,0x14
8001d364:	a9 7b       	lsl	r11,0x9
8001d366:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8001d36a:	a9 7a       	lsl	r10,0x9
8001d36c:	bd bb       	sbr	r11,0x1d
8001d36e:	e4 1b 3f ff 	andh	r11,0x3fff
8001d372:	ab d7       	cbr	r7,0xb
8001d374:	e0 80 00 cc 	breq	8001d50c <__avr32_f64_div_round_subnormal+0x54>
8001d378:	e0 47 07 ff 	cp.w	r7,2047
8001d37c:	e0 84 00 b5 	brge	8001d4e6 <__avr32_f64_div_round_subnormal+0x2e>
8001d380:	f2 06 16 14 	lsr	r6,r9,0x14
8001d384:	a9 79       	lsl	r9,0x9
8001d386:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8001d38a:	a9 78       	lsl	r8,0x9
8001d38c:	bd b9       	sbr	r9,0x1d
8001d38e:	e4 19 3f ff 	andh	r9,0x3fff
8001d392:	ab d6       	cbr	r6,0xb
8001d394:	e0 80 00 e2 	breq	8001d558 <__avr32_f64_div_round_subnormal+0xa0>
8001d398:	e0 46 07 ff 	cp.w	r6,2047
8001d39c:	e0 84 00 b2 	brge	8001d500 <__avr32_f64_div_round_subnormal+0x48>
8001d3a0:	0c 17       	sub	r7,r6
8001d3a2:	fe 37 fc 01 	sub	r7,-1023
8001d3a6:	fc 1c 80 00 	movh	r12,0x8000
8001d3aa:	f8 03 16 01 	lsr	r3,r12,0x1
8001d3ae:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8001d3b2:	5c d4       	com	r4
8001d3b4:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8001d3b8:	e6 09 06 44 	mulu.d	r4,r3,r9
8001d3bc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001d3c0:	e6 05 06 44 	mulu.d	r4,r3,r5
8001d3c4:	ea 03 15 02 	lsl	r3,r5,0x2
8001d3c8:	e6 09 06 44 	mulu.d	r4,r3,r9
8001d3cc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001d3d0:	e6 05 06 44 	mulu.d	r4,r3,r5
8001d3d4:	ea 03 15 02 	lsl	r3,r5,0x2
8001d3d8:	e6 09 06 44 	mulu.d	r4,r3,r9
8001d3dc:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8001d3e0:	e6 05 06 44 	mulu.d	r4,r3,r5
8001d3e4:	ea 03 15 02 	lsl	r3,r5,0x2
8001d3e8:	e6 08 06 40 	mulu.d	r0,r3,r8
8001d3ec:	e4 09 07 40 	macu.d	r0,r2,r9
8001d3f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8001d3f4:	02 04       	add	r4,r1
8001d3f6:	5c 05       	acr	r5
8001d3f8:	a3 65       	lsl	r5,0x2
8001d3fa:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8001d3fe:	a3 64       	lsl	r4,0x2
8001d400:	5c 34       	neg	r4
8001d402:	f8 05 01 45 	sbc	r5,r12,r5
8001d406:	e6 04 06 40 	mulu.d	r0,r3,r4
8001d40a:	e4 05 07 40 	macu.d	r0,r2,r5
8001d40e:	e6 05 06 44 	mulu.d	r4,r3,r5
8001d412:	02 04       	add	r4,r1
8001d414:	5c 05       	acr	r5
8001d416:	ea 03 15 02 	lsl	r3,r5,0x2
8001d41a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001d41e:	e8 02 15 02 	lsl	r2,r4,0x2
8001d422:	e6 08 06 40 	mulu.d	r0,r3,r8
8001d426:	e4 09 07 40 	macu.d	r0,r2,r9
8001d42a:	e6 09 06 44 	mulu.d	r4,r3,r9
8001d42e:	02 04       	add	r4,r1
8001d430:	5c 05       	acr	r5
8001d432:	a3 65       	lsl	r5,0x2
8001d434:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8001d438:	a3 64       	lsl	r4,0x2
8001d43a:	5c 34       	neg	r4
8001d43c:	f8 05 01 45 	sbc	r5,r12,r5
8001d440:	e6 04 06 40 	mulu.d	r0,r3,r4
8001d444:	e4 05 07 40 	macu.d	r0,r2,r5
8001d448:	e6 05 06 44 	mulu.d	r4,r3,r5
8001d44c:	02 04       	add	r4,r1
8001d44e:	5c 05       	acr	r5
8001d450:	ea 03 15 02 	lsl	r3,r5,0x2
8001d454:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8001d458:	e8 02 15 02 	lsl	r2,r4,0x2
8001d45c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8001d460:	e4 0b 07 40 	macu.d	r0,r2,r11
8001d464:	e6 0b 06 42 	mulu.d	r2,r3,r11
8001d468:	02 02       	add	r2,r1
8001d46a:	5c 03       	acr	r3
8001d46c:	ed b3 00 1c 	bld	r3,0x1c
8001d470:	c0 90       	breq	8001d482 <__avr32_f64_div+0x12a>
8001d472:	a1 72       	lsl	r2,0x1
8001d474:	5c f3       	rol	r3
8001d476:	20 17       	sub	r7,1
8001d478:	a3 9a       	lsr	r10,0x3
8001d47a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8001d47e:	a3 9b       	lsr	r11,0x3
8001d480:	c0 58       	rjmp	8001d48a <__avr32_f64_div+0x132>
8001d482:	a5 8a       	lsr	r10,0x4
8001d484:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8001d488:	a5 8b       	lsr	r11,0x4
8001d48a:	58 07       	cp.w	r7,0
8001d48c:	e0 8a 00 8b 	brle	8001d5a2 <__avr32_f64_div_res_subnormal>
8001d490:	e0 12 ff 00 	andl	r2,0xff00
8001d494:	e8 12 00 80 	orl	r2,0x80
8001d498:	e6 08 06 40 	mulu.d	r0,r3,r8
8001d49c:	e4 09 07 40 	macu.d	r0,r2,r9
8001d4a0:	e4 08 06 44 	mulu.d	r4,r2,r8
8001d4a4:	e6 09 06 48 	mulu.d	r8,r3,r9
8001d4a8:	00 05       	add	r5,r0
8001d4aa:	f0 01 00 48 	adc	r8,r8,r1
8001d4ae:	5c 09       	acr	r9
8001d4b0:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8001d4b4:	58 04       	cp.w	r4,0
8001d4b6:	5c 25       	cpc	r5

8001d4b8 <__avr32_f64_div_round_subnormal>:
8001d4b8:	f4 08 13 00 	cpc	r8,r10
8001d4bc:	f6 09 13 00 	cpc	r9,r11
8001d4c0:	5f 36       	srlo	r6
8001d4c2:	f8 06 17 00 	moveq	r6,r12
8001d4c6:	e4 0a 16 08 	lsr	r10,r2,0x8
8001d4ca:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8001d4ce:	e6 0b 16 08 	lsr	r11,r3,0x8
8001d4d2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8001d4d6:	ed be 00 1f 	bld	lr,0x1f
8001d4da:	ef bb 00 1f 	bst	r11,0x1f
8001d4de:	0c 0a       	add	r10,r6
8001d4e0:	5c 0b       	acr	r11
8001d4e2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001d4e6:	e4 1b 00 0f 	andh	r11,0xf
8001d4ea:	14 4b       	or	r11,r10
8001d4ec:	e0 81 00 a7 	brne	8001d63a <__avr32_f64_div_res_subnormal+0x98>
8001d4f0:	f2 06 16 14 	lsr	r6,r9,0x14
8001d4f4:	ab d6       	cbr	r6,0xb
8001d4f6:	e0 46 07 ff 	cp.w	r6,2047
8001d4fa:	e0 81 00 a4 	brne	8001d642 <__avr32_f64_div_res_subnormal+0xa0>
8001d4fe:	c9 e8       	rjmp	8001d63a <__avr32_f64_div_res_subnormal+0x98>
8001d500:	e4 19 00 0f 	andh	r9,0xf
8001d504:	10 49       	or	r9,r8
8001d506:	e0 81 00 9a 	brne	8001d63a <__avr32_f64_div_res_subnormal+0x98>
8001d50a:	c9 28       	rjmp	8001d62e <__avr32_f64_div_res_subnormal+0x8c>
8001d50c:	a3 7b       	lsl	r11,0x3
8001d50e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8001d512:	a3 7a       	lsl	r10,0x3
8001d514:	f5 eb 10 04 	or	r4,r10,r11
8001d518:	e0 80 00 a0 	breq	8001d658 <__avr32_f64_div_op1_zero>
8001d51c:	f6 04 12 00 	clz	r4,r11
8001d520:	c1 70       	breq	8001d54e <__avr32_f64_div_round_subnormal+0x96>
8001d522:	c0 c3       	brcs	8001d53a <__avr32_f64_div_round_subnormal+0x82>
8001d524:	e8 05 11 20 	rsub	r5,r4,32
8001d528:	f6 04 09 4b 	lsl	r11,r11,r4
8001d52c:	f4 05 0a 45 	lsr	r5,r10,r5
8001d530:	0a 4b       	or	r11,r5
8001d532:	f4 04 09 4a 	lsl	r10,r10,r4
8001d536:	08 17       	sub	r7,r4
8001d538:	c0 b8       	rjmp	8001d54e <__avr32_f64_div_round_subnormal+0x96>
8001d53a:	f4 04 12 00 	clz	r4,r10
8001d53e:	f9 b4 03 00 	movlo	r4,0
8001d542:	f7 b4 02 e0 	subhs	r4,-32
8001d546:	f4 04 09 4b 	lsl	r11,r10,r4
8001d54a:	30 0a       	mov	r10,0
8001d54c:	08 17       	sub	r7,r4
8001d54e:	a3 8a       	lsr	r10,0x2
8001d550:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8001d554:	a3 8b       	lsr	r11,0x2
8001d556:	c1 1b       	rjmp	8001d378 <__avr32_f64_div+0x20>
8001d558:	a3 79       	lsl	r9,0x3
8001d55a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8001d55e:	a3 78       	lsl	r8,0x3
8001d560:	f3 e8 10 04 	or	r4,r9,r8
8001d564:	c6 f0       	breq	8001d642 <__avr32_f64_div_res_subnormal+0xa0>
8001d566:	f2 04 12 00 	clz	r4,r9
8001d56a:	c1 70       	breq	8001d598 <__avr32_f64_div_round_subnormal+0xe0>
8001d56c:	c0 c3       	brcs	8001d584 <__avr32_f64_div_round_subnormal+0xcc>
8001d56e:	e8 05 11 20 	rsub	r5,r4,32
8001d572:	f2 04 09 49 	lsl	r9,r9,r4
8001d576:	f0 05 0a 45 	lsr	r5,r8,r5
8001d57a:	0a 49       	or	r9,r5
8001d57c:	f0 04 09 48 	lsl	r8,r8,r4
8001d580:	08 16       	sub	r6,r4
8001d582:	c0 b8       	rjmp	8001d598 <__avr32_f64_div_round_subnormal+0xe0>
8001d584:	f0 04 12 00 	clz	r4,r8
8001d588:	f9 b4 03 00 	movlo	r4,0
8001d58c:	f7 b4 02 e0 	subhs	r4,-32
8001d590:	f0 04 09 49 	lsl	r9,r8,r4
8001d594:	30 08       	mov	r8,0
8001d596:	08 16       	sub	r6,r4
8001d598:	a3 88       	lsr	r8,0x2
8001d59a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8001d59e:	a3 89       	lsr	r9,0x2
8001d5a0:	cf ca       	rjmp	8001d398 <__avr32_f64_div+0x40>

8001d5a2 <__avr32_f64_div_res_subnormal>:
8001d5a2:	5c 37       	neg	r7
8001d5a4:	2f f7       	sub	r7,-1
8001d5a6:	f1 b7 04 c0 	satu	r7,0x6
8001d5aa:	e0 47 00 20 	cp.w	r7,32
8001d5ae:	c1 54       	brge	8001d5d8 <__avr32_f64_div_res_subnormal+0x36>
8001d5b0:	ee 06 11 20 	rsub	r6,r7,32
8001d5b4:	e4 07 0a 42 	lsr	r2,r2,r7
8001d5b8:	e6 06 09 4c 	lsl	r12,r3,r6
8001d5bc:	18 42       	or	r2,r12
8001d5be:	e6 07 0a 43 	lsr	r3,r3,r7
8001d5c2:	f4 06 09 41 	lsl	r1,r10,r6
8001d5c6:	f4 07 0a 4a 	lsr	r10,r10,r7
8001d5ca:	f6 06 09 4c 	lsl	r12,r11,r6
8001d5ce:	18 4a       	or	r10,r12
8001d5d0:	f6 07 0a 4b 	lsr	r11,r11,r7
8001d5d4:	30 00       	mov	r0,0
8001d5d6:	c1 58       	rjmp	8001d600 <__avr32_f64_div_res_subnormal+0x5e>
8001d5d8:	ee 06 11 20 	rsub	r6,r7,32
8001d5dc:	f9 b0 00 00 	moveq	r0,0
8001d5e0:	f9 bc 00 00 	moveq	r12,0
8001d5e4:	c0 50       	breq	8001d5ee <__avr32_f64_div_res_subnormal+0x4c>
8001d5e6:	f4 06 09 40 	lsl	r0,r10,r6
8001d5ea:	f6 06 09 4c 	lsl	r12,r11,r6
8001d5ee:	e6 07 0a 42 	lsr	r2,r3,r7
8001d5f2:	30 03       	mov	r3,0
8001d5f4:	f4 07 0a 41 	lsr	r1,r10,r7
8001d5f8:	18 41       	or	r1,r12
8001d5fa:	f6 07 0a 4a 	lsr	r10,r11,r7
8001d5fe:	30 0b       	mov	r11,0
8001d600:	e0 12 ff 00 	andl	r2,0xff00
8001d604:	e8 12 00 80 	orl	r2,0x80
8001d608:	e6 08 06 46 	mulu.d	r6,r3,r8
8001d60c:	e4 09 07 46 	macu.d	r6,r2,r9
8001d610:	e4 08 06 44 	mulu.d	r4,r2,r8
8001d614:	e6 09 06 48 	mulu.d	r8,r3,r9
8001d618:	0c 05       	add	r5,r6
8001d61a:	f0 07 00 48 	adc	r8,r8,r7
8001d61e:	5c 09       	acr	r9
8001d620:	30 07       	mov	r7,0
8001d622:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8001d626:	00 34       	cp.w	r4,r0
8001d628:	e2 05 13 00 	cpc	r5,r1
8001d62c:	c4 6b       	rjmp	8001d4b8 <__avr32_f64_div_round_subnormal>
8001d62e:	1c 9b       	mov	r11,lr
8001d630:	e6 1b 80 00 	andh	r11,0x8000,COH
8001d634:	30 0a       	mov	r10,0
8001d636:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001d63a:	3f fb       	mov	r11,-1
8001d63c:	30 0a       	mov	r10,0
8001d63e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001d642:	f5 eb 10 04 	or	r4,r10,r11
8001d646:	c0 90       	breq	8001d658 <__avr32_f64_div_op1_zero>
8001d648:	1c 9b       	mov	r11,lr
8001d64a:	e6 1b 80 00 	andh	r11,0x8000,COH
8001d64e:	ea 1b 7f f0 	orh	r11,0x7ff0
8001d652:	30 0a       	mov	r10,0
8001d654:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8001d658 <__avr32_f64_div_op1_zero>:
8001d658:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8001d65c:	ce f0       	breq	8001d63a <__avr32_f64_div_res_subnormal+0x98>
8001d65e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8001d662:	e0 44 07 ff 	cp.w	r4,2047
8001d666:	ce 41       	brne	8001d62e <__avr32_f64_div_res_subnormal+0x8c>
8001d668:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8001d66c:	ce 10       	breq	8001d62e <__avr32_f64_div_res_subnormal+0x8c>
8001d66e:	ce 6b       	rjmp	8001d63a <__avr32_f64_div_res_subnormal+0x98>

8001d670 <__avr32_f64_to_f32>:
8001d670:	f6 09 15 01 	lsl	r9,r11,0x1
8001d674:	b5 99       	lsr	r9,0x15
8001d676:	5e 0d       	reteq	0
8001d678:	f6 08 15 0a 	lsl	r8,r11,0xa
8001d67c:	f1 ea 13 6c 	or	r12,r8,r10>>0x16
8001d680:	ab 6a       	lsl	r10,0xa
8001d682:	5c 3a       	neg	r10
8001d684:	5c fc       	rol	r12
8001d686:	e0 49 07 ff 	cp.w	r9,2047
8001d68a:	c1 a0       	breq	8001d6be <__truncdfsf_return_op1+0x6>
8001d68c:	e0 29 03 80 	sub	r9,896
8001d690:	bf bc       	sbr	r12,0x1f
8001d692:	58 09       	cp.w	r9,0
8001d694:	e0 8a 00 1a 	brle	8001d6c8 <__truncdfsf_return_op1+0x10>
8001d698:	37 fa       	mov	r10,127
8001d69a:	ed bc 00 08 	bld	r12,0x8
8001d69e:	f7 ba 00 ff 	subeq	r10,-1
8001d6a2:	14 0c       	add	r12,r10
8001d6a4:	f7 b9 03 fe 	sublo	r9,-2
8001d6a8:	ed bc 00 1f 	bld	r12,0x1f
8001d6ac:	f7 b9 01 01 	subne	r9,1
8001d6b0:	f8 0c 16 07 	lsr	r12,r12,0x7
8001d6b4:	f9 d9 d3 08 	bfins	r12,r9,0x18,0x8

8001d6b8 <__truncdfsf_return_op1>:
8001d6b8:	a1 7b       	lsl	r11,0x1
8001d6ba:	5d 0c       	ror	r12
8001d6bc:	5e fc       	retal	r12
8001d6be:	bf dc       	cbr	r12,0x1f
8001d6c0:	5e 1e       	retne	-1
8001d6c2:	fc 1c 7f 80 	movh	r12,0x7f80
8001d6c6:	5e fc       	retal	r12
8001d6c8:	f2 09 11 01 	rsub	r9,r9,1
8001d6cc:	59 99       	cp.w	r9,25
8001d6ce:	f9 bc 02 00 	movhs	r12,0
8001d6d2:	c1 32       	brcc	8001d6f8 <__truncdfsf_return_op1+0x40>
8001d6d4:	f2 0a 11 20 	rsub	r10,r9,32
8001d6d8:	f8 0a 09 4a 	lsl	r10,r12,r10
8001d6dc:	5f 1a       	srne	r10
8001d6de:	f8 09 0a 4c 	lsr	r12,r12,r9
8001d6e2:	14 4c       	or	r12,r10
8001d6e4:	37 fa       	mov	r10,127
8001d6e6:	ed bc 00 08 	bld	r12,0x8
8001d6ea:	f7 ba 00 ff 	subeq	r10,-1
8001d6ee:	14 0c       	add	r12,r10
8001d6f0:	f8 0c 16 07 	lsr	r12,r12,0x7
8001d6f4:	a1 7b       	lsl	r11,0x1
8001d6f6:	5d 0c       	ror	r12
8001d6f8:	5e fc       	retal	r12

8001d6fa <__avr32_umod64>:
8001d6fa:	d4 31       	pushm	r0-r7,lr
8001d6fc:	1a 97       	mov	r7,sp
8001d6fe:	20 3d       	sub	sp,12
8001d700:	10 9c       	mov	r12,r8
8001d702:	12 95       	mov	r5,r9
8001d704:	14 9e       	mov	lr,r10
8001d706:	16 91       	mov	r1,r11
8001d708:	16 96       	mov	r6,r11
8001d70a:	58 09       	cp.w	r9,0
8001d70c:	e0 81 00 81 	brne	8001d80e <__avr32_umod64+0x114>
8001d710:	16 38       	cp.w	r8,r11
8001d712:	e0 88 00 12 	brls	8001d736 <__avr32_umod64+0x3c>
8001d716:	f0 08 12 00 	clz	r8,r8
8001d71a:	c4 e0       	breq	8001d7b6 <__avr32_umod64+0xbc>
8001d71c:	f6 08 09 46 	lsl	r6,r11,r8
8001d720:	f8 08 09 4c 	lsl	r12,r12,r8
8001d724:	f0 0b 11 20 	rsub	r11,r8,32
8001d728:	f4 08 09 4e 	lsl	lr,r10,r8
8001d72c:	f4 0b 0a 4b 	lsr	r11,r10,r11
8001d730:	f7 e6 10 06 	or	r6,r11,r6
8001d734:	c4 18       	rjmp	8001d7b6 <__avr32_umod64+0xbc>
8001d736:	58 08       	cp.w	r8,0
8001d738:	c0 51       	brne	8001d742 <__avr32_umod64+0x48>
8001d73a:	30 19       	mov	r9,1
8001d73c:	f2 08 0d 08 	divu	r8,r9,r8
8001d740:	10 9c       	mov	r12,r8
8001d742:	f8 08 12 00 	clz	r8,r12
8001d746:	c0 31       	brne	8001d74c <__avr32_umod64+0x52>
8001d748:	18 16       	sub	r6,r12
8001d74a:	c3 68       	rjmp	8001d7b6 <__avr32_umod64+0xbc>
8001d74c:	f0 03 11 20 	rsub	r3,r8,32
8001d750:	f4 03 0a 4b 	lsr	r11,r10,r3
8001d754:	f8 08 09 4c 	lsl	r12,r12,r8
8001d758:	ec 08 09 49 	lsl	r9,r6,r8
8001d75c:	ec 03 0a 43 	lsr	r3,r6,r3
8001d760:	f7 e9 10 09 	or	r9,r11,r9
8001d764:	f8 05 16 10 	lsr	r5,r12,0x10
8001d768:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8001d76c:	e6 05 0d 02 	divu	r2,r3,r5
8001d770:	f2 0e 16 10 	lsr	lr,r9,0x10
8001d774:	ec 02 02 4b 	mul	r11,r6,r2
8001d778:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8001d77c:	16 3e       	cp.w	lr,r11
8001d77e:	c0 72       	brcc	8001d78c <__avr32_umod64+0x92>
8001d780:	18 0e       	add	lr,r12
8001d782:	18 3e       	cp.w	lr,r12
8001d784:	c0 43       	brcs	8001d78c <__avr32_umod64+0x92>
8001d786:	16 3e       	cp.w	lr,r11
8001d788:	fd dc e3 0e 	addcs	lr,lr,r12
8001d78c:	fc 0b 01 03 	sub	r3,lr,r11
8001d790:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8001d794:	e6 05 0d 02 	divu	r2,r3,r5
8001d798:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8001d79c:	a5 36       	mul	r6,r2
8001d79e:	0c 39       	cp.w	r9,r6
8001d7a0:	c0 72       	brcc	8001d7ae <__avr32_umod64+0xb4>
8001d7a2:	18 09       	add	r9,r12
8001d7a4:	18 39       	cp.w	r9,r12
8001d7a6:	c0 43       	brcs	8001d7ae <__avr32_umod64+0xb4>
8001d7a8:	0c 39       	cp.w	r9,r6
8001d7aa:	f3 dc e3 09 	addcs	r9,r9,r12
8001d7ae:	f2 06 01 06 	sub	r6,r9,r6
8001d7b2:	f4 08 09 4e 	lsl	lr,r10,r8
8001d7b6:	f8 0a 16 10 	lsr	r10,r12,0x10
8001d7ba:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8001d7be:	ec 0a 0d 02 	divu	r2,r6,r10
8001d7c2:	fc 09 16 10 	lsr	r9,lr,0x10
8001d7c6:	ea 02 02 4b 	mul	r11,r5,r2
8001d7ca:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8001d7ce:	16 39       	cp.w	r9,r11
8001d7d0:	c0 72       	brcc	8001d7de <__avr32_umod64+0xe4>
8001d7d2:	18 09       	add	r9,r12
8001d7d4:	18 39       	cp.w	r9,r12
8001d7d6:	c0 43       	brcs	8001d7de <__avr32_umod64+0xe4>
8001d7d8:	16 39       	cp.w	r9,r11
8001d7da:	f3 dc e3 09 	addcs	r9,r9,r12
8001d7de:	f2 0b 01 0b 	sub	r11,r9,r11
8001d7e2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8001d7e6:	f6 0a 0d 0a 	divu	r10,r11,r10
8001d7ea:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8001d7ee:	ea 0a 02 4a 	mul	r10,r5,r10
8001d7f2:	14 3e       	cp.w	lr,r10
8001d7f4:	c0 72       	brcc	8001d802 <__avr32_umod64+0x108>
8001d7f6:	18 0e       	add	lr,r12
8001d7f8:	18 3e       	cp.w	lr,r12
8001d7fa:	c0 43       	brcs	8001d802 <__avr32_umod64+0x108>
8001d7fc:	14 3e       	cp.w	lr,r10
8001d7fe:	fd dc e3 0e 	addcs	lr,lr,r12
8001d802:	fc 0a 01 0a 	sub	r10,lr,r10
8001d806:	30 0b       	mov	r11,0
8001d808:	f4 08 0a 4a 	lsr	r10,r10,r8
8001d80c:	c7 b8       	rjmp	8001d902 <__avr32_umod64+0x208>
8001d80e:	16 39       	cp.w	r9,r11
8001d810:	e0 8b 00 79 	brhi	8001d902 <__avr32_umod64+0x208>
8001d814:	f2 09 12 00 	clz	r9,r9
8001d818:	c1 21       	brne	8001d83c <__avr32_umod64+0x142>
8001d81a:	10 3a       	cp.w	r10,r8
8001d81c:	5f 2b       	srhs	r11
8001d81e:	0a 31       	cp.w	r1,r5
8001d820:	5f ba       	srhi	r10
8001d822:	f7 ea 10 0a 	or	r10,r11,r10
8001d826:	f2 0a 18 00 	cp.b	r10,r9
8001d82a:	c0 60       	breq	8001d836 <__avr32_umod64+0x13c>
8001d82c:	fc 08 01 0c 	sub	r12,lr,r8
8001d830:	e2 05 01 46 	sbc	r6,r1,r5
8001d834:	18 9e       	mov	lr,r12
8001d836:	0c 9b       	mov	r11,r6
8001d838:	1c 9a       	mov	r10,lr
8001d83a:	c6 48       	rjmp	8001d902 <__avr32_umod64+0x208>
8001d83c:	ea 09 09 4c 	lsl	r12,r5,r9
8001d840:	f2 06 11 20 	rsub	r6,r9,32
8001d844:	f6 09 09 4b 	lsl	r11,r11,r9
8001d848:	f0 09 09 42 	lsl	r2,r8,r9
8001d84c:	ef 46 ff f4 	st.w	r7[-12],r6
8001d850:	f0 06 0a 48 	lsr	r8,r8,r6
8001d854:	18 48       	or	r8,r12
8001d856:	e2 06 0a 4c 	lsr	r12,r1,r6
8001d85a:	f4 09 09 43 	lsl	r3,r10,r9
8001d85e:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8001d862:	f4 06 0a 4a 	lsr	r10,r10,r6
8001d866:	16 4a       	or	r10,r11
8001d868:	f0 0b 16 10 	lsr	r11,r8,0x10
8001d86c:	f8 0b 0d 04 	divu	r4,r12,r11
8001d870:	f4 0c 16 10 	lsr	r12,r10,0x10
8001d874:	08 91       	mov	r1,r4
8001d876:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8001d87a:	e8 0e 02 46 	mul	r6,r4,lr
8001d87e:	0c 3c       	cp.w	r12,r6
8001d880:	c0 a2       	brcc	8001d894 <__avr32_umod64+0x19a>
8001d882:	20 11       	sub	r1,1
8001d884:	10 0c       	add	r12,r8
8001d886:	10 3c       	cp.w	r12,r8
8001d888:	c0 63       	brcs	8001d894 <__avr32_umod64+0x19a>
8001d88a:	0c 3c       	cp.w	r12,r6
8001d88c:	f7 b1 03 01 	sublo	r1,1
8001d890:	f9 d8 e3 0c 	addcs	r12,r12,r8
8001d894:	0c 1c       	sub	r12,r6
8001d896:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8001d89a:	f8 0b 0d 04 	divu	r4,r12,r11
8001d89e:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8001d8a2:	08 96       	mov	r6,r4
8001d8a4:	e8 0e 02 4e 	mul	lr,r4,lr
8001d8a8:	1c 3b       	cp.w	r11,lr
8001d8aa:	c0 a2       	brcc	8001d8be <__avr32_umod64+0x1c4>
8001d8ac:	20 16       	sub	r6,1
8001d8ae:	10 0b       	add	r11,r8
8001d8b0:	10 3b       	cp.w	r11,r8
8001d8b2:	c0 63       	brcs	8001d8be <__avr32_umod64+0x1c4>
8001d8b4:	1c 3b       	cp.w	r11,lr
8001d8b6:	f7 b6 03 01 	sublo	r6,1
8001d8ba:	f7 d8 e3 0b 	addcs	r11,r11,r8
8001d8be:	ed e1 11 01 	or	r1,r6,r1<<0x10
8001d8c2:	1c 1b       	sub	r11,lr
8001d8c4:	e2 02 06 40 	mulu.d	r0,r1,r2
8001d8c8:	00 9e       	mov	lr,r0
8001d8ca:	02 9c       	mov	r12,r1
8001d8cc:	16 3c       	cp.w	r12,r11
8001d8ce:	e0 8b 00 08 	brhi	8001d8de <__avr32_umod64+0x1e4>
8001d8d2:	5f 06       	sreq	r6
8001d8d4:	06 30       	cp.w	r0,r3
8001d8d6:	5f ba       	srhi	r10
8001d8d8:	ed ea 00 0a 	and	r10,r6,r10
8001d8dc:	c0 60       	breq	8001d8e8 <__avr32_umod64+0x1ee>
8001d8de:	fc 02 01 04 	sub	r4,lr,r2
8001d8e2:	f8 08 01 4c 	sbc	r12,r12,r8
8001d8e6:	08 9e       	mov	lr,r4
8001d8e8:	e6 0e 01 0a 	sub	r10,r3,lr
8001d8ec:	f6 0c 01 4c 	sbc	r12,r11,r12
8001d8f0:	ee f1 ff f4 	ld.w	r1,r7[-12]
8001d8f4:	f8 09 0a 4b 	lsr	r11,r12,r9
8001d8f8:	f4 09 0a 4a 	lsr	r10,r10,r9
8001d8fc:	f8 01 09 4c 	lsl	r12,r12,r1
8001d900:	18 4a       	or	r10,r12
8001d902:	2f dd       	sub	sp,-12
8001d904:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8001da00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
8001da00:	c0 08       	rjmp	8001da00 <_evba>
	...

8001da04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
8001da04:	c0 08       	rjmp	8001da04 <_handle_TLB_Multiple_Hit>
	...

8001da08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
8001da08:	c0 08       	rjmp	8001da08 <_handle_Bus_Error_Data_Fetch>
	...

8001da0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8001da0c:	c0 08       	rjmp	8001da0c <_handle_Bus_Error_Instruction_Fetch>
	...

8001da10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
8001da10:	c0 08       	rjmp	8001da10 <_handle_NMI>
	...

8001da14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
8001da14:	c0 08       	rjmp	8001da14 <_handle_Instruction_Address>
	...

8001da18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
8001da18:	c0 08       	rjmp	8001da18 <_handle_ITLB_Protection>
	...

8001da1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8001da1c:	c0 08       	rjmp	8001da1c <_handle_Breakpoint>
	...

8001da20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
8001da20:	c0 08       	rjmp	8001da20 <_handle_Illegal_Opcode>
	...

8001da24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
8001da24:	c0 08       	rjmp	8001da24 <_handle_Unimplemented_Instruction>
	...

8001da28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
8001da28:	c0 08       	rjmp	8001da28 <_handle_Privilege_Violation>
	...

8001da2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
8001da2c:	c0 08       	rjmp	8001da2c <_handle_Floating_Point>
	...

8001da30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
8001da30:	c0 08       	rjmp	8001da30 <_handle_Coprocessor_Absent>
	...

8001da34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
8001da34:	c0 08       	rjmp	8001da34 <_handle_Data_Address_Read>
	...

8001da38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
8001da38:	c0 08       	rjmp	8001da38 <_handle_Data_Address_Write>
	...

8001da3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8001da3c:	c0 08       	rjmp	8001da3c <_handle_DTLB_Protection_Read>
	...

8001da40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
8001da40:	c0 08       	rjmp	8001da40 <_handle_DTLB_Protection_Write>
	...

8001da44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
8001da44:	c0 08       	rjmp	8001da44 <_handle_DTLB_Modified>
	...

8001da50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
8001da50:	c0 08       	rjmp	8001da50 <_handle_ITLB_Miss>
	...

8001da60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
8001da60:	c0 08       	rjmp	8001da60 <_handle_DTLB_Miss_Read>
	...

8001da70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
8001da70:	c0 08       	rjmp	8001da70 <_handle_DTLB_Miss_Write>
	...

8001db00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
8001db00:	c0 08       	rjmp	8001db00 <_handle_Supervisor_Call>
8001db02:	d7 03       	nop

8001db04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001db04:	30 0c       	mov	r12,0
8001db06:	fe b0 49 7d 	rcall	80006e00 <_get_interrupt_handler>
8001db0a:	58 0c       	cp.w	r12,0
8001db0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001db10:	d6 03       	rete

8001db12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001db12:	30 1c       	mov	r12,1
8001db14:	fe b0 49 76 	rcall	80006e00 <_get_interrupt_handler>
8001db18:	58 0c       	cp.w	r12,0
8001db1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001db1e:	d6 03       	rete

8001db20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001db20:	30 2c       	mov	r12,2
8001db22:	fe b0 49 6f 	rcall	80006e00 <_get_interrupt_handler>
8001db26:	58 0c       	cp.w	r12,0
8001db28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001db2c:	d6 03       	rete

8001db2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8001db2e:	30 3c       	mov	r12,3
8001db30:	fe b0 49 68 	rcall	80006e00 <_get_interrupt_handler>
8001db34:	58 0c       	cp.w	r12,0
8001db36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8001db3a:	d6 03       	rete
8001db3c:	d7 03       	nop
8001db3e:	d7 03       	nop
8001db40:	d7 03       	nop
8001db42:	d7 03       	nop
8001db44:	d7 03       	nop
8001db46:	d7 03       	nop
8001db48:	d7 03       	nop
8001db4a:	d7 03       	nop
8001db4c:	d7 03       	nop
8001db4e:	d7 03       	nop
8001db50:	d7 03       	nop
8001db52:	d7 03       	nop
8001db54:	d7 03       	nop
8001db56:	d7 03       	nop
8001db58:	d7 03       	nop
8001db5a:	d7 03       	nop
8001db5c:	d7 03       	nop
8001db5e:	d7 03       	nop
8001db60:	d7 03       	nop
8001db62:	d7 03       	nop
8001db64:	d7 03       	nop
8001db66:	d7 03       	nop
8001db68:	d7 03       	nop
8001db6a:	d7 03       	nop
8001db6c:	d7 03       	nop
8001db6e:	d7 03       	nop
8001db70:	d7 03       	nop
8001db72:	d7 03       	nop
8001db74:	d7 03       	nop
8001db76:	d7 03       	nop
8001db78:	d7 03       	nop
8001db7a:	d7 03       	nop
8001db7c:	d7 03       	nop
8001db7e:	d7 03       	nop
8001db80:	d7 03       	nop
8001db82:	d7 03       	nop
8001db84:	d7 03       	nop
8001db86:	d7 03       	nop
8001db88:	d7 03       	nop
8001db8a:	d7 03       	nop
8001db8c:	d7 03       	nop
8001db8e:	d7 03       	nop
8001db90:	d7 03       	nop
8001db92:	d7 03       	nop
8001db94:	d7 03       	nop
8001db96:	d7 03       	nop
8001db98:	d7 03       	nop
8001db9a:	d7 03       	nop
8001db9c:	d7 03       	nop
8001db9e:	d7 03       	nop
8001dba0:	d7 03       	nop
8001dba2:	d7 03       	nop
8001dba4:	d7 03       	nop
8001dba6:	d7 03       	nop
8001dba8:	d7 03       	nop
8001dbaa:	d7 03       	nop
8001dbac:	d7 03       	nop
8001dbae:	d7 03       	nop
8001dbb0:	d7 03       	nop
8001dbb2:	d7 03       	nop
8001dbb4:	d7 03       	nop
8001dbb6:	d7 03       	nop
8001dbb8:	d7 03       	nop
8001dbba:	d7 03       	nop
8001dbbc:	d7 03       	nop
8001dbbe:	d7 03       	nop
8001dbc0:	d7 03       	nop
8001dbc2:	d7 03       	nop
8001dbc4:	d7 03       	nop
8001dbc6:	d7 03       	nop
8001dbc8:	d7 03       	nop
8001dbca:	d7 03       	nop
8001dbcc:	d7 03       	nop
8001dbce:	d7 03       	nop
8001dbd0:	d7 03       	nop
8001dbd2:	d7 03       	nop
8001dbd4:	d7 03       	nop
8001dbd6:	d7 03       	nop
8001dbd8:	d7 03       	nop
8001dbda:	d7 03       	nop
8001dbdc:	d7 03       	nop
8001dbde:	d7 03       	nop
8001dbe0:	d7 03       	nop
8001dbe2:	d7 03       	nop
8001dbe4:	d7 03       	nop
8001dbe6:	d7 03       	nop
8001dbe8:	d7 03       	nop
8001dbea:	d7 03       	nop
8001dbec:	d7 03       	nop
8001dbee:	d7 03       	nop
8001dbf0:	d7 03       	nop
8001dbf2:	d7 03       	nop
8001dbf4:	d7 03       	nop
8001dbf6:	d7 03       	nop
8001dbf8:	d7 03       	nop
8001dbfa:	d7 03       	nop
8001dbfc:	d7 03       	nop
8001dbfe:	d7 03       	nop
